// Generated by dts-bundle-generator v8.0.1

import { ColumnDef } from '@tanstack/react-table';
import React from 'react';
import { Component, ReactElement, ReactNode } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { z } from 'zod';

/** Address: represents an account's address */
export interface Address {
	/**
	 * the address field
	 * Validations:
	 * - must be at least 5 character long (meaning cannot be empty)
	 * @example "1234 5th Ave"
	 */
	address?: string;
	/**
	 * the city
	 * Validations:
	 * - must be at least 3 characters long (meaning cannot be empty)
	 * @example "New York"
	 */
	city?: string;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	/**
	 * latittude
	 * Validations: None - can be empty
	 * @example "40.123456"
	 */
	lattitude?: string;
	/**
	 * longitude
	 * Validations: None - can be empty
	 * @example "-73.987654"
	 */
	longitude?: string;
	/**
	 * the state/municipality
	 * Validations
	 * - must be at least 2 characters long
	 * @example "New York"
	 */
	state?: string;
	/**
	 * the unit if the address is an apartment
	 * Validations:
	 * - must be at least 1 character long (meaning cannot be empty)
	 * @example "Apt 1"
	 */
	unit?: string;
	/**
	 * the address zipcode
	 * Validations:
	 * - must be exactly 5 characters this is to ensure the client inputs the proper zip code
	 * @example "12345"
	 */
	zipcode?: string;
}
/**
 * Display and interaction preferences.
 * @default "APPLICATION_THEME_UNSPECIFIED"
 */
export type ApplicationTheme = "APPLICATION_THEME_UNSPECIFIED" | "APPLICATION_THEME_LIGHT" | "APPLICATION_THEME_DARK";
/**
 * AuditAction defines the types of actions that can be audited.
 * @default "AUDIT_ACTION_UNSPECIFIED"
 */
export type AuditAction = "AUDIT_ACTION_UNSPECIFIED" | "AUDIT_ACTION_CREATED" | "AUDIT_ACTION_UPDATED" | "AUDIT_ACTION_DELETED";
/** BusinessAccount represents a business account within the context of solomon-ai. */
export interface BusinessAccount {
	/** auth0 user id associated with the business account */
	auth0UserId?: string;
	/** The type of profile associated with the business account (e.g., individual, corporate). */
	accountType?: ProfileType;
	/** Physical address associated with the business account. */
	address?: Address;
	/**
	 * Identifier for the associated authentication service account.
	 * @format uint64
	 */
	authnAccountId?: string;
	/**
	 * Short description of the business account. Maximum of 200 characters.
	 * @example "sample description"
	 */
	bio?: string;
	/**
	 * Description of the company associated with the business account.
	 * @example "We help businesses succeed"
	 */
	companyDescription?: string;
	/** Date when the company associated with the business account was established. */
	companyEstablishedDate?: string;
	/**
	 * Industry type of the company associated with the business account.
	 * @example "fintech"
	 */
	companyIndustryType?: string;
	/**
	 * Name of the company associated with the business account.
	 * @example "Solomon AI"
	 */
	companyName?: string;
	/** Website URL of the company associated with the business account. */
	companyWebsiteUrl?: string;
	/**
	 * Timestamp indicating when the business account was created.
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * Email associated with the business account.
	 * @example "example@gmail.com"
	 */
	email?: string;
	/**
	 * Headline for the profile of the business account.
	 * @example "sample headline"
	 */
	headline?: string;
	/**
	 * Unique identifier for the business account.
	 * @format uint64
	 */
	id?: string;
	/**
	 * Indicates whether the business account is active.
	 * @example true
	 */
	isActive?: boolean;
	/**
	 * Indicates whether the email associated with the business account has been verified.
	 * @example false
	 */
	isEmailVerified?: boolean;
	/**
	 * Indicates whether the business account is private.
	 * @example false
	 */
	isPrivate?: boolean;
	/**
	 * Phone number associated with the business account.
	 * @example "6513424124"
	 */
	phoneNumber?: string;
	/** Profile image associated with the user account. */
	profileImageUrl?: string;
	/** Role defines the role of a user in the system with specific permissions. */
	role?: Role;
	/** Settings specific to the business account. */
	settings?: Settings;
	/** Tags associated with the business account. Between 1 and 10 tags are allowed. */
	tags?: Array<Tags>;
	/**
	 * Username for the business account. Must be at least 10 characters long.
	 * @example "testuser9696"
	 */
	username?: string;
	/**
	 * Timestamp indicating when the email for the business account was verified.
	 * @format date-time
	 */
	verifiedAt?: string;
}
/**
 * CreateUserV2Request: Represents the request object invoked against the user
 * service to create a user account
 */
export interface CreateUserV2Request {
	/**
	 * The auth0 user id of the user
	 * @example "lksdjhfgsdhfghdsgfhgdh.com"
	 */
	auth0UserId: string;
	/** BusinessAccount represents a business account within the context of solomon-ai. */
	businessAccount?: BusinessAccount;
	/**
	 * set of community IDs to follow
	 * Validations:
	 * - at least 0 and at most 20 community ids supported at one time
	 */
	communityIdsToFollow?: Array<string>;
	/**
	 * The profile image of the user
	 * Validations:
	 * - must be a valid URI
	 * @example "lksdjhfgsdhfghdsgfhgdh.com"
	 */
	profileImageUrl: string;
	/** @brief Represents a user account in the context of simfinni. */
	userAccount?: UserAccount;
}
/**
 * CreateUserResponse: Represents the response object returned as a response to
 * the `create-user` request
 */
export interface CreateUserV2Response {
	/** @format uint64 */
	userId?: string;
}
/** DigitalWorkerToolChainConfiguration defines the overall settings for a digital worker. */
export interface DigitalWorkerSettings {
	enableLogging?: boolean;
	/**
	 * Unique identifier for the toolchain configuration.
	 * @format uint64
	 */
	id?: string;
	workerName?: string;
	workerVersion?: string;
}
export interface FinancialPreferences {
	currencyPreference?: string;
	financialYearStart?: string;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	taxCode?: string;
	/** @format double */
	taxPercentage?: number;
}
export interface GetCannyUserSSOTokenResponse {
	token?: string;
}
/** @default "LIKED_DASHBOARD_PANELS_TRANSACTIONS_UNSPECIFIED" */
export type LikedDashboardPanels = "LIKED_DASHBOARD_PANELS_TRANSACTIONS_UNSPECIFIED" | "LIKED_DASHBOARD_PANELS_TRANSACTIONS_OVERVIEW" | "LIKED_DASHBOARD_PANELS_INVESTMENT_SUMMARY" | "LIKED_DASHBOARD_PANELS_MONTHLY_SPENDING_REPORT" | "LIKED_DASHBOARD_PANELS_SAVINGS_TRACKER" | "LIKED_DASHBOARD_PANELS_CREDIT_SCORE_MONITOR";
export interface NotificationSettings {
	/** True if user wants to be alerted for anomalies */
	alerts?: boolean;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	notificationType?: NotificationType;
}
/**
 * - NOTIFICATION_TYPE_EMAIL: email based notification
 *  - NOTIFICATION_TYPE_SMS: sms based notification
 *  - NOTIFICATION_TYPE_IN_APP: app based notification
 *  - NOTIFICATION_TYPE_SLACK: slack based notification
 * @default "NOTIFICATION_TYPE_UNSPECIFIED"
 */
export type NotificationType = "NOTIFICATION_TYPE_UNSPECIFIED" | "NOTIFICATION_TYPE_EMAIL" | "NOTIFICATION_TYPE_SMS" | "NOTIFICATION_TYPE_IN_APP" | "NOTIFICATION_TYPE_SLACK";
/**
 * ProfileType: represents the type of account tied to a given profile
 * @default "PROFILE_TYPE_UNSPECIFIED"
 */
export type ProfileType = "PROFILE_TYPE_UNSPECIFIED" | "PROFILE_TYPE_USER" | "PROFILE_TYPE_BUSINESS";
/**
 * Risk Tolerance Investment preferences.
 * @default "RISK_TOLERANCE_SETTINGS_UNSPECIFIED"
 */
export type RiskToleranceSettings = "RISK_TOLERANCE_SETTINGS_UNSPECIFIED" | "RISK_TOLERANCE_SETTINGS_LOW" | "RISK_TOLERANCE_SETTINGS_MEDIUM" | "RISK_TOLERANCE_SETTINGS_HIGH";
/** Role defines the role of a user in the system with specific permissions. */
export interface Role {
	/** Audit log for this role. */
	auditLog?: Array<RoleAuditEvents>;
	/** Permissions related to project management. */
	canCreateProjects?: boolean;
	/** Permissions related to report management. */
	canCreateReports?: boolean;
	/** Permissions related to user management. */
	canCreateUsers?: boolean;
	canDeleteProjects?: boolean;
	canDeleteReports?: boolean;
	canDeleteUsers?: boolean;
	canReadProjects?: boolean;
	canReadReports?: boolean;
	canReadUsers?: boolean;
	canUpdateProjects?: boolean;
	canUpdateReports?: boolean;
	canUpdateUsers?: boolean;
	/**
	 * Add more permissions as necessary for other modules or features.
	 * Timestamps for tracking creation and modification times.
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * Unique identifier for the role.
	 * @format int64
	 */
	id?: string;
	/** Name of the role. */
	name?: string;
	/** Type of the role. */
	type?: RoleType;
	/** @format date-time */
	updatedAt?: string;
}
/** RoleAuditEvents defines the audit record for any changes made to a role. */
export interface RoleAuditEvents {
	/**
	 * The type of action (created, updated, deleted)
	 * AuditAction defines the types of actions that can be audited.
	 */
	action?: AuditAction;
	/**
	 * Additional fields for enhanced auditing:
	 * Specific fields that were changed (if applicable)
	 */
	affectedFields?: Array<string>;
	/** IP address of the client that initiated the change */
	clientIp?: string;
	/** Additional context about the change (e.g., reason for change) */
	context?: string;
	/** @format int64 */
	id?: string;
	/** Identifier of the user who performed the action */
	performedBy?: string;
	/** Values of those fields before the change */
	previousValues?: Array<string>;
	/**
	 * Time of the event
	 * @format date-time
	 */
	timestamp?: string;
	/** User agent string of the client */
	userAgent?: string;
}
/**
 * RoleType defines the different types of roles.
 * @default "ROLE_TYPE_UNSPECIFIED"
 */
export type RoleType = "ROLE_TYPE_UNSPECIFIED" | "ROLE_TYPE_SUPER_ADMIN" | "ROLE_TYPE_TEAM_ADMIN" | "ROLE_TYPE_REGULAR";
/** User settings for the fintech application. */
export interface Settings {
	/** Display and interaction preferences. */
	appTheme?: ApplicationTheme;
	/** Settings specific to the user's digital worker. */
	digitalWorkerSettings?: DigitalWorkerSettings;
	financialPreferences?: FinancialPreferences;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	/** Dashboard customization, e.g., specific widgets or reports. */
	likedDashboardPanels?: Array<LikedDashboardPanels>;
	/** Notification preferences. */
	notificationSettings?: NotificationSettings;
	/** Language preference. */
	preferredLanguage?: string;
	/** Risk tolerance settings defined for user settings. */
	riskTolerance?: RiskToleranceSettings;
}
/** Tags: represents metadata tags associated to an account */
export interface Tags {
	/**
	 * tag id
	 * @format uint64
	 */
	id?: string;
	/**
	 * metadata associated with tag
	 * validations:
	 * - must provide between 1 and 10 metadata tags
	 * @example ["testmetadata1","testmetadata2"]
	 */
	metadata?: Array<string>;
	/**
	 * description of tag
	 * validations:
	 * - cannot be empty
	 * - must be at least 10 characters long
	 * @example "testtagdescription"
	 */
	tagDescription?: string;
	/**
	 * name of tag
	 * validations:
	 * - cannot be empty
	 * - must be at least 3 characters long
	 * @example "testtagname"
	 */
	tagName?: string;
}
/** @brief Represents a user account in the context of simfinni. */
export interface UserAccount {
	/** Auth0 user id */
	auth0UserId?: string;
	/** Enum indicating the type of profile (e.g., individual, corporate). */
	accountType?: ProfileType;
	/** Physical address associated with the user. */
	address?: Address;
	/**
	 * ID for the authentication service linked to this account.
	 * @format uint64
	 */
	authnAccountId?: string;
	/** Brief description about the user, up to 200 characters. */
	bio?: string;
	/**
	 * Timestamp for when the account was created.
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * Email associated with the user account.
	 * @example "sample@example.com"
	 */
	email?: string;
	/** User's first name. */
	firstname?: string;
	/** Short headline for the user's profile. */
	headline?: string;
	/**
	 * Unique identifier for the account.
	 * @format uint64
	 */
	id?: string;
	/** Indicates if the account is currently active. */
	isActive?: boolean;
	/** Indicates if the user's email has been verified. */
	isEmailVerified?: boolean;
	/** Indicates if the account is set to private. */
	isPrivate?: boolean;
	/** User's last name. */
	lastname?: string;
	/** Phone number associated with the account. */
	phoneNumber?: string;
	/** Profile image associated with the user account. */
	profileImageUrl?: string;
	/** Role defines the role of a user in the system with specific permissions. */
	role?: Role;
	/** Settings specific to the user account. */
	settings?: Settings;
	/** Tags associated with the user account, between 1 and 10. */
	tags?: Array<Tags>;
	/**
	 * Username associated with the account, minimum of 10 characters.
	 * @example "testuser9696"
	 */
	username?: string;
	/**
	 * Timestamp for when the email was verified.
	 * @format date-time
	 */
	verifiedAt?: string;
}
/**
 * Represents a geographic address.
 *
 * This class provides a structured representation of a physical location, capturing details such as address line, city, state, unit, zipcode, and geo-coordinates.
 * It also has utility methods like `getFullAddress` to fetch a formatted string representation of the address.
 *
 * @example Constructing an `Address`:
 *
 * ```ts
 * // Example data
 * const addressData = {
 *   address: "123 Main St",
 *   city: "Anytown",
 *   state: "CA",
 *   unit: "Apt 4B",
 *   zipcode: "12345",
 *   lattitude: "34.0522",
 *   longitude: "-118.2437",
 *   id: "unique-address-id"
 * };
 *
 * const location = new Address(addressData);
 * console.log(location.getFullAddress()); // Outputs: "123 Main St, Anytown, CA 12345"
 * ```
 *
 * @property address - The main line of the address, typically the street name and number.
 * @property city - The city or municipality of the address.
 * @property state - The state or province of the address.
 * @property unit - Optional unit or apartment number.
 * @property zipcode - The postal code for the address.
 * @property lattitude - The geographic latitude of the address.
 * @property longitude - The geographic longitude of the address.
 * @property id - A unique identifier for the address.
 */
export declare class AddressClass implements Address {
	address?: string;
	city?: string;
	state?: string;
	unit?: string;
	zipcode?: string;
	lattitude?: string;
	longitude?: string;
	id?: string;
	/**
	 * Initializes a new instance of the `Address` class.
	 * @param [data] - The data used to populate the properties of the class.
	 */
	constructor(data?: Partial<Address>);
	/**
	 * Returns a formatted string of the full address.
	 *
	 * @example
	 * ```ts
	 * const location = new Address({address: "123 Main St", city: "Anytown", state: "CA", zipcode: "12345"});
	 * console.log(location.getFullAddress()); // Outputs: "123 Main St, Anytown, CA 12345"
	 * ```
	 *
	 * @returns The formatted address string.
	 */
	getFullAddress(): string;
	static randomInstance(): Address;
}
/**
 * Represents a metadata tag.
 *
 * The `Tag` class provides a structured representation for tags, commonly used for categorization or metadata annotation.
 * Each tag can have a name, a description, and associated metadata.
 *
 * @remarks
 * The class provides utility methods like `getName`, `getDescription`, and `getMetadata` for fetching properties with a safe default value.
 *
 * @example Constructing a `Tag`:
 *
 * ```ts
 * // Example data
 * const tagData = {
 *   id: "unique-tag-id",
 *   tagName: "ExampleTag",
 *   tagDescription: "A description for the ExampleTag",
 *   metadata: ["meta1", "meta2"]
 * };
 *
 * const exampleTag = new Tag(tagData);
 * console.log(exampleTag.getName()); // Outputs: "ExampleTag"
 * ```
 *
 * @property id - A unique identifier for the tag.
 * @property tagName - The name of the tag.
 * @property tagDescription - A brief description of what the tag represents.
 * @property metadata - An array of associated metadata strings.
 *
 * @author Yoan Yomba
 */
export declare class TagClass implements Tags {
	id?: string;
	tagName?: string;
	tagDescription?: string;
	metadata?: string[];
	/**
	 * Initializes a new instance of the `Tag` class.
	 * @param {Partial<Tag>} [data] - Data used to populate the properties of the class.
	 */
	constructor(data?: Partial<Tags>);
	static randomInstance(): Tags;
	/**
	 * Fetches the tag's description or provides a default empty string if not set.
	 * @returns The tag's description or an empty string.
	 */
	getDescription(): string;
	/**
	 * Fetches the tag's name or provides a default empty string if not set.
	 * @returns The tag's name or an empty string.
	 */
	getName(): string;
	/**
	 * Fetches the tag's metadata or provides a default empty array if not set.
	 * @returns The tag's metadata array or an empty array.
	 */
	getMetadata(): string[];
}
/**
 * Represents metadata associated with an error.
 * This might be directly from a service or part of an error response.
 */
export declare class ErrorMetadata {
	/**
	 * An optional numeric code indicating the specific error.
	 */
	code?: number;
	/**
	 * An optional status string providing more context about the error's nature.
	 */
	status?: string;
	/**
	 * A more descriptive message explaining the error.
	 */
	message?: string;
	/**
	 * Detailed breakdown or additional information about the error.
	 * This can be useful for debugging or for more granular client-side handling.
	 */
	details?: string[];
	/**
	 * Creates a new instance of ErrorMetadata.
	 *
	 * @param data - A partial structure representing ErrorMetadata. Used for initialization.
	 */
	constructor(data?: Partial<ErrorMetadata>);
}
/**
 * Represents an error response from the backend or service.
 */
export declare class BackendError {
	/**
	 * Contains an array of error metadata detailing the specifics of the error(s).
	 */
	response: {
		errors: ErrorMetadata[];
	};
	/**
	 * Creates a new instance of BackendError.
	 *
	 * @param data - A partial structure representing BackendError. Used for initialization.
	 */
	constructor(data?: Partial<BackendError>);
}
/**
 * Represents an error message that might include HTTP-specific details.
 */
export declare class ErrorMessage {
	/**
	 * Contains the backend error details.
	 */
	http_body: BackendError;
	/**
	 * Represents the HTTP status code associated with this error.
	 */
	http_status_code: number;
	/**
	 * Creates a new instance of ErrorMessage.
	 *
	 * @param data - A partial structure representing ErrorMessage. Used for initialization.
	 */
	constructor(data?: Partial<ErrorMessage>);
}
/**
 * Represents a full error response, which may be returned to a client or user.
 */
export declare class ErrorResponse {
	/**
	 * Contains the error message details including HTTP specifics.
	 */
	error_message: ErrorMessage;
	/**
	 * Creates a new instance of ErrorResponse.
	 *
	 * @param data - A partial structure representing ErrorResponse. Used for initialization.
	 */
	constructor(data?: Partial<ErrorResponse>);
}
/**
 * Account Balance History
 * This message is used to represent the balance history of an account.
 */
export interface AccountBalanceHistory {
	accountId?: string;
	/** @format double */
	balance?: number;
	id?: string;
	isoCurrencyCode?: string;
	profileType?: FinancialUserProfileType;
	/** @format int64 */
	sign?: number;
	/** @format date-time */
	time?: string;
	/** @format uint64 */
	userId?: string;
}
/**
 * An actionable insight serves as a basic insight users
 * can leverage and act upon and is typically generated based off of their financial contexts
 */
export interface ActionableInsight {
	/** for each user we generate a detailed actionable insights for them to see */
	detailedAction?: string;
	/**
	 * the time the insight was generated
	 * @format date-time
	 */
	generatedTime?: string;
	/** @format uint64 */
	id?: string;
	/** for each user we generate a summarized insight targeted at optimizing a certain condition */
	summarizedAction?: string;
	/** associated tags with the generated insights */
	tags?: Array<string>;
}
export type AddDefaultPocketsToBankAccountData = any;
export interface AddDefaultPocketsToBankAccountRequest {
	/**
	 * The financial account type
	 * as of now we only support credit and bank accounts
	 */
	financialAccountType: FinancialAccountType;
	/**
	 * The bank account id
	 * Validations:
	 * - account_id must be greater than 0
	 */
	plaidAccountId: string;
	profileType: FinancialUserProfileType;
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
export interface AddDefaultPocketsToBankAccountResponse {
	bankAccount?: BankAccount;
	creditAccount?: CreditAccount;
}
export type AddNoteToRecurringTransactionData = any;
/** AddNoteToTransactionRequest adds a note to a transaction */
export interface AddNoteToRecurringTransactionRequest {
	/**
	 * The note to add
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
	/**
	 * The transaction id
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
}
/** AddNoteToRecurringTransactionResponse is the responsed obtained after we add a note to a transaction */
export interface AddNoteToRecurringTransactionResponse {
	/**
	 * The transaction id
	 * Message representing recurring transactions associated with a Plaid account.
	 */
	transaction?: PlaidAccountRecurringTransaction;
}
export type AddNoteToSmartGoalData = any;
export interface AddNoteToSmartGoalRequest {
	/**
	 * The note to add
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
	/**
	 * The smart goal id
	 * Validations:
	 * - smart_goal_id must be greater than 0
	 * @format uint64
	 */
	smartGoalId: string;
}
export interface AddNoteToSmartGoalResponse {
	/**
	 * The smart goal id
	 * SmartGoal: The Goals table stores information about each financial goal, including the name of the goal,
	 * its description, the target amount of money the user wants to save or invest, and the expected date of completion.
	 *
	 * The Goals table also includes columns for the start date of the goal, the current amount of money saved or
	 * invested towards the goal, and a boolean flag indicating whether the goal has been achieved.
	 * These additional columns allow the user to track their progress towards the goal and see how much
	 * more they need to save or invest to reach their target amount.
	 */
	goal?: SmartGoal;
}
export type AddNoteToTransactionData = any;
/** AddNoteToTransactionRequest adds a note to a transaction */
export interface AddNoteToTransactionRequest {
	/**
	 * The note to add
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
	/**
	 * The transaction id
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
}
/** AddNoteToTransactionResponse is the responsed obtained after we add a note to a transaction */
export interface AddNoteToTransactionResponse {
	/**
	 * The transaction id
	 * Message representing Plaid account transactions.
	 */
	transaction?: PlaidAccountTransaction;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a
 * URL that describes the type of the serialized message.
 *
 * Protobuf library provides support to pack/unpack Any values in the form
 * of utility functions or additional generated methods of the Any type.
 *
 * Example 1: Pack and unpack a message in C++.
 *
 *     Foo foo = ...;
 *     Any any;
 *     any.PackFrom(foo);
 *     ...
 *     if (any.UnpackTo(&foo)) {
 *       ...
 *     }
 *
 * Example 2: Pack and unpack a message in Java.
 *
 *     Foo foo = ...;
 *     Any any = Any.pack(foo);
 *     ...
 *     if (any.is(Foo.class)) {
 *       foo = any.unpack(Foo.class);
 *     }
 *
 * Example 3: Pack and unpack a message in Python.
 *
 *     foo = Foo(...)
 *     any = Any()
 *     any.Pack(foo)
 *     ...
 *     if any.Is(Foo.DESCRIPTOR):
 *       any.Unpack(foo)
 *       ...
 *
 * Example 4: Pack and unpack a message in Go
 *
 *      foo := &pb.Foo{...}
 *      any, err := anypb.New(foo)
 *      if err != nil {
 *        ...
 *      }
 *      ...
 *      foo := &pb.Foo{}
 *      if err := any.UnmarshalTo(foo); err != nil {
 *        ...
 *      }
 *
 * The pack methods provided by protobuf library will by default use
 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
 * methods only use the fully qualified type name after the last '/'
 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
 * name "y.z".
 *
 *
 * JSON
 *
 * The JSON representation of an `Any` value uses the regular
 * representation of the deserialized, embedded message, with an
 * additional field `@type` which contains the type URL. Example:
 *
 *     package google.profile;
 *     message Person {
 *       string first_name = 1;
 *       string last_name = 2;
 *     }
 *
 *     {
 *       "@type": "type.googleapis.com/google.profile.Person",
 *       "firstName": <string>,
 *       "lastName": <string>
 *     }
 *
 * If the embedded message type is well-known and has a custom JSON
 * representation, that representation will be embedded adding a field
 * `value` which holds the custom JSON in addition to the `@type`
 * field. Example (for message [google.protobuf.Duration][]):
 *
 *     {
 *       "@type": "type.googleapis.com/google.protobuf.Duration",
 *       "value": "1.212s"
 *     }
 */
export interface Any {
	/**
	 * A URL/resource name that uniquely identifies the type of the serialized
	 * protocol buffer message. This string must contain at least
	 * one "/" character. The last segment of the URL's path must represent
	 * the fully qualified name of the type (as in
	 * `path/google.protobuf.Duration`). The name should be in a canonical form
	 * (e.g., leading "." is not accepted).
	 *
	 * In practice, teams usually precompile into the binary all types that they
	 * expect it to use in the context of Any. However, for URLs which use the
	 * scheme `http`, `https`, or no scheme, one can optionally set up a type
	 * server that maps type URLs to message definitions as follows:
	 *
	 * * If no scheme is provided, `https` is assumed.
	 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	 *   value in binary format, or produce an error.
	 * * Applications are allowed to cache lookup results based on the
	 *   URL, or have them precompiled into a binary to avoid any
	 *   lookup. Therefore, binary compatibility needs to be preserved
	 *   on changes to types. (Use versioned type names to manage
	 *   breaking changes.)
	 *
	 * Note: this functionality is not currently available in the official
	 * protobuf release, and it is not used for type URLs beginning with
	 * type.googleapis.com.
	 *
	 * Schemes other than `http`, `https` (or the empty scheme) might be
	 * used with implementation specific semantics.
	 */
	"@type"?: string;
	[key: string]: any;
}
export interface Apr {
	/** @format double */
	balanceSubjectToApr?: number;
	/** @format uint64 */
	id?: string;
	/** @format double */
	interestChargeAmount?: number;
	/** @format double */
	percentage?: number;
	type?: string;
}
export type AskCopilotQuestionData = any;
export interface BankAccount {
	/**
	 * the bank account balance
	 * @format float
	 */
	balance: number;
	/** @format uint64 */
	balanceLimit?: string;
	/** the bank account currency */
	currency: string;
	/** @format double */
	currentFunds: number;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** the bank account name */
	name: string;
	/** the bank account number */
	number: string;
	/** plaid account id mapped to this bank account */
	plaidAccountId?: string;
	/**
	 * the set of "virtualized accounts this user witholds"
	 * NOTE: these pockets are automatically created by the system
	 * when a user connects a bank account
	 */
	pockets?: Array<Pocket>;
	/** the set of subscriptions tied to this account */
	recurringTransactions?: Array<PlaidAccountRecurringTransaction>;
	/** the bank account status */
	status?: BankAccountStatus;
	/** account subtype */
	subtype?: string;
	/** the set of transactions tied to this account */
	transactions?: Array<PlaidAccountTransaction>;
	/** the bank account type */
	type: BankAccountType;
	/**
	 * the user id to which this bank account is tied to
	 * @format uint64
	 */
	userId?: string;
}
/** @default "BANK_ACCOUNT_STATUS_UNSPECIFIED" */
export type BankAccountStatus = "BANK_ACCOUNT_STATUS_UNSPECIFIED" | "BANK_ACCOUNT_STATUS_ACTIVE" | "BANK_ACCOUNT_STATUS_INACTIVE";
/** @default "BANK_ACCOUNT_TYPE_UNSPECIFIED" */
export type BankAccountType = "BANK_ACCOUNT_TYPE_UNSPECIFIED" | "BANK_ACCOUNT_TYPE_PLAID" | "BANK_ACCOUNT_TYPE_MANUAL";
/**
 * The Budgets table stores information about each budget created by the user,
 * including the name of the budget, the start and end dates, and the user ID.
 */
export interface Budget {
	/**
	 * category associated with the goal
	 * The Categories table stores information about the different categories of expenses or income,
	 * such as "Housing", "Food", "Transportation", and "Entertainment". Each category has one or more
	 * subcategories, which are stored in the Subcategories table.
	 *
	 * For example, the "Housing" category might have subcategories for "Rent", "Utilities", and "Home Maintenance".
	 */
	category?: Category;
	description?: string;
	/** the time the goal was updated */
	endDate?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/**
	 * The name of the budget
	 * @minLength 10
	 * @example "Buy a car"
	 */
	name?: string;
	/** the time the goal was created */
	startDate?: string;
}
export type BulkUpdateRecurringTransactionData = any;
/** BulkUpdateRecurringTransactionRequest is the bulk update transaction request */
export interface BulkUpdateRecurringTransactionRequest {
	/**
	 * The transactions to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	transactions: Array<PlaidAccountRecurringTransaction>;
}
/** BulkUpdateRecurringTransactionResponse is the bulk update transaction response */
export interface BulkUpdateRecurringTransactionResponse {
	/** The transactions that were successfully updated */
	transactions?: Array<PlaidAccountRecurringTransaction>;
}
export type BulkUpdateTransactionData = any;
/** BulkUpdateTransactionRequest is the bulk update transaction request */
export interface BulkUpdateTransactionRequest {
	/**
	 * The transactions to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	transactions: Array<PlaidAccountTransaction>;
}
/** BulkUpdateTransactionResponse is the bulk update transaction response */
export interface BulkUpdateTransactionResponse {
	/** The transactions that were successfully updated */
	transactions?: Array<PlaidAccountTransaction>;
}
/**
 * The Categories table stores information about the different categories of expenses or income,
 * such as "Housing", "Food", "Transportation", and "Entertainment". Each category has one or more
 * subcategories, which are stored in the Subcategories table.
 *
 * For example, the "Housing" category might have subcategories for "Rent", "Utilities", and "Home Maintenance".
 */
export interface Category {
	/**
	 * The description of the category
	 * @minLength 10
	 * @example "Housing is a category primarily for housing"
	 */
	description?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/**
	 * The name of the category
	 * @minLength 3
	 * @example "Housing"
	 */
	name?: string;
	/** the sub categories of the category */
	subcategories?: Array<string>;
}
/**
 * CategoryMetricsFinancialSubProfile
 * This message is used to represent the financial sub profile of a category.
 */
export interface CategoryMetricsFinancialSubProfile {
	/** @format int64 */
	month?: number;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	spentLastMonth?: number;
	/** @format double */
	spentLastSixMonths?: number;
	/** @format double */
	spentLastTwoWeeks?: number;
	/** @format double */
	spentLastTwoYears?: number;
	/** @format double */
	spentLastWeek?: number;
	/** @format double */
	spentLastYear?: number;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
/**
 * CategoryMonthlyExpenditure represents the monthly expenditure of a category.
 * This message is used to represent the monthly expenditure of a category.
 */
export interface CategoryMonthlyExpenditure {
	/** @format int64 */
	month?: number;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalSpending?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * CategoryMonthlyIncome
 * This message is used to represent the monthly income of a category.
 */
export interface CategoryMonthlyIncome {
	/** @format int64 */
	month?: number;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalIncome?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * CategoryMonthlyTransactionCount
 * This message is used to represent the monthly transaction count of a category.
 */
export interface CategoryMonthlyTransactionCount {
	/** @format int64 */
	month?: number;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format int64 */
	transactionCount?: number;
	/** @format uint64 */
	userId?: string;
}
export type CheckIfQuotaExceededData = any;
export interface CheckIfQuotaExceededResponse {
	exceeded?: boolean;
}
export type CreateBankAccountData = any;
/**
 * CreateBankAccountRequest: Represents the request object invoked against the financial
 * service to create a bank account for a given user
 */
export interface CreateBankAccountRequest {
	/**
	 * The bank account to create
	 * Validations:
	 * - cannot be nil hence required
	 */
	bankAccount: BankAccount;
	/**
	 * The linkId to associate this bank account with
	 * @format uint64
	 */
	linkId: string;
	profileType: FinancialUserProfileType;
	/**
	 * The account ID associated with the user
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
/**
 * CreateBankAccountResponse: Represents the response object returned as a response to
 * the `create bank account` request
 */
export interface CreateBankAccountResponse {
	/**
	 * The bank account id
	 * @format uint64
	 */
	bankAccountId?: string;
}
export type CreateBudgetData = any;
export interface CreateBudgetRequest {
	/**
	 * The budget to create
	 * Validations:
	 * - cannot be nil hence required
	 * The Budgets table stores information about each budget created by the user,
	 * including the name of the budget, the start and end dates, and the user ID.
	 */
	budget: Budget;
	/**
	 * The milestone to associate this budget with
	 * @format uint64
	 */
	milestroneId: string;
}
export interface CreateBudgetResponse {
	/**
	 * The budget id
	 * @format uint64
	 */
	budgetId?: string;
}
export type CreateLinkData = any;
export interface CreateManualLinkRequest {
	/**
	 * The manual account link
	 * A Link represents a login at a financial institution. A single end-user of your application might have accounts at different financial
	 * institutions, which means they would have multiple different Items. An Item is not the same as a financial institution account,
	 * although every account will be associated with an Item. For example, if a user has one login at their bank that allows them to access
	 * both their checking account and their savings account, a single Item would be associated with both of those accounts. Each Item
	 * linked within your application will have a corresponding access_token, which is a token that you can use to make API requests related
	 * to that specific Item.
	 * Two Items created for the same set of credentials at the same institution will be considered different and not share the same item_id.
	 */
	manualAccountLink: Link;
	profileType: FinancialUserProfileType;
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
export interface CreateManualLinkResponse {
	/**
	 * The link's id
	 * @format uint64
	 */
	linkId?: string;
}
export type CreateMilestoneData = any;
export interface CreateMilestoneRequest {
	/**
	 * The milestone to create
	 * Validations:
	 * - cannot be nil hence required
	 */
	milestone: Milestone;
	/**
	 * The smart goal id
	 * Validations:
	 * - smart_goal_id must be greater than 0
	 * @format uint64
	 */
	smartGoalId: string;
}
export interface CreateMilestoneResponse {
	/**
	 * The milestone id
	 * @format uint64
	 */
	milestoneId?: string;
}
export type CreateSmartGoalData = any;
export interface CreateSmartGoalRequest {
	/**
	 * The pocket account id
	 * Validations:
	 * - pocket_account_id must be greater than 0
	 * @format uint64
	 */
	pocketId: string;
	/**
	 * The smart goal to create
	 * Validations:
	 * - cannot be nil hence required
	 * SmartGoal: The Goals table stores information about each financial goal, including the name of the goal,
	 * its description, the target amount of money the user wants to save or invest, and the expected date of completion.
	 *
	 * The Goals table also includes columns for the start date of the goal, the current amount of money saved or
	 * invested towards the goal, and a boolean flag indicating whether the goal has been achieved.
	 * These additional columns allow the user to track their progress towards the goal and see how much
	 * more they need to save or invest to reach their target amount.
	 */
	smartGoal: SmartGoal;
}
export interface CreateSmartGoalResponse {
	/**
	 * The smart goal id
	 * @format uint64
	 */
	smartGoalId?: string;
}
export type CreateSubscriptionData = any;
export interface CreateSubscriptionRequest {
	priceId: string;
	profileType: FinancialUserProfileType;
	/** @format uint64 */
	userId: string;
}
export interface CreateSubscriptionResponse {
	paymentIntentClientSecret?: string;
	subscriptionId?: string;
}
export type CreateUserProfileData = any;
/**
 * CreateUserProfileRequest: Represents the request object invoked against the user
 * service to create a user profile
 */
export interface CreateUserProfileRequest {
	/** the email of the account to create */
	email: string;
	/**
	 * User profile to create
	 * Validations:
	 * - cannot be nil hence required
	 */
	profile: FinancialUserProfile;
}
/**
 * CreateUserProfileResponse: Represents the response object returned as a response to
 * the `create user profile` request
 */
export interface CreateUserProfileResponse {
	/** @format uint64 */
	userId?: string;
}
export interface CreditAccount {
	/** the aprs */
	aprs?: Array<Apr>;
	/**
	 * the bank account balance
	 * @format float
	 */
	balance?: number;
	/**
	 * balance limit
	 * @format uint64
	 */
	balanceLimit?: string;
	/**
	 * current funds on the account
	 * @format double
	 */
	currentFunds?: number;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** wether the account is overdue */
	isOverdue?: boolean;
	/**
	 * the last payment amount
	 * @format double
	 */
	lastPaymentAmount?: number;
	/** the last payment date */
	lastPaymentDate?: string;
	/**
	 * the last statement balance
	 * @format double
	 */
	lastStatementBalance?: number;
	/** the last statement issue date */
	lastStatementIssueDate?: string;
	/**
	 * the minimum amount due date
	 * @format double
	 */
	minimumAmountDueDate?: number;
	/**
	 * the minimum payment amount
	 * @format double
	 */
	minimumPaymentAmount?: number;
	/** the account name */
	name?: string;
	/** the next payment date */
	nextPaymentDate?: string;
	/** the next payment due date */
	nextPaymentDueDate?: string;
	/** the bank account number */
	number?: string;
	/** plaid account id mapped to this bank account */
	plaidAccountId?: string;
	/** set of pockets tied to this account */
	pockets?: Array<Pocket>;
	/** the set of subscriptions tied to this account */
	recurringTransactions?: Array<PlaidAccountRecurringTransaction>;
	/** the bank account status */
	status?: BankAccountStatus;
	/** accoint subtype */
	subtype?: string;
	/** the set of transactions tied to this account */
	transactions?: Array<PlaidAccountTransaction>;
	/** the bank account type */
	type?: string;
	/**
	 * the user id to which this bank account is tied to
	 * @format uint64
	 */
	userId?: string;
}
/**
 * DebtToIncomeRatio
 * This message is used to represent the debt to income ratio of a user.
 */
export interface DebtToIncomeRatio {
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	ratio?: number;
	/** @format uint64 */
	userId?: string;
}
export interface DeleteBankAccountResponse {
	/**
	 * The bank account id
	 * @example "true"
	 */
	deleted?: boolean;
}
export type DeleteBudgetData = any;
export interface DeleteBudgetResponse {
	/** The budget id */
	deleted?: boolean;
}
export type DeleteLinkData = any;
export interface DeleteLinkResponse {
	/**
	 * The link's id
	 * @format uint64
	 */
	linkId?: string;
}
export type DeleteMilestoneData = any;
export interface DeleteMilestoneResponse {
	/** The milestone id */
	deleted?: boolean;
}
export type DeleteNoteFromRecurringTransactionData = any;
export interface DeleteNoteFromRecurringTransactionResponse {
	/** The transaction id */
	deleted?: boolean;
}
export type DeleteNoteFromSmartGoalData = any;
export interface DeleteNoteFromSmartGoalResponse {
	/** The smart goal id */
	deleted?: boolean;
}
export type DeleteNoteFromTransactionData = any;
export interface DeleteNoteFromTransactionResponse {
	/** The transaction id */
	deleted?: boolean;
}
export type DeletePocketData = any;
export interface DeletePocketResponse {
	/** The pocket id */
	deleted?: boolean;
}
/** DeleteTransactionResponse is the delete transaction response */
export interface DeleteRecurringTransactionResponse {
	/** the transaction that was successfully deleted */
	deleted?: boolean;
}
export type DeleteSmartGoalData = any;
export interface DeleteSmartGoalResponse {
	/** The smart goal id */
	deleted?: boolean;
}
export type DeleteTransaction2Data = any;
export type DeleteTransactionData = any;
/** DeleteTransactionResponse is the delete transaction response */
export interface DeleteTransactionResponse {
	/** the transaction that was successfully deleted */
	deleted?: boolean;
}
export type DeleteUserProfile2Data = any;
export type DeleteUserProfileData = any;
/**
 * DeleteUserProfileResponse: Represents the response object returned as a response to
 * the `delete user profile` request
 */
export interface DeleteUserProfileResponse {
	profileDeleted?: boolean;
}
export type ExchangePlaidTokenData = any;
/**
 * ExpenseMetrics
 * This message is used to represent the expense metrics of a user.
 */
export interface ExpenseMetrics {
	/** @format int64 */
	month?: number;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalExpenses?: number;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
/**
 * ExpenseMetricsFinancialSubProfileMetrics
 * This message is used to represent the financial sub profile metrics of a user.
 */
export interface ExpenseMetricsFinancialSubProfileMetrics {
	/** @format double */
	averageMonthlyDiscretionarySpending?: number;
	/** @format double */
	averageMonthlyRecurringSpending?: number;
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	spentLastMonth?: number;
	/** @format double */
	spentLastSixMonths?: number;
	/** @format double */
	spentLastWeek?: number;
	/** @format uint64 */
	userId?: string;
}
/** @default "FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED" */
export type FinancialAccountType = "FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED" | "FINANCIAL_ACCOUNT_TYPE_BANK" | "FINANCIAL_ACCOUNT_TYPE_INVESTMENT" | "FINANCIAL_ACCOUNT_TYPE_CREDIT" | "FINANCIAL_ACCOUNT_TYPE_MORTGAGE" | "FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN";
/**
 * FinancialProfile
 * This message is used to represent the financial profile of a user.
 */
export interface FinancialProfile {
	/** @format int64 */
	month?: number;
	mostExpensiveCategory?: string;
	/** @format uint64 */
	numberOfTransactions?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalExpenses?: number;
	/** @format double */
	totalIncome?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * FinancialUserProfile stores high level user profile details
 * such as the id, user_id tied to the profile, and many more
 */
export interface FinancialUserProfile {
	actionableInsights?: Array<ActionableInsight>;
	actionablePersonalInsights?: Array<PersonalActionableInsight>;
	email?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** a user profile can have many links (connected institutions) of which finanical accounts are tied to (checking, savings, etc) */
	link?: Array<Link>;
	profileType?: FinancialUserProfileType;
	stripeCustomerId?: string;
	/** the stripe subscriptions the user profile actively maintains */
	stripeSubscriptions?: StripeSubscription;
	/** @format uint64 */
	userId?: string;
}
/** @default "FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED" */
export type FinancialUserProfileType = "FINANCIAL_USER_PROFILE_TYPE_UNSPECIFIED" | "FINANCIAL_USER_PROFILE_TYPE_USER" | "FINANCIAL_USER_PROFILE_TYPE_BUSINESS";
/**
 * The Forecast table stores information about each forecast generated for a particular goal,
 * including the forecast date, the forecasted amount of money saved or invested for the
 * goal by the target date, and the variance between the forecasted and target amounts.
 * This allows the user to track how well they are progressing towards their goal and make adjustments as needed.
 */
export interface Forecast {
	/**
	 * the forecasted amount of the goal
	 * @example "Active"
	 */
	forecastedAmount?: string;
	/**
	 * the forecasted completion date of the goal
	 * @example "Active"
	 */
	forecastedCompletionDate?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/**
	 * the forecasted variance of the goal between the forecasted and target amounts
	 * @example "Active"
	 */
	varianceAmount?: string;
}
export type GetAccountBalanceData = any;
export type GetAccountBalanceHistoryData = any;
export interface GetAccountBalanceHistoryResponse {
	/** List of account balance history records for specific account */
	accountBalanceHistory?: Array<AccountBalanceHistory>;
}
export type GetAllBudgetsData = any;
export interface GetAllBudgetsResponse {
	/** The budgets */
	budgets?: Array<Budget>;
}
export type GetBankAccountData = any;
/**
 * GetBankAccountResponse: Represents the response object returned as a response to
 * the `get bank account` request
 */
export interface GetBankAccountResponse {
	/** The bank account */
	bankAccount?: BankAccount;
}
export type GetBudgetData = any;
export interface GetBudgetResponse {
	/**
	 * The budget
	 * The Budgets table stores information about each budget created by the user,
	 * including the name of the budget, the start and end dates, and the user ID.
	 */
	budget?: Budget;
}
export type GetCategoryMonthlyTransactionCountData = any;
export interface GetCategoryMonthlyTransactionCountResponse {
	categoryMonthlyTransactionCount?: Array<CategoryMonthlyTransactionCount>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetDebtToIncomeRatioData = any;
export interface GetDebtToIncomeRatioResponse {
	debtToIncomeRatios?: Array<DebtToIncomeRatio>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetExpenseMetricsData = any;
export interface GetExpenseMetricsResponse {
	expenseMetrics?: Array<ExpenseMetrics>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetFinancialProfileData = any;
export interface GetFinancialProfileResponse {
	financialProfiles?: Array<FinancialProfile>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetForecastData = any;
export interface GetForecastResponse {
	/**
	 * The forecast
	 * The Forecast table stores information about each forecast generated for a particular goal,
	 * including the forecast date, the forecasted amount of money saved or invested for the
	 * goal by the target date, and the variance between the forecasted and target amounts.
	 * This allows the user to track how well they are progressing towards their goal and make adjustments as needed.
	 */
	forecast?: Forecast;
}
export interface GetHistoricalAccountBalanceResponse {
	historicalAccountBalance?: Array<AccountBalanceHistory>;
}
export type GetIncomeExpenseRatioData = any;
export interface GetIncomeExpenseRatioResponse {
	incomeExpenseRatios?: Array<IncomeExpenseRatio>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetIncomeMetricsData = any;
export interface GetIncomeMetricsResponse {
	incomeMetrics?: Array<IncomeMetrics>;
	/** @format int64 */
	nextPageNumber?: string;
}
export interface GetInvestmentAcccountResponse {
	/** The investment account */
	investmentAccount?: InvestmentAccount;
}
export type GetInvestmentAccountData = any;
export type GetLiabilityAccountData = any;
export interface GetLiabilityAccountResponse {
	/** The liability account */
	liabilityAccount?: CreditAccount;
}
export type GetLinkData = any;
export interface GetLinkResponse {
	/**
	 * The link
	 * A Link represents a login at a financial institution. A single end-user of your application might have accounts at different financial
	 * institutions, which means they would have multiple different Items. An Item is not the same as a financial institution account,
	 * although every account will be associated with an Item. For example, if a user has one login at their bank that allows them to access
	 * both their checking account and their savings account, a single Item would be associated with both of those accounts. Each Item
	 * linked within your application will have a corresponding access_token, which is a token that you can use to make API requests related
	 * to that specific Item.
	 * Two Items created for the same set of credentials at the same institution will be considered different and not share the same item_id.
	 */
	link?: Link;
}
export type GetLinksData = any;
export interface GetLinksResponse {
	/** The links */
	links?: Array<Link>;
}
export type GetMelodyFinancialContextData = any;
export interface GetMelodyFinancialContextResponse {
	/**
	 * MelodyFinancialContext represents the financial context of a user.
	 * This message is used to represent the financial context of a user.
	 */
	melodyFinancialContext?: MelodyFinancialContext;
}
export type GetMerchantMonthlyExpenditureData = any;
export interface GetMerchantMonthlyExpenditureResponse {
	merchantMonthlyExpenditures?: Array<MerchantMonthlyExpenditure>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMilestoneData = any;
export interface GetMilestoneResponse {
	/** The milestone */
	milestone?: Milestone;
}
export interface GetMilestonesBySmartGoalIdResponse {
	/** The milestones */
	milestones?: Array<Milestone>;
}
export type GetMilestonesData = any;
export type GetMonthlyBalanceData = any;
export interface GetMonthlyBalanceResponse {
	monthlyBalances?: Array<MonthlyBalance>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMonthlyExpenditureData = any;
export interface GetMonthlyExpenditureResponse {
	monthlyExpenditures?: Array<MonthlyExpenditure>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMonthlyIncomeData = any;
export interface GetMonthlyIncomeResponse {
	monthlyIncomes?: Array<MonthlyIncome>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMonthlySavingsData = any;
export interface GetMonthlySavingsResponse {
	monthlySavings?: Array<MonthlySavings>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMonthlyTotalQuantityBySecurityAndUserData = any;
export interface GetMonthlyTotalQuantityBySecurityAndUserResponse {
	monthlyTotalQuantityBySecurityAndUser?: Array<MonthlyTotalQuantityBySecurityAndUser>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMonthlyTransactionCountData = any;
export interface GetMonthlyTransactionCountResponse {
	monthlyTransactionCounts?: Array<MonthlyTransactionCount>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetMortageAccountData = any;
export interface GetMortgageAccountResponse {
	/** The mortage account */
	mortageAccount?: MortgageAccount;
}
export type GetNoteFromSmartGoalData = any;
export interface GetNoteFromSmartGoalResponse {
	/** The note */
	note?: SmartNote;
}
export type GetNoteFromTransactionData = any;
export interface GetNoteFromTransactionResponse {
	/** The note */
	note?: SmartNote;
}
export type GetNotesFromSmartGoalData = any;
export interface GetNotesFromSmartGoalResponse {
	/** The notes */
	notes?: Array<SmartNote>;
}
export type GetPaymentChannelMonthlyExpenditureData = any;
export interface GetPaymentChannelMonthlyExpenditureResponse {
	/** @format int64 */
	nextPageNumber?: string;
	paymentChannelMonthlyExpenditure?: Array<PaymentChannelMonthlyExpenditure>;
}
export type GetPocketData = any;
export interface GetPocketResponse {
	/** The pocket account */
	pocket?: Pocket;
}
export interface GetReCurringTransactionsResponse {
	/** The re-occuring transactions */
	reCcuringTransactions?: Array<ReOccuringTransaction>;
}
export type GetRecurringTransactionData = any;
/** GetRecurringTransactionResponse is the get transaction response */
export interface GetRecurringTransactionResponse {
	/**
	 * the transaction queried
	 * Message representing recurring transactions associated with a Plaid account.
	 */
	transaction?: PlaidAccountRecurringTransaction;
}
export type GetRecurringTransactionsData = any;
export type GetSmartGoalsByPocketIdData = any;
export interface GetSmartGoalsByPocketIdResponse {
	/** The smart goals */
	smartGoals?: Array<SmartGoal>;
}
export type GetSplitTransactionData = any;
export interface GetSplitTransactionResponse {
	/** The split transactions */
	splitTransactions?: Array<TransactionSplit>;
}
export type GetStudentLoanAccountData = any;
export interface GetStudentLoanAccountResponse {
	/** The student loan account */
	studentLoanAccount?: StudentLoanAccount;
}
export type GetTotalInvestmentBySecurityData = any;
export interface GetTotalInvestmentBySecurityResponse {
	/** @format int64 */
	nextPageNumber?: string;
	totalInvestmentBySecurity?: Array<TotalInvestmentBySecurity>;
}
export interface GetTransactionAggregatesResponse {
	/** @format int64 */
	nextPageNumber?: string;
	transactionAggregates?: Array<TransactionAggregatesByMonth>;
}
export type GetTransactionData = any;
/** GetTransactionResponse is the get transaction response */
export interface GetTransactionResponse {
	/**
	 * the transaction queried
	 * Message representing Plaid account transactions.
	 */
	transaction?: PlaidAccountTransaction;
}
export type GetTransactions2Data = any;
export interface GetTransactionsBetweenTimeRangesResponse {
	/**
	 * Current page number
	 * @format int64
	 */
	currentPage?: number;
	/**
	 * Total number of pages
	 * @format int64
	 */
	totalAges?: number;
	/**
	 * Total number of transactions in the month
	 * @format uint64
	 */
	totalTransactions?: string;
	/** The transactions */
	transactions?: Array<PlaidAccountTransaction>;
}
export type GetTransactionsByTimeData = any;
export type GetTransactionsData = any;
export interface GetTransactionsForBankAccountResponse {
	/** @format uint64 */
	nextPageNumber?: string;
	/** The transactions */
	transactions?: Array<Transaction>;
}
export type GetTransactionsForPastMonthData = any;
export interface GetTransactionsForPastMonthResponse {
	/**
	 * Current page number
	 * @format int64
	 */
	currentPage?: number;
	/**
	 * Total number of pages
	 * @format int64
	 */
	totalPages?: number;
	/**
	 * Total number of transactions in the month
	 * @format uint64
	 */
	totalTransactions?: string;
	transactions?: Array<PlaidAccountTransaction>;
}
export type GetTransactionsForPastWeekData = any;
export interface GetTransactionsForPastWeekResponse {
	/**
	 * Current page number
	 * @format int64
	 */
	currentPage?: number;
	/**
	 * Total number of pages
	 * @format int64
	 */
	totalPages?: number;
	/**
	 * Total number of transactions in the week
	 * @format uint64
	 */
	totalTransactions?: string;
	transactions?: Array<PlaidAccountTransaction>;
}
export interface GetTransactionsResponse {
	/** @format uint64 */
	nextPageNumber?: string;
	/** The transactions */
	transactions?: Array<Transaction>;
}
export type GetUserAccountBalanceHistoryData = any;
export interface GetUserAccountBalanceHistoryResponse {
	/** List of account balance history records */
	accountBalanceHistory?: Array<AccountBalanceHistory>;
}
export type GetUserCategoryMonthlyExpenditureData = any;
export interface GetUserCategoryMonthlyExpenditureResponse {
	/** List of CategoryMonthlyExpenditure records for the user */
	categoryMonthlyExpenditure?: Array<CategoryMonthlyExpenditure>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetUserCategoryMonthlyIncomeData = any;
export interface GetUserCategoryMonthlyIncomeResponse {
	categoryMonthlyIncome?: Array<CategoryMonthlyIncome>;
	/** @format int64 */
	nextPageNumber?: string;
}
export type GetUserProfileData = any;
/**
 * GetUserProfileResponse: Represents the response object returned as a response to
 * the `get user profile` request
 */
export interface GetUserProfileResponse {
	/**
	 * financial context for the user
	 * MelodyFinancialContext represents the financial context of a user.
	 * This message is used to represent the financial context of a user.
	 */
	financialContext: MelodyFinancialContext;
	profile?: FinancialUserProfile;
}
/** @default "GOAL_TYPE_UNSPECIFIED" */
export type GoalType = "GOAL_TYPE_UNSPECIFIED" | "GOAL_TYPE_SAVINGS" | "GOAL_TYPE_INVESTMENT" | "GOAL_TYPE_DEBT" | "GOAL_TYPE_EXPENSE";
export type HealthCheckData = any;
export interface HealthCheckResponse {
	healthy?: boolean;
}
/**
 * IncomeExpenseRatio
 * This message is used to represent the income expense ratio of a user.
 */
export interface IncomeExpenseRatio {
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	ratio?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * IncomeMetrics
 * This message is used to represent the income metrics of a user.
 */
export interface IncomeMetrics {
	/** @format int64 */
	month?: number;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalIncome?: number;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
/**
 * IncomeMetricsFinancialSubProfile
 * This message is used to represent the financial sub profile of a user.
 */
export interface IncomeMetricsFinancialSubProfile {
	/** @format double */
	incomeLastMonth?: number;
	/** @format double */
	incomeLastSixMonths?: number;
	/** @format double */
	incomeLastTwoMonths?: number;
	/** @format double */
	incomeLastTwoWeeks?: number;
	/** @format double */
	incomeLastYear?: number;
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format uint64 */
	userId?: string;
}
export type InitiatePlaidSetupData = any;
export type InitiatePlaidTokenUpdateData = any;
export interface InvesmentHolding {
	/**
	 * @format double
	 * @example "15"
	 */
	costBasis?: number;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/**
	 * @format double
	 * @example "13.73"
	 */
	institutionPrice?: number;
	/** @example "2021-04-13" */
	institutionPriceAsOf?: string;
	/** @example "2022-06-07T23:01:00Z" */
	institutionPriceDatetime?: string;
	/**
	 * @format double
	 * @example "4437.35905"
	 */
	institutionValue?: number;
	/** @example "USD" */
	isoCurrencyCode?: string;
	/**
	 * The name of the investment holding
	 * @minLength 3
	 * @example "nfdkjfjksdhjhfjsdhjgf"
	 */
	name?: string;
	/**
	 * plaid account id
	 * @example "k67E4xKvMlhmleEa4pg9hlwGGNnnEeixPolGm"
	 */
	plaidAccountId?: string;
	/**
	 * @format double
	 * @example "25000"
	 */
	quantity?: number;
	/** @example "vLRMV3MvY1FYNP91on35CJD5QN5rw9Fpa9qOL" */
	securityId?: string;
	/** @example "USD" */
	unofficialCurrencyCode?: string;
}
export interface InvestmentAccount {
	/**
	 * the bank account balance
	 * @format float
	 */
	balance?: number;
	/** @format uint64 */
	balanceLimit?: string;
	/** @format double */
	currentFunds?: number;
	/** invesment holding is the set of securities this account witholds */
	holdings?: Array<InvesmentHolding>;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** the account name */
	name?: string;
	/** the bank account number */
	number?: string;
	/** plaid account id mapped to this bank account */
	plaidAccountId?: string;
	/** the set of securities this account witholds */
	securities?: Array<InvestmentSecurity>;
	/** the bank account status */
	status?: BankAccountStatus;
	/** accoint subtype */
	subtype?: string;
	/** the set of transactions tied to this account */
	transactions?: Array<PlaidAccountInvestmentTransaction>;
	/** the bank account type */
	type?: string;
	/**
	 * the user id to which this bank account is tied to
	 * @format uint64
	 */
	userId?: string;
}
export interface InvestmentSecurity {
	/**
	 * @format double
	 * @example " 0.140034616"
	 */
	closePrice?: number;
	/** @example "2022-01-24" */
	closePriceAsOf?: string;
	/** @example "dfkjhdgjdhhgd" */
	cusip?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** @example "ins_3" */
	institutionId?: string;
	/** @example "dfkjhdgjdhhgd" */
	institutionSecurityId?: string;
	/** @example "true" */
	isCashEquivalent?: boolean;
	/** @example "dfkjhdgjdhhgd" */
	isin?: string;
	/** @example "USD" */
	isoCurrencyCode?: string;
	/** @example "Dogecoin" */
	name?: string;
	/** @example "dfkjhdgjdhhgd" */
	proxySecurityId?: string;
	/** @example "vLRMV3MvY1FYNP91on35CJD5QN5rw9Fpa9qOL" */
	securityId?: string;
	/** @example "dfkjhdgjdhhgd" */
	sedol?: string;
	/** @example "DOGE" */
	tickerSymbol?: string;
	/** @example "cryptocurrency" */
	type?: string;
	/** @example "USD" */
	unofficialCurrencyCode?: string;
	/** @example "2022-06-07T23:01:00Z" */
	updateDatetime?: string;
}
/**
 * A Link represents a login at a financial institution. A single end-user of your application might have accounts at different financial
 * institutions, which means they would have multiple different Items. An Item is not the same as a financial institution account,
 * although every account will be associated with an Item. For example, if a user has one login at their bank that allows them to access
 * both their checking account and their savings account, a single Item would be associated with both of those accounts. Each Item
 * linked within your application will have a corresponding access_token, which is a token that you can use to make API requests related
 * to that specific Item.
 * Two Items created for the same set of credentials at the same institution will be considered different and not share the same item_id.
 */
export interface Link {
	/**
	 * a link event - or client login event can have many connected bank accounts
	 * for example a log in link against one instition like chase can have many account (checking and savings)
	 * it is important though to ensure that if a link against an instition already exists, we dont fascilitate duplicated
	 */
	bankAccounts?: Array<BankAccount>;
	/** credit accounts tied to a user */
	creditAccounts?: Array<CreditAccount>;
	customInstitutionName?: string;
	description?: string;
	errorCode?: string;
	expirationDate?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	institutionName?: string;
	/**
	 * a link event - or client login event can have many connected investment accounts
	 * for example a log in link against one instition like fidelity can have many accounts (401k and investment account)
	 * it is important though to ensure that if a link against an instition already exists, we dont fascilitate duplicated
	 */
	investmentAccounts?: Array<InvestmentAccount>;
	lastManualSync?: string;
	lastSuccessfulUpdate?: string;
	linkStatus?: LinkStatus;
	/** the type of link this is ... can be either a manual or plaid link type */
	linkType?: LinkType;
	/** mortgage accounts tied to a user */
	mortgageAccounts?: Array<MortgageAccount>;
	newAccountsAvailable?: boolean;
	/** the id of the institution this link is tied to and against */
	plaidInstitutionId?: string;
	plaidLink?: PlaidLink;
	plaidNewAccountsAvailable?: boolean;
	plaidSync?: PlaidSync;
	shouldBeUpdated?: boolean;
	/** student loan accounts tied to a link */
	studentLoanAccounts?: Array<StudentLoanAccount>;
	/**
	 * token object witholds an access token which is a token used to make API requests related to a specific Item. You will typically obtain an access_token
	 * by calling /item/public_token/exchange. For more details, see the Token exchange flow. An access_token does not expire,
	 * although it may require updating, such as when a user changes their password, or when working with European institutions
	 * that comply with PSD2's 90-day consent window. For more information, see When to use update mode.
	 * Access tokens should always be stored securely, and associated with the user whose data they represent.
	 * If compromised, an access_token can be rotated via /item/access_token/invalidate. If no longer needed,
	 * it can be revoked via /item/remove.(gorm.field).has_one = {disable_association_autocreate: false disable_association_autoupdate: false preload: true}];
	 */
	token?: Token;
	updatedAt?: string;
}
/** @default "LINK_STATUS_UNSPECIFIED" */
export type LinkStatus = "LINK_STATUS_UNSPECIFIED" | "LINK_STATUS_SETUP" | "LINK_STATUS_PENDING" | "LINK_STATUS_ERROR" | "LINK_STATUS_SUCCESS" | "LINK_STATUS_PENDING_EXPIRATION" | "LINK_STATUS_REVOKED" | "LINK_STATUS_ITEM_LOGIN_REQUIRED";
/** @default "LINK_TYPE_UNSPECIFIED" */
export type LinkType = "LINK_TYPE_UNSPECIFIED" | "LINK_TYPE_PLAID" | "LINK_TYPE_MANUAL";
export type ListRecurringTransactionNotesData = any;
export interface ListRecurringTransactionNotesResponse {
	/** The notes */
	notes?: Array<SmartNote>;
}
export type ListRecurringTransactionsData = any;
/** ListRecurringTransactionsResponse is the list transaction response */
export interface ListRecurringTransactionsResponse {
	nextPage?: string;
	transactions?: Array<PlaidAccountRecurringTransaction>;
}
export type ListTransactionNotesData = any;
export interface ListTransactionNotesResponse {
	/** The notes */
	notes?: Array<SmartNote>;
}
export type ListTransactions2Data = any;
/** ListTransactionsResponse is the list transaction response */
export interface ListTransactionsAcrossAllAccountsResponse {
	/** @format uint64 */
	nextPage?: string;
	transactions?: Array<PlaidAccountTransaction>;
}
export type ListTransactionsData = any;
/** ListTransactionsResponse is the list transaction response */
export interface ListTransactionsResponse {
	nextPage?: string;
	transactions?: Array<PlaidAccountTransaction>;
}
/**
 * LocationFinancialSubProfile
 * This message is used to represent the financial sub profile of a location.
 */
export interface LocationFinancialSubProfile {
	locationCity?: string;
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	spentLastMonth?: number;
	/** @format double */
	spentLastSixMonths?: number;
	/** @format double */
	spentLastTwoWeeks?: number;
	/** @format double */
	spentLastTwoYears?: number;
	/** @format double */
	spentLastWeek?: number;
	/** @format double */
	spentLastYear?: number;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
/**
 * MelodyFinancialContext represents the financial context of a user.
 * This message is used to represent the financial context of a user.
 */
export interface MelodyFinancialContext {
	bankAccounts?: Array<BankAccount>;
	categories?: Array<CategoryMetricsFinancialSubProfile>;
	creditAccounts?: Array<CreditAccount>;
	expenses?: Array<ExpenseMetricsFinancialSubProfileMetrics>;
	financialUserProfileType?: FinancialUserProfileType;
	income?: Array<IncomeMetricsFinancialSubProfile>;
	investmentAccounts?: Array<InvestmentAccount>;
	locations?: Array<LocationFinancialSubProfile>;
	merchants?: Array<MerchantMetricsFinancialSubProfile>;
	mortgageLoanAccounts?: Array<MortgageAccount>;
	paymentChannels?: Array<PaymentChannelMetricsFinancialSubProfile>;
	studentLoanAccounts?: Array<StudentLoanAccount>;
}
/**
 * MerchantFinancialSubProfile
 * This message is used to represent the financial sub profile of a merchant.
 */
export interface MerchantMetricsFinancialSubProfile {
	merchantName?: string;
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	spentLastMonth?: number;
	/** @format double */
	spentLastSixMonths?: number;
	/** @format double */
	spentLastTwoWeeks?: number;
	/** @format double */
	spentLastTwoYears?: number;
	/** @format double */
	spentLastWeek?: number;
	/** @format double */
	spentLastYear?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * MerchantMonthlyExpenditure
 * This message is used to represent the monthly expenditure of a merchant.
 */
export interface MerchantMonthlyExpenditure {
	merchantName?: string;
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalSpending?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * Milestone: represents a milestone in the context of simfinni. A financial milestone that is both smart
 * and achievable. A milestone is a sub goal of a goal and is tied to a goal by the goal id
 */
export interface Milestone {
	/**
	 * the budget associated with the milestone
	 * The Budgets table stores information about each budget created by the user,
	 * including the name of the budget, the start and end dates, and the user ID.
	 */
	budget?: Budget;
	/**
	 * The description of the miletone
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "Buy a car"
	 */
	description?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/**
	 * wethe milestone is completed or not
	 * @example true
	 */
	isCompleted?: boolean;
	/**
	 * The name of the milestone
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "Buy a car"
	 */
	name?: string;
	/**
	 * the target amount of the milestone
	 * @example "Active"
	 */
	targetAmount?: string;
	/**
	 * the target date of the milestone
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "testtagdescription"
	 */
	targetDate?: string;
}
/**
 * MonthlyBalance
 * This message is used to represent the monthly balance of a user.
 */
export interface MonthlyBalance {
	/** @format int64 */
	month?: number;
	/** @format double */
	netBalance?: number;
	profileType?: FinancialUserProfileType;
	/** @format uint64 */
	userId?: string;
}
/**
 * MonthlyExpenditure
 * This message is used to represent the monthly expenditure of a user.
 */
export interface MonthlyExpenditure {
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalSpending?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * MonthlyIncome
 * This message is used to represent the monthly income of a user.
 */
export interface MonthlyIncome {
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalIncome?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * MonthlySavings
 * This message is used to represent the monthly savings of a user.
 */
export interface MonthlySavings {
	/** @format int64 */
	month?: number;
	/** @format double */
	netSavings?: number;
	profileType?: FinancialUserProfileType;
	/** @format uint64 */
	userId?: string;
}
/**
 * MonthlyTotalQuantityBySecurityAndUser
 * This message is used to represent the monthly total quantity of a security.
 */
export interface MonthlyTotalQuantityBySecurityAndUser {
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	securityId?: string;
	/** @format double */
	totalQuantity?: number;
	/** @format uint64 */
	userId?: string;
}
/**
 * MonthlyTransactionCount
 * This message is used to represent the monthly transaction count of a user.
 */
export interface MonthlyTransactionCount {
	/** @format int64 */
	month?: number;
	profileType?: FinancialUserProfileType;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
export interface MortgageAccount {
	accountNumber?: string;
	/** @format double */
	currentLateFee?: number;
	/** @format double */
	escrowBalance?: number;
	hasPmi?: boolean;
	hasPrepaymentPenalty?: boolean;
	/** @format uint64 */
	id?: string;
	/** @format double */
	interestRatePercentage?: number;
	interestRateType?: string;
	/** @format double */
	lastPaymentAmount?: number;
	lastPaymentDate?: string;
	loanTerm?: string;
	loanTypeDescription?: string;
	maturityDate?: string;
	/** @format double */
	nextMonthlyPayment?: number;
	nextPaymentDueDate?: string;
	/** @format double */
	originalPrincipalBalance?: number;
	/** @format double */
	originalPropertyValue?: number;
	originationDate?: string;
	/** @format double */
	originationPrincipalAmount?: number;
	/** @format double */
	outstandingPrincipalBalance?: number;
	/** @format double */
	pastDueAmount?: number;
	/** @format double */
	paymentAmount?: number;
	paymentDate?: string;
	plaidAccountId?: string;
	propertyAddressCity?: string;
	propertyAddressPostalCode?: string;
	propertyAddressState?: string;
	propertyAddressStreet?: string;
	propertyCountry?: string;
	propertyRegion?: string;
	/** the bank account status */
	status?: BankAccountStatus;
	/** @format double */
	ytdInterestPaid?: number;
	/** @format double */
	ytdPrincipalPaid?: number;
}
/**
 * PaymentChannelMetricsFinancialSubProfile
 * This message is used to represent the financial sub profile of a payment channel.
 */
export interface PaymentChannelMetricsFinancialSubProfile {
	/** @format int64 */
	month?: number;
	paymentChannel?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	spentLastMonth?: number;
	/** @format double */
	spentLastSixMonths?: number;
	/** @format double */
	spentLastTwoWeeks?: number;
	/** @format double */
	spentLastTwoYears?: number;
	/** @format double */
	spentLastWeek?: number;
	/** @format double */
	spentLastYear?: number;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
/**
 * PaymentChannelMonthlyExpenditure
 * This message is used to represent the monthly expenditure of a payment channel.
 */
export interface PaymentChannelMonthlyExpenditure {
	/** @format int64 */
	month?: number;
	paymentChannel?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalSpending?: number;
	/** @format uint64 */
	userId?: string;
}
export interface PersonalActionableInsight {
	/** insight action */
	action?: string;
	/** insight description */
	description?: string;
	/** insight expected benefit */
	expectedBenefit?: string;
	/**
	 * insight generated time
	 * @format date-time
	 */
	generatedTime?: string;
	/** @format uint64 */
	id?: string;
	insightName?: PersonalActionableInsightName;
	/** metrics to optimize for */
	metricsToOptimizeFor?: Array<string>;
	/** insight tags */
	tags?: Array<string>;
	/** insight takeaway */
	takeaway?: string;
}
/** @default "PERSONAL_ACTIONABLE_INSIGHT_NAME_UNSPECIFIED" */
export type PersonalActionableInsightName = "PERSONAL_ACTIONABLE_INSIGHT_NAME_UNSPECIFIED" | "PERSONAL_ACTIONABLE_INSIGHT_NAME_EXPENSE" | "PERSONAL_ACTIONABLE_INSIGHT_NAME_EMERGENCY_FUND" | "PERSONAL_ACTIONABLE_INSIGHT_NAME_DEBT_PRIORITIZATION" | "PERSONAL_ACTIONABLE_INSIGHT_NAME_NON_ESSENTIAL_EXPENSES" | "PERSONAL_ACTIONABLE_INSIGHT_NAME_NON_SUBSCRIPTIONS" | "PERSONAL_ACTIONABLE_INSIGHT_NAME_DISCRETIONARY_SPENDING";
/** Message representing investment transactions associated with a Plaid account. */
export interface PlaidAccountInvestmentTransaction {
	/**
	 * The unique identifier for the associated investment account.
	 * @gotag: ch:"account_id"
	 */
	accountId?: string;
	/**
	 * Additional properties related to this investment transaction.
	 * @gotag: ch:"additional_properties"
	 * `Any` contains an arbitrary serialized protocol buffer message along with a
	 * URL that describes the type of the serialized message.
	 *
	 * Protobuf library provides support to pack/unpack Any values in the form
	 * of utility functions or additional generated methods of the Any type.
	 *
	 * Example 1: Pack and unpack a message in C++.
	 *
	 *     Foo foo = ...;
	 *     Any any;
	 *     any.PackFrom(foo);
	 *     ...
	 *     if (any.UnpackTo(&foo)) {
	 *       ...
	 *     }
	 *
	 * Example 2: Pack and unpack a message in Java.
	 *
	 *     Foo foo = ...;
	 *     Any any = Any.pack(foo);
	 *     ...
	 *     if (any.is(Foo.class)) {
	 *       foo = any.unpack(Foo.class);
	 *     }
	 *
	 * Example 3: Pack and unpack a message in Python.
	 *
	 *     foo = Foo(...)
	 *     any = Any()
	 *     any.Pack(foo)
	 *     ...
	 *     if any.Is(Foo.DESCRIPTOR):
	 *       any.Unpack(foo)
	 *       ...
	 *
	 * Example 4: Pack and unpack a message in Go
	 *
	 *      foo := &pb.Foo{...}
	 *      any, err := anypb.New(foo)
	 *      if err != nil {
	 *        ...
	 *      }
	 *      ...
	 *      foo := &pb.Foo{}
	 *      if err := any.UnmarshalTo(foo); err != nil {
	 *        ...
	 *      }
	 *
	 * The pack methods provided by protobuf library will by default use
	 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
	 * methods only use the fully qualified type name after the last '/'
	 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
	 * name "y.z".
	 *
	 *
	 * JSON
	 *
	 * The JSON representation of an `Any` value uses the regular
	 * representation of the deserialized, embedded message, with an
	 * additional field `@type` which contains the type URL. Example:
	 *
	 *     package google.profile;
	 *     message Person {
	 *       string first_name = 1;
	 *       string last_name = 2;
	 *     }
	 *
	 *     {
	 *       "@type": "type.googleapis.com/google.profile.Person",
	 *       "firstName": <string>,
	 *       "lastName": <string>
	 *     }
	 *
	 * If the embedded message type is well-known and has a custom JSON
	 * representation, that representation will be embedded adding a field
	 * `value` which holds the custom JSON in addition to the `@type`
	 * field. Example (for message [google.protobuf.Duration][]):
	 *
	 *     {
	 *       "@type": "type.googleapis.com/google.protobuf.Duration",
	 *       "value": "1.212s"
	 *     }
	 */
	additionalProperties?: Any;
	/**
	 * The amount of the investment transaction.
	 * @gotag: ch:"amount"
	 */
	ammount?: string;
	/**
	 * The monetary amount of the investment transaction.
	 * @gotag: ch:"amount"
	 * @format double
	 */
	amount?: number;
	/**
	 * The date and time when this investment transaction was created.
	 * @gotag: ch:"created_at"
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * The date of the investment transaction.
	 * @gotag: ch:"date"
	 */
	currentDate?: string;
	/**
	 * The fees associated with the investment transaction.
	 * @gotag: ch:"fees"
	 * @format double
	 */
	fees?: number;
	/**
	 * The unique identifier for this investment transaction.
	 * @gotag: ch:"id"
	 * @format uint64
	 */
	id?: string;
	/**
	 * The unique identifier for the investment transaction.
	 * @gotag: ch:"investment_transaction_id"
	 */
	investmentTransactionId?: string;
	/**
	 * The ISO currency code for the investment transaction.
	 * @gotag: ch:"iso_currency_code"
	 */
	isoCurrencyCode?: string;
	/**
	 * The link ID associated with this investment transaction.
	 * @gotag: ch:"link_id"
	 * @format uint64
	 */
	linkId?: string;
	/**
	 * The name or description of the investment transaction.
	 * @gotag: ch:"name"
	 */
	name?: string;
	/**
	 * Notes associated with this investment transaction.
	 * @gotag: ch:"notes"
	 */
	notes?: Array<SmartNote>;
	/**
	 * The price per unit of the security for the investment transaction.
	 * @gotag: ch:"price"
	 * @format double
	 */
	price?: number;
	/**
	 * The quantity of the investment transaction (e.g., number of shares).
	 * @gotag: ch:"quantity"
	 * @format double
	 */
	quantity?: number;
	/**
	 * The security or asset identifier associated with the investment transaction.
	 * @gotag: ch:"security_id"
	 */
	securityId?: string;
	/**
	 * The subtype of the investment transaction (e.g., stock, bond).
	 * @gotag: ch:"subtype"
	 */
	subtype?: string;
	/**
	 * The timestamp associated with this investment transaction.
	 * @gotag: ch:"time"
	 * @format date-time
	 */
	time?: string;
	/**
	 * The type of the investment transaction (e.g., buy, sell, dividend).
	 * @gotag: ch:"type"
	 */
	type?: string;
	/**
	 * The unofficial currency code of the investment transaction.
	 * @gotag: ch:"unofficial_currency_code"
	 */
	unofficialCurrencyCode?: string;
	/**
	 * The user ID associated with this investment transaction.
	 * @gotag: ch:"user_id"
	 * @format uint64
	 */
	userId?: string;
}
/** Message representing recurring transactions associated with a Plaid account. */
export interface PlaidAccountRecurringTransaction {
	/**
	 * The unique identifier for the associated bank account.
	 * @gotag: ch:"account_id"
	 */
	accountId?: string;
	/** Additional properties related to this recurring transaction. */
	additionalProperties?: Any;
	/**
	 * The average amount of the recurring transaction.
	 * @gotag: ch:"average_amount"
	 */
	averageAmount?: string;
	/**
	 * The ISO currency code for the average transaction amount.
	 * @gotag: ch:"average_amount_iso_currency_code"
	 */
	averageAmountIsoCurrencyCode?: string;
	/**
	 * The category ID associated with the recurring transaction.
	 * @gotag: ch:"category_id"
	 */
	categoryId?: string;
	/**
	 * A description or note for the recurring transaction.
	 * @gotag: ch:"description"
	 */
	description?: string;
	/**
	 * The date of the first occurrence of the recurring transaction.
	 * @gotag: ch:"first_date"
	 * @format date-time
	 */
	firstDate?: string;
	/**
	 * The flow associated with this recurring transaction.
	 * @gotag: ch:"flow"
	 */
	flow?: string;
	/**
	 * The frequency at which the recurring transaction occurs (e.g., monthly).
	 * @gotag: ch:"frequency"
	 */
	frequency?: string;
	/**
	 * The unique identifier for this recurring transaction.
	 * @gotag: ch:"id"
	 * @format uint64
	 */
	id?: string;
	/**
	 * Indicates whether the recurring transaction is currently active.
	 * @gotag: ch:"is_active"
	 */
	isActive?: boolean;
	/**
	 * The amount of the most recent occurrence of the recurring transaction.
	 * @gotag: ch:"last_amount"
	 */
	lastAmount?: string;
	/**
	 * The ISO currency code for the most recent transaction amount.
	 * @gotag: ch:"last_amount_iso_currency_code"
	 */
	lastAmountIsoCurrencyCode?: string;
	/**
	 * The date of the last occurrence of the recurring transaction.
	 * @gotag: ch:"last_date"
	 * @format date-time
	 */
	lastDate?: string;
	/**
	 * The link ID associated with this recurring transaction.
	 * @gotag: ch:"link_id"
	 * @format uint64
	 */
	linkId?: string;
	/**
	 * The name of the merchant associated with the recurring transaction.
	 * @gotag: ch:"merchant_name"
	 */
	merchantName?: string;
	/** Notes associated with this recurring transaction. */
	notes?: Array<SmartNote>;
	/**
	 * The detailed personal finance category of the recurring transaction.
	 * @gotag: ch:"personal_finance_category_detailed"
	 */
	personalFinanceCategoryDetailed?: string;
	/**
	 * The primary personal finance category of the recurring transaction.
	 * @gotag: ch:"personal_finance_category_primary"
	 */
	personalFinanceCategoryPrimary?: string;
	/**
	 * The status of the recurring transaction (e.g., "Active" or "Inactive").
	 * @gotag: ch:"status"
	 */
	status?: string;
	/**
	 * The identifier for the recurring transaction stream.
	 * @gotag: ch:"stream_id"
	 */
	streamId?: string;
	/**
	 * The timestamp associated with this recurring transaction.
	 * @format date-time
	 */
	time?: string;
	/**
	 * A comma-separated list of transaction IDs associated with this recurring transaction.
	 * @gotag: ch:"transaction_ids,array"
	 */
	transactionIds?: string;
	/**
	 * The timestamp when this recurring transaction was last updated.
	 * @gotag: ch:"updated_time"
	 * @format date-time
	 */
	updatedTime?: string;
	/**
	 * The user ID associated with this recurring transaction.
	 * @gotag: ch:"user_id"
	 * @format uint64
	 */
	userId?: string;
}
/** Message representing Plaid account transactions. */
export interface PlaidAccountTransaction {
	/**
	 * The bank account ID associated with the transaction.
	 *
	 * @gotag: ch:"account_id"
	 */
	accountId?: string;
	/**
	 * The account owner associated with the transaction.
	 *
	 * @gotag: ch:"account_owner"
	 */
	accountOwner?: string;
	/** Additional properties that can be of any type. */
	additionalProperties?: Any;
	/**
	 * The amount of the transaction.
	 *
	 * @gotag: ch:"amount"
	 * @format double
	 */
	amount?: number;
	/**
	 * The time at which the transaction was authorized.
	 *
	 * @gotag: ch:"authorized_date"
	 * @format date-time
	 */
	authorizedDate?: string;
	/**
	 * The date-time when the transaction was authorized.
	 *
	 * @gotag: ch:"authorized_datetime"
	 * @format date-time
	 */
	authorizedDatetime?: string;
	/** The set of categories that the transaction belongs to. */
	categories?: Array<string>;
	/**
	 * The category ID of the transaction.
	 *
	 * @gotag: ch:"category_id"
	 */
	categoryId?: string;
	/**
	 * The check number associated with the transaction.
	 *
	 * @gotag: ch:"check_number"
	 */
	checkNumber?: string;
	/**
	 * The date of the transaction.
	 *
	 * @gotag: ch:"date"
	 * @format date-time
	 */
	currentDate?: string;
	/**
	 * The current datetime of the transaction.
	 *
	 * @gotag: ch:"datetime"
	 * @format date-time
	 */
	currentDatetime?: string;
	/** Indicates whether this transaction should be hidden. */
	hideTransaction?: boolean;
	/**
	 * The unique ID for this transaction.
	 * @format uint64
	 */
	id?: string;
	/**
	 * The currency code of the transaction.
	 *
	 * @gotag: ch:"iso_currency_code"
	 */
	isoCurrencyCode?: string;
	/**
	 * The link ID associated with this transaction.
	 * @format uint64
	 */
	linkId?: string;
	/** The street address of the transaction location (if available). */
	locationAddress?: string;
	/** The city of the transaction location (if available). */
	locationCity?: string;
	/** The country of the transaction location (if available). */
	locationCountry?: string;
	/**
	 * The latitude of the transaction location (if available).
	 * @format double
	 */
	locationLat?: number;
	/**
	 * The longitude of the transaction location (if available).
	 * @format double
	 */
	locationLon?: number;
	/** The postal code of the transaction location (if available). */
	locationPostalCode?: string;
	/** The region or state of the transaction location (if available). */
	locationRegion?: string;
	/** The store number associated with the transaction location (if available). */
	locationStoreNumber?: string;
	/**
	 * The merchant name of the transaction.
	 *
	 * @gotag: ch:"merchant_name"
	 */
	merchantName?: string;
	/** Indicates whether this transaction needs review. */
	needsReview?: boolean;
	/** Notes associated with this transaction. */
	notes?: Array<SmartNote>;
	/**
	 * The payment channel for the transaction.
	 *
	 * @gotag: ch:"payment_channel"
	 */
	paymentChannel?: string;
	/** Information about the entity to whom the payment is made (if available). */
	paymentMetaByOrderOf?: string;
	/** Information about the payee (if available). */
	paymentMetaPayee?: string;
	/** Information about the payer (if available). */
	paymentMetaPayer?: string;
	/** The payment method used for the transaction (if available). */
	paymentMetaPaymentMethod?: string;
	/** The payment processor involved in the transaction (if available). */
	paymentMetaPaymentProcessor?: string;
	/** The Prearranged Payment and Deposit (PPD) ID (if available). */
	paymentMetaPpdId?: string;
	/** The reason for the payment (if available). */
	paymentMetaReason?: string;
	/** The reference number associated with the payment (if available). */
	paymentMetaReferenceNumber?: string;
	/**
	 * Indicates whether the transaction is pending.
	 *
	 * @gotag: ch:"pending"
	 */
	pending?: boolean;
	/**
	 * The ID of the pending transaction, if applicable.
	 *
	 * @gotag: ch:"pending_transaction_id"
	 */
	pendingTransactionId?: string;
	/**
	 * The detailed personal finance category of the transaction.
	 *
	 * @gotag: ch:"personal_finance_category_detailed"
	 */
	personalFinanceCategoryDetailed?: string;
	/**
	 * The primary personal finance category of the transaction.
	 *
	 * @gotag: ch:"personal_finance_category_primary"
	 */
	personalFinanceCategoryPrimary?: string;
	/** The number of splits associated with this transaction. */
	splits?: Array<TransactionSplit>;
	/** Tags associated with this transaction. */
	tags?: Array<string>;
	/**
	 * The timestamp associated with the transaction.
	 * @format date-time
	 */
	time?: string;
	/**
	 * The transaction code.
	 *
	 * @gotag: ch:"transaction_code"
	 */
	transactionCode?: string;
	/**
	 * The transaction ID of interest.
	 *
	 * @gotag: ch:"transaction_id"
	 */
	transactionId?: string;
	/**
	 * The name of the transaction.
	 *
	 * @gotag: ch:"name"
	 */
	transactionName?: string;
	/**
	 * The unofficial currency code of the transaction.
	 *
	 * @gotag: ch:"unofficial_currency_code"
	 */
	unofficialCurrencyCode?: string;
	/**
	 * The user ID associated with this transaction.
	 * @format uint64
	 */
	userId?: string;
}
export interface PlaidExchangeTokenRequest {
	/** The institution id */
	institutionId?: string;
	/** The institution name */
	institutionName?: string;
	profileType: FinancialUserProfileType;
	/**
	 * The public token
	 * Validations:
	 * - cannot be nil hence required
	 */
	publicToken: string;
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
export interface PlaidExchangeTokenResponse {
	/** wether the operation was successful */
	success: boolean;
	/** the id of the async task triggered to sync plaid records */
	taskId?: string;
}
export interface PlaidInitiateTokenExchangeRequest {
	/**
	 * The user's email address. This field is optional, but required to enable the
	 * [pre-authenticated returning user flow](https://plaid.com/docs/link/returning-user/#enabling-the-returning-user-experience).
	 */
	email: string;
	/**
	 * The user's full legal name. This is an optional field used in
	 * the [returning user experience](https://plaid.com/docs/link/returning-user) to associate Items to the user.
	 */
	fullName: string;
	/**
	 * The user's phone number in [E.164](https://en.wikipedia.org/wiki/E.164) format.
	 * This field is optional, but required to enable the [returning user experience](https://plaid.com/docs/link/returning-user).
	 */
	phoneNumber: string;
	profileType: FinancialUserProfileType;
	/**
	 * A unique ID representing the end user. Typically this will be a user ID number from your application.
	 * Personally identifiable information, such as an email address or phone number,
	 * should not be used in the `client_user_id`. It is currently used as a means of searching logs
	 * for the given user in the Plaid Dashboard.
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
export interface PlaidInitiateTokenExchangeResponse {
	expiration?: string;
	linkToken?: string;
	plaidRequestId?: string;
}
export interface PlaidInitiateTokenUpdateRequest {
	/**
	 * The link id we want to update for
	 * Validations:
	 * - cannot be nil hence required
	 * @format uint64
	 */
	linkId: string;
	profileType: FinancialUserProfileType;
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
export interface PlaidInitiateTokenUpdateResponse {
	expiration?: string;
	linkToken?: string;
}
export interface PlaidLink {
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	institutionId?: string;
	institutionName?: string;
	itemId?: string;
	products?: Array<string>;
	usePlaidSync?: boolean;
	webhookUrl?: string;
}
export interface PlaidSync {
	/** @format int64 */
	added?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** @format int64 */
	modified?: string;
	nextCursor?: string;
	/** @format int64 */
	removed?: string;
	timeStamp?: string;
	trigger?: string;
}
/**
 * Pocket is an abstraction of a over a bank account. A user can has at most 4 pockets per connected account
 * NOTE: these pockets are automatically created by the system and should not be exposed for mutation
 * by any client. The only operations that can be performed against a pocket are:
 * 1. Get the pocket
 * 2. Get the pocket's smart goals
 * 3. Adding a smart goal to the pocket
 */
export interface Pocket {
	/** the set of smart goals this user witholds */
	goals?: Array<SmartGoal>;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** the tags tied to this pocket */
	tags?: Array<string>;
	/** The type of the pocket */
	type?: PocketType;
}
/** @default "POCKET_TYPE_UNSPECIFIED" */
export type PocketType = "POCKET_TYPE_UNSPECIFIED" | "POCKET_TYPE_DISCRETIONARY_SPENDING" | "POCKET_TYPE_FUN_MONEY" | "POCKET_TYPE_DEBT_REDUCTION" | "POCKET_TYPE_EMERGENCY_FUND" | "POCKET_TYPE_INVESTMENT" | "POCKET_TYPE_SHORT_TERM_SAVINGS" | "POCKET_TYPE_LONG_TERM_SAVINGS" | "POCKET_TYPE_IMPROVE_CREDIT_SCORE" | "POCKET_TYPE_DEBT_CONSOLIDATION" | "POCKET_TYPE_CREDIT_CARD_MANAGEMENT" | "POCKET_TYPE_LOAN_REPAYMENT";
export type PollAsyncTaskExecutionStatusData = any;
export interface PollAsyncTaskExecutionStatusResponse {
	/**
	 * The task status
	 *  - TASK_STATE_UNSPECIFIED: The zero value is omitted in proto3 by convention if it's not used.
	 * In your case, since you start your iota with 1, we will not define a zero value.
	 *  - TASK_STATE_ACTIVE: Indicates that the task is currently being processed by Handler.
	 *  - TASK_STATE_PENDING: Indicates that the task is ready to be processed by Handler.
	 *  - TASK_STATE_SCHEDULED: Indicates that the task is scheduled to be processed some time in the future.
	 *  - TASK_STATE_RETRY: Indicates that the task has previously failed and scheduled to be processed some time in the future.
	 *  - TASK_STATE_ARCHIVED: Indicates that the task is archived and stored for inspection purposes.
	 *  - TASK_STATE_COMPLETED: Indicates that the task is processed successfully and retained until the retention TTL expires.
	 *  - TASK_STATE_AGGREGATING: Indicates that the task is waiting in a group to be aggregated into one task.
	 *  - TASK_STATE_FAILED: Indicates that the task has failed and will not be retried.
	 */
	status?: TaskState;
	/** The task id */
	taskId?: string;
}
/** @default "RE_CURRING_FLOW_UNSPECIFIED" */
export type ReCurringFlow = "RE_CURRING_FLOW_UNSPECIFIED" | "RE_CURRING_FLOW_INFLOW" | "RE_CURRING_FLOW_OUTFLOW";
export interface ReOccuringTransaction {
	/** @gotag: ch:"account_id" */
	accountId?: string;
	/**
	 * `Any` contains an arbitrary serialized protocol buffer message along with a
	 * URL that describes the type of the serialized message.
	 *
	 * Protobuf library provides support to pack/unpack Any values in the form
	 * of utility functions or additional generated methods of the Any type.
	 *
	 * Example 1: Pack and unpack a message in C++.
	 *
	 *     Foo foo = ...;
	 *     Any any;
	 *     any.PackFrom(foo);
	 *     ...
	 *     if (any.UnpackTo(&foo)) {
	 *       ...
	 *     }
	 *
	 * Example 2: Pack and unpack a message in Java.
	 *
	 *     Foo foo = ...;
	 *     Any any = Any.pack(foo);
	 *     ...
	 *     if (any.is(Foo.class)) {
	 *       foo = any.unpack(Foo.class);
	 *     }
	 *
	 * Example 3: Pack and unpack a message in Python.
	 *
	 *     foo = Foo(...)
	 *     any = Any()
	 *     any.Pack(foo)
	 *     ...
	 *     if any.Is(Foo.DESCRIPTOR):
	 *       any.Unpack(foo)
	 *       ...
	 *
	 * Example 4: Pack and unpack a message in Go
	 *
	 *      foo := &pb.Foo{...}
	 *      any, err := anypb.New(foo)
	 *      if err != nil {
	 *        ...
	 *      }
	 *      ...
	 *      foo := &pb.Foo{}
	 *      if err := any.UnmarshalTo(foo); err != nil {
	 *        ...
	 *      }
	 *
	 * The pack methods provided by protobuf library will by default use
	 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
	 * methods only use the fully qualified type name after the last '/'
	 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
	 * name "y.z".
	 *
	 *
	 * JSON
	 *
	 * The JSON representation of an `Any` value uses the regular
	 * representation of the deserialized, embedded message, with an
	 * additional field `@type` which contains the type URL. Example:
	 *
	 *     package google.profile;
	 *     message Person {
	 *       string first_name = 1;
	 *       string last_name = 2;
	 *     }
	 *
	 *     {
	 *       "@type": "type.googleapis.com/google.profile.Person",
	 *       "firstName": <string>,
	 *       "lastName": <string>
	 *     }
	 *
	 * If the embedded message type is well-known and has a custom JSON
	 * representation, that representation will be embedded adding a field
	 * `value` which holds the custom JSON in addition to the `@type`
	 * field. Example (for message [google.protobuf.Duration][]):
	 *
	 *     {
	 *       "@type": "type.googleapis.com/google.protobuf.Duration",
	 *       "value": "1.212s"
	 *     }
	 */
	additionalProperties?: Any;
	/** @gotag: ch:"average_amount" */
	averageAmount?: string;
	/** @gotag: ch:"average_amount_iso_currency_code" */
	averageAmountIsoCurrencyCode?: string;
	/** @gotag: ch:"category_id" */
	categoryId?: string;
	/** @gotag: ch:"description" */
	description?: string;
	/** @gotag: ch:"first_date" */
	firstDate?: string;
	/** @gotag: ch:"flow" */
	flow?: ReCurringFlow;
	/** @gotag: ch:"frequency" */
	frequency?: ReOccuringTransactionsFrequency;
	/** @gotag: ch:"id" */
	id?: string;
	/** @gotag: ch:"is_active" */
	isActive?: boolean;
	/** @gotag: ch:"last_amount" */
	lastAmount?: string;
	/** @gotag: ch:"last_amount_iso_currency_code" */
	lastAmountIsoCurrencyCode?: string;
	/** @gotag: ch:"last_date" */
	lastDate?: string;
	/**
	 * @gotag: ch:"link_id"
	 * @format uint64
	 */
	linkId?: string;
	/** @gotag: ch:"merchant_name" */
	merchantName?: string;
	/** @gotag: ch:"personal_finance_category_detailed" */
	personalFinanceCategoryDetailed?: string;
	/** @gotag: ch:"personal_finance_category_primary" */
	personalFinanceCategoryPrimary?: string;
	/** @gotag: ch:"profile_type" */
	profileType?: FinancialUserProfileType;
	/** @format int32 */
	sign?: number;
	/**
	 * @gotag: ch:"status"
	 *  - RE_OCCURING_TRANSACTIONS_STATUS_MATURE: A MATURE recurring stream should have at least 3 transactions and happen
	 *  on a regular cadence (For Annual recurring stream, we will mark it MATURE after 2 instances).
	 *  - RE_OCCURING_TRANSACTIONS_STATUS_EARLY_DETECTION: When a recurring transaction first appears in the transaction history and before it fulfills
	 * the requirement of a mature stream, the status will be EARLY_DETECTION.
	 *  - RE_OCCURING_TRANSACTIONS_STATUS_TOMBSTONED: A stream that was previously in the EARLY_DETECTION status will move to the TOMBSTONED
	 * status when no further transactions were found at the next expected date.
	 */
	status?: ReOccuringTransactionsStatus;
	/** @gotag: ch:"stream_id" */
	streamId?: string;
	/** @format date-time */
	time?: string;
	/** @gotag: ch:"transaction_ids,array" */
	transactionIds?: string;
	/** @gotag: ch:"updated_time" */
	updatedTime?: string;
	/**
	 * @gotag: ch:"user_id"
	 * @format uint64
	 */
	userId?: string;
}
/** @default "RE_OCCURING_TRANSACTIONS_FREQUENCY_UNSPECIFIED" */
export type ReOccuringTransactionsFrequency = "RE_OCCURING_TRANSACTIONS_FREQUENCY_UNSPECIFIED" | "RE_OCCURING_TRANSACTIONS_FREQUENCY_WEEKLY" | "RE_OCCURING_TRANSACTIONS_FREQUENCY_BIWEEKLY" | "RE_OCCURING_TRANSACTIONS_FREQUENCY_SEMI_MONTHLY" | "RE_OCCURING_TRANSACTIONS_FREQUENCY_MONTHLY" | "RE_OCCURING_TRANSACTIONS_FREQUENCY_ANNUALLY";
/**
 *  - RE_OCCURING_TRANSACTIONS_STATUS_MATURE: A MATURE recurring stream should have at least 3 transactions and happen
 *  on a regular cadence (For Annual recurring stream, we will mark it MATURE after 2 instances).
 *  - RE_OCCURING_TRANSACTIONS_STATUS_EARLY_DETECTION: When a recurring transaction first appears in the transaction history and before it fulfills
 * the requirement of a mature stream, the status will be EARLY_DETECTION.
 *  - RE_OCCURING_TRANSACTIONS_STATUS_TOMBSTONED: A stream that was previously in the EARLY_DETECTION status will move to the TOMBSTONED
 * status when no further transactions were found at the next expected date.
 * @default "RE_OCCURING_TRANSACTIONS_STATUS_UNSPECIFIED"
 */
export type ReOccuringTransactionsStatus = "RE_OCCURING_TRANSACTIONS_STATUS_UNSPECIFIED" | "RE_OCCURING_TRANSACTIONS_STATUS_MATURE" | "RE_OCCURING_TRANSACTIONS_STATUS_EARLY_DETECTION" | "RE_OCCURING_TRANSACTIONS_STATUS_TOMBSTONED";
export type ReadynessCheckData = any;
export interface ReadynessCheckResponse {
	healthy?: boolean;
}
export interface RecordAskCopilotQuestionRequest {
	/** @example "username:testuser" */
	profileType: FinancialUserProfileType;
	/**
	 * the account id associated with the user
	 * @format uint64
	 */
	userId?: string;
}
export interface RecordAskCopilotQuestionResponse {
	/**
	 * the remaining quote
	 * @format double
	 */
	remainingQuota?: number;
	/** wether or not the user is below quote */
	success?: boolean;
}
export type SearchTransactionsData = any;
export interface SearchTransactionsRequest {
	/** category */
	category?: string;
	/**
	 * end date
	 * @format date-time
	 */
	endDate?: string;
	financialAccountType?: FinancialAccountType;
	/**
	 * max amount
	 * @format double
	 */
	maxAmount?: number;
	/**
	 * min amount
	 * @format double
	 */
	minAmount?: number;
	/**
	 * The page number
	 * @format uint64
	 */
	pageNumber: string;
	/**
	 * The page size
	 * @format uint64
	 */
	pageSize: string;
	/** the profile type */
	profileType: FinancialUserProfileType;
	/**
	 * start date
	 * @format date-time
	 */
	startDate?: string;
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
}
export interface SearchTransactionsResponse {
	/** @format uint64 */
	nextPageNumber?: string;
	/** The transactions */
	transactions?: Array<PlaidAccountTransaction>;
}
/**
 * SmartGoal: The Goals table stores information about each financial goal, including the name of the goal,
 * its description, the target amount of money the user wants to save or invest, and the expected date of completion.
 *
 * The Goals table also includes columns for the start date of the goal, the current amount of money saved or
 * invested towards the goal, and a boolean flag indicating whether the goal has been achieved.
 * These additional columns allow the user to track their progress towards the goal and see how much
 * more they need to save or invest to reach their target amount.
 */
export interface SmartGoal {
	/**
	 * the current amount of the goal
	 * current amount of money saved or invested towards the goal
	 * @example "Active"
	 */
	currentAmount?: string;
	/**
	 * The description of the goal
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "Buy a car"
	 */
	description?: string;
	/**
	 * The duration of the goal
	 * @example "Active"
	 */
	duration?: string;
	/**
	 * the end date of the goal
	 * @example "Active"
	 */
	endDate?: string;
	/**
	 * Forecasts associated with the goal
	 * The Forecast table stores information about each forecast generated for a particular goal,
	 * including the forecast date, the forecasted amount of money saved or invested for the
	 * goal by the target date, and the variance between the forecasted and target amounts.
	 * This allows the user to track how well they are progressing towards their goal and make adjustments as needed.
	 */
	forecasts?: Forecast;
	/** The type of the goal */
	goalType?: GoalType;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/**
	 * wether the goal has been achieved or not
	 * @example true
	 */
	isCompleted?: boolean;
	/** Milestones associated with the goal */
	milestones?: Array<Milestone>;
	/**
	 * The name of the goal
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "Buy a car"
	 */
	name?: string;
	/** Notes associated with the goal */
	notes?: Array<SmartNote>;
	/**
	 * the start date of the goal
	 * @example "Active"
	 */
	startDate?: string;
	/**
	 * the target amount of the goal
	 * amount of money the user wants to save or invest
	 * @example "Active"
	 */
	targetAmount?: string;
	/**
	 * the user id to which this goal is tied to
	 * @format uint64
	 */
	userId?: string;
}
/** Note schema */
export interface SmartNote {
	/**
	 * The content of the note
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "Note content here..."
	 */
	content?: string;
	/**
	 * Timestamp indicating when the note was created
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * Unique identifier for the note
	 * @format uint64
	 */
	id?: string;
	/**
	 * Timestamp indicating when the note was last updated
	 * @format date-time
	 */
	updatedAt?: string;
	/**
	 * The user id who created the note. This can be useful if in the future you allow multiple users to add notes to the same goal.
	 * @format uint64
	 */
	userId?: string;
}
export type SplitTransactionData = any;
export interface SplitTransactionRequest {
	/**
	 * The split transaction
	 * Validations:
	 * - cannot be nil hence required
	 */
	splitTransactions: Array<TransactionSplit>;
	/**
	 * The transaction id
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
}
export interface SplitTransactionResponse {
	/**
	 * The transaction id
	 * Message representing Plaid account transactions.
	 */
	transaction?: PlaidAccountTransaction;
}
export interface Status {
	/** @format int32 */
	code?: number;
	details?: Array<Any>;
	message?: string;
}
/** StripeSubscription stores high level stripe subscription details of which the user profile has */
export interface StripeSubscription {
	/** @format uint64 */
	id?: string;
	/** wether the subscription is trialing */
	isTrialing?: boolean;
	/** stripe subscription active until */
	stripeSubscriptionActiveUntil?: string;
	/** stripe subscription id tied to the customer */
	stripeSubscriptionId?: string;
	/** stripe subscription status */
	stripeSubscriptionStatus?: StripeSubscriptionStatus;
	/** stripe webhook latest timestamp */
	stripeWebhookLatestTimestamp?: string;
}
/** @default "STRIPE_SUBSCRIPTION_STATUS_UNSPECIFIED" */
export type StripeSubscriptionStatus = "STRIPE_SUBSCRIPTION_STATUS_UNSPECIFIED" | "STRIPE_SUBSCRIPTION_STATUS_TRIALING" | "STRIPE_SUBSCRIPTION_STATUS_ACTIVE" | "STRIPE_SUBSCRIPTION_STATUS_PAST_DUE" | "STRIPE_SUBSCRIPTION_STATUS_CANCELED" | "STRIPE_SUBSCRIPTION_STATUS_UNPAID" | "STRIPE_SUBSCRIPTION_STATUS_COMPLETE" | "STRIPE_SUBSCRIPTION_STATUS_INCOMPLETE" | "STRIPE_SUBSCRIPTION_STATUS_INCOMPLETE_EXPIRED" | "STRIPE_SUBSCRIPTION_STATUS_CREATED" | "STRIPE_SUBSCRIPTION_STATUS_PAUSED";
export interface StudentLoanAccount {
	disbursementDates?: Array<string>;
	expectedPayoffDate?: string;
	guarantor?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** @format double */
	interestRatePercentage?: number;
	isOverdue?: boolean;
	/** @format double */
	lastPaymentAmount?: number;
	lastPaymentDate?: string;
	lastStatementIssueDate?: string;
	loanEndDate?: string;
	loanName?: string;
	loanType?: string;
	/** @format double */
	minimumPaymentAmount?: number;
	/** the account name */
	name?: string;
	nextPaymentDueDate?: string;
	originationDate?: string;
	/** @format double */
	originationPrincipalAmount?: number;
	/** @format double */
	outstandingInterestAmount?: number;
	paymentReferenceNumber?: string;
	plaidAccountId?: string;
	pslfStatusEstimatedEligibilityDate?: string;
	/** @format int32 */
	pslfStatusPaymentsMade?: number;
	/** @format int32 */
	pslfStatusPaymentsRemaining?: number;
	repaymentPlanDescription?: string;
	repaymentPlanType?: string;
	sequenceNumber?: string;
	servicerAddressCity?: string;
	servicerAddressCountry?: string;
	servicerAddressPostalCode?: string;
	servicerAddressRegion?: string;
	servicerAddressState?: string;
	servicerAddressStreet?: string;
	/** the bank account status */
	status?: BankAccountStatus;
	/**
	 * the user id to which this bank account is tied to
	 * @format uint64
	 */
	userId?: string;
	/** @format double */
	ytdInterestPaid?: number;
	/** @format double */
	ytdPrincipalPaid?: number;
}
/**
 *  - TASK_STATE_UNSPECIFIED: The zero value is omitted in proto3 by convention if it's not used.
 * In your case, since you start your iota with 1, we will not define a zero value.
 *  - TASK_STATE_ACTIVE: Indicates that the task is currently being processed by Handler.
 *  - TASK_STATE_PENDING: Indicates that the task is ready to be processed by Handler.
 *  - TASK_STATE_SCHEDULED: Indicates that the task is scheduled to be processed some time in the future.
 *  - TASK_STATE_RETRY: Indicates that the task has previously failed and scheduled to be processed some time in the future.
 *  - TASK_STATE_ARCHIVED: Indicates that the task is archived and stored for inspection purposes.
 *  - TASK_STATE_COMPLETED: Indicates that the task is processed successfully and retained until the retention TTL expires.
 *  - TASK_STATE_AGGREGATING: Indicates that the task is waiting in a group to be aggregated into one task.
 *  - TASK_STATE_FAILED: Indicates that the task has failed and will not be retried.
 * @default "TASK_STATE_UNSPECIFIED"
 */
export type TaskState = "TASK_STATE_UNSPECIFIED" | "TASK_STATE_ACTIVE" | "TASK_STATE_PENDING" | "TASK_STATE_SCHEDULED" | "TASK_STATE_RETRY" | "TASK_STATE_ARCHIVED" | "TASK_STATE_COMPLETED" | "TASK_STATE_AGGREGATING" | "TASK_STATE_FAILED";
export interface Token {
	accessToken?: string;
	/**
	 * id
	 * @format uint64
	 */
	id?: string;
	/** the id of the item the token is tied to */
	itemId?: string;
	keyId?: string;
	/**
	 * last time you performed a merge fetch
	 * @format date-time
	 */
	lastMergeCreatedAt?: string;
	/** This is what you'll pass to Merge as the end_user_origin_id. */
	mergeEndUserOriginId?: string;
	/** The integration slug/identifier. This is returned at the end of the linking flow. */
	mergeIntegrationSlug?: string;
	version?: string;
}
/**
 * TotalInvestmentBySecurity
 * This message is used to represent the total investment of a security.
 */
export interface TotalInvestmentBySecurity {
	profileType?: FinancialUserProfileType;
	securityId?: string;
	/** @format double */
	totalInvestment?: number;
	/** @format uint64 */
	userId?: string;
}
export interface Transaction {
	/** @gotag: ch:"account_id" */
	accountId?: string;
	/** @gotag: ch:"account_owner" */
	accountOwner?: string;
	/**
	 * `Any` contains an arbitrary serialized protocol buffer message along with a
	 * URL that describes the type of the serialized message.
	 *
	 * Protobuf library provides support to pack/unpack Any values in the form
	 * of utility functions or additional generated methods of the Any type.
	 *
	 * Example 1: Pack and unpack a message in C++.
	 *
	 *     Foo foo = ...;
	 *     Any any;
	 *     any.PackFrom(foo);
	 *     ...
	 *     if (any.UnpackTo(&foo)) {
	 *       ...
	 *     }
	 *
	 * Example 2: Pack and unpack a message in Java.
	 *
	 *     Foo foo = ...;
	 *     Any any = Any.pack(foo);
	 *     ...
	 *     if (any.is(Foo.class)) {
	 *       foo = any.unpack(Foo.class);
	 *     }
	 *
	 * Example 3: Pack and unpack a message in Python.
	 *
	 *     foo = Foo(...)
	 *     any = Any()
	 *     any.Pack(foo)
	 *     ...
	 *     if any.Is(Foo.DESCRIPTOR):
	 *       any.Unpack(foo)
	 *       ...
	 *
	 * Example 4: Pack and unpack a message in Go
	 *
	 *      foo := &pb.Foo{...}
	 *      any, err := anypb.New(foo)
	 *      if err != nil {
	 *        ...
	 *      }
	 *      ...
	 *      foo := &pb.Foo{}
	 *      if err := any.UnmarshalTo(foo); err != nil {
	 *        ...
	 *      }
	 *
	 * The pack methods provided by protobuf library will by default use
	 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
	 * methods only use the fully qualified type name after the last '/'
	 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
	 * name "y.z".
	 *
	 *
	 * JSON
	 *
	 * The JSON representation of an `Any` value uses the regular
	 * representation of the deserialized, embedded message, with an
	 * additional field `@type` which contains the type URL. Example:
	 *
	 *     package google.profile;
	 *     message Person {
	 *       string first_name = 1;
	 *       string last_name = 2;
	 *     }
	 *
	 *     {
	 *       "@type": "type.googleapis.com/google.profile.Person",
	 *       "firstName": <string>,
	 *       "lastName": <string>
	 *     }
	 *
	 * If the embedded message type is well-known and has a custom JSON
	 * representation, that representation will be embedded adding a field
	 * `value` which holds the custom JSON in addition to the `@type`
	 * field. Example (for message [google.protobuf.Duration][]):
	 *
	 *     {
	 *       "@type": "type.googleapis.com/google.protobuf.Duration",
	 *       "value": "1.212s"
	 *     }
	 */
	additionalProperties?: Any;
	/**
	 * @gotag: ch:"amount"
	 * @format double
	 */
	amount?: number;
	/** @gotag: ch:"authorized_date" */
	authorizedDate?: string;
	/** @gotag: ch:"authorized_datetime" */
	authorizedDatetime?: string;
	categories?: Array<string>;
	/** @gotag: ch:"category_id" */
	categoryId?: string;
	/** @gotag: ch:"check_number" */
	checkNumber?: string;
	/** @gotag: ch:"date" */
	currentDate?: string;
	/** @gotag: ch:"datetime" */
	currentDatetime?: string;
	id?: string;
	/** @gotag: ch:"iso_currency_code" */
	isoCurrencyCode?: string;
	/**
	 * @gotag: ch:"link_id"
	 * @format uint64
	 */
	linkId?: string;
	locationAddress?: string;
	locationCity?: string;
	locationCountry?: string;
	/** @format double */
	locationLat?: number;
	/** @format double */
	locationLon?: number;
	locationPostalCode?: string;
	locationRegion?: string;
	locationStoreNumber?: string;
	/** @gotag: ch:"merchant_name" */
	merchantName?: string;
	/** @gotag: ch:"name" */
	name?: string;
	/** @gotag: ch:"payment_channel" */
	paymentChannel?: string;
	paymentMetaByOrderOf?: string;
	paymentMetaPayee?: string;
	paymentMetaPayer?: string;
	paymentMetaPaymentMethod?: string;
	paymentMetaPaymentProcessor?: string;
	paymentMetaPpdId?: string;
	paymentMetaReason?: string;
	paymentMetaReferenceNumber?: string;
	/** @gotag: ch:"pending" */
	pending?: boolean;
	/** @gotag: ch:"pending_transaction_id" */
	pendingTransactionId?: string;
	/** @gotag: ch:"personal_finance_category_detailed" */
	personalFinanceCategoryDetailed?: string;
	/** @gotag: ch:"personal_finance_category_primary" */
	personalFinanceCategoryPrimary?: string;
	/** @gotag: ch:"profile_type" */
	profileType?: FinancialUserProfileType;
	/** @format int32 */
	sign?: number;
	/** @format date-time */
	time?: string;
	/** @gotag: ch:"transaction_code" */
	transactionCode?: string;
	/** @gotag: ch:"transaction_id" */
	transactionId?: string;
	/** @gotag: ch:"unofficial_currency_code" */
	unofficialCurrencyCode?: string;
	/**
	 * @gotag: ch:"user_id"
	 * @format uint64
	 */
	userId?: string;
}
/**
 * TransactionAggregatesByMonth
 * This message is used to represent the transaction aggregates of a user.
 */
export interface TransactionAggregatesByMonth {
	locationCity?: string;
	merchantName?: string;
	/** @format int64 */
	month?: number;
	paymentChannel?: string;
	personalFinanceCategoryPrimary?: string;
	profileType?: FinancialUserProfileType;
	/** @format double */
	totalAmount?: number;
	/** @format uint64 */
	transactionCount?: string;
	/** @format uint64 */
	userId?: string;
}
export type TransactionAggregatesData = any;
/** PlaidAccountTransactionSplit represents a split of a PlaidAccountTransaction. */
export interface TransactionSplit {
	/**
	 * The amount of money involved in the transaction.
	 * @format double
	 */
	amount?: number;
	/**
	 * The time at which the transaction was authorized (time field)
	 * @format date-time
	 */
	authorizedDate?: string;
	/**
	 * The date-time when the transaction was authorized.
	 * @format date-time
	 */
	authorizedDatetime?: string;
	/** The set of categories that the transaction belongs to. */
	categories?: Array<string>;
	/** The description of the transaction. */
	description?: string;
	/**
	 * The unique ID for this transaction.
	 * @format uint64
	 */
	id?: string;
	/**
	 * The link ID associated with this transaction.
	 * @format uint64
	 */
	linkId?: string;
	/** The detailed personal finance category of the transaction. */
	personalFinanceCategoryDetailed?: string;
	/** The primary personal finance category of the transaction. */
	personalFinanceCategoryPrimary?: string;
	/** Tags associated with this transaction. */
	tags?: Array<string>;
	/**
	 * The time of split of the transaction
	 * @format date-time
	 */
	timeOfSplit?: string;
	/**
	 * The user ID associated with this transaction.
	 * @format uint64
	 */
	userId?: string;
}
export type TriggerSyncData = any;
export interface TriggerSyncRequest {
	/**
	 * tha financial account type
	 * @example "username:testuser"
	 */
	financialAccountType: FinancialAccountType;
	/**
	 * the account id associated with the user
	 * @format uint64
	 */
	linkId?: string;
	/** @example "username:testuser" */
	profileType: FinancialUserProfileType;
	/**
	 * the account id associated with the user
	 * @format uint64
	 */
	userId?: string;
}
export interface TriggerSyncResponse {
	/** the task id */
	taskId?: string;
}
export interface UnSplitTransactionsRequest {
	/**
	 * The transaction id
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
}
export interface UnSplitTransactionsResponse {
	/**
	 * The transaction id
	 * Message representing Plaid account transactions.
	 */
	transaction?: PlaidAccountTransaction;
}
export type UnsplitTransactionsData = any;
export type UpdateBankAccountData = any;
export interface UpdateBankAccountRequest {
	/**
	 * The bank account to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	bankAccount: BankAccount;
}
export interface UpdateBankAccountResponse {
	/** The bank account */
	bankAccount?: BankAccount;
	/** The bank account id */
	updated?: boolean;
}
export interface UpdateBudgetRequest {
	/**
	 * The budget to update
	 * Validations:
	 * - cannot be nil hence required
	 * The Budgets table stores information about each budget created by the user,
	 * including the name of the budget, the start and end dates, and the user ID.
	 */
	budget: Budget;
}
export interface UpdateBudgetResponse {
	/**
	 * The budget id
	 * The Budgets table stores information about each budget created by the user,
	 * including the name of the budget, the start and end dates, and the user ID.
	 */
	budget?: Budget;
}
export interface UpdateMilestoneRequest {
	/**
	 * The milestone to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	milestone: Milestone;
}
export interface UpdateMilestoneResponse {
	/** The milestone id */
	milestone?: Milestone;
}
export type UpdateNoteToRecurringTransactionData = any;
/** UpdateNoteToTransactionRequest updates a note to a transaction */
export interface UpdateNoteToRecurringTransactionRequest {
	/**
	 * The note to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
}
/** UpdateNoteToTransactionResponse is the responsed obtained after we update a note to a transaction */
export interface UpdateNoteToRecurringTransactionResponse {
	/**
	 * The transaction id
	 * Message representing recurring transactions associated with a Plaid account.
	 */
	transaction?: PlaidAccountRecurringTransaction;
}
export type UpdateNoteToSmartGoalData = any;
export interface UpdateNoteToSmartGoalRequest {
	/**
	 * The note to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
}
export interface UpdateNoteToSmartGoalResponse {
	/** The smart goal id */
	note?: SmartNote;
}
export type UpdateNoteToTransactionData = any;
/** UpdateNoteToTransactionRequest updates a note to a transaction */
export interface UpdateNoteToTransactionRequest {
	/**
	 * The note to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
}
/** UpdateNoteToTransactionResponse is the responsed obtained after we update a note to a transaction */
export interface UpdateNoteToTransactionResponse {
	/**
	 * The transaction id
	 * Message representing Plaid account transactions.
	 */
	transaction?: PlaidAccountTransaction;
}
export type UpdatePocketData = any;
export interface UpdatePocketRequest {
	/**
	 * The pocket to update
	 * Validations:
	 * - cannot be nil hence required
	 */
	pocket: Pocket;
}
export interface UpdatePocketResponse {
	/** The pocket id */
	pocket?: Pocket;
}
/** UpdateRecurringTransactionRequest is the update transaction request */
export interface UpdateRecurringTransactionRequest {
	/**
	 * The transaction to update
	 * Validations:
	 * - cannot be nil hence required
	 * Message representing recurring transactions associated with a Plaid account.
	 */
	transaction: PlaidAccountRecurringTransaction;
}
/** UpdateRecurringTransactionResponse is the update transaction response */
export interface UpdateRecurringTransactionResponse {
	/**
	 * The transaction that was successfully updated
	 * Message representing recurring transactions associated with a Plaid account.
	 */
	transaction?: PlaidAccountRecurringTransaction;
}
export type UpdateSmartGoalData = any;
export interface UpdateSmartGoalRequest {
	/**
	 * The smart goal to update
	 * Validations:
	 * - cannot be nil hence required
	 * SmartGoal: The Goals table stores information about each financial goal, including the name of the goal,
	 * its description, the target amount of money the user wants to save or invest, and the expected date of completion.
	 *
	 * The Goals table also includes columns for the start date of the goal, the current amount of money saved or
	 * invested towards the goal, and a boolean flag indicating whether the goal has been achieved.
	 * These additional columns allow the user to track their progress towards the goal and see how much
	 * more they need to save or invest to reach their target amount.
	 */
	smartGoal: SmartGoal;
}
export interface UpdateSmartGoalResponse {
	/**
	 * The smart goal id
	 * @format uint64
	 */
	smartGoalId?: string;
}
export type UpdateTransaction2Data = any;
export type UpdateTransactionData = any;
/** UpdateTransactionRequest is the update transaction request */
export interface UpdateTransactionRequest {
	/**
	 * The transaction to update
	 * Validations:
	 * - cannot be nil hence required
	 * Message representing Plaid account transactions.
	 */
	transaction: PlaidAccountTransaction;
}
/** UpdateTransactionResponse is the update transaction response */
export interface UpdateTransactionResponse {
	/**
	 * The transaction that was successfully updated
	 * Message representing Plaid account transactions.
	 */
	transaction?: PlaidAccountTransaction;
}
export type UpdateUserProfileData = any;
/**
 * UpdateUserProfileRequest: Represents the request object invoked against the user
 * service to update a user profile
 */
export interface UpdateUserProfileRequest {
	/**
	 * User profile to update
	 * Validation:
	 * - cannot nil hence required
	 */
	profile: FinancialUserProfile;
}
/**
 * UpdateUserProfileResponse: Represents the response object returned as a response to
 * the `update user profile` request
 */
export interface UpdateUserProfileResponse {
	profile?: FinancialUserProfile;
	profileUpdated?: boolean;
}
export type UpdatesBudgetData = any;
export type UpdatesMilestoneData = any;
export declare class InvestmentSecurityClass implements InvestmentSecurity {
	/** id */
	id: string;
	closePrice: number;
	closePriceAsOf: string;
	cusip: string;
	institutionId: string;
	institutionSecurityId: string;
	isCashEquivalent: boolean;
	isin: string;
	isoCurrencyCode: string;
	name: string;
	proxySecurityId: string;
	securityId: string;
	sedol: string;
	tickerSymbol: string;
	type: string;
	unofficialCurrencyCode: string;
	updateDatetime: string;
	constructor(data: Partial<InvestmentSecurity>);
	static randomInstance(): InvestmentSecurity;
}
export declare class MilestoneClass implements Milestone {
	/** id */
	id: string;
	/**
	 * The name of the milestone
	 * Validations:
	 * - must be at least 3 characters long
	 */
	name: string;
	/**
	 * The description of the miletone
	 * Validations:
	 * - must be at least 3 characters long
	 */
	description: string;
	/**
	 * the target date of the milestone
	 * Validations:
	 * - must be at least 3 characters long
	 */
	targetDate: string;
	/** the target amount of the milestone */
	targetAmount: string;
	/** wethe milestone is completed or not */
	isCompleted: boolean;
	/** the budget associated with the milestone */
	budget: Budget | undefined;
	constructor(data: Partial<Milestone>);
	/**
	 * Creates a random instance of the Milestone class with all fields populated.
	 * @returns {Milestone} A random Milestone.
	 */
	static randomInstance(): Milestone;
}
export declare class MortgageAccountClass implements MortgageAccount {
	id: string;
	plaidAccountId: string;
	accountNumber: string;
	currentLateFee: number;
	escrowBalance: number;
	hasPmi: boolean;
	hasPrepaymentPenalty: boolean;
	lastPaymentAmount: number;
	lastPaymentDate: string;
	loanTerm: string;
	loanTypeDescription: string;
	maturityDate: string;
	nextMonthlyPayment: number;
	nextPaymentDueDate: string;
	originalPrincipalBalance: number;
	originalPropertyValue: number;
	outstandingPrincipalBalance: number;
	paymentAmount: number;
	paymentDate: string;
	originationDate: string;
	originationPrincipalAmount: number;
	pastDueAmount: number;
	ytdInterestPaid: number;
	ytdPrincipalPaid: number;
	propertyAddressCity: string;
	propertyAddressState: string;
	propertyAddressStreet: string;
	propertyAddressPostalCode: string;
	propertyRegion: string;
	propertyCountry: string;
	interestRatePercentage: number;
	interestRateType: string;
	constructor(data: Partial<MortgageAccount>);
}
/**
 * Pocket represents the Pocket entity.
 *
 * @export
 * @class Pocket
 * @implements {IPocket}
 * */
export declare class PocketClass implements Pocket {
	/** id */
	id: string;
	/** the set of smart goals this user witholds */
	goals: SmartGoal[];
	/** The type of the pocket */
	type: PocketType;
	constructor(data: Partial<Pocket>);
	/**
	 * Creates a random instance of the Pocket class with all fields populated.
	 * @returns {Pocket} A random pocket.
	 */
	static randomInstance(): Pocket;
}
export declare class SmartGoalClass implements SmartGoal {
	/** id */
	id: string;
	/** the user id to which this goal is tied to */
	userId: string;
	/**
	 * The name of the goal
	 * Validations:
	 * - must be at least 3 characters long
	 */
	name: string;
	/**
	 * The description of the goal
	 * Validations:
	 * - must be at least 3 characters long
	 */
	description: string;
	/** wether the goal has been achieved or not */
	isCompleted: boolean;
	/** The type of the goal */
	goalType: GoalType;
	/** The duration of the goal */
	duration: string;
	/** the start date of the goal */
	startDate: string;
	/** the end date of the goal */
	endDate: string;
	/**
	 * the target amount of the goal
	 * amount of money the user wants to save or invest
	 */
	targetAmount: string;
	/**
	 * the current amount of the goal
	 * current amount of money saved or invested towards the goal
	 */
	currentAmount: string;
	/** Milestones associated with the goal */
	milestones: Milestone[];
	/** Forecasts associated with the goal */
	forecasts: Forecast | undefined;
	constructor(data: Partial<SmartGoal>);
	/**
	 * Creates a random instance of the SmartGoal class with all fields populated.
	 * @returns {SmartGoal} A random SmartGoal.
	 */
	static randomInstance(): SmartGoal;
}
export declare class ForecastClass implements Forecast {
	/** id */
	id: string;
	/** the forecasted amount of the goal */
	forecastedAmount: string;
	/** the forecasted completion date of the goal */
	forecastedCompletionDate: string;
	/** the forecasted variance of the goal between the forecasted and target amounts */
	varianceAmount: string;
	constructor(data: Partial<Forecast>);
	/**
	 * Creates a random instance of the Forecast class with all fields populated.
	 * @returns {Forecast} A random Forecast.
	 */
	static randomInstance(): Forecast;
}
export declare class InvestmentAccountClass implements InvestmentAccount {
	/** id */
	id: string;
	/** the user id to which this bank account is tied to */
	userId: string;
	/** the account name */
	name: string;
	/** the bank account number */
	number: string;
	/** the bank account type */
	type: string;
	/** the bank account balance */
	balance: number;
	currentFunds: number;
	balanceLimit: string;
	/** plaid account id mapped to this bank account */
	plaidAccountId: string;
	/** accoint subtype */
	subtype: string;
	/** invesment holding is the set of securities this account witholds */
	holdings: InvesmentHolding[];
	/** the set of securities this account witholds */
	securities: InvestmentSecurity[];
	constructor(data: Partial<InvestmentAccount>);
	static randomInstance(): InvestmentAccount;
}
export declare class AprClass implements Apr {
	id: string;
	percentage: number;
	type: string;
	balanceSubjectToApr: number;
	interestChargeAmount: number;
	constructor(data: Partial<Apr>);
	static randomInstance(): Apr;
}
export declare class BudgetClass implements Budget {
	/** id */
	id: string;
	/** The name of the budget */
	name: string;
	description: string;
	/** the time the goal was created */
	startDate: string;
	/** the time the goal was updated */
	endDate: string;
	/** category associated with the goal */
	category: Category | undefined;
	constructor(data: Partial<Budget>);
	/**
	 * Creates a random instance of the Budget class with all fields populated.
	 * @returns {Budget} A random Budget.
	 */
	static randomInstance(): Budget;
}
export declare class CategoryClass implements Category {
	/** id */
	id: string;
	/** The name of the category */
	name: string;
	/** The description of the category */
	description: string;
	/** the sub categories of the category */
	subcategories: string[];
	constructor(data: Partial<Category>);
	/**
	 * Creates a random instance of the Category class with all fields populated.
	 * @returns {Category} A random Category.
	 */
	static randomInstance(): Category;
}
export declare class CreditAccountClass implements CreditAccount {
	/** id */
	id: string;
	/** the user id to which this bank account is tied to */
	userId: string;
	/** the account name */
	name: string;
	/** the bank account number */
	number: string;
	/** the bank account type */
	type: string;
	/** the bank account balance */
	balance: number;
	/** current funds on the account */
	currentFunds: number;
	/** balance limit */
	balanceLimit: string;
	/** plaid account id mapped to this bank account */
	plaidAccountId: string;
	/** accoint subtype */
	subtype: string;
	/** wether the account is overdue */
	isOverdue: boolean;
	/** the last payment amount */
	lastPaymentAmount: number;
	/** the last payment date */
	lastPaymentDate: string;
	/** the last statement issue date */
	lastStatementIssueDate: string;
	/** the minimum amount due date */
	minimumAmountDueDate: number;
	/** the next payment date */
	nextPaymentDate: string;
	/** the aprs */
	aprs: Apr[];
	/** the last statement balance */
	lastStatementBalance: number;
	/** the minimum payment amount */
	minimumPaymentAmount: number;
	/** the next payment due date */
	nextPaymentDueDate: string;
	constructor(data: Partial<CreditAccount>);
	static randomInstance(): CreditAccount;
}
export declare class ActionableInsightClass implements ActionableInsight {
	/**
	 * The unique identifier for the actionable insight.
	 * @type {number}
	 */
	id: string | undefined;
	/**
	 * A detailed actionable insight generated for the user to act upon.
	 * @type {string}
	 */
	detailedAction: string | undefined;
	/**
	 * A summarized insight targeting optimization of a certain condition.
	 * @type {string}
	 */
	summarizedAction: string | undefined;
	/**
	 * The time at which the insight was generated.
	 * @type {string | undefined}
	 */
	generatedTime: string | undefined;
	/**
	 * An array of associated tags with the generated insights.
	 * @type {string[]}
	 */
	tags: Array<string>;
	/**
	 * Constructs a new ActionableInsight object.
	 * @constructor
	 * @param {Partial<ActionableInsight>} data - Optional data for initializing the actionable insight.
	 */
	constructor(data?: Partial<ActionableInsight>);
}
/**
 * Represents a bank account tied to a user.
 */
export declare class BankAccountClass implements BankAccount {
	/**
	 * The unique identifier for the bank account.
	 * @type {number}
	 */
	id: string;
	/**
	 * The user ID to which this bank account is tied.
	 * @type {number}
	 */
	userId: string;
	/**
	 * The name of the bank account.
	 * @type {string}
	 */
	name: string;
	/**
	 * The bank account number.
	 * @type {string}
	 */
	number: string;
	/**
	 * The type of bank account.
	 * @type {BankAccountType}
	 */
	type: BankAccountType;
	/**
	 * The balance of the bank account.
	 * @type {number}
	 */
	balance: number;
	/**
	 * The currency of the bank account.
	 * @type {string}
	 */
	currency: string;
	/**
	 * The current funds available in the bank account.
	 * @type {number}
	 */
	currentFunds: number;
	/**
	 * The balance limit of the bank account.
	 * @type {number}
	 */
	balanceLimit: string;
	/**
	 * The set of virtualized pockets associated with this bank account.
	 * @type {Pocket[]}
	 */
	pockets: Pocket[];
	/**
	 * The Plaid account ID mapped to this bank account.
	 * @type {string}
	 */
	plaidAccountId: string;
	/**
	 * The subtype of the bank account.
	 * @type {string}
	 */
	subtype: string;
	/**
	 * The status of the bank account.
	 * @type {BankAccountStatus}
	 */
	status: BankAccountStatus;
	/**
	 * Constructs a new BankAccount object.
	 * @constructor
	 * @param {Partial<BankAccount>} data - Optional data for initializing the bank account.
	 */
	constructor(data: Partial<BankAccount>);
	/**
	 * Gets the number of pockets tied to this bank account.
	 */
	getNumberOfPockets(): number;
	/**
	 * Gets the number of goals tied to this bank account.
	 */
	getNumberOfGoals(): number;
	getGoals(): SmartGoal[];
	getMilestones(): Milestone[];
	/**
	 * Creates a random instance of the BankAccount class with all fields populated.
	 * @returns {BankAccount} A random bank account.
	 */
	static randomInstance(): BankAccount;
}
/**
 * Represents a user's financial profile.
 *
 * @remarks
 * This class is designed to store and manage the details related to a user's financial standing and interactions.
 * It integrates with services like Stripe and can manage multiple links to different financial institutions.
 *
 * @example Constructing a `FinancialProfile`
 *
 * ```ts
 * // Example data
 * const data = {
 *   userFinancialProfileID: 123,
 *   userId: 456,
 *   stripeCustomerId: 'stripe-customer-1',
 *   stripeSubscriptions: new StripeSubscription({ ...stripeSubscriptionData... }),
 *   link: [new Link({ ...linkData... })],
 *   actionableInsights: [new ActionableInsight({ ...insightData... })],
 * };
 *
 * const financialProfile = new FinancialProfile(data);
 * ```
 *
 * @property userFinancialProfileID - Unique identifier for the financial profile.
 * @property userId - Identifier for the user associated with this profile.
 * @property stripeCustomerId - Identifier for the Stripe customer associated with this user.
 * @property stripeSubscriptions - The Stripe subscriptions that the user profile actively maintains.
 * @property link - Array of linked financial institutions associated with the user's profile.
 * @property actionableInsights - Array of insights derived from the user's financial data.
 */
export declare class FinancialProfileClass implements FinancialUserProfile {
	/** id */
	userFinancialProfileID: number;
	/** the user id tied to the profile */
	userId: string;
	stripeCustomerId: string;
	/** the stripe subscriptions the user profile actively maintains */
	stripeSubscriptions: StripeSubscription | undefined;
	/** a user profile can have many links (connected institutions) of which finanical accounts are tied to (checking, savings, etc) */
	link: Link[];
	actionableInsights: ActionableInsight[];
	constructor(data?: Partial<FinancialUserProfile>);
}
export declare class InvesmentHoldingClass implements InvesmentHolding {
	/** id */
	id: string;
	/** The name of the investment holding */
	name: string;
	/** plaid account id */
	plaidAccountId: string;
	costBasis: number;
	institutionPrice: number;
	institutionPriceAsOf: string;
	institutionPriceDatetime: string;
	institutionValue: number;
	isoCurrencyCode: string;
	quantity: number;
	securityId: string;
	unofficialCurrencyCode: string;
	constructor(data: Partial<InvesmentHolding>);
	static randomInstance(): InvesmentHolding;
}
export declare class LinkClass implements Link {
	/**
	 * The unique identifier for the link.
	 * @type {number}
	 */
	id: string;
	/**
	 * Information about Plaid synchronization.
	 * @type {PlaidSync | undefined}
	 */
	plaidSync: PlaidSync | undefined;
	/**
	 * The status of the link.
	 * @type {LinkStatus}
	 */
	linkStatus: LinkStatus;
	/**
	 * Information about Plaid linking.
	 * @type {PlaidLink | undefined}
	 */
	plaidLink: PlaidLink | undefined;
	/**
	 * Indicates if new accounts are available through Plaid.
	 * @type {boolean}
	 */
	plaidNewAccountsAvailable: boolean;
	/**
	 * The expiration date of the link.
	 * @type {string}
	 */
	expirationDate: string;
	/**
	 * The name of the financial institution.
	 * @type {string}
	 */
	institutionName: string;
	/**
	 * Custom name for the institution.
	 * @type {string}
	 */
	customInstitutionName: string;
	/**
	 * Description of the link.
	 * @type {string}
	 */
	description: string;
	/**
	 * The timestamp of the last manual sync.
	 * @type {string}
	 */
	lastManualSync: string;
	/**
	 * The timestamp of the last successful update.
	 * @type {string}
	 */
	lastSuccessfulUpdate: string;
	/**
	 * @type {Token | undefined}
	 */
	token: Token | undefined;
	/**
	 * @type {BankAccount[]}
	 */
	bankAccounts: BankAccount[];
	/**
	 * @type {InvestmentAccount[]}
	 */
	investmentAccounts: InvestmentAccount[];
	/**
	 * Credit accounts tied to the link.
	 * @type {CreditAccount[]}
	 */
	creditAccounts: CreditAccount[];
	/**
	 * Mortgage accounts tied to the link.
	 * @type {MortgageAccount[]}
	 */
	mortgageAccounts: MortgageAccount[];
	/**
	 * Student loan accounts tied to the link.
	 * @type {StudentLoanAccount[]}
	 */
	studentLoanAccounts: StudentLoanAccount[];
	/**
	 * The ID of the institution this link is tied to.
	 * @type {string}
	 */
	plaidInstitutionId: string;
	/**
	 * The type of link.
	 * @type {LinkType}
	 */
	linkType: LinkType;
	/**
	 * Error code associated with the link.
	 * @type {string}
	 */
	errorCode: string;
	/**
	 * The timestamp of the last update.
	 * @type {string}
	 */
	updatedAt: string;
	/**
	 * Indicates if new accounts are available.
	 * @type {boolean}
	 */
	newAccountsAvailable: boolean;
	/**
	 * Indicates if the link should be updated.
	 * @type {boolean}
	 */
	shouldBeUpdated: boolean;
	/**
	 * Constructs a new Link object.
	 * @constructor
	 * @param {Partial<Link>} data - Optional data for initializing the link.
	 */
	constructor(data: Partial<Link>);
}
/**
 * Represents linking information related to Plaid.
 */
export declare class PlaidLinkClass implements PlaidLink {
	/**
	 * The unique identifier for the Plaid link.
	 * @type {string}
	 */
	id: string;
	/**
	 * An array of products associated with the Plaid link.
	 * @type {string[]}
	 */
	products: string[];
	/**
	 * The webhook URL associated with the Plaid link.
	 * @type {string}
	 */
	webhookUrl: string;
	/**
	 * The ID of the institution associated with the Plaid link.
	 * @type {string}
	 */
	institutionId: string;
	/**
	 * The name of the institution associated with the Plaid link.
	 * @type {string}
	 */
	institutionName: string;
	/**
	 * Indicates whether Plaid sync is used with the link.
	 * @type {boolean}
	 */
	usePlaidSync: boolean;
	/**
	 * The ID of the item associated with the Plaid link.
	 * @type {string}
	 */
	itemId: string;
	/**
	 * Constructs a new PlaidLink object.
	 * @constructor
	 * @param {Partial<PlaidLink>} data - Optional data for initializing the PlaidLink.
	 */
	constructor(data?: Partial<PlaidLink>);
}
/**
 * Represents synchronization information related to Plaid.
 */
export declare class PlaidSyncClass implements PlaidSync {
	/**
	 * The unique identifier for the Plaid synchronization.
	 * @type {number}
	 */
	id: string;
	/**
	 * The timestamp of the synchronization.
	 * @type {string}
	 */
	timeStamp: string;
	/**
	 * The trigger that initiated the synchronization.
	 * @type {string}
	 */
	trigger: string;
	/**
	 * The cursor for the next synchronization.
	 * @type {string}
	 */
	nextCursor: string;
	/**
	 * The number of added items in the synchronization.
	 * @type {number}
	 */
	added: string;
	/**
	 * The string of removed items in the synchronization.
	 * @type {string}
	 */
	removed: string;
	/**
	 * The string of modified items in the synchronization.
	 * @type {string}
	 */
	modified: string;
	/**
	 * Constructs a new PlaidSync object.
	 * @constructor
	 * @param {Partial<PlaidSync>} data - Optional data for initializing the PlaidSync.
	 */
	constructor(data?: Partial<PlaidSync>);
}
/**
 * Represents a subscription managed through the Stripe payment platform.
 */
export declare class StripeSubscriptionClass implements StripeSubscription {
	/**
	 * The unique identifier for the subscription.
	 * @type {string}
	 */
	id: string;
	/**
	 * The ID of the subscription in the Stripe system tied to the customer.
	 * @type {string}
	 */
	stripeSubscriptionId: string;
	/**
	 * The status of the Stripe subscription.
	 * @type {StripeSubscriptionStatus}
	 */
	stripeSubscriptionStatus: StripeSubscriptionStatus;
	/**
	 * The date until which the Stripe subscription is active.
	 * @type {string}
	 */
	stripeSubscriptionActiveUntil: string;
	/**
	 * The latest timestamp from the Stripe webhook related to the subscription.
	 * @type {string}
	 */
	stripeWebhookLatestTimestamp: string;
	/**
	 * Indicates whether the subscription is currently in a trial period.
	 * @type {boolean}
	 */
	isTrialing: boolean;
	/**
	 * Constructs a new StripeSubscription object.
	 * @constructor
	 * @param {Partial<StripeSubscription>} [data] - Optional data for initializing the subscription.
	 */
	constructor(data?: Partial<StripeSubscription>);
}
export declare class StudentLoanAccountClass implements StudentLoanAccount {
	/** id */
	id: string;
	plaidAccountId: string;
	disbursementDates: string[];
	expectedPayoffDate: string;
	guarantor: string;
	interestRatePercentage: number;
	isOverdue: boolean;
	lastPaymentAmount: number;
	lastPaymentDate: string;
	lastStatementIssueDate: string;
	loanName: string;
	loanEndDate: string;
	minimumPaymentAmount: number;
	nextPaymentDueDate: string;
	originationDate: string;
	originationPrincipalAmount: number;
	outstandingInterestAmount: number;
	paymentReferenceNumber: string;
	sequenceNumber: string;
	ytdInterestPaid: number;
	ytdPrincipalPaid: number;
	loanType: string;
	pslfStatusEstimatedEligibilityDate: string;
	pslfStatusPaymentsMade: number;
	pslfStatusPaymentsRemaining: number;
	repaymentPlanType: string;
	repaymentPlanDescription: string;
	servicerAddressCity: string;
	servicerAddressPostalCode: string;
	servicerAddressState: string;
	servicerAddressStreet: string;
	servicerAddressRegion: string;
	servicerAddressCountry: string;
	/** the user id to which this bank account is tied to */
	userId: string;
	/** the account name */
	name: string;
	constructor(data: Partial<StudentLoanAccount>);
	static randomInstance(): StudentLoanAccount;
}
/**
 * Token object holding an access token used to make API requests related to a specific Item.
 */
export declare class TokenClass implements Token {
	/**
	 * The unique identifier for the token.
	 * @type {string}
	 */
	id: string;
	/**
	 * The ID of the item the token is tied to.
	 * @type {string}
	 */
	itemId: string;
	/**
	 * The key ID associated with the token.
	 * @type {string}
	 */
	keyId: string;
	/**
	 * The access token.
	 * @type {string}
	 */
	accessToken: string;
	/**
	 * The version of the token.
	 * @type {string}
	 */
	version: string;
	/**
	 * Constructs a new Token object.
	 * @constructor
	 * @param {Partial<Token>} data - Optional data for initializing the token.
	 */
	constructor(data?: Partial<TokenClass>);
}
/**
 * Represents the balance history of an account.
 *
 * @remarks
 * This class is used to store and manage the details of the balance history associated with a specific account.
 * It provides an organized structure to manage the time, currency, balance, and other related information.
 *
 * @example Constructing an `AccountBalanceHistory` instance
 *
 * ```ts
 * const data = {
 *   time: new Date(),
 *   accountId: 'ACC-12345',
 *   isoCurrencyCode: 'USD',
 *   balance: 100.50,
 *   userId: 1,
 *   sign: 1,
 *   id: 'BAL-67890'
 * };
 *
 * const accountHistory = new AccountBalanceHistory(data);
 * ```
 *
 * @property time - The timestamp when the balance history was recorded.
 * @property accountId - The account ID associated with the balance history.
 * @property isoCurrencyCode - The ISO currency code of the balance.
 * @property balance - The balance value.
 * @property userId - The user ID associated with the balance history.
 * @property sign - The sign indicating the balance change direction (e.g., +1 or -1).
 * @property id - The unique identifier for the balance history.
 */
export declare class AccountBalanceHistoryClass implements AccountBalanceHistory {
	time: string;
	accountId: string;
	isoCurrencyCode: string;
	balance: number;
	userId: string;
	sign: number;
	id: string;
	/**
	 * Constructs a new AccountBalanceHistory instance.
	 *
	 * @param data - Initialization data for the balance history.
	 */
	constructor(data: Partial<AccountBalanceHistory>);
	/**
	 * Creates a random instance of the AccountBalanceHistory class with all fields populated.
	 * @returns {AccountBalanceHistory} A random AccountBalanceHistory.
	 */
	static randomInstance(): AccountBalanceHistory;
}
export declare class AnyClass implements Any {
	/**
	 * A URL/resource name that uniquely identifies the type of the serialized
	 * protocol buffer message. This string must contain at least
	 * one "/" character. The last segment of the URL's path must represent
	 * the fully qualified name of the type (as in
	 * `path/google.protobuf.Duration`). The name should be in a canonical form
	 * (e.g., leading "." is not accepted).
	 *
	 * In practice, teams usually precompile into the binary all types that they
	 * expect it to use in the context of Any. However, for URLs which use the
	 * scheme `http`, `https`, or no scheme, one can optionally set up a type
	 * server that maps type URLs to message definitions as follows:
	 *
	 * * If no scheme is provided, `https` is assumed.
	 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
	 *   value in binary format, or produce an error.
	 * * Applications are allowed to cache lookup results based on the
	 *   URL, or have them precompiled into a binary to avoid any
	 *   lookup. Therefore, binary compatibility needs to be preserved
	 *   on changes to types. (Use versioned type names to manage
	 *   breaking changes.)
	 *
	 * Note: this functionality is not currently available in the official
	 * protobuf release, and it is not used for type URLs beginning with
	 * type.googleapis.com.
	 *
	 * Schemes other than `http`, `https` (or the empty scheme) might be
	 * used with implementation specific semantics.
	 */
	typeUrl: string;
	/** Must be a valid serialized protocol buffer of the above specified type. */
	value: Uint8Array;
	constructor(typeUrl: string, value: Uint8Array);
	static fromJSON(object: any): AnyClass;
	toJSON(): unknown;
	static create<I extends Exact<DeepPartial<AnyClass>, I>>(base?: I): AnyClass;
	static fromPartial<I extends Exact<DeepPartial<AnyClass>, I>>(object: I): AnyClass;
}
export type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
	[K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
	[K in keyof P]: Exact<P[K], I[K]>;
} & {
	[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
/**
 * Represents the financial sub-profile of a category.
 *
 * @remarks
 * This class is used to store and manage the details of the financial metrics associated with a specific category.
 * It offers a detailed view into the financial transactions, spending habits, and more over various time periods.
 *
 * @example Constructing a `CategoryMetricsFinancialSubProfile` instance
 *
 * ```ts
 * const data = {
 *   month: 5,
 *   personalFinanceCategoryPrimary: 'Groceries',
 *   transactionCount: 10,
 *   spentLastWeek: 50.00,
 *   spentLastTwoWeeks: 95.00,
 *   spentLastMonth: 200.00,
 *   spentLastSixMonths: 1200.00,
 *   spentLastYear: 2400.00,
 *   spentLastTwoYears: 4800.00,
 *   userId: 1
 * };
 *
 * const metricsProfile = new CategoryMetricsFinancialSubProfile(data);
 * ```
 *
 * @property month - The month for which the metrics are recorded.
 * @property personalFinanceCategoryPrimary - The primary category of personal finance for these metrics.
 * @property transactionCount - The number of transactions made in the category.
 * @property spentLastWeek - Amount spent in the last week for this category.
 * @property spentLastTwoWeeks - Amount spent in the last two weeks for this category.
 * @property spentLastMonth - Amount spent in the last month for this category.
 * @property spentLastSixMonths - Amount spent in the last six months for this category.
 * @property spentLastYear - Amount spent in the last year for this category.
 * @property spentLastTwoYears - Amount spent in the last two years for this category.
 * @property userId - The user ID associated with these metrics.
 */
export declare class CategoryMetricsFinancialSubProfileClass implements CategoryMetricsFinancialSubProfile {
	month: number;
	personalFinanceCategoryPrimary: string;
	transactionCount: string;
	spentLastWeek: number;
	spentLastTwoWeeks: number;
	spentLastMonth: number;
	spentLastSixMonths: number;
	spentLastYear: number;
	spentLastTwoYears: number;
	userId: string;
	/**
	 * Constructs a new CategoryMetricsFinancialSubProfile instance.
	 *
	 * @param data - Initialization data for the financial sub-profile.
	 */
	constructor(data?: Partial<CategoryMetricsFinancialSubProfile>);
}
/**
 * Represents the monthly expenditure of a category.
 *
 * @remarks
 * This class provides insights into the monthly spending habits of a user for a specific category.
 * It can be beneficial for tracking spending patterns and understanding financial behaviors over time.
 *
 * @example Constructing a `CategoryMonthlyExpenditure` instance
 *
 * ```ts
 * const data = {
 *   month: 5,
 *   personalFinanceCategoryPrimary: 'Utilities',
 *   totalSpending: 150.00,
 *   userId: 1
 * };
 *
 * const monthlyExpenditure = new CategoryMonthlyExpenditure(data);
 * ```
 *
 * @property month - The month for which the expenditure is recorded.
 * @property personalFinanceCategoryPrimary - The primary category of personal finance for this expenditure.
 * @property totalSpending - Total amount spent in the specified month for this category.
 * @property userId - The user ID associated with this expenditure.
 */
export declare class CategoryMonthlyExpenditureClass implements CategoryMonthlyExpenditure {
	month: number;
	personalFinanceCategoryPrimary: string;
	totalSpending: number;
	userId: string;
	/**
	 * Constructs a new CategoryMonthlyExpenditure instance.
	 *
	 * @param data - Initialization data for the monthly expenditure.
	 */
	constructor(data?: Partial<CategoryMonthlyExpenditure>);
}
/**
 * Represents the monthly income of a category.
 *
 * @remarks
 * This class provides insights into the monthly income habits of a user for a specific category.
 * It can be valuable for tracking income patterns and understanding financial behaviors over time.
 *
 * @example Constructing a `CategoryMonthlyIncome` instance
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   personalFinanceCategoryPrimary: 'Salary',
 *   totalIncome: 3000,
 *   userId: 123
 * };
 *
 * const monthlyIncome = new CategoryMonthlyIncome(data);
 * ```
 *
 * @property month - The month for which the income is recorded.
 * @property personalFinanceCategoryPrimary - The primary category of personal finance for this income.
 * @property totalIncome - Total income received in the specified month for this category.
 * @property userId - The user ID associated with this income.
 */
export declare class CategoryMonthlyIncomeClass implements CategoryMonthlyIncome {
	month: number;
	personalFinanceCategoryPrimary: string;
	totalIncome: number;
	userId: string;
	/**
	 * Constructs a new CategoryMonthlyIncome instance.
	 *
	 * @param data - Initialization data for the monthly income.
	 */
	constructor(data: Partial<CategoryMonthlyIncome>);
}
/**
 * Represents the monthly transaction count of a category.
 *
 * @remarks
 * This class provides insights into the monthly transaction frequency of a user for a specific category.
 * It helps in understanding the user's transactional habits and identifying financial behaviors over specific months.
 *
 * @example Constructing a `CategoryMonthlyTransactionCount` instance
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   personalFinanceCategoryPrimary: 'Groceries',
 *   transactionCount: 15,
 *   userId: 123
 * };
 *
 * const monthlyTransactionCount = new CategoryMonthlyTransactionCount(data);
 * ```
 *
 * @property month - The month for which the transaction count is recorded.
 * @property personalFinanceCategoryPrimary - The primary category of personal finance for these transactions.
 * @property transactionCount - Total number of transactions in the specified month for this category.
 * @property userId - The user ID associated with these transactions.
 */
export declare class CategoryMonthlyTransactionCountClass implements CategoryMonthlyTransactionCount {
	month: number;
	personalFinanceCategoryPrimary: string;
	transactionCount: number;
	userId: string;
	/**
	 * Constructs a new CategoryMonthlyTransactionCount instance.
	 *
	 * @param data - Initialization data for the monthly transaction count.
	 */
	constructor(data?: Partial<CategoryMonthlyTransactionCount>);
}
/**
 * Represents the debt to income ratio of a user.
 *
 * @remarks
 * This class provides a snapshot of a user's financial health by comparing their total debt to their total income for a specific month.
 * A lower ratio indicates that a user has a good balance between debt and income, whereas a higher ratio can signal potential financial distress.
 *
 * @example Constructing a `DebtToIncomeRatio` instance
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   ratio: 0.5,
 *   userId: 123
 * };
 *
 * const dtiRatio = new DebtToIncomeRatio(data);
 * ```
 *
 * @property month - The month for which the debt to income ratio is recorded.
 * @property ratio - Represents the proportion of debt to income for the user. It's typically a value between 0 and 1, with higher values indicating more debt relative to income.
 * @property userId - The user ID for whom the ratio is calculated.
 */
export declare class DebtToIncomeRatioClass implements DebtToIncomeRatio {
	month: number;
	ratio: number;
	userId: string;
	/**
	 * Constructs a new DebtToIncomeRatio instance.
	 *
	 * @param data - Initialization data for the debt to income ratio.
	 */
	constructor(data?: Partial<DebtToIncomeRatio>);
}
/**
 * Represents the financial sub-profile metrics related to a user's expenses.
 *
 * @remarks
 * This class captures a detailed overview of a user's spending habits, tracking expenses on various timelines and categorizing them into discretionary and recurring spending.
 * Discretionary spending refers to non-essential expenses, while recurring spending covers fixed, consistent expenses like rent or mortgage.
 *
 * @example Constructing an `ExpenseMetricsFinancialSubProfileMetrics` instance
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   spentLastWeek: 100,
 *   spentLastMonth: 400,
 *   spentLastSixMonths: 2400,
 *   averageMonthlyDiscretionarySpending: 200,
 *   averageMonthlyRecurringSpending: 800,
 *   userId: 123
 * };
 *
 * const expenseMetrics = new ExpenseMetricsFinancialSubProfileMetrics(data);
 * ```
 *
 * @property month - The month for which the financial metrics are recorded.
 * @property spentLastWeek - The total amount spent by the user in the last week.
 * @property spentLastMonth - The total amount spent by the user in the last month.
 * @property spentLastSixMonths - The total amount spent by the user in the last six months.
 * @property averageMonthlyDiscretionarySpending - The average amount spent by the user on non-essential items every month.
 * @property averageMonthlyRecurringSpending - The average monthly fixed expenses of the user.
 * @property userId - The user ID for whom the metrics are calculated.
 */
export declare class ExpenseMetricsFinancialSubProfileMetricsClass implements ExpenseMetricsFinancialSubProfileMetrics {
	month: number;
	spentLastWeek: number;
	spentLastMonth: number;
	spentLastSixMonths: number;
	averageMonthlyDiscretionarySpending: number;
	averageMonthlyRecurringSpending: number;
	userId: string;
	/**
	 * Constructs a new ExpenseMetricsFinancialSubProfileMetrics instance.
	 *
	 * @param data - Initialization data for the financial sub profile metrics.
	 */
	constructor(data?: Partial<ExpenseMetricsFinancialSubProfileMetrics>);
}
/**
 * Represents the expense metrics related to a user's personal finance.
 *
 * @remarks
 * This class captures an overview of a user's monthly expenditure based on specific financial categories. It provides a comprehensive snapshot of the user's spending patterns, transaction frequency, and total expenses.
 *
 * @example Constructing an `ExpenseMetrics` instance
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   personalFinanceCategoryPrimary: "Dining",
 *   transactionCount: 15,
 *   totalExpenses: 500,
 *   userId: 123
 * };
 *
 * const expenseMetrics = new ExpenseMetrics(data);
 * ```
 *
 * @property month - The month for which the expense metrics are recorded.
 * @property personalFinanceCategoryPrimary - The primary category under personal finance for which metrics are recorded.
 * @property transactionCount - The number of transactions carried out in that month under the given category.
 * @property totalExpenses - The total amount spent by the user in that month for the given category.
 * @property userId - The user ID for whom the metrics are calculated.
 */
export declare class ExpenseMetricsClass implements ExpenseMetrics {
	month: number;
	personalFinanceCategoryPrimary: string;
	transactionCount: string;
	totalExpenses: number;
	userId: string;
	/**
	 * Constructs a new ExpenseMetrics instance.
	 *
	 * @param data - Initialization data for the expense metrics.
	 */
	constructor(data?: Partial<ExpenseMetrics>);
	/**
	 * Creates a random instance of the expense metrics class with all fields populated.
	 * @returns {ExpenseMetrics} A random ExpenseMetrics.
	 */
	static randomInstance(): ExpenseMetrics;
}
/**
 * Represents the comprehensive financial profile of a user.
 *
 * @remarks
 * This class provides a holistic view of a user's financial activities in a given month. It encapsulates the user's total income, total expenses, number of transactions, and the category where the most was spent.
 *
 * @example Constructing a `FinancialProfileMetrics` instance:
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   totalIncome: 5000,
 *   totalExpenses: 3000,
 *   numberOfTransactions: 40,
 *   mostExpensiveCategory: "Travel",
 *   userId: 123
 * };
 *
 * const financialProfileMetrics = new FinancialProfileMetrics(data);
 * ```
 *
 * @property month - The month for which the financial profile is detailed.
 * @property totalIncome - The total income of the user for that month.
 * @property totalExpenses - The total expenditure of the user for that month.
 * @property numberOfTransactions - The number of transactions the user made during that month.
 * @property mostExpensiveCategory - The category in which the user spent the most during that month.
 * @property userId - The user ID associated with this financial profile.
 */
export declare class FinancialProfileMetricsClass implements FinancialProfile {
	/**
	 * Constructs a new FinancialProfileMetrics instance.
	 *
	 * @param data - Initialization data for the financial profile.
	 */
	constructor(data?: Partial<FinancialProfileMetricsClass>);
	static randomInstance(): FinancialProfile;
}
/**
 * Represents the income-expense ratio of a user for a particular month.
 *
 * @remarks
 * This class provides insight into a user's financial health by comparing the total income to total expenses. A ratio greater than 1 indicates that income exceeds expenses, which is a positive financial indicator. Conversely, a ratio less than 1 indicates expenses exceeding income, suggesting potential financial challenges.
 *
 * @example Constructing an `IncomeExpenseRatio` instance:
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   ratio: 1.5,
 *   userId: 123
 * };
 *
 * const incomeExpenseRatio = new IncomeExpenseRatio(data);
 * ```
 *
 * @property month - The month for which the income-expense ratio is detailed.
 * @property ratio - The calculated ratio between total income and total expenses for the user for that month.
 * @property userId - The user ID associated with this income-expense ratio.
 */
export declare class IncomeExpenseRatioClass implements IncomeExpenseRatio {
	month: number;
	ratio: number;
	userId: string;
	/**
	 * Constructs a new IncomeExpenseRatio instance.
	 *
	 * @param data - Initialization data for the income-expense ratio.
	 */
	constructor(data?: Partial<IncomeExpenseRatio>);
}
/**
 * Represents the income metrics for a user's financial sub-profile.
 *
 * @remarks
 * This class offers an insight into a user's historical income patterns, providing data points for various intervals like the last two weeks, last month, and so forth. It's crucial for financial analysis and planning.
 *
 * @example Constructing an `IncomeMetricsFinancialSubProfile` instance:
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   incomeLastTwoWeeks: 2000,
 *   incomeLastMonth: 4000,
 *   incomeLastTwoMonths: 7500,
 *   incomeLastSixMonths: 22000,
 *   incomeLastYear: 50000,
 *   userId: 123
 * };
 *
 * const incomeMetrics = new IncomeMetricsFinancialSubProfile(data);
 * ```
 *
 * @property month - The month for which the income metrics are detailed.
 * @property incomeLastTwoWeeks - The total income for the last two weeks.
 * @property incomeLastMonth - The total income for the last month.
 * @property incomeLastTwoMonths - The total income for the last two months.
 * @property incomeLastSixMonths - The total income for the last six months.
 * @property incomeLastYear - The total income for the last year.
 * @property userId - The user ID associated with these income metrics.
 */
export declare class IncomeMetricsFinancialSubProfileClass implements IncomeMetricsFinancialSubProfile {
	month: number;
	incomeLastTwoWeeks: number;
	incomeLastMonth: number;
	incomeLastTwoMonths: number;
	incomeLastSixMonths: number;
	incomeLastYear: number;
	userId: string;
	/**
	 * Constructs a new IncomeMetricsFinancialSubProfile instance.
	 *
	 * @param data - Initialization data for the income metrics.
	 */
	constructor(data?: Partial<IncomeMetricsFinancialSubProfile>);
}
/**
 * Represents the income metrics for a user.
 *
 * @remarks
 * This class provides an overview of a user's income activity, including the category, transaction count, and total income. It helps in tracking and analyzing the income patterns for a specific month.
 *
 * @example Constructing an `IncomeMetrics` instance:
 *
 * ```ts
 * const data = {
 *   month: 6,
 *   personalFinanceCategoryPrimary: 'Salary',
 *   transactionCount: 2,
 *   totalIncome: 5000,
 *   userId: 123
 * };
 *
 * const incomeDetails = new IncomeMetrics(data);
 * ```
 *
 * @property month - The month for which the income metrics are detailed.
 * @property personalFinanceCategoryPrimary - The primary financial category associated with the income.
 * @property transactionCount - The total number of income transactions for the specified month.
 * @property totalIncome - The total income amount for the month.
 * @property userId - The user ID associated with these income metrics.
 */
export declare class IncomeMetricsClass implements IncomeMetrics {
	month: number;
	personalFinanceCategoryPrimary: string;
	transactionCount: string;
	totalIncome: number;
	userId: string;
	/**
	 * Constructs a new IncomeMetrics instance.
	 *
	 * @param data - Initialization data for the income metrics.
	 */
	constructor(data?: Partial<IncomeMetrics>);
	/**
	 * Creates a random instance of the income metrics class with all fields populated.
	 * @returns {IncomeMetrics} A random IncomeMetrics.
	 */
	static randomInstance(): IncomeMetrics;
}
/**
 * Represents an investment transaction.
 *
 * @remarks
 * This class provides detailed information regarding a specific investment transaction, including quantities, prices, fees, and other metadata. The associated gotags help in mapping these properties for database integration or other systems.
 *
 * @example Constructing an `InvestmentTransaction` instance:
 *
 * ```ts
 * const data = {
 *   accountId: '12345',
 *   ammount: '150',
 *   investmentTransactionId: 'trans001',
 *   // ... other properties
 * };
 *
 * const investmentTrans = new InvestmentTransaction(data);
 * ```
 *
 * @property accountId - The ID of the account.
 * @property ammount - The amount of the investment transaction. (There's a typo here, it should probably be 'amount'.)
 * @property investmentTransactionId - The unique ID of the investment transaction.
 * @property securityId - The ID of the security involved in the transaction.
 * @property currentDate - The current date of the transaction.
 * @property name - The name of the transaction.
 * @property quantity - The quantity involved in the transaction.
 * @property amount - The exact amount of the transaction.
 * @property price - The price per security for the transaction.
 * @property fees - Any associated fees with the transaction.
 * @property type - The type of transaction.
 * @property subtype - The subtype of transaction.
 * @property isoCurrencyCode - The official ISO code for the currency.
 * @property unofficialCurrencyCode - Any unofficial currency code that might be associated.
 * @property linkId - The ID of the link associated with the transaction.
 * @property id - The unique identifier for the transaction.
 * @property userId - The user ID associated with the transaction.
 * @property createdAt - The timestamp when the transaction was created.
 * @property sign - A sign indicating the direction of the transaction.
 * @property time - The exact time of the transaction.
 * @property additionalProperties - Any additional properties that might be associated with the transaction.
 */
export declare class InvestmentTransactionClass {
	accountId: string;
	ammount: string;
	investmentTransactionId: string;
	securityId: string;
	currentDate: string;
	name: string;
	quantity: number;
	amount: number;
	price: number;
	fees: number;
	type: string;
	subtype: string;
	isoCurrencyCode: string;
	unofficialCurrencyCode: string;
	linkId: number;
	id: string;
	userId: number;
	createdAt: string;
	sign: number;
	time: Date | undefined;
	additionalProperties: Any | undefined;
	/**
	 * Constructs a new InvestmentTransaction instance.
	 *
	 * @param data - Initialization data for the investment transaction.
	 */
	constructor(data?: Partial<InvestmentTransactionClass>);
}
/**
 * Represents the financial sub profile of a location.
 *
 * @remarks
 * This class provides a detailed representation of the financial transactions and spending patterns associated with a specific city or location. It can be used to understand user behavior and spending in different regions.
 *
 * @example Constructing a `LocationFinancialSubProfile` instance:
 *
 * ```ts
 * const data = {
 *   locationCity: 'New York',
 *   transactionCount: 120,
 *   spentLastWeek: 250,
 *   // ... other properties
 * };
 *
 * const locationProfile = new LocationFinancialSubProfile(data);
 * ```
 *
 * @property locationCity - The name of the city or location.
 * @property transactionCount - The total number of transactions made in the specified location.
 * @property spentLastWeek - The total amount spent in the location during the last week.
 * @property spentLastTwoWeeks - The total amount spent in the location during the last two weeks.
 * @property spentLastMonth - The total amount spent in the location during the last month.
 * @property spentLastSixMonths - The total amount spent in the location over the past six months.
 * @property spentLastYear - The total amount spent in the location over the past year.
 * @property spentLastTwoYears - The total amount spent in the location over the past two years.
 * @property userId - The user ID associated with this financial profile.
 * @property month - The month for which this financial profile is reported.
 */
export declare class LocationFinancialSubProfileClass implements LocationFinancialSubProfile {
	locationCity: string;
	transactionCount: string;
	spentLastWeek: number;
	spentLastTwoWeeks: number;
	spentLastMonth: number;
	spentLastSixMonths: number;
	spentLastYear: number;
	spentLastTwoYears: number;
	userId: string;
	month: number;
	/**
	 * Constructs a new LocationFinancialSubProfile instance.
	 *
	 * @param data - Initialization data for the location financial sub profile.
	 */
	constructor(data?: Partial<LocationFinancialSubProfile>);
}
/**
 * Represents the comprehensive financial context of a user.
 *
 * @remarks
 * This class captures a holistic view of a user's financial life, covering various aspects from categories
 * and expenses to different account types. By holding this extensive information, it becomes the foundation
 * for financial decision-making, insights generation, and personalized recommendations.
 *
 * @example Constructing a `MelodyFinancialContext` instance:
 *
 * ```ts
 * // Sample data
 * const financialContextData = {
 *   categories: [...], // array of CategoryMetricsFinancialSubProfile instances
 *   expenses: [...],   // array of ExpenseMetricsFinancialSubProfileMetrics instances
 *   income: [...],     // array of IncomeMetricsFinancialSubProfile instances
 *   // Add other properties here
 * };
 *
 * const userFinancialContext = new MelodyFinancialContext(financialContextData);
 * ```
 *
 * @property categories - Array of metrics related to financial categories.
 * @property expenses - Array of metrics related to expenses.
 * @property income - Array of metrics related to income sources.
 * @property locations - Array of location-specific financial metrics.
 * @property merchants - Array of metrics concerning merchants.
 * @property paymentChannels - Array of metrics related to different payment channels.
 * @property bankAccounts - Array of user's bank accounts.
 * @property investmentAccounts - Array of user's investment accounts.
 * @property creditAccounts - Array of user's credit accounts.
 * @property mortgageLoanAccounts - Array of user's mortgage accounts.
 * @property studentLoanAccounts - Array of user's student loan accounts.
 */
export declare class MelodyFinancialContextClass implements MelodyFinancialContext {
	categories: CategoryMetricsFinancialSubProfile[];
	expenses: ExpenseMetricsFinancialSubProfileMetrics[];
	income: IncomeMetricsFinancialSubProfile[];
	locations: LocationFinancialSubProfile[];
	merchants: MerchantMetricsFinancialSubProfile[];
	paymentChannels: PaymentChannelMetricsFinancialSubProfile[];
	bankAccounts: BankAccount[];
	investmentAccounts: InvestmentAccount[];
	creditAccounts: CreditAccount[];
	mortgageLoanAccounts: MortgageAccount[];
	studentLoanAccounts: StudentLoanAccount[];
	/**
	 * Creates an instance of MelodyFinancialContext.
	 * @param data - Object containing properties for MelodyFinancialContext.
	 */
	constructor(data: Partial<MelodyFinancialContext>);
}
/**
 * Represents the financial sub profile of a merchant.
 *
 * @remarks
 * This class encapsulates the financial metrics related to a specific merchant's transactions. It gives insights into user spending patterns and behaviors over various time frames with a particular merchant.
 *
 * @example Constructing a `MerchantMetricsFinancialSubProfile` instance:
 *
 * ```ts
 * const data = {
 *   merchantName: 'Amazon',
 *   spentLastWeek: 150,
 *   spentLastMonth: 700,
 *   // ... other properties
 * };
 *
 * const merchantProfile = new MerchantMetricsFinancialSubProfile(data);
 * ```
 *
 * @property merchantName - The name of the merchant.
 * @property spentLastWeek - The total amount spent with the merchant during the last week.
 * @property spentLastTwoWeeks - The total amount spent with the merchant during the last two weeks.
 * @property spentLastMonth - The total amount spent with the merchant during the last month.
 * @property spentLastSixMonths - The total amount spent with the merchant over the past six months.
 * @property spentLastYear - The total amount spent with the merchant over the past year.
 * @property spentLastTwoYears - The total amount spent with the merchant over the past two years.
 * @property userId - The user ID associated with this financial profile.
 * @property month - The month for which this financial profile is reported.
 */
export declare class MerchantMetricsFinancialSubProfileClass implements MerchantMetricsFinancialSubProfile {
	merchantName: string;
	spentLastWeek: number;
	spentLastTwoWeeks: number;
	spentLastMonth: number;
	spentLastSixMonths: number;
	spentLastYear: number;
	spentLastTwoYears: number;
	userId: string;
	month: number;
	/**
	 * Constructs a new MerchantMetricsFinancialSubProfile instance.
	 *
	 * @param data - Initialization data for the merchant financial sub profile.
	 */
	constructor(data?: Partial<MerchantMetricsFinancialSubProfile>);
}
/**
 * Represents the monthly expenditure of a merchant.
 *
 * @remarks
 * This class encapsulates the monthly financial metrics related to a specific merchant's transactions. It provides insights into how much a user spends with a particular merchant on a monthly basis.
 *
 * @example Constructing a `MerchantMonthlyExpenditure` instance:
 *
 * ```ts
 * const expenditureData = {
 *   month: 7,
 *   merchantName: 'Amazon',
 *   totalSpending: 500,
 *   userId: 12345,
 * };
 *
 * const monthlyExpenditure = new MerchantMonthlyExpenditure(expenditureData);
 * ```
 *
 * @property month - The month for which this expenditure is reported.
 * @property merchantName - The name of the merchant.
 * @property totalSpending - The total amount spent with the merchant during the month.
 * @property userId - The user ID associated with this expenditure.
 */
export declare class MerchantMonthlyExpenditureClass implements MerchantMonthlyExpenditure {
	month: number;
	merchantName: string;
	totalSpending: number;
	userId: string;
	/**
	 * Constructs a new MerchantMonthlyExpenditure instance.
	 *
	 * @param data - Initialization data for the merchant monthly expenditure.
	 */
	constructor(data?: Partial<MerchantMonthlyExpenditure>);
}
/**
 * Represents the monthly balance of a user.
 *
 * @remarks
 * This class provides insights into the net balance of a user for a specific month, helping in understanding their financial health and status for that period.
 *
 * @example Constructing a `MonthlyBalance` instance:
 *
 * ```ts
 * const balanceData = {
 *   month: 7,
 *   netBalance: 1000,
 *   userId: 12345,
 * };
 *
 * const userMonthlyBalance = new MonthlyBalance(balanceData);
 * ```
 *
 * @property month - The month for which the balance is reported.
 * @property netBalance - The net balance of the user for the month.
 * @property userId - The user ID associated with this balance.
 */
export declare class MonthlyBalanceClass implements MonthlyBalance {
	month: number;
	netBalance: number;
	userId: string;
	/**
	 * Constructs a new MonthlyBalance instance.
	 *
	 * @param data - Initialization data for the monthly balance.
	 */
	constructor(data?: Partial<MonthlyBalance>);
}
/**
 * Represents the monthly expenditure of a user.
 *
 * @remarks
 * This class offers insights into the total expenditure of a user for a particular month, assisting in understanding their spending habits and financial decisions during that period.
 *
 * @example Constructing a `MonthlyExpenditure` instance:
 *
 * ```ts
 * const expenditureData = {
 *   month: 7,
 *   totalSpending: 500,
 *   userId: 12345,
 * };
 *
 * const userMonthlyExpenditure = new MonthlyExpenditure(expenditureData);
 * ```
 *
 * @property month - The month for which the expenditure is reported.
 * @property totalSpending - The total expenditure of the user for the month.
 * @property userId - The user ID associated with this expenditure record.
 */
export declare class MonthlyExpenditureClass implements MonthlyExpenditure {
	month: number;
	totalSpending: number;
	userId: string;
	/**
	 * Constructs a new MonthlyExpenditure instance.
	 *
	 * @param data - Initialization data for the monthly expenditure.
	 */
	constructor(data?: Partial<MonthlyExpenditure>);
}
/**
 * Represents the monthly income of a user.
 *
 * @remarks
 * This class provides insights into the total income of a user for a particular month, assisting in understanding their income sources and financial gains during that timeframe.
 *
 * @example Constructing a `MonthlyIncome` instance:
 *
 * ```ts
 * const incomeData = {
 *   month: 7,
 *   totalIncome: 1500,
 *   userId: 12345,
 * };
 *
 * const userMonthlyIncome = new MonthlyIncome(incomeData);
 * ```
 *
 * @property month - The month for which the income is reported.
 * @property totalIncome - The total income of the user for the month.
 * @property userId - The user ID associated with this income record.
 */
export declare class MonthlyIncomeClass implements MonthlyIncome {
	month: number;
	totalIncome: number;
	userId: string;
	/**
	 * Constructs a new MonthlyIncome instance.
	 *
	 * @param data - Initialization data for the monthly income.
	 */
	constructor(data?: Partial<MonthlyIncome>);
}
/**
 * Represents the monthly savings of a user.
 *
 * @remarks
 * This class provides insights into the net savings of a user for a particular month. It assists in understanding their financial health, disciplined spending, and savings habits during that timeframe.
 *
 * @example Constructing a `MonthlySavings` instance:
 *
 * ```ts
 * const savingsData = {
 *   month: 7,
 *   netSavings: 800,
 *   userId: 12345,
 * };
 *
 * const userMonthlySavings = new MonthlySavings(savingsData);
 * ```
 *
 * @property month - The month for which the savings are reported.
 * @property netSavings - The net savings amount of the user for the month.
 * @property userId - The user ID associated with this savings record.
 */
export declare class MonthlySavingsClass implements MonthlySavings {
	month: number;
	netSavings: number;
	userId: string;
	/**
	 * Constructs a new MonthlySavings instance.
	 *
	 * @param data - Initialization data for the monthly savings.
	 */
	constructor(data?: Partial<MonthlySavings>);
}
/**
 * Represents the monthly total quantity of a security by user.
 *
 * @remarks
 * This class provides insights into the total quantity of a particular security held by a user for a specific month. It aids in tracking investments and holdings in different securities.
 *
 * @example Constructing a `MonthlyTotalQuantityBySecurityAndUser` instance:
 *
 * ```ts
 * const securityData = {
 *   month: 7,
 *   securityId: "XYZ123",
 *   totalQuantity: 100,
 *   userId: 12345,
 * };
 *
 * const userSecurity = new MonthlyTotalQuantityBySecurityAndUser(securityData);
 * ```
 *
 * @property month - The month for which the total quantity is reported.
 * @property securityId - The unique identifier for the security.
 * @property totalQuantity - The total quantity of the security held by the user for the month.
 * @property userId - The user ID associated with this record.
 */
export declare class MonthlyTotalQuantityBySecurityAndUserClass implements MonthlyTotalQuantityBySecurityAndUser {
	month: number;
	securityId: string;
	totalQuantity: number;
	userId: string;
	/**
	 * Constructs a new MonthlyTotalQuantityBySecurityAndUser instance.
	 *
	 * @param data - Initialization data for the monthly total quantity by security and user.
	 */
	constructor(data?: Partial<MonthlyTotalQuantityBySecurityAndUser>);
}
/**
 * Represents the monthly transaction count of a user.
 *
 * @remarks
 * This class offers insights into the number of transactions a user has made for a specific month. It aids in monitoring user activity and spending behavior.
 *
 * @example Constructing a `MonthlyTransactionCount` instance:
 *
 * ```ts
 * const userTransactionData = {
 *   month: 7,
 *   transactionCount: 20,
 *   userId: 12345,
 * };
 *
 * const userTransaction = new MonthlyTransactionCount(userTransactionData);
 * ```
 *
 * @property month - The month for which the transaction count is reported.
 * @property transactionCount - The total number of transactions made by the user for the month.
 * @property userId - The user ID associated with this record.
 */
export declare class MonthlyTransactionCountClass implements MonthlyTransactionCount {
	month: number;
	transactionCount: string;
	userId: string;
	/**
	 * Constructs a new MonthlyTransactionCount instance.
	 *
	 * @param data - Initialization data for the monthly transaction count.
	 */
	constructor(data?: Partial<MonthlyTransactionCount>);
}
/**
 * Represents the financial sub profile of a payment channel.
 *
 * @remarks
 * This class provides insights into a user's spending behavior and patterns across different payment channels. It helps in understanding user preferences and can be instrumental in tailoring offerings to user habits.
 *
 * @example Constructing a `PaymentChannelMetricsFinancialSubProfile` instance:
 *
 * ```ts
 * const paymentChannelData = {
 *   paymentChannel: 'Credit Card',
 *   spentLastWeek: 200,
 *   spentLastTwoWeeks: 500,
 *   spentLastMonth: 1200,
 *   spentLastSixMonths: 7500,
 *   spentLastYear: 15000,
 *   spentLastTwoYears: 30000,
 *   userId: 12345,
 *   month: 7,
 *   transactionCount: 25
 * };
 *
 * const paymentChannelProfile = new PaymentChannelMetricsFinancialSubProfile(paymentChannelData);
 * ```
 *
 * @property paymentChannel - The type of payment channel.
 * @property spentLastWeek - Amount spent by the user through this channel in the last week.
 * @property spentLastTwoWeeks - Amount spent in the last two weeks.
 * @property spentLastMonth - Amount spent in the last month.
 * @property spentLastSixMonths - Amount spent in the last six months.
 * @property spentLastYear - Amount spent in the last year.
 * @property spentLastTwoYears - Amount spent in the last two years.
 * @property userId - The user ID associated with this record.
 * @property month - The month for which the data is reported.
 * @property transactionCount - Number of transactions made through this channel in the specified month.
 */
export declare class PaymentChannelMetricsFinancialSubProfileClass implements PaymentChannelMetricsFinancialSubProfile {
	paymentChannel: string;
	spentLastWeek: number;
	spentLastTwoWeeks: number;
	spentLastMonth: number;
	spentLastSixMonths: number;
	spentLastYear: number;
	spentLastTwoYears: number;
	userId: string;
	month: number;
	transactionCount: string;
	/**
	 * Constructs a new PaymentChannelMetricsFinancialSubProfile instance.
	 *
	 * @param data - Initialization data for the financial sub profile of the payment channel.
	 */
	constructor(data?: Partial<PaymentChannelMetricsFinancialSubProfile>);
}
/**
 * Represents the monthly expenditure of a payment channel.
 *
 * @remarks
 * This class provides insights into the monthly spending behavior of a user across different payment channels. It offers a detailed view of user spending patterns for each month, aiding financial analysis and decision-making.
 *
 * @example Constructing a `PaymentChannelMonthlyExpenditure` instance:
 *
 * ```ts
 * const monthlyExpenditureData = {
 *   month: 7,
 *   paymentChannel: 'Credit Card',
 *   totalSpending: 1200,
 *   userId: 12345
 * };
 *
 * const monthlyExpenditure = new PaymentChannelMonthlyExpenditure(monthlyExpenditureData);
 * ```
 *
 * @property month - The month for which the expenditure data is reported.
 * @property paymentChannel - The type of payment channel.
 * @property totalSpending - Total amount spent by the user through this channel for the specified month.
 * @property userId - The user ID associated with this record.
 */
export declare class PaymentChannelMonthlyExpenditureClass implements PaymentChannelMonthlyExpenditure {
	month: number;
	paymentChannel: string;
	totalSpending: number;
	userId: string;
	/**
	 * Constructs a new PaymentChannelMonthlyExpenditure instance.
	 *
	 * @param data - Initialization data for the monthly expenditure of the payment channel.
	 */
	constructor(data?: Partial<PaymentChannelMonthlyExpenditureClass>);
}
/**
 * Represents a recurring financial transaction for a user.
 *
 * @remarks
 * This class captures and manages the specifics of a recurring financial transaction, such as subscriptions
 * or regular bill payments. It tracks transaction details, merchants, dates, and amounts, making it useful
 * for personal finance management applications or services.
 *
 * @example Constructing a `ReOccuringTransaction`
 *
 * ```ts
 * // Example data
 * const transactionData = {
 *   accountId: 'account123',
 *   description: 'Monthly subscription to streaming service',
 *   merchantName: 'StreamFlix',
 *   averageAmount: '14.99',
 *   averageAmountIsoCurrencyCode: 'USD',
 *   // Add other properties here
 * };
 *
 * const recurringTransaction = new ReOccuringTransaction(transactionData);
 * ```
 *
 * @property accountId - The unique identifier of the account associated with the transaction.
 * @property streamId - The unique identifier of the transaction stream.
 * @property categoryId - The unique identifier of the category associated with the transaction.
 * @property description - A brief overview of the transaction's purpose.
 * @property merchantName - The name of the merchant or business entity related to the transaction.
 * @property personalFinanceCategoryPrimary - The primary financial category of the transaction.
 * @property personalFinanceCategoryDetailed - The more detailed categorization of the transaction.
 * @property firstDate - The date when the transaction first occurred.
 * @property lastDate - The date of the most recent occurrence of the transaction.
 * @property frequency - How often the transaction occurs (e.g., weekly, monthly).
 * @property transactionIds - A list of unique transaction IDs associated with this recurring transaction.
 * @property averageAmount - The typical transaction amount for this recurring item.
 * @property averageAmountIsoCurrencyCode - The currency code of the average transaction amount.
 * @property lastAmount - The amount from the most recent transaction occurrence.
 * @property lastAmountIsoCurrencyCode - The currency code of the most recent transaction amount.
 * @property isActive - Flag indicating if the transaction is still active or not.
 * @property status - The current status of the recurring transaction (e.g., active, paused).
 * @property updatedTime - The last time the transaction details were updated.
 * @property userId - The identifier of the user associated with this transaction.
 * @property linkId - The unique identifier of a linked transaction or reference.
 * @property id - The unique identifier of this recurring transaction.
 * @property flow - The direction or flow of the transaction (e.g., inbound, outbound).
 * @property sign - A numerical indicator that signifies the nature of the transaction (e.g., credit, debit).
 * @property time - The exact timestamp of the transaction.
 * @property additionalProperties - Any extra data or properties associated with the transaction.
 */
export declare class ReOccuringTransactionClass implements ReOccuringTransaction {
	/** The unique identifier of the account associated with the transaction. */
	accountId: string;
	/** The unique identifier of the transaction stream. */
	streamId: string;
	/** The unique identifier of the category associated with the transaction. */
	categoryId: string;
	/** A description of the transaction. */
	description: string;
	/** The name of the merchant. */
	merchantName: string;
	/** The primary personal finance category of the transaction. */
	personalFinanceCategoryPrimary: string;
	/** The detailed personal finance category of the transaction. */
	personalFinanceCategoryDetailed: string;
	/** The date of the first occurrence of the transaction. */
	firstDate: string;
	/** The date of the last occurrence of the transaction. */
	lastDate: string;
	/** The frequency of the recurring transaction. */
	frequency: ReOccuringTransactionsFrequency;
	/** A comma-separated list of transaction IDs. */
	transactionIds: string;
	/** The average amount of the transaction. */
	averageAmount: string;
	/** The ISO currency code of the average amount. */
	averageAmountIsoCurrencyCode: string;
	/** The amount of the last occurrence of the transaction. */
	lastAmount: string;
	/** The ISO currency code of the last amount. */
	lastAmountIsoCurrencyCode: string;
	/** Indicates whether the transaction is active. */
	isActive: boolean;
	/** The status of the recurring transaction. */
	status: ReOccuringTransactionsStatus;
	/** The last time the transaction was updated. */
	updatedTime: string;
	/** The unique identifier of the user associated with the transaction. */
	userId: string;
	/** The unique identifier of the linked transaction. */
	linkId: string;
	/** The unique identifier of the transaction. */
	id: string;
	/** The flow of the recurring transaction. */
	flow: ReCurringFlow;
	/** A numerical sign associated with the transaction. */
	sign: number;
	/** The date and time of the transaction. */
	time: string | undefined;
	/** Additional properties associated with the transaction. */
	additionalProperties: Any | undefined;
	/**
	 * Creates an instance of ReOccuringTransaction.
	 * @param data - Object containing properties for ReOccuringTransaction.
	 * @example
	 * const transactionData = {
	 *   accountId: 'account123',
	 *   description: 'Monthly subscription',
	 *   // Add other properties here
	 * };
	 * const recurringTransaction = new ReOccuringTransaction(transactionData);
	 */
	constructor(data: Partial<ReOccuringTransactionClass>);
	static randomInstance(): ReOccuringTransactionClass;
}
/**
 * Represents the total investment in a particular security.
 *
 * @remarks
 * This class encapsulates details about the total investment made by a user in a specific security.
 * It provides a structured way to track and manage the investment amounts across different securities
 * for portfolio management, financial reporting, and analysis purposes.
 *
 * @example Constructing a `TotalInvestmentBySecurity` instance:
 *
 * ```ts
 * // Example data
 * const investmentData = {
 *   securityId: 'AAPL123',
 *   totalInvestment: 5000,
 *   userId: 456
 * };
 *
 * const investment = new TotalInvestmentBySecurity(investmentData);
 * ```
 *
 * @property securityId - The unique identifier of the security (e.g., stock ticker, bond ID).
 * @property totalInvestment - The total monetary amount invested in the security.
 * @property userId - The identifier of the user who made the investment.
 */
export declare class TotalInvestmentBySecurityClass implements TotalInvestmentBySecurity {
	securityId: string;
	totalInvestment: number;
	userId: string;
	/**
	 * Creates an instance of TotalInvestmentBySecurity.
	 *
	 * @param data - Object containing properties for TotalInvestmentBySecurity.
	 */
	constructor(data: Partial<TotalInvestmentBySecurityClass>);
}
/**
 * Represents the aggregated transactions of a user by month.
 *
 * @remarks
 * This class is essential for generating monthly reports or providing insights into a user's spending habits.
 * By capturing the primary finance category, location, payment channel, and merchant name, it gives
 * a comprehensive view of the user's monthly transactions.
 *
 * @example Constructing a `TransactionAggregatesByMonth` instance:
 *
 * ```ts
 * // Sample transaction aggregate data
 * const aggregateData = {
 *   month: 5, // May
 *   personalFinanceCategoryPrimary: 'Food & Dining',
 *   locationCity: 'New York',
 *   paymentChannel: 'Online',
 *   merchantName: 'Restaurant XYZ',
 *   transactionCount: 15,
 *   totalAmount: 500,
 *   userId: 12345,
 * };
 *
 * const monthlyAggregate = new TransactionAggregatesByMonth(aggregateData);
 * ```
 *
 * @property month - The month (1-12) for which the transactions are aggregated.
 * @property personalFinanceCategoryPrimary - The primary category of the transaction, e.g., 'Food & Dining', 'Entertainment'.
 * @property locationCity - The city in which the transaction took place.
 * @property paymentChannel - The channel through which the payment was made, e.g., 'Online', 'In-store'.
 * @property merchantName - The name of the merchant or store where the transaction was made.
 * @property transactionCount - The total number of transactions made in the specified month.
 * @property totalAmount - The total amount spent in the specified month.
 * @property userId - Identifier of the user associated with these transactions.
 */
export declare class TransactionAggregatesByMonthClass implements TransactionAggregatesByMonth {
	month: number;
	personalFinanceCategoryPrimary: string;
	locationCity: string;
	paymentChannel: string;
	merchantName: string;
	transactionCount: string;
	totalAmount: number;
	userId: string;
	/**
	 * Creates an instance of TransactionAggregatesByMonth.
	 * @param data - Object containing properties for TransactionAggregatesByMonth.
	 */
	constructor(data: Partial<TransactionAggregatesByMonthClass>);
}
/**
 * Represents a financial transaction.
 *
 * @remarks
 * This class provides a comprehensive view of a financial transaction, capturing essential
 * details like amounts, dates, merchant information, and location data. It's an integral component
 * for financial systems, banking applications, or any platform requiring transaction tracking and
 * analytics.
 *
 * @example Constructing a `Transaction` instance:
 *
 * ```ts
 * // Sample transaction data
 * const transactionDetails = {
 *   accountId: 'acc-123',
 *   amount: 500,
 *   isoCurrencyCode: 'USD',
 *   // ... other properties ...
 * };
 *
 * const transactionInstance = new Transaction(transactionDetails);
 * ```
 *
 * @property accountId - Unique identifier of the account associated with the transaction.
 * @property amount - Monetary amount of the transaction.
 * @property isoCurrencyCode - Official ISO code representing the currency used in the transaction.
 * @property unofficialCurrencyCode - Any non-official currency codes, if applicable.
 * @property categoryId - Identifier for the transaction category.
 * @property checkNumber - Check number if the transaction was a cheque payment.
 * @property currentDate - Date of the transaction.
 * @property currentDatetime - Detailed timestamp of the transaction.
 * @property authorizedDate - Date when the transaction was authorized.
 * @property authorizedDatetime - Timestamp when the transaction was authorized.
 * @property name - Name or title of the transaction.
 * @property merchantName - Name of the merchant or vendor.
 * @property paymentChannel - Channel through which payment was made (e.g., online, in-store).
 * @property pending - Indicates if the transaction is still pending.
 * @property pendingTransactionId - If pending, a unique identifier for the pending transaction.
 * @property accountOwner - Name of the account owner or holder.
 * @property transactionId - Unique identifier for the transaction.
 * @property transactionCode - Code related to the type or nature of the transaction.
 * @property id - Unique identifier for this specific record or object.
 * @property userId - Identifier of the user associated with the transaction.
 * @property linkId - Identifier linking to another related record or object.
 * @property sign - Numerical sign associated with the transaction (e.g., positive for credit, negative for debit).
 * @property personalFinanceCategoryPrimary - Broad category for personal finance classification.
 * @property personalFinanceCategoryDetailed - More detailed or specific financial category.
 * @property locationAddress - Address where the transaction occurred.
 * @property locationCity - City of the transaction location.
 * @property locationRegion - Region or state of the transaction location.
 * @property locationPostalCode - Postal or ZIP code of the transaction location.
 * @property locationCountry - Country of the transaction location.
 * @property locationLat - Latitude coordinates of the transaction location.
 * @property locationLon - Longitude coordinates of the transaction location.
 * @property locationStoreNumber - Store number if the transaction was at a retail chain.
 * @property paymentMetaByOrderOf - Metadata field for payment details.
 * @property paymentMetaPayee - Metadata about the payee or recipient of the funds.
 * @property paymentMetaPayer - Metadata about the payer or sender of the funds.
 * @property paymentMetaPaymentMethod - Method used for the payment.
 * @property paymentMetaPaymentProcessor - Processor or intermediary handling the payment.
 * @property paymentMetaPpdId - Prearranged Payment and Deposit identifier.
 * @property paymentMetaReason - Reason or note for the transaction.
 * @property paymentMetaReferenceNumber - A reference number for the transaction.
 * @property time - Timestamp of the transaction.
 * @property additionalProperties - Any extra or miscellaneous properties related to the transaction.
 * @property categories - List of categories associated with the transaction.
 */
export declare class TransactionClass implements Transaction {
	accountId: string;
	amount: number;
	isoCurrencyCode: string;
	unofficialCurrencyCode: string;
	categoryId: string;
	checkNumber: string;
	currentDate: string;
	currentDatetime: string;
	authorizedDate: string;
	authorizedDatetime: string;
	name: string;
	merchantName: string;
	paymentChannel: string;
	pending: boolean;
	pendingTransactionId: string;
	accountOwner: string;
	transactionId: string;
	transactionCode: string;
	id: string;
	userId: string;
	linkId: string;
	sign: number;
	personalFinanceCategoryPrimary: string;
	personalFinanceCategoryDetailed: string;
	locationAddress: string;
	locationCity: string;
	locationRegion: string;
	locationPostalCode: string;
	locationCountry: string;
	locationLat: number;
	locationLon: number;
	locationStoreNumber: string;
	paymentMetaByOrderOf: string;
	paymentMetaPayee: string;
	paymentMetaPayer: string;
	paymentMetaPaymentMethod: string;
	paymentMetaPaymentProcessor: string;
	paymentMetaPpdId: string;
	paymentMetaReason: string;
	paymentMetaReferenceNumber: string;
	time: string;
	additionalProperties: Any | undefined;
	categories: string[];
	/**
	 * Creates an instance of Transaction.
	 *
	 * @param data - Object with details for Transaction.
	 */
	constructor(data: Partial<TransactionClass>);
	static randomInstance(): TransactionClass;
}
/**
 * Represents the financial health metrics of a user.
 *
 * @remarks
 * This class provides insights into a user's financial health by capturing vital metrics
 * such as income, expenses, and transaction diversity. It's an essential tool for financial
 * advisors, banking systems, or any platform aiming to provide financial advice or insights to users.
 *
 * @example Constructing a `UserFinancialHealthMetricsTable` instance:
 *
 * ```ts
 * // Sample financial health metrics data
 * const userMetrics = {
 *   userId: 12345,
 *   monthlyIncome: 5000,
 *   monthlyExpenses: 4000,
 *   transactionDiversity: 0.7,
 *   // ... other properties ...
 * };
 *
 * const userFinancialHealth = new UserFinancialHealthMetricsTable(userMetrics);
 * ```
 *
 * @property time - Timestamp when the metrics were recorded or updated.
 * @property userId - Identifier of the user associated with these metrics.
 * @property monthlyIncome - The user's total income on a monthly basis.
 * @property monthlyExpenses - The user's total expenses on a monthly basis.
 * @property transactionDiversity - A metric representing the diversity or variety of transactions.
 *                                 For instance, a value closer to 1 might indicate a diverse set
 *                                 of transactions across different categories.
 * @property debtToIncomeRatio - Ratio of a user's total debt to their income. A lower value is generally seen as favorable.
 * @property overdraftFrequency - Number of times the user has had an overdraft in a specific period,
 *                                e.g., the past month or year.
 */
export declare class UserFinancialHealthMetricsTableClass {
	time: Date | undefined;
	userId: number;
	monthlyIncome: number;
	monthlyExpenses: number;
	transactionDiversity: number;
	debtToIncomeRatio: number;
	overdraftFrequency: number;
	/**
	 * Creates an instance of UserFinancialHealthMetricsTable.
	 * @param data - Object containing properties for UserFinancialHealthMetricsTable.
	 */
	constructor(data: Partial<UserFinancialHealthMetricsTableClass>);
}
export declare class BusinessAccountClass implements BusinessAccount {
	accountType?: ProfileType;
	address?: Address;
	authnAccountId?: string;
	bio?: string;
	companyDescription?: string;
	companyEstablishedDate?: string;
	companyIndustryType?: string;
	companyName?: string;
	companyWebsiteUrl?: string;
	createdAt?: string;
	email?: string;
	headline?: string;
	id?: string;
	isActive?: boolean;
	isEmailVerified?: boolean;
	isPrivate?: boolean;
	phoneNumber?: string;
	tags?: Array<Tags>;
	username?: string;
	verifiedAt?: string;
	/** Settings specific to the business account. */
	settings?: Settings;
	constructor(data: Partial<BusinessAccount>);
	static randomInstance(): BusinessAccount;
}
export declare class FinancialPreferencesClass implements FinancialPreferences {
	currencyPreference?: string;
	financialYearStart?: string;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	taxCode?: string;
	/** @format double */
	taxPercentage?: number;
	constructor(data: Partial<FinancialPreferences>);
	static randomInstance(): FinancialPreferences;
}
export declare class NotificationSettingsClass implements NotificationSettings {
	/** True if user wants to be alerted for anomalies */
	alerts?: boolean;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	/**
	 * - TYPE_EMAIL: email based notification
	 *  - TYPE_SMS: sms based notification
	 *  - TYPE_IN_APP: app based notification
	 */
	notificationType?: NotificationType;
	constructor(data: Partial<NotificationSettings>);
	static randomInstance(): NotificationSettings;
}
export declare class TransactionSplitClass implements TransactionSplit {
	/**
	 * The amount of money involved in the transaction.
	 * @format double
	 */
	amount?: number;
	/**
	 * The time at which the transaction was authorized (time field)
	 * @format date-time
	 */
	authorizedDate?: string;
	/**
	 * The date-time when the transaction was authorized.
	 * @format date-time
	 */
	authorizedDatetime?: string;
	/** The set of categories that the transaction belongs to. */
	categories?: Array<string>;
	/** The description of the transaction. */
	description?: string;
	/**
	 * The unique ID for this transaction.
	 * @format uint64
	 */
	id?: string;
	/**
	 * The link ID associated with this transaction.
	 * @format uint64
	 */
	linkId?: string;
	/** The detailed personal finance category of the transaction. */
	personalFinanceCategoryDetailed?: string;
	/** The primary personal finance category of the transaction. */
	personalFinanceCategoryPrimary?: string;
	/** Tags associated with this transaction. */
	tags?: Array<string>;
	/**
	 * The time of split of the transaction
	 * @format date-time
	 */
	timeOfSplit?: string;
	/**
	 * The user ID associated with this transaction.
	 * @format uint64
	 */
	userId?: string;
	/**
	 * Creates an instance of TransactionSplitClass.
	 *
	 * @param data - Object with details for TransactionSplit.
	 */
	constructor(data: Partial<TransactionSplit>);
	/**
	 * Creates an instance of TransactionSplitClass.
	 *
	 * @param data - Object with details for TransactionSplit.
	 */
	static randomInstance(): TransactionSplit;
}
export declare class PlaidAccountTransactionClass implements PlaidAccountTransaction {
	/**
	 * The bank account ID associated with the transaction.
	 *
	 * @gotag: ch:"account_id"
	 */
	accountId?: string;
	/**
	 * The account owner associated with the transaction.
	 *
	 * @gotag: ch:"account_owner"
	 */
	accountOwner?: string;
	/** Additional properties that can be of any type. */
	additionalProperties?: Any;
	/**
	 * The amount of the transaction.
	 *
	 * @gotag: ch:"amount"
	 * @format double
	 */
	amount?: number;
	/**
	 * The time at which the transaction was authorized.
	 *
	 * @gotag: ch:"authorized_date"
	 * @format date-time
	 */
	authorizedDate?: string;
	/**
	 * The date-time when the transaction was authorized.
	 *
	 * @gotag: ch:"authorized_datetime"
	 * @format date-time
	 */
	authorizedDatetime?: string;
	/** The set of categories that the transaction belongs to. */
	categories?: Array<string>;
	/**
	 * The category ID of the transaction.
	 *
	 * @gotag: ch:"category_id"
	 */
	categoryId?: string;
	/**
	 * The check number associated with the transaction.
	 *
	 * @gotag: ch:"check_number"
	 */
	checkNumber?: string;
	/**
	 * The date of the transaction.
	 *
	 * @gotag: ch:"date"
	 * @format date-time
	 */
	currentDate?: string;
	/**
	 * The current datetime of the transaction.
	 *
	 * @gotag: ch:"datetime"
	 * @format date-time
	 */
	currentDatetime?: string;
	/** Indicates whether this transaction should be hidden. */
	hideTransaction?: boolean;
	/**
	 * The unique ID for this transaction.
	 * @format uint64
	 */
	id?: string;
	/**
	 * The currency code of the transaction.
	 *
	 * @gotag: ch:"iso_currency_code"
	 */
	isoCurrencyCode?: string;
	/**
	 * The link ID associated with this transaction.
	 * @format uint64
	 */
	linkId?: string;
	/** The street address of the transaction location (if available). */
	locationAddress?: string;
	/** The city of the transaction location (if available). */
	locationCity?: string;
	/** The country of the transaction location (if available). */
	locationCountry?: string;
	/**
	 * The latitude of the transaction location (if available).
	 * @format double
	 */
	locationLat?: number;
	/**
	 * The longitude of the transaction location (if available).
	 * @format double
	 */
	locationLon?: number;
	/** The postal code of the transaction location (if available). */
	locationPostalCode?: string;
	/** The region or state of the transaction location (if available). */
	locationRegion?: string;
	/** The store number associated with the transaction location (if available). */
	locationStoreNumber?: string;
	/**
	 * The merchant name of the transaction.
	 *
	 * @gotag: ch:"merchant_name"
	 */
	merchantName?: string;
	/** Indicates whether this transaction needs review. */
	needsReview?: boolean;
	/** Notes associated with this transaction. */
	notes?: Array<SmartNote>;
	/**
	 * The payment channel for the transaction.
	 *
	 * @gotag: ch:"payment_channel"
	 */
	paymentChannel?: string;
	/** Information about the entity to whom the payment is made (if available). */
	paymentMetaByOrderOf?: string;
	/** Information about the payee (if available). */
	paymentMetaPayee?: string;
	/** Information about the payer (if available). */
	paymentMetaPayer?: string;
	/** The payment method used for the transaction (if available). */
	paymentMetaPaymentMethod?: string;
	/** The payment processor involved in the transaction (if available). */
	paymentMetaPaymentProcessor?: string;
	/** The Prearranged Payment and Deposit (PPD) ID (if available). */
	paymentMetaPpdId?: string;
	/** The reason for the payment (if available). */
	paymentMetaReason?: string;
	/** The reference number associated with the payment (if available). */
	paymentMetaReferenceNumber?: string;
	/**
	 * Indicates whether the transaction is pending.
	 *
	 * @gotag: ch:"pending"
	 */
	pending?: boolean;
	/**
	 * The ID of the pending transaction, if applicable.
	 *
	 * @gotag: ch:"pending_transaction_id"
	 */
	pendingTransactionId?: string;
	/**
	 * The detailed personal finance category of the transaction.
	 *
	 * @gotag: ch:"personal_finance_category_detailed"
	 */
	personalFinanceCategoryDetailed?: string;
	/**
	 * The primary personal finance category of the transaction.
	 *
	 * @gotag: ch:"personal_finance_category_primary"
	 */
	personalFinanceCategoryPrimary?: string;
	/** The number of splits associated with this transaction. */
	splits?: Array<TransactionSplit>;
	/** Tags associated with this transaction. */
	tags?: Array<string>;
	/**
	 * The timestamp associated with the transaction.
	 * @format date-time
	 */
	time?: string;
	/**
	 * The transaction code.
	 *
	 * @gotag: ch:"transaction_code"
	 */
	transactionCode?: string;
	/**
	 * The transaction ID of interest.
	 *
	 * @gotag: ch:"transaction_id"
	 */
	transactionId?: string;
	/**
	 * The name of the transaction.
	 *
	 * @gotag: ch:"name"
	 */
	transactionName?: string;
	/**
	 * The unofficial currency code of the transaction.
	 *
	 * @gotag: ch:"unofficial_currency_code"
	 */
	unofficialCurrencyCode?: string;
	/**
	 * The user ID associated with this transaction.
	 * @format uint64
	 */
	userId?: string;
	/**
	 * Creates an instance of Transaction.
	 *
	 * @param data - Object with details for Transaction.
	 */
	constructor(data: Partial<PlaidAccountTransaction>);
	/**
	 * Creates an instance of Transaction.
	 *
	 * @param data - Object with details for Transaction.
	 */
	static randomInstance(): PlaidAccountTransactionClass;
}
export declare class SmartNoteClass implements SmartNote {
	/**
	 * The content of the note
	 * Validations:
	 * - must be at least 3 characters long
	 * @example "Note content here..."
	 */
	content?: string;
	/**
	 * Timestamp indicating when the note was created
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * Unique identifier for the note
	 * @format uint64
	 */
	id?: string;
	/**
	 * Timestamp indicating when the note was last updated
	 * @format date-time
	 */
	updatedAt?: string;
	/**
	 * The user id who created the note. This can be useful if in the future you allow multiple users to add notes to the same goal.
	 * @format uint64
	 */
	userId?: string;
	/**
	 * Creates an instance of SmartNote.
	 *
	 * @param data - Object with details for SmartNote.
	 */
	constructor(data: Partial<SmartNote>);
	/**
	 * Creates an instance of SmartNote.
	 *
	 * @param data - Object with details for SmartNote.
	 */
	static randomInstance(): SmartNote;
}
export interface Bookmark {
	/**
	 * the id of the blocked record
	 * @format uint64
	 */
	id?: string;
	postIds?: Array<string>;
	publications?: Array<Publication>;
}
/**
 * A Publication is a collections of stories based around a common theme. Anyone can create them
 * As the creator of a publication, you're an editor by default, which means you have the ability to
 * a) add writers to your publication,
 * b) edit and publish the stories that are submitted by your writers, and
 * c) review the metrics for all of the stories that are part of your publication.
 * As the publication's creator, you'll also have the ability
 * to appoint new editors (so they can do all of that stuff I just mentioned)
 * Use Case
 * - An online magazine, a publication with a fixed publication staff that posts stories around a specific topic
 * - A community publication, a publication that accepts stories published around Medium
 * - A company blog, a publication that is created specifically to share company news
 * - A collection of individual stories by a single author that are parts of a larger whole
 */
export interface Publication {
	admin?: UserProfile;
	/** @format uint64 */
	adminSimfinyPlatformUserId: string;
	createdAt?: string;
	description?: string;
	editors?: Array<UserProfile>;
	/** @format uint64 */
	id?: string;
	/** stories are post that can be submitted only by the publication editors */
	postIds?: Array<string>;
	publicationName: string;
	subjects: Array<string>;
	tags: Array<string>;
	type: PublicationType;
}
/**
 * - PUBLICATION_TYPE_MAGAZINE: a publication with a fixed publication staff that posts stories around a specific topic
 *  - PUBLICATION_TYPE_PLATFORM: a publication that accepts stories published around simfiny
 *  - PUBLICATION_TYPE_BLOG: A community blog, a publication that is created specifically to share subset (community) news
 *  - PUBLICATION_TYPE_SUBJECTS: A collection of individual stories by a set of authors that are part of a whole
 * @default "PUBLICATION_TYPE_UNSPECIFIED"
 */
export type PublicationType = "PUBLICATION_TYPE_UNSPECIFIED" | "PUBLICATION_TYPE_MAGAZINE" | "PUBLICATION_TYPE_PLATFORM" | "PUBLICATION_TYPE_BLOG" | "PUBLICATION_TYPE_SUBJECTS";
/** UserProfile: The profile object tied to a given user */
export interface UserProfile {
	/**
	 * The id of the algolia record referencing this user
	 * @example "asndlkhaskhdhasgdahsf-feed-id"
	 */
	algoliaId: string;
	/** all the bookmarked pieces of content on the platform */
	bookmarks: Bookmark;
	/**
	 * Followers outlines the number of followers this user profile has
	 * @format int64
	 */
	followers: string;
	/**
	 * Number of people account is following
	 * @format int64
	 */
	following: string;
	/**
	 * User profile ID
	 * @format uint64
	 */
	id?: string;
	/**
	 * Profile name is the name tied to the user profile
	 * user name must be at least 5 characters long
	 * @example "test-user"
	 */
	name: string;
	/**
	 * Newsfeed timeline ID Displays all followed and group activities the user
	 * follows
	 * @example "asndlkhaskhdhasgdahsf-feed-id"
	 */
	newsFeedTimelineId: string;
	/**
	 * Notification timeline Id. Notification for anything a user/group is
	 * following
	 * @example "asndlkhaskhdhasgdahsf-feed-id"
	 */
	notificationFeedTimelineId: string;
	/**
	 * Personal timeline ID Has activities for a user that can be followed
	 * @example "asndlkhaskhdhasgdahsf-feed-id"
	 */
	personalFeedTimelineId: string;
	/**
	 * Private defines wether only approved followers can see what this profile
	 * posts
	 */
	private: boolean;
	/**
	 * ProfileImageUrl witholds the url of a given profile image
	 * @example "asndlkhaskhdhasgdahsf.jpg"
	 */
	profileImageUrl: string;
	/** Tags are interests */
	tags: Array<UserTags>;
}
/** Tags: tags that can be associated to a record */
export interface UserTags {
	/**
	 * the description of the tag ... tag must be at least 5 characters long
	 * @example "test-description sakjlDKJGSAHGHFDHSGJHFGAHDFJKGSHAJDLgAKSGDHAS CSVDJKSADASKJHDASFDGJKJLHSAHGFJDSAHD kjskhdgfhgdhfgkhsdfdsdfdssdfsdf"
	 */
	description: string;
	/**
	 * the id of the tag record
	 * @format uint64
	 */
	id?: string;
	/**
	 * the name of the tag ... tag must be at least 5 characters long
	 * @example "test-tagname"
	 */
	tagName: string;
}
/**
 * Represents a user's social profile on the platform.
 *
 * The SocialUserProfile captures various details about a user's presence and activity in the social aspect of the platform. This includes details such as interests (tags), followers and following counts, profile image, and timelines.
 *
 * @remarks
 * Each social user profile is uniquely identified by its ID. It has a name, privacy setting (private or public), followers and following counts, and three distinct timelines: notification, personal feed, and news feed.
 *
 * @example
 * Creating an instance of `SocialUserProfile`:
 * ```ts
 * const profileData = {
 *   id: 12345,
 *   tags: [new Tag('Technology'), new Tag('AI')],
 *   name: "techenthusiast",
 *   private: false,
 *   followers: 500,
 *   following: 150,
 *   notificationFeedTimelineId: "notif12345",
 *   personalFeedTimelineId: "persfeed12345",
 *   newsFeedTimelineId: "newsfeed12345",
 *   profileImageUrl: "https://example.com/path/to/profile/image.jpg",
 *   algoliaId: "alg12345"
 * };
 * const userProfile = new SocialUserProfile(profileData);
 * console.log(userProfile.name); // Outputs: "techenthusiast"
 * ```
 *
 * @property id - The unique identifier of the user profile.
 * @property tags - An array of tags representing the user's interests.
 * @property name - The name tied to the user profile. Must be at least 5 characters long.
 * @property private - A boolean indicating if only approved followers can see what this profile posts.
 * @property followers - The number of followers this user profile has.
 * @property following - The number of users or groups this user profile is following.
 * @property notificationFeedTimelineId - The ID for the timeline capturing notifications for anything the user/group is following.
 * @property personalFeedTimelineId - The ID for the personal timeline capturing activities of the user.
 * @property newsFeedTimelineId - The ID for the news feed displaying all followed activities and groups the user is interested in.
 * @property profileImageUrl - The URL pointing to the user's profile image.
 * @property bookmarks - All content that the user has bookmarked on the platform.
 * @property algoliaId - The ID referencing this user in the Algolia platform.
 *
 * @implements {ISocialUserProfile}
 * @author ["yoan yomba"]
 */
export declare class SocialUserProfileClass implements UserProfile {
	/** User profile ID */
	id: string;
	/** Tags are interests */
	tags: UserTags[];
	/**
	 * Profile name is the name tied to the user profile
	 * user name must be at least 5 characters long
	 */
	name: string;
	/**
	 * Private defines wether only approved followers can see what this profile
	 * posts
	 */
	private: boolean;
	/** Followers outlines the number of followers this user profile has */
	followers: string;
	/** Number of people account is following */
	following: string;
	/**
	 * Notification timeline Id. Notification for anything a user/group is
	 * following
	 */
	notificationFeedTimelineId: string;
	/** Personal timeline ID Has activities for a user that can be followed */
	personalFeedTimelineId: string;
	/**
	 * Newsfeed timeline ID Displays all followed and group activities the user
	 * follows
	 */
	newsFeedTimelineId: string;
	/** ProfileImageUrl witholds the url of a given profile image */
	profileImageUrl: string;
	/** all the bookmarked pieces of content on the platform */
	bookmarks: Bookmark;
	/** The id of the algolia record referencing this user */
	algoliaId: string;
	constructor(data: Partial<UserProfile>);
}
/**
 * A Publication is a collections of stories based around a common theme. Anyone can create them
 * As the creator of a publication, you're an editor by default, which means you have the ability to
 * a) add writers to your publication,
 * b) edit and publish the stories that are submitted by your writers, and
 * c) review the metrics for all of the stories that are part of your publication.
 * As the publication's creator, you'll also have the ability
 * to appoint new editors (so they can do all of that stuff I just mentioned)
 *
 * Use Case
 * - An online magazine, a publication with a fixed publication staff that posts stories around a specific topic
 * - A community publication, a publication that accepts stories published around Medium
 * - A company blog, a publication that is created specifically to share company news
 * - A collection of individual stories by a single author that are parts of a larger whole
 *
 * Publications can be thought of as a collection of posts or articles, curated and managed by one or more administrators and editors.
 *
 * @remarks
 * Each publication has a unique ID, associated tags, subjects, a description, creation date, and a publication type.
 * The publication can have multiple editors and is owned by an admin.
 *
 * @example
 * Creating an instance of `Publication`:
 * ```ts
 * const publicationData = {
 *   id: 1,
 *   postIds: ["post123", "post456"],
 *   admin: new UserProfile({...}),
 *   tags: ["tech", "AI"],
 *   editors: [new UserProfile({...}), new UserProfile({...})],
 *   subjects: ["Deep Learning", "Neural Networks"],
 *   description: "A tech publication focusing on AI advancements.",
 *   createdAt: "2023-01-01",
 *   type: PublicationType.JOURNAL,
 *   publicationName: "Tech Forward"
 * };
 * const techPublication = new Publication(publicationData);
 * console.log(techPublication.publicationName); // Outputs: "Tech Forward"
 * ```
 *
 * @property id - The unique identifier for the publication.
 * @property postIds - An array of post IDs that belong to this publication.
 * @property admin - The administrator `UserProfile` of this publication.
 * @property adminSimfinyPlatformUserId - The unique identifier of the admin in the Simfiny platform.
 * @property tags - An array of tags associated with this publication.
 * @property editors - An array of editor `UserProfile`s who curate the publication's content.
 * @property subjects - Topics or subjects covered by the publication.
 * @property description - A brief description of the publication.
 * @property createdAt - The date when the publication was created.
 * @property type - The type/category of the publication.
 * @property publicationName - The name/title of the publication.
 *
 * @implements {Publication}
 * @author [Your Name or the Original Author's Name if you know it]
 */
export declare class PublicationClass implements Publication {
	id: string;
	postIds: string[];
	admin: SocialUserProfileClass | undefined;
	adminSimfinyPlatformUserId: string;
	tags: string[];
	editors: SocialUserProfileClass[];
	subjects: string[];
	description: string;
	createdAt: string | undefined;
	type: PublicationType;
	publicationName: string;
	constructor(data: Partial<Publication>);
}
/**
 * Represents a social account in the platform.
 *
 * A `SocialAccount` is a representation of a user's social presence on the platform. It captures details about followers, following, tags (interests), profile imagery, and more.
 *
 * @remarks
 * Each `SocialAccount` is uniquely identified by its ID and is associated with a user profile. It also provides details like the number of followers, the number of users it's following, and tags associated with it.
 *
 * @example
 * Initializing a new instance of `SocialAccount`:
 * ```ts
 * const accountData = {
 *   id: "12345",
 *   followers: "500",
 *   following: "150",
 *   name: "techuser",
 *   tags: [new Tag('Technology'), new Tag('AI')],
 *   profileImageUrl: "https://example.com/path/to/profile/image.jpg"
 * };
 * const socialAccount = new SocialAccount(accountData);
 * console.log(socialAccount.name); // Outputs: "techuser"
 * ```
 *
 * @property followers - The number of followers this profile has.
 * @property following - The number of users this profile is following.
 * @property id - The unique identifier for the social account.
 * @property name - The name or username associated with the social account.
 * @property tags - An array of tags (interests) associated with this profile.
 * @property private - A boolean indicating if this account is private or public.
 * @property profileImageUrl - The URL pointing to the user's profile image.
 * @property userProfileid - The ID of the user that owns this social account. Kept for backwards compatibility with earlier versions.
 *
 * @author [yoan yomba]
 */
export declare class SocialAccount {
	/**
	 * The number of followers this profile has.
	 *
	 * @type {string}
	 */
	followers: string;
	/**
	 * The number of users this profile is following.
	 *
	 * @type {string}
	 */
	following: string;
	/**
	 * the id of the profile
	 *
	 * @type {string}
	 */
	id: string;
	/**
	 * this is the username of the profile
	 *
	 * @type {string}
	 */
	name: string;
	/**
	 * The set of tags associated to this profile
	 *
	 * @type {Tag[]}
	 */
	tags: Tags[];
	/**
	 * Deliniates wether the profile is a private or public one
	 *
	 * @type {boolean}
	 */
	private: boolean;
	/**
	 * The profile image url.
	 *
	 * @type {string}
	 */
	profileImageUrl: string;
	/**
	 * User profile id.
	 * This is the id of the user that owns the profile.
	 * NOTE: this is the same as the id field referenced above.
	 * However we are keeping this field for backwards compatibility.
	 *
	 * @type {string}
	 */
	userProfileid: string;
	bookmarks: Bookmark | undefined;
	/**
	 * Creates an instance of Profile.
	 *
	 * @constructor
	 * @param {?Partial<Profile>} [data]
	 */
	constructor(data?: Partial<SocialAccount>);
	/**
	 * Checks if the profile is private.
	 * @returns {boolean} True if the profile is private, false otherwise.
	 */
	isPrivate(): boolean;
	/**
	 * Deciphers wether or not to show the profile's content
	 * @returns {boolean} True if the profile is not private, false otherwise.
	 */
	shouldShowContent(): boolean;
	/**
	 * Gets the profile image url.
	 *
	 * @returns {string} The profile image url.
	 */
	getProfileImageUrl(): string;
	/**
	 * Gets the tags of the profile.
	 *
	 * @returns {(Tag[] | string[])} The tags of the profile.
	 */
	getTags(): Tags[] | string[];
	/**
	 * Gets the number of tags the profile has.
	 *
	 * @returns {number} The number of tags the profile has.
	 */
	getTagCount(): number;
	/**
	 * Gets the tag names of the profile.
	 * @returns {string[]} The tag names of the profile.
	 */
	getTagNames(): string[];
	/**
	 * Gets the number of followers this profile has.
	 *
	 * @returns {string} The number of followers this profile has.
	 */
	getFollowerCount(): number;
	/**
	 * Get the number of users following this profile.
	 * @returns {string} The number of users following this profile.
	 */
	getfollowingCount(): number;
}
/**
 * Represents a user's account in simfiny's backend.
 *
 * The `UserAccount` class is central to operations within simfiny's backend. An instance of this class captures a user's details and
 * metadata such as their address, contact information, profile data, account verification status, and more.
 *
 * @remarks
 * The gateway performs some data transformations; specifically:
 *   - `id` becomes `userAccountID`
 *   - `authnId` becomes `userAuthnAccountID`
 *
 * @example Creating an instance of `UserAccount`:
 * ```ts
 * const userData = {
 *   email: "user@example.com",
 *   username: "exampleUser",
 *   // ... other data fields ...
 * };
 * const account = new UserAccount(userData);
 * console.log(account.getUserName()); // Outputs: "exampleUser"
 * ```
 *
 * @property address - A structured address associated with the user.
 * @property bio - A short biography or description for the user.
 * @property email - The user's email address.
 * @property firstname - The user's first name.
 * @property lastname - The user's last name.
 * @property username - The user's unique username.
 * @property headline - A headline or title for the user's profile.
 * @property phoneNumber - The user's contact phone number.
 * @property userAccountID - A transformed ID for the user, manipulated by the gateway.
 * @property userAuthnAccountID - A transformed authentication ID for the user, manipulated by the gateway.
 * @property id - The user's unique identifier.
 * @property tags - An array of tags associated with the user.
 * @property created_at - Timestamp for when the user was created.
 * @property isEmailVerified - Indicates if the user's email is verified.
 * @property isPrivate - Indicates if the user's account content is private.
 * @property verifiedAt - Timestamp for when the user was verified.
 * @property isActive - Indicates if the user's account is active.
 * @property authnAccountId - The user's authentication account ID.
 * @property createdAt - The user's account creation timestamp.
 *
 * @author Yoan Yomba
 */
export interface UserAccountContractWithAccountID {
	userAccountID?: string;
}
export declare class UserAccountClass implements UserAccount, UserAccountContractWithAccountID {
	/** Enum indicating the type of profile (e.g., individual, corporate). */
	accountType?: ProfileType;
	/** Physical address associated with the user. */
	address?: Address;
	/**
	 * ID for the authentication service linked to this account.
	 * @format uint64
	 */
	authnAccountId?: string;
	/** Brief description about the user, up to 200 characters. */
	bio?: string;
	/**
	 * Timestamp for when the account was created.
	 * @format date-time
	 */
	createdAt?: string;
	/**
	 * Email associated with the user account.
	 * @example "sample@example.com"
	 */
	email?: string;
	/** User's first name. */
	firstname?: string;
	/** Short headline for the user's profile. */
	headline?: string;
	/**
	 * Unique identifier for the account.
	 * @format uint64
	 */
	id?: string;
	/** Indicates if the account is currently active. */
	isActive?: boolean;
	/** Indicates if the user's email has been verified. */
	isEmailVerified?: boolean;
	/** Indicates if the account is set to private. */
	isPrivate?: boolean;
	/** User's last name. */
	lastname?: string;
	/** Phone number associated with the account. */
	phoneNumber?: string;
	/** Tags associated with the user account, between 1 and 10. */
	tags?: Array<Tags>;
	/** Settings specific to the user account. */
	userSettings?: Settings;
	/**
	 * Username associated with the account, minimum of 10 characters.
	 * @example "testuser9696"
	 */
	username?: string;
	/**
	 * Timestamp for when the email was verified.
	 * @format date-time
	 */
	verifiedAt?: string;
	userAccountID?: string;
	userAuthnAccountID?: string;
	auth0AccountID?: string;
	/**
	 * A constructor function that takes in a data object and assigns the data to the UserAccount class.
	 * @param [data] - The data that you want to assign to the object.
	 */
	constructor(data?: Partial<UserAccountClass>);
	/**
	 * Returns the username of the account
	 *
	 * @return {*}  {string}
	 * @memberof UserAccount
	 */
	getUserName(): string;
	/**
	 * Returns the tags associated with a given account
	 *
	 * @return {*}  {Tag[]}
	 * @memberof UserAccount
	 */
	getTags(): Tags[];
	/**
	 * Returns the number of tags associated with a given account
	 *
	 * @return {*}  {number}
	 * @memberof UserAccount
	 */
	getTagCount(): number;
	/**
	 * Deciphers wether the account has a verified email or not
	 *
	 * @return {*}  {boolean}
	 * @memberof UserAccount
	 */
	isAccountVerified(): boolean | undefined;
	/**
	 * Deciphers wether the account's content should be shown or not
	 *
	 * @return {*}  {boolean}
	 * @memberof UserAccount
	 */
	shouldShowContent(): boolean | undefined;
	/**
	 * Obtains the bio of the account
	 *
	 * @return {*}  {string}
	 * @memberof UserAccount
	 */
	getBio(): string | undefined;
	/**
	 * Obtains the headline of the account
	 *
	 * @return {*}  {string}
	 * @memberof UserAccount
	 */
	getHeadline(): string | undefined;
	/**
	 * @description Returns the ID of the account
	 * @author Yoan Yomba
	 * @returns {*}  {string}
	 * @memberof UserAccount
	 */
	getID(): string | undefined;
	static randomInstance(): UserAccount;
}
export declare class UserSettingsClass implements Settings {
	/** Display and interaction preferences. */
	appTheme?: ApplicationTheme;
	/** Settings specific to the user's digital worker. */
	digitalWorkerSettings?: DigitalWorkerSettings;
	financialPreferences?: FinancialPreferences;
	/**
	 * address id
	 * @format uint64
	 */
	id?: string;
	/** Dashboard customization, e.g., specific widgets or reports. */
	likedDashboardPanels?: Array<LikedDashboardPanels>;
	/** Notification preferences. */
	notificationSettings?: NotificationSettings;
	/** Language preference. */
	preferredLanguage?: string;
	/** Risk tolerance settings defined for user settings. */
	riskTolerance?: RiskToleranceSettings;
	constructor(data: Partial<Settings>);
	static randomInstance(): Settings;
}
export interface IRequest {
	isValid(): boolean;
}
/**
 * @description The request to authenticate a user
 * @author Yoan Yomba
 * @export
 * @class AuthenticateRequest
 */
export declare class AuthenticateRequestClass implements IRequest {
	Username: string;
	Password: string;
	constructor(data?: Partial<AuthenticateRequestClass>);
	isValid(): boolean;
}
export type FinancialProfileResponse = {
	profile: FinancialUserProfile;
	financialContext: MelodyFinancialContext;
};
/**
 * @description The response when a user is authenticated
 * @author Yoan Yomba
 * @export
 * @class AuthenticationResponse
 * @extends {ErrorResponse}
 */
export declare class AuthenticationResponseClass extends ErrorResponse {
	code: number;
	err: string;
	token: string;
	user_account: UserAccountClass;
	user_profile: UserProfile;
	user_financial_profile: FinancialProfileResponse;
	constructor(data?: Partial<AuthenticationResponseClass>);
}
export declare class CheckEmailExistsRequestClass {
	/** The email of the user of interest */
	email: string;
	constructor(data?: Partial<CheckEmailExistsRequestClass>);
}
export declare class CheckEmailExistsResponseClass extends ErrorResponse {
	exists: boolean;
	constructor(data?: Partial<CheckEmailExistsResponseClass>);
	private create;
	private fromPartial;
}
export declare class CheckUsernameExistsRequestClass implements IRequest {
	/** The username of the user of interest */
	username: string;
	constructor(data?: Partial<CheckUsernameExistsRequestClass>);
	isValid(): boolean;
}
export declare class CheckUsernameExistsResponseClass extends ErrorResponse {
	exists: boolean;
	constructor(data?: Partial<CheckUsernameExistsResponseClass>);
	private create;
	private fromPartial;
}
export declare class UserRegistrationAccountDetails {
	/** Enum indicating the type of profile (e.g., individual, corporate). */
	accountType: ProfileType;
	/** account id */
	id: number;
	/**
	 * account email
	 * Validations:
	 * - must be an email and required
	 */
	email: string;
	/**
	 * simple description specific to account should be less than 200 characters
	 * Validations:
	 * - can be empty
	 */
	bio: string;
	/**
	 * profile headline
	 * Validations:
	 * - can be empty
	 */
	headline: string;
	/**
	 * account phone number
	 * Validations:
	 * - mcan be empty
	 */
	phoneNumber: string;
	/**
	 * sample tags easily associable to account
	 * account first name
	 * Validations:
	 * - must be at provide between 1 and 10 tags
	 */
	tags: Tags[];
	/** authentication service account id */
	authnAccountId: number;
	/** infers wether the account is active */
	isActive: boolean;
	/**
	 * account first name
	 * Validations:
	 * - can be empty
	 */
	firstname: string;
	/**
	 * account last name
	 * Validations:
	 * - can be empty
	 */
	lastname: string;
	/**
	 * account user name
	 * Validations:
	 * - must be at least 10 character
	 */
	username: string;
	/** account is private */
	isPrivate: boolean;
	/**
	 * isEmailVerified is a field denoting wether or not the user account has
	 * indeed verified their email address
	 */
	isEmailVerified: boolean;
	createdAt: Date | undefined;
	verifiedAt: Date | undefined;
	constructor(data?: Partial<UserRegistrationAccountDetails>);
	toJSON(): {
		id: number;
		email: string;
		bio: string;
		headline: string;
		phoneNumber: string;
		tags: Tags[];
		authnAccountId: number;
		isActive: boolean;
		firstname: string;
		lastname: string;
		username: string;
		isPrivate: boolean;
		isEmailVerified: boolean;
		createdAt: string | undefined;
		verifiedAt: string | undefined;
		accountType: ProfileType;
	};
}
/**
 * @description The request to create a user account
 * @author Yoan Yomba
 * @export
 * @class CreateAccountRequest
 */
export declare class CreateAccountRequestClass implements IRequest {
	account: UserRegistrationAccountDetails;
	communityIdsToFollow: number[];
	profileImage: string;
	password: string;
	constructor(data?: Partial<CreateAccountRequestClass>);
	toJSON(): {
		account: {
			id: number;
			email: string;
			bio: string;
			headline: string;
			phoneNumber: string;
			tags: Tags[];
			authnAccountId: number;
			isActive: boolean;
			firstname: string;
			lastname: string;
			username: string;
			isPrivate: boolean;
			isEmailVerified: boolean;
			createdAt: string | undefined;
			verifiedAt: string | undefined;
			accountType: ProfileType;
		};
		communityIdsToFollow: number[];
		profileImage: string;
		password: string;
	};
	isValid(): boolean;
}
export declare class GetAccountBalanceHistoryResponseClass extends ErrorResponse {
	accountBalanceHistory: AccountBalanceHistory[];
	constructor(data: Partial<GetAccountBalanceHistoryResponseClass>);
}
/**
 * Represents the request for getting account balance history.
 */
export declare class GetAccountBalanceHistoryRequestClass {
	/**
	 * The account ID associated with the request.
	 */
	plaidAccountId: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetAccountBalanceHistoryRequest.
	 * @param partialRequest Partial request object to initialize the GetAccountBalanceHistoryRequest.
	 * @remarks You can use this constructor to create a partial instance of GetAccountBalanceHistoryRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetAccountBalanceHistoryRequestClass>);
}
/**
 * Represents the request for getting category monthly transaction count.
 */
export declare class GetCategoryMonthlyTransactionCountRequestClass {
	/**
	 * The user ID associated with the request (has to be present and defined).
	 */
	userId: number;
	/**
	 * The month for which category monthly transaction count is requested (optional).
	 */
	month: number;
	/**
	 * The primary personal finance category for filtering the records (optional).
	 */
	personalFinanceCategoryPrimary: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetCategoryMonthlyTransactionCountRequest.
	 * @param partialRequest Partial request object to initialize the GetCategoryMonthlyTransactionCountRequest.
	 * @remarks You can use this constructor to create a partial instance of GetCategoryMonthlyTransactionCountRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetCategoryMonthlyTransactionCountRequestClass>);
}
export declare class GetCategoryMonthlyTransactionCountResponseClass extends ErrorResponse {
	categoryMonthlyTransactionCount: CategoryMonthlyTransactionCount[];
	nextPageNumber: number;
	constructor(data?: Partial<GetCategoryMonthlyTransactionCountResponseClass>);
}
/**
 * Represents the request for getting debt to income ratio.
 */
export declare class GetDebtToIncomeRatioRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which debt to income ratio is requested (optional).
	 */
	month?: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetDebtToIncomeRatioRequest.
	 * @param partialRequest Partial request object to initialize the GetDebtToIncomeRatioRequest.
	 * @remarks You can use this constructor to create a partial instance of GetDebtToIncomeRatioRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetDebtToIncomeRatioRequestClass>);
}
/**
 * Represents the response for getting debt to income ratio.
 */
export declare class GetDebtToIncomeRatioResponseClass extends ErrorResponse {
	/**
	 * List of debt to income ratios.
	 */
	debtToIncomeRatios: DebtToIncomeRatio[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetDebtToIncomeRatioResponse.
	 * @param debtToIncomeRatios List of debt to income ratios.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetDebtToIncomeRatioResponseClass>);
}
/**
 * Represents the request for getting expense metrics.
 */
export declare class GetExpenseMetricsRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which expense metrics are requested (optional).
	 */
	month?: number;
	/**
	 * The primary personal finance category for filtering the records (optional).
	 */
	personalFinanceCategoryPrimary?: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetExpenseMetricsRequest.
	 * @param partialRequest Partial request object to initialize the GetExpenseMetricsRequest.
	 * @remarks You can use this constructor to create a partial instance of GetExpenseMetricsRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetExpenseMetricsRequestClass>);
}
/**
 * Represents the response for getting expense metrics.
 */
export declare class GetExpenseMetricsResponseClass extends ErrorResponse {
	/**
	 * List of expense metrics.
	 */
	expenseMetrics: ExpenseMetrics[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetExpenseMetricsResponse.
	 * @param expenseMetrics List of expense metrics.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetExpenseMetricsResponseClass>);
}
/**
 * Represents the response for getting melody financial context.
 */
export declare class GetMelodyFinancialContextResponseClass extends ErrorResponse {
	/**
	 * Melody financial context information.
	 */
	melodyFinancialContext: MelodyFinancialContext | undefined;
	/**
	 * Creates a new instance of GetMelodyFinancialContextResponse.
	 * @param melodyFinancialContext Melody financial context information.
	 */
	constructor(data?: Partial<GetMelodyFinancialContextResponseClass>);
}
/**
 * Represents the request for getting Melody financial context.
 */
export declare class GetMelodyFinancialContextRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * Creates a new instance of GetMelodyFinancialContextRequest.
	 * @param userId The user ID associated with the request.
	 */
	constructor(userId: number);
}
/**
 * Represents the request for getting financial profile.
 */
export declare class GetFinancialProfileRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which financial profile is requested (optional).
	 */
	month?: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetFinancialProfileRequest.
	 * @param partialRequest Partial request object to initialize the GetFinancialProfileRequest.
	 * @remarks You can use this constructor to create a partial instance of GetFinancialProfileRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetFinancialProfileRequestClass>);
}
/**
 * Represents the response for getting financial profile.
 */
export declare class GetFinancialProfileResponseClass extends ErrorResponse {
	/**
	 * List of financial profiles.
	 */
	financialProfiles: FinancialProfile[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetFinancialProfileResponse.
	 * @param financialProfiles List of financial profiles.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetFinancialProfileResponseClass>);
}
/**
 * Represents the request for getting income expense ratio.
 */
export declare class GetIncomeExpenseRatioRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which income expense ratio is requested (optional).
	 */
	month?: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetIncomeExpenseRatioRequest.
	 * @param partialRequest Partial request object to initialize the GetIncomeExpenseRatioRequest.
	 * @remarks You can use this constructor to create a partial instance of GetIncomeExpenseRatioRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetIncomeExpenseRatioRequestClass>);
}
/**
 * Represents the response for getting income expense ratio.
 */
export declare class GetIncomeExpenseRatioResponseClass extends ErrorResponse {
	/**
	 * List of income expense ratios.
	 */
	incomeExpenseRatios: IncomeExpenseRatio[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetIncomeExpenseRatioResponse.
	 * @param incomeExpenseRatios List of income expense ratios.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetIncomeExpenseRatioResponseClass>);
}
/**
 * Represents the request for getting income metrics.
 */
export declare class GetIncomeMetricsRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which income metrics are requested (optional).
	 */
	month?: number;
	/**
	 * The primary personal finance category for filtering the records (optional).
	 */
	personalFinanceCategoryPrimary?: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetIncomeMetricsRequest.
	 * @param partialRequest Partial request object to initialize the GetIncomeMetricsRequest.
	 * @remarks You can use this constructor to create a partial instance of GetIncomeMetricsRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetIncomeMetricsRequestClass>);
}
/**
 * Represents the response for getting income metrics.
 */
export declare class GetIncomeMetricsResponseClass extends ErrorResponse {
	/**
	 * List of income metrics.
	 */
	incomeMetrics: IncomeMetrics[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetIncomeMetricsResponse.
	 * @param incomeMetrics List of income metrics.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetIncomeMetricsResponseClass>);
}
/**
 * Represents the request for getting merchant monthly expenditure.
 */
export declare class GetMerchantMonthlyExpenditureRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which merchant monthly expenditure is requested (optional).
	 */
	month?: number;
	/**
	 * The merchant name for filtering the records (optional).
	 */
	merchantName?: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMerchantMonthlyExpenditureRequest.
	 * @param partialRequest Partial request object to initialize the GetMerchantMonthlyExpenditureRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMerchantMonthlyExpenditureRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMerchantMonthlyExpenditureRequestClass>);
}
/**
 * Represents the response for getting merchant monthly expenditure.
 */
export declare class GetMerchantMonthlyExpenditureResponseClass extends ErrorResponse {
	/**
	 * List of merchant monthly expenditures.
	 */
	merchantMonthlyExpenditures: MerchantMonthlyExpenditure[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMerchantMonthlyExpenditureResponse.
	 * @param merchantMonthlyExpenditures List of merchant monthly expenditures.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMerchantMonthlyExpenditureResponseClass>);
}
/**
 * Represents the request for getting monthly balance.
 */
export declare class GetMonthlyBalanceRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which monthly balance is requested (optional).
	 */
	month?: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMonthlyBalanceRequest.
	 * @param partialRequest Partial request object to initialize the GetMonthlyBalanceRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMonthlyBalanceRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMonthlyBalanceRequestClass>);
}
/**
 * Represents the response for getting monthly balance.
 */
export declare class GetMonthlyBalanceResponseClass extends ErrorResponse {
	/**
	 * List of monthly balances.
	 */
	monthlyBalances: MonthlyBalance[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMonthlyBalanceResponse.
	 * @param monthlyBalances List of monthly balances.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMonthlyBalanceResponseClass>);
}
/**
 * Represents the request for getting monthly expenditure.
 */
export declare class GetMonthlyExpenditureRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which monthly expenditure is requested.
	 */
	month: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMonthlyExpenditureRequest.
	 * @param partialRequest Partial request object to initialize the GetMonthlyExpenditureRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMonthlyExpenditureRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMonthlyExpenditureRequestClass>);
}
/**
 * Represents the response for getting monthly expenditure.
 */
export declare class GetMonthlyExpenditureResponseClass extends ErrorResponse {
	/**
	 * List of monthly expenditures.
	 */
	monthlyExpenditures: MonthlyExpenditure[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMonthlyExpenditureResponse.
	 * @param monthlyExpenditures List of monthly expenditures.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMonthlyExpenditureResponseClass>);
}
/**
 * Represents the request for getting monthly income.
 */
export declare class GetMonthlyIncomeRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which monthly income is requested.
	 */
	month: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMonthlyIncomeRequest.
	 * @param partialRequest Partial request object to initialize the GetMonthlyIncomeRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMonthlyIncomeRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMonthlyIncomeRequestClass>);
}
/**
 * Represents the response for getting monthly income.
 */
export declare class GetMonthlyIncomeResponseClass extends ErrorResponse {
	/**
	 * List of monthly incomes.
	 */
	monthlyIncomes: MonthlyIncome[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMonthlyIncomeResponse.
	 * @param monthlyIncomes List of monthly incomes.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMonthlyIncomeResponseClass>);
}
/**
 * Represents the request for getting monthly savings.
 */
export declare class GetMonthlySavingsRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which monthly savings is requested.
	 */
	month: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMonthlySavingsRequest.
	 * @param partialRequest Partial request object to initialize the GetMonthlySavingsRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMonthlySavingsRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMonthlySavingsRequestClass>);
}
/**
 * Represents the response for getting monthly savings.
 */
export declare class GetMonthlySavingsResponseClass extends ErrorResponse {
	/**
	 * List of monthly savings.
	 */
	monthlySavings: MonthlySavings[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMonthlySavingsResponse.
	 * @param monthlySavings List of monthly savings.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMonthlySavingsResponseClass>);
}
/**
 * Represents the request for getting monthly total quantity by security and user.
 */
export declare class GetMonthlyTotalQuantityBySecurityAndUserRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which monthly total quantity is requested.
	 */
	month: number;
	/**
	 * The security ID for filtering the records.
	 */
	securityId: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMonthlyTotalQuantityBySecurityAndUserRequest.
	 * @param partialRequest Partial request object to initialize the GetMonthlyTotalQuantityBySecurityAndUserRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMonthlyTotalQuantityBySecurityAndUserRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMonthlyTotalQuantityBySecurityAndUserRequestClass>);
}
/**
 * Represents the response for getting monthly total quantity by security and user.
 */
export declare class GetMonthlyTotalQuantityBySecurityAndUserResponseClass extends ErrorResponse {
	/**
	 * List of monthly total quantity by security and user.
	 */
	monthlyTotalQuantityBySecurityAndUser: MonthlyTotalQuantityBySecurityAndUser[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMonthlyTotalQuantityBySecurityAndUserResponse.
	 * @param monthlyTotalQuantityBySecurityAndUser List of monthly total quantity by security and user.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMonthlyTotalQuantityBySecurityAndUserResponseClass>);
}
/**
 * Represents the request for getting monthly transaction count.
 */
export declare class GetMonthlyTransactionCountRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which monthly transaction count is requested.
	 */
	month: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetMonthlyTransactionCountRequest.
	 * @param partialRequest Partial request object to initialize the GetMonthlyTransactionCountRequest.
	 * @remarks You can use this constructor to create a partial instance of GetMonthlyTransactionCountRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetMonthlyTransactionCountRequestClass>);
}
/**
 * Represents the response for getting monthly transaction count.
 */
export declare class GetMonthlyTransactionCountResponseClass extends ErrorResponse {
	/**
	 * List of monthly transaction counts.
	 */
	monthlyTransactionCounts: MonthlyTransactionCount[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetMonthlyTransactionCountResponse.
	 * @param monthlyTransactionCounts List of monthly transaction counts.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetMonthlyTransactionCountResponseClass>);
}
/**
 * Represents the request for getting payment channel monthly expenditure.
 */
export declare class GetPaymentChannelMonthlyExpenditureRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which payment channel monthly expenditure is requested.
	 */
	month: number;
	/**
	 * The payment channel for filtering the records.
	 */
	paymentChannel: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetPaymentChannelMonthlyExpenditureRequest.
	 * @param partialRequest Partial request object to initialize the GetPaymentChannelMonthlyExpenditureRequest.
	 * @remarks You can use this constructor to create a partial instance of GetPaymentChannelMonthlyExpenditureRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetPaymentChannelMonthlyExpenditureRequestClass>);
}
/**
 * Represents the response for getting payment channel monthly expenditure.
 */
export declare class GetPaymentChannelMonthlyExpenditureResponseClass extends ErrorResponse {
	/**
	 * List of payment channel monthly expenditures.
	 */
	paymentChannelMonthlyExpenditure: PaymentChannelMonthlyExpenditure[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetPaymentChannelMonthlyExpenditureResponse.
	 * @param paymentChannelMonthlyExpenditure List of payment channel monthly expenditures.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetPaymentChannelMonthlyExpenditureResponseClass>);
}
export declare class GetReCurringTransactionsRequestClass {
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 */
	userId: number;
	constructor(data?: Partial<GetReCurringTransactionsRequestClass>);
}
export declare class GetReCurringTransactionsResponseClass extends ErrorResponse {
	reCcuringTransactions: ReOccuringTransaction[];
	constructor(data: Partial<GetReCurringTransactionsResponseClass>);
}
/**
 * Represents the request for getting total investment by security.
 */
export declare class GetTotalInvestmentBySecurityRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The security ID for filtering the records.
	 */
	securityId: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetTotalInvestmentBySecurityRequest.
	 * @param partialRequest Partial request object to initialize the GetTotalInvestmentBySecurityRequest.
	 * @remarks You can use this constructor to create a partial instance of GetTotalInvestmentBySecurityRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetTotalInvestmentBySecurityRequestClass>);
}
/**
 * Represents the response for getting total investment by security.
 */
export declare class GetTotalInvestmentBySecurityResponseClass extends ErrorResponse {
	/**
	 * List of total investment by security.
	 */
	totalInvestmentBySecurity: TotalInvestmentBySecurity[];
	/**
	 * The page number of the next set of data.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetTotalInvestmentBySecurityResponse.
	 * @param totalInvestmentBySecurity List of total investment by security.
	 * @param nextPageNumber The page number of the next set of data.
	 */
	constructor(data?: Partial<GetTotalInvestmentBySecurityResponseClass>);
}
export declare class GetTransactionAggregatesResponseClass extends ErrorResponse {
	transactionAggregates: TransactionAggregatesByMonth[];
	nextPageNumber: number;
	constructor(data?: Partial<GetTransactionAggregatesResponseClass>);
}
export declare class GetTransactionAggregatesRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The month for which transaction aggregates are requested (in the format YYYYMM).
	 */
	month: number;
	/**
	 * The primary personal finance category for filtering the transactions.
	 */
	personalFinanceCategoryPrimary: string;
	/**
	 * The city location for filtering the transactions.
	 */
	locationCity: string;
	/**
	 * The payment channel for filtering the transactions.
	 */
	paymentChannel: string;
	/**
	 * The merchant name for filtering the transactions.
	 */
	merchantName: string;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetTransactionAggregatesRequest.
	 * @param partialRequest Partial request object to initialize the GetTransactionAggregatesRequest.
	 * @remarks You can use this constructor to create a partial instance of GetTransactionAggregatesRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetTransactionAggregatesRequestClass>);
}
/**
 * Represents the response for getting transactions for a bank account.
 */
export declare class GetTransactionsForBankAccountResponseClass extends ErrorResponse {
	/**
	 * An array of transactions for the bank account.
	 */
	transactions: Transaction[];
	/**
	 * The page number of the next set of transactions.
	 */
	nextPageNumber: number;
	/**
	 * Creates a new instance of GetTransactionsForBankAccountResponse.
	 * @param transactions An array of transactions for the bank account.
	 * @param nextPageNumber The page number of the next set of transactions.
	 */
	constructor(data: GetTransactionsForBankAccountResponseClass);
}
/**
 * Class representing a request to get transactions for a bank account.
 */
export declare class GetTransactionsForBankAccountRequestClass {
	/** The user id */
	userId: number;
	/** Plaid account id */
	plaidAccountId: string;
	/** Page number for paginated results */
	pageNumber: number;
	/** Page size for paginated results */
	pageSize: number;
	/**
	 * Create a request to get transactions for a bank account.
	 * @param {Partial<GetTransactionsForBankAccountRequest>} data - Object containing any properties of a request.
	 */
	constructor(data: Partial<GetTransactionsForBankAccountRequestClass>);
}
/**
 * GetTransactionsRequest class
 *
 * Represents a request for getting transactions.
 */
export declare class GetTransactionsRequestClass {
	/**
	 * The user ID.
	 * Validations:
	 * - Must be greater than 0.
	 */
	userId: number;
	/**
	 * The page number.
	 */
	pageNumber: number;
	/**
	 * The number of transactions per page.
	 */
	pageSize: number;
	/**
	 * Creates an instance of GetTransactionsRequest.
	 *
	 * @param data - The data to initialize the request.
	 */
	constructor(data: Partial<GetTransactionsRequestClass>);
}
export declare class GetTransactionsResponseClass extends ErrorResponse {
	nextPageNumber: number | undefined;
	transactions: Transaction[] | undefined;
	constructor(data: Partial<GetTransactionsResponseClass>);
}
export declare class GetUpdatedUserAccountResponseClass extends ErrorResponse {
	account: UserAccount | undefined;
	constructor(data: Partial<GetUpdatedUserAccountResponseClass>);
}
/**
 * Represents the response for getting user account balance history.
 */
export declare class GetUserAccountBalanceHistoryResponseClass extends ErrorResponse {
	/**
	 * List of account balance history records.
	 */
	accountBalanceHistory: AccountBalanceHistory[];
	constructor(data: Partial<GetUserAccountBalanceHistoryResponseClass>);
}
/**
 * Represents the request for getting user account balance history.
 */
export declare class GetUserAccountBalanceHistoryRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetUserAccountBalanceHistoryRequest.
	 * @param partialRequest Partial request object to initialize the GetUserAccountBalanceHistoryRequest.
	 * @remarks You can use this constructor to create a partial instance of GetUserAccountBalanceHistoryRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetUserAccountBalanceHistoryRequestClass>);
}
/**
 * Represents the request for getting user category monthly expenditure.
 */
export declare class GetUserCategoryMonthlyExpenditureRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The primary personal finance category for filtering the records.
	 */
	personalFinanceCategoryPrimary: string;
	/**
	 * The month for which category monthly expenditure is requested (in the format YYYYMM).
	 */
	month: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetUserCategoryMonthlyExpenditureRequest.
	 * @param partialRequest Partial request object to initialize the GetUserCategoryMonthlyExpenditureRequest.
	 * @remarks You can use this constructor to create a partial instance of GetUserCategoryMonthlyExpenditureRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetUserCategoryMonthlyExpenditureRequestClass>);
}
export declare class GetUserCategoryMonthlyExpenditureResponseClass extends ErrorResponse {
	categoryMonthlyExpenditure: CategoryMonthlyExpenditure[];
	nextPageNumber: number;
	constructor(data?: Partial<GetUserCategoryMonthlyExpenditureResponseClass>);
}
/**
 * Represents the request for getting user category monthly income.
 */
export declare class GetUserCategoryMonthlyIncomeRequestClass {
	/**
	 * The user ID associated with the request.
	 */
	userId: number;
	/**
	 * The primary personal finance category for filtering the records.
	 */
	personalFinanceCategoryPrimary: string;
	/**
	 * The month for which category monthly income is requested (in the format YYYYMM).
	 */
	month: number;
	/**
	 * The page number of the requested data.
	 */
	pageNumber: number;
	/**
	 * Number of items to return per page.
	 */
	pageSize: number;
	/**
	 * Creates a new instance of GetUserCategoryMonthlyIncomeRequest.
	 * @param partialRequest Partial request object to initialize the GetUserCategoryMonthlyIncomeRequest.
	 * @remarks You can use this constructor to create a partial instance of GetUserCategoryMonthlyIncomeRequest.
	 *          You can later populate the additional properties manually if needed.
	 */
	constructor(partialRequest: Partial<GetUserCategoryMonthlyIncomeRequestClass>);
}
export declare class GetUserCategoryMonthlyIncomeResponseClass extends ErrorResponse {
	categoryMonthlyIncome: CategoryMonthlyIncome[];
	nextPageNumber: number;
	constructor(data?: Partial<GetUserCategoryMonthlyIncomeResponseClass>);
}
export interface RequestPasswordResetRequestClass {
	email: string;
}
export declare class RequestPasswordResetResponseClass extends ErrorResponse {
	success: boolean;
	constructor(data: Partial<RequestPasswordResetResponseClass>);
}
export declare class PlaidExchangeTokenRequestClass implements PlaidExchangeTokenRequest {
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 */
	userId: string;
	/**
	 * The public token
	 * Validations:
	 * - cannot be nil hence required
	 */
	publicToken: string;
	/** The institution id */
	institutionId: string;
	/** The institution name */
	institutionName: string;
	/** The profile type of the financial user */
	profileType: FinancialUserProfileType;
	constructor(data?: Partial<PlaidExchangeTokenRequestClass>);
}
export declare class PlaidExchangeTokenResponseClass extends ErrorResponse implements PlaidExchangeTokenResponse {
	/** wether the operation was successful */
	success: boolean;
	taskId: string;
	constructor(data?: Partial<PlaidExchangeTokenResponseClass>);
}
export declare class PlaidInitiateTokenExchangeRequestClass implements PlaidInitiateTokenExchangeRequest {
	/**
	 * A unique ID representing the end user. Typically this will be a user ID number from your application.
	 * Personally identifiable information, such as an email address or phone number,
	 * should not be used in the `client_user_id`. It is currently used as a means of searching logs
	 * for the given user in the Plaid Dashboard.
	 * Validations:
	 * - user_id must be greater than 0
	 */
	userId: string;
	/**
	 * The user's full legal name. This is an optional field used in
	 * the [returning user experience](https://plaid.com/docs/link/returning-user) to associate Items to the user.
	 */
	fullName: string;
	/**
	 * The user's email address. This field is optional, but required to enable the
	 * [pre-authenticated returning user flow](https://plaid.com/docs/link/returning-user/#enabling-the-returning-user-experience).
	 */
	email: string;
	/**
	 * The user's phone number in [E.164](https://en.wikipedia.org/wiki/E.164) format.
	 * This field is optional, but required to enable the [returning user experience](https://plaid.com/docs/link/returning-user).
	 */
	phoneNumber: string;
	/**
	 * The financial profile type of the financial user
	 */
	profileType: FinancialUserProfileType;
	constructor(data: Partial<PlaidInitiateTokenExchangeRequestClass>);
}
export declare class PlaidInitiateTokenExchangeResponseClass implements PlaidInitiateTokenExchangeResponse {
	linkToken: string;
	expiration: string;
	plaidRequestId: string;
	constructor(data: Partial<PlaidInitiateTokenExchangeResponseClass>);
}
export declare class PlaidLinkRequestClass implements PlaidInitiateTokenExchangeRequest {
	/**
	 * A unique ID representing the end user. Typically this will be a user ID number from your application.
	 * Personally identifiable information, such as an email address or phone number,
	 * should not be used in the `client_user_id`. It is currently used as a means of searching logs
	 * for the given user in the Plaid Dashboard.
	 * Validations:
	 * - user_id must be greater than 0
	 */
	userId: string;
	/**
	 * The user's full legal name. This is an optional field used in
	 * the [returning user experience](https://plaid.com/docs/link/returning-user) to associate Items to the user.
	 */
	fullName: string;
	/**
	 * The user's email address. This field is optional, but required to enable the
	 * [pre-authenticated returning user flow](https://plaid.com/docs/link/returning-user/#enabling-the-returning-user-experience).
	 */
	email: string;
	/**
	 * The user's phone number in [E.164](https://en.wikipedia.org/wiki/E.164) format.
	 * This field is optional, but required to enable the [returning user experience](https://plaid.com/docs/link/returning-user).
	 */
	phoneNumber: string;
	profileType: FinancialUserProfileType;
	constructor(data?: Partial<PlaidLinkRequestClass>);
}
export declare class PlaidLinkResponseClass extends ErrorResponse implements PlaidInitiateTokenExchangeResponse {
	linkToken: string;
	expiration: string;
	plaidRequestId: string;
	constructor(data?: Partial<PlaidLinkResponseClass>);
}
export declare class PlaidInitiateTokenUpdateRequestClass implements PlaidInitiateTokenUpdateRequest {
	/**
	 * The link id we want to update for
	 * Validations:
	 * - cannot be nil hence required
	 * @format uint64
	 */
	linkId: string;
	profileType: FinancialUserProfileType;
	/**
	 * The user id
	 * Validations:
	 * - user_id must be greater than 0
	 * @format uint64
	 */
	userId: string;
	constructor(data?: Partial<PlaidInitiateTokenUpdateRequestClass>);
}
export declare class PlaidInitiateTokenUpdateResponseClass extends ErrorResponse implements PlaidInitiateTokenUpdateResponse {
	linkToken: string;
	expiration: string;
	constructor(data: Partial<PlaidInitiateTokenUpdateResponseClass>);
}
/**
 * Represents a request to reset a password.
 */
export interface ResetPasswordRequestClass {
	/**
	 * The new password that the user wants to set.
	 */
	password: string;
	/**
	 * A token that verifies the legitimacy of the reset password request.
	 */
	token: string;
}
/**
 * Represents a response containing a token.
 */
export declare class ResetPasswordResponseClass {
	/**
	 * The token returned by the server, typically used for authentication purposes.
	 */
	token: string;
	/**
	 * A code indicating the status or result of the operation.
	 */
	code: number;
	/**
	 * An error message, if any occurred during the operation.
	 */
	err: string;
	/**
	 * Creates a new instance of `TokenResponse`.
	 *
	 * @param data - An object containing any subset of the `TokenResponse` properties.
	 */
	constructor(data: Partial<ResetPasswordResponseClass>);
}
/**
 * UpdateUserRequest: Represents the request object invoked against the user
 * service to update a given user account
 */
export declare class UpdateUserAccountRequestClass implements IRequest {
	/**
	 * UserAccount to update
	 * Validation:
	 * - cannot nil hence required
	 */
	account: UserAccount | undefined;
	constructor(data?: Partial<UpdateUserAccountRequestClass>);
	isValid(): boolean;
}
export declare class UpdateUserAccountResponseClass extends ErrorResponse {
	accountUpdated: boolean;
	account: UserAccount | undefined;
	constructor(data?: Partial<UpdateUserAccountResponseClass>);
}
/**
 * Represents a request to create a user account or a business account.
 * @implements {IRequest} {CreateUserV2Request}
 * @class {CreateAccountV2RequestClass}
 * @extends {CreateUserV2Request}
 * @param {Partial<CreateUserV2Request>} request
 * @property {BusinessAccount} businessAccount
 * @property {Array<string>} communityIdsToFollow
 * @property {string} password
 * @property {string} profileImage
 * @property {UserAccount} userAccount
 * @method {isValid} {boolean}
 * @method {randomInstance} {CreateUserV2Request}
 * @returns {CreateAccountV2RequestClass}
 * @example
 * import { CreateAccountV2RequestClass } from 'src/types/request-response/create-account-v2';
 * const request = new CreateAccountV2RequestClass({
 *  businessAccount: BusinessAccountClass.randomInstance(),
 * communityIdsToFollow: [
 * getRandomString(10),
 * getRandomString(10),
 * getRandomString(10),
 * getRandomString(10),
 * getRandomString(10),
 * ],
 * password: getRandomString(10),
 * profileImage: getRandomString(10),
 * userAccount: UserAccountClass.randomInstance(),
 * });
 * console.log(request.isValid()); // Outputs: true
 * console.log(request.randomInstance()); // Outputs: CreateAccountV2RequestClass
 */
export declare class CreateAccountV2RequestClass implements IRequest, CreateUserV2Request {
	businessAccount?: BusinessAccount;
	communityIdsToFollow?: Array<string>;
	password: string;
	userAccount?: UserAccount;
	auth0UserId: string;
	profileImageUrl: string;
	constructor(request: Partial<CreateUserV2Request>);
	isValid(): boolean;
	static randomInstance(): CreateUserV2Request;
}
export declare class CreateUserV2ResponseClass extends ErrorResponse implements CreateUserV2Response {
	/** @format uint64 */
	userId?: string;
	constructor(data?: Partial<CreateUserV2Response>);
	static randomInstance(): CreateUserV2Response;
}
export declare class GetCannyUserSSOTokenRequestClass implements IRequest {
	/** The email of the user of interest */
	userId: number;
	profileType: ProfileType;
	constructor(data?: Partial<GetCannyUserSSOTokenRequestClass>);
	isValid(): boolean;
}
export declare class GetCannyUserSSOTokenResponseClass extends ErrorResponse implements GetCannyUserSSOTokenResponse {
	token: string;
	constructor(data?: Partial<GetCannyUserSSOTokenResponse>);
}
/**
 * Represents a request to ask a question to GitHub Copilot.
 */
export declare class RecordAskCopilotQuestionRequestClass implements IRequest {
	/**
	 * The user ID associated with the request.
	 */
	userId: string;
	/**
	 * The profile type associated with the request.
	 */
	profileType: FinancialUserProfileType;
	/**
	 * Creates an instance of AskCopilotQuestionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<RecordAskCopilotQuestionRequestClass>);
	/**
	 * Checks if the request is valid.
	 * @returns True if the user ID is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class RecordAskCopilotQuestionResponseClass extends ErrorResponse implements RecordAskCopilotQuestionResponse {
	code: number;
	err: string;
	token: string;
	success: boolean;
	remainingQuota: number;
	/**
	 * Creates an instance of AskCopilotQuestionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<RecordAskCopilotQuestionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the response is valid, otherwise false.
	 */
	isValid(): boolean;
	/**
	 * Gets the question quota.
	 * @returns The question quota.
	 */
	getRemainingQuota(): number;
}
export declare class TriggerSyncRequestClass implements TriggerSyncRequest, IRequest {
	/**
	 * the account id associated with the user
	 * @format uint64
	 */
	userId: string;
	/**
	 * the account id associated with the user
	 * @format uint64
	 */
	linkId: string;
	/**
	 * tha financial account type
	 * @example "username:testuser"
	 */
	financialAccountType: FinancialAccountType;
	/** @example "username:testuser" */
	profileType: FinancialUserProfileType;
	constructor(data?: Partial<TriggerSyncRequestClass>);
	isValid(): boolean;
}
export declare class TriggerSyncResponseClass extends ErrorResponse implements TriggerSyncResponse {
	code: number;
	err: string;
	token: string;
	taskId: string;
	constructor(data?: Partial<TriggerSyncResponseClass>);
	isValid(): boolean;
	getTaskId(): string;
}
export declare class PollAsyncTaskExecutionRequestClass implements IRequest {
	/**
	 * The user ID associated with the request.
	 */
	taskId: string;
	/**
	 * Creates an instance of PollAsyncTaskExecutionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<PollAsyncTaskExecutionRequestClass>);
	/**
	 * Checks if the request is valid.
	 * @returns True if the user ID is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class PollAsyncTaskExecutionResponseClass extends ErrorResponse implements PollAsyncTaskExecutionStatusResponse {
	code: number;
	err: string;
	token: string;
	status: TaskState;
	/** The task id */
	taskId: string;
	/**
	 * Creates an instance of PollAsyncTaskExecutionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<PollAsyncTaskExecutionStatusResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the task id is not empty, otherwise false.
	 */
	isValid(): boolean;
}
/**
 * Represents a request to ask a question to GitHub Copilot.
 */
export declare class CheckIfQuestionQuotaExceededRequestClass implements IRequest {
	/**
	 * The user ID associated with the request.
	 */
	userId: string;
	/**
	 * The profile type associated with the request.
	 */
	profileType: FinancialUserProfileType;
	/**
	 * Creates an instance of AskCopilotQuestionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<CheckIfQuestionQuotaExceededRequestClass>);
	/**
	 * Checks if the request is valid.
	 * @returns True if the user ID is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class CheckIfQuestionQuotaExceededResponseClass extends ErrorResponse implements CheckIfQuotaExceededResponse {
	code: number;
	err: string;
	token: string;
	exceeded: boolean;
	/**
	 * Creates an instance of AskCopilotQuestionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<CheckIfQuotaExceededResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the response is valid, otherwise false.
	 */
	isValid(): boolean;
	/**
	 * Checks if the quota has been exceeded.
	 *
	 * @returns True if the quota has been exceeded, otherwise false.
	 */
	hasExceeded(): boolean;
}
export declare class SplitTransactionRequestClass implements IRequest, SplitTransactionRequest {
	/**
	 * The user ID associated with the request.
	 */
	transactionId: string;
	splitTransactions: Array<TransactionSplit>;
	/**
	 * Creates an instance of AskCopilotQuestionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<SplitTransactionRequestClass>);
	/**
	 * Checks if the request is valid.
	 * @returns True if the user ID is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class SplitTransactionResponseClass extends ErrorResponse implements SplitTransactionResponse {
	code: number;
	err: string;
	token: string;
	transaction: PlaidAccountTransaction;
	/**
	 * Creates an instance of SplitTransactionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<SplitTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the response is valid, otherwise false.
	 */
	isValid(): boolean;
	getNumberOfTransactionSplit(): number;
}
export declare class UnSplitTransactionRequestClass implements IRequest, UnSplitTransactionsRequest {
	/**
	 * The user ID associated with the request.
	 */
	transactionId: string;
	/**
	 * Creates an instance of AskCopilotQuestionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<UnSplitTransactionRequestClass>);
	/**
	 * Checks if the request is valid.
	 * @returns True if the user ID is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class UnsplitTransactionResponseClass extends ErrorResponse implements UnSplitTransactionsResponse {
	code: number;
	err: string;
	token: string;
	transaction: PlaidAccountTransaction;
	/**
	 * Creates an instance of AskCopilotQuestionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<UnSplitTransactionsResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the token is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class UpdateTransactionRequestClass implements IRequest, UpdateTransactionRequest {
	transaction: PlaidAccountTransaction;
	/**
	 * Creates an instance of AskCopilotQuestionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<UpdateTransactionRequest>);
	isValid(): boolean;
}
export declare class UpdateTransactionResponseClass extends ErrorResponse implements UpdateTransactionResponse {
	code: number;
	err: string;
	token: string;
	transaction: PlaidAccountTransaction;
	/**
	 * Constructor for UpdateTransactionResponseClass
	 * @param data - Optional data to initialize the response.
	 * @param options - Optional options
	 *
	 */
	constructor(data?: Partial<UpdateTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the token is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class BulkUpdateTransactionRequestClass implements IRequest, BulkUpdateTransactionRequest {
	transactions: Array<PlaidAccountTransaction>;
	/**
	 * Creates an instance of AskCopilotQuestionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<BulkUpdateTransactionRequestClass>);
	/**
	 * Checks if the request is valid.
	 * @returns True if the user ID is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class BulkUpdateTransactionResponseClass extends ErrorResponse implements BulkUpdateTransactionResponse {
	code: number;
	err: string;
	token: string;
	transactions: Array<PlaidAccountTransaction>;
	/**
	 * Creates an instance of AskCopilotQuestionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<BulkUpdateTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the token is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class DeleteTransactionRequestClass implements IRequest {
	transactionId: string;
	constructor(data?: Partial<DeleteTransactionRequestClass>);
	isValid(): boolean;
}
export declare class DeleteTransactionResponseClass extends ErrorResponse implements DeleteTransactionResponse {
	code: number;
	err: string;
	token: string;
	deleted: boolean;
	constructor(data?: Partial<DeleteTransactionResponseClass>);
	isValid(): boolean;
}
export declare class AddNoteToTransactionRequestClass implements IRequest, AddNoteToTransactionRequest {
	/**
	 * The note to add
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
	/**
	 * The transaction id
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
	/**
	 * Creates an instance of AddNoteToTransactionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<AddNoteToTransactionRequestClass>);
	isValid(): boolean;
}
export declare class AddNoteToTransactionResponseClass extends ErrorResponse implements AddNoteToTransactionResponse {
	code: number;
	err: string;
	token: string;
	transaction: PlaidAccountTransaction;
	/**
	 * Creates an instance of AddNoteToTransactionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<AddNoteToTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the token is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class UpdateNoteToTransactionRequestClass implements IRequest, UpdateNoteToTransactionRequest {
	/**
	 * The updated note
	 * Validations:
	 * - cannot be nil hence required
	 */
	note: SmartNote;
	/**
	 * Creates an instance of UpdateNoteToTransactionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<UpdateNoteToTransactionRequestClass>);
	isValid(): boolean;
}
export declare class UpdateNoteToTransactionResponseClass extends ErrorResponse implements UpdateNoteToTransactionResponse {
	code: number;
	err: string;
	token: string;
	transaction: PlaidAccountTransaction;
	/**
	 * Creates an instance of UpdateNoteToTransactionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<UpdateNoteToTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the token is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class DeleteNoteFromTransactionRequestClass implements IRequest {
	/**
	 * The transaction id to delete the note from
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
	/**
	 * The note id to delete
	 * Validations:
	 * - note_id must be greater than 0
	 * @format uint64
	 */
	noteId: string;
	/**
	 * Creates an instance of DeleteNoteFromTransactionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<DeleteNoteFromTransactionRequestClass>);
	isValid(): boolean;
}
export declare class DeleteNoteFromTransactionResponseClass extends ErrorResponse implements DeleteNoteFromTransactionResponse {
	code: number;
	err: string;
	token: string;
	deleted: boolean;
	/**
	 * Creates an instance of DeleteNoteFromTransactionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<DeleteNoteFromTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the token is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class ListTransactionNotesRequestClass implements IRequest {
	/**
	 * The transaction id to list notes for
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
	/**
	 * Creates an instance of ListTransactionNotesRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<ListTransactionNotesRequestClass>);
	isValid(): boolean;
}
export declare class ListTransactionNotesResponseClass extends ErrorResponse implements ListTransactionNotesResponse {
	code: number;
	err: string;
	token: string;
	notes: Array<SmartNote>;
	/**
	 * Creates an instance of ListTransactionNotesResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<ListTransactionNotesResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if there are notes in the response, otherwise false.
	 */
	isValid(): boolean;
}
export declare class GetNoteFromTransactionRequestClass implements IRequest {
	/**
	 * The transaction id to get the note from
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
	/**
	 * The note id to retrieve
	 * Validations:
	 * - note_id must be greater than 0
	 * @format uint64
	 */
	noteId: string;
	/**
	 * Creates an instance of GetNoteFromTransactionRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<GetNoteFromTransactionRequestClass>);
	isValid(): boolean;
}
export declare class GetNoteFromTransactionResponseClass extends ErrorResponse implements GetNoteFromTransactionResponse {
	code: number;
	err: string;
	token: string;
	note: SmartNote;
	/**
	 * Creates an instance of GetNoteFromTransactionResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<GetNoteFromTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if the note is not empty, otherwise false.
	 */
	isValid(): boolean;
}
export declare class GetSplitTransactionsRequestClass implements IRequest {
	/**
	 * The transaction id for which to get split transactions
	 * Validations:
	 * - transaction_id must be greater than 0
	 * @format uint64
	 */
	transactionId: string;
	/**
	 * Creates an instance of GetSplitTransactionsRequestClass.
	 * @param data - Optional data to initialize the request.
	 */
	constructor(data?: Partial<GetSplitTransactionsRequestClass>);
	isValid(): boolean;
}
export declare class GetSplitTransactionsResponseClass extends ErrorResponse implements GetSplitTransactionResponse {
	code: number;
	err: string;
	token: string;
	splitTransactions: Array<TransactionSplit>;
	/**
	 * Creates an instance of GetSplitTransactionsResponseClass.
	 * @param data - Optional data to initialize the response.
	 */
	constructor(data?: Partial<GetSplitTransactionResponse>);
	/**
	 * Checks if the response is valid.
	 * @returns True if there are split transactions in the response, otherwise false.
	 */
	isValid(): boolean;
}
/**
 * Represents individual data points for the chart.
 */
export interface ChartData {
	/** The name for this data point (typically represents a unit on the X-axis, like month or day). */
	name: string;
	/** Value for the 'uv' metric. */
	uv: number;
	/** Optional value for the 'pv' metric. */
	pv?: number;
}
/**
 * Props for the CustomAreaChart component.
 */
export interface CustomAreaChartProps {
	/** Array of data points to plot on the chart. */
	data: ChartData[];
	/** Optional CSS class to be applied to the chart's outermost container. */
	className?: string;
	label: string;
	enableGrid?: boolean;
}
/** @type {React.Context<T extends BankAccount>} */
export declare const BankAccountContext: React.Context<BankAccount | undefined>;
export declare const FinancialProfileContext: React.Context<FinancialProfile>;
export declare const AccountBalanceHistoryContext: React.Context<AccountBalanceHistory[]>;
export type BankAccountCardProps<T extends BankAccount> = {
	bankAccount: T;
	financialProfile: FinancialProfile;
	className?: string;
	contextQuestions?: string[];
	enableDemoMode?: boolean;
	children?: ReactNode;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type BankAccountCardState<T extends BankAccount> = {
	bankAccount: T;
};
/**
 * @class BankAccountCard
 * @extends {Component<BankAccountCardProps, BankAccountCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class BankAccountCard<T extends BankAccount> extends Component<BankAccountCardProps<T>, BankAccountCardState<T>> {
	private myRef;
	static defaultProps: {
		bankAccount: BankAccountClass;
		financialProfile: FinancialProfileClass;
		contextQuestions: string[];
		enableDemoMode: boolean;
		children: null;
	};
	constructor(props: BankAccountCardProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type BankAccountHoverLabelProps<T extends BankAccount> = {
	bankAccount: T;
	className?: string;
	enableDemoMode?: boolean;
	children?: ReactNode;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type BankAccountHoverLabelState<T extends BankAccount> = {
	bankAccount: T;
};
/**
 * The `BankAccountHoverLabel` is a specialized React class component
 * designed to provide detailed hover information about a bank account.
 * It is built with TypeScript and extends the React `Component` class,
 * with types specified for both props and state.
 *
 * @template T - Specifies the type of bank account this component works with,
 * extending a base BankAccount.
 *
 * @example
 * ```tsx
 * import { BankAccountHoverLabel } from './BankAccountHoverLabel';
 *
 * <BankAccountHoverLabel
 *    bankAccount={new BankAccount({
 *      name: 'Savings Account',
 *      currentFunds: 5000,
 *      goals: [{name: 'Vacation', amount: 1000}]
 *    })}
 *    enableDemoMode={false}
 * />
 * ```
 *
 * @class
 * @extends {Component<BankAccountHoverLabelProps<T>, BankAccountHoverLabelState<T>>}
 */
export declare class BankAccountHoverLabel<T extends BankAccount> extends Component<BankAccountHoverLabelProps<T>, BankAccountHoverLabelState<T>> {
	/**
	 * A reference to the DOM element of the component.
	 * Useful for direct DOM manipulations.
	 */
	private myRef;
	/**
	 * Default properties for the BankAccountHoverLabel component.
	 */
	static defaultProps: {
		contextQuestions: string[];
		enableDemoMode: boolean;
		children: null;
	};
	/**
	 * Constructs a new `BankAccountHoverLabel` component.
	 *
	 * @param props - The properties passed to the component.
	 */
	constructor(props: BankAccountHoverLabelProps<T>);
	/**
	 * Lifecycle method that triggers immediately after the component is added to the DOM.
	 * This method focuses the current component if it has a valid reference.
	 */
	componentDidMount(): void;
	/**
	 * Renders the `BankAccountHoverLabel` component.
	 *
	 * @returns {ReactNode} The React Node representing the component's UI.
	 */
	render(): ReactNode;
}
export interface BarGraphProps {
	data: {
		name: string;
		total: number;
	}[];
	label: string;
	className?: string;
}
export declare const BarGraph: React.FC<BarGraphProps>;
export type CommandPalleteQuickAction = {
	name: string;
	shortcut: string;
	icon: React.ForwardRefExoticComponent<Omit<React.SVGProps<SVGSVGElement>, "ref"> & {
		title?: string | undefined;
		titleId?: string | undefined;
	} & React.RefAttributes<SVGSVGElement>>;
	callback: () => void;
};
export declare const CommandPalleteWithIcons: React.FC<{
	transactions: Transaction[];
	quickActions: CommandPalleteQuickAction[];
}>;
export declare const CommandPalletterWithPreview: React.FC<{
	transactions: Transaction[];
}>;
export type AccountMetadata = {
	name: string;
	accountPlaidId: string;
};
export declare const CommandPalleteWithFooter: React.FC<{
	transactions: Transaction[];
	accounts: AccountMetadata[];
}>;
export declare const SimpleTransactionCommandPallete: React.FC<{
	transactions: Transaction[];
}>;
/**
 * Props definition for the `Container` component.
 */
export interface ContainerProps extends React.ComponentPropsWithoutRef<"div"> {
	/**
	 * Sets the max width of the container. This prop allows for more flexible widths.
	 * Defaults to `max-w-7xl`.
	 *
	 * @example
	 * maxWidth="max-w-5xl"
	 */
	maxWidth?: string;
}
/**
 * A responsive container component that centers its content and provides consistent padding.
 *
 * The `Container` component is a versatile wrapper that controls the maximum width of its content across different screen sizes. By default, it sets the maximum width to `7xl` and provides responsive horizontal padding.
 *
 * Usage:
 *
 * ```tsx
 * <Container>
 *   Your content here...
 * </Container>
 * ```
 *
 * @param props The properties of the `Container` component.
 * @returns A React element with content wrapped inside the container.
 */
export declare function Container({ className, maxWidth, ...props }: ContainerProps): import("react/jsx-runtime").JSX.Element;
export type CreditAccountHoverLabelProps<T extends CreditAccount> = {
	creditAccount: T;
	institutionName: string;
	className?: string;
	enableDemoMode?: boolean;
	children?: ReactNode;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type CreditAccountHoverLabelState<T extends CreditAccount> = {
	creditAccount: T;
};
/**
 * The `CreditAccountHoverLabel` is a specialized React class component
 * designed to provide detailed hover information about a credit account.
 * It is built with TypeScript and extends the React `Component` class,
 * with types specified for both props and state.
 *
 * @template T - Specifies the type of bank account this component works with,
 * extending a base CreditAccount.
 *
 * @example
 * ```tsx
 * import { CreditAccountHoverLabel } from './CreditAccountHoverLabel';
 *
 * <CreditAccountHoverLabel
 *    creditAccount={new CreditAccount({
 *      name: 'Savings Account',
 *      currentFunds: 5000,
 *      goals: [{name: 'Vacation', amount: 1000}]
 *    })}
 *    enableDemoMode={false}
 * />
 * ```
 *
 * @class
 * @extends {Component<CreditAccountHoverLabelProps<T>, CreditAccountHoverLabelState<T>>}
 */
export declare class CreditAccountHoverLabel<T extends CreditAccount> extends Component<CreditAccountHoverLabelProps<T>, CreditAccountHoverLabelState<T>> {
	/**
	 * A reference to the DOM element of the component.
	 * Useful for direct DOM manipulations.
	 */
	private myRef;
	/**
	 * Default properties for the CreditAccountHoverLabel component.
	 */
	static defaultProps: {
		contextQuestions: string[];
		enableDemoMode: boolean;
		children: null;
		institutionName: string;
	};
	/**
	 * Constructs a new `CreditAccountHoverLabel` component.
	 *
	 * @param props - The properties passed to the component.
	 */
	constructor(props: CreditAccountHoverLabelProps<T>);
	/**
	 * Lifecycle method that triggers immediately after the component is added to the DOM.
	 * This method focuses the current component if it has a valid reference.
	 */
	componentDidMount(): void;
	/**
	 * Renders the `CreditAccountHoverLabel` component.
	 *
	 * @returns {ReactNode} The React Node representing the component's UI.
	 */
	render(): ReactNode;
}
export interface CallToActionSplitProps {
	backgroundColor?: "white" | "indigo-100";
	button1Title?: string;
	button1Handler?: () => void;
	button2Title?: string;
	button2Handlder?: () => void;
	title?: string;
}
export declare const CallToActionSplit: React.FC<CallToActionSplitProps>;
export interface SimpleCallToActionProps {
	title: string;
	description?: string;
	backgroundColor?: "white" | "gray-900" | "indigo-700";
	showGradient?: boolean;
	centered?: boolean;
	button1Title?: string;
	button1Handler?: () => void;
	button2Title?: string;
	button2Handlder?: () => void;
}
export declare const SimpleCallToAction: React.FC<SimpleCallToActionProps>;
export type FlyoutMenuOption = {
	name: string;
	href: string;
	icon?: React.ForwardRefExoticComponent<Omit<React.SVGProps<SVGSVGElement>, "ref"> & {
		title?: string | undefined;
		titleId?: string | undefined;
	} & React.RefAttributes<SVGSVGElement>>;
	description?: string;
};
export declare const FlyoutMenuSimple: React.FC<{
	title: string;
	options: FlyoutMenuOption[];
}>;
export declare const FlyoutMenuFullWidth: React.FC<{
	title: string;
	options: FlyoutMenuOption[];
	footerOptions: FlyoutMenuOption[];
}>;
export type Options = {
	name: string;
	description: string;
	href: string;
	icon: React.ElementType;
};
export type FooterOption = {
	name: string;
	href: string;
	icon: React.ElementType;
};
export declare const FlyoutMenuWithStackedFooterIcons: React.FC<{
	options: Options[];
	footerOptions: FooterOption[];
	title: string;
}>;
export type FlyoutMenuFooterOption = {
	title: string;
	tagline: string;
	subtext: string;
};
export declare const FlyoutMenuTwoColumn: React.FC<{
	title: string;
	options: FlyoutMenuOption[];
	footerOption?: FlyoutMenuFooterOption;
}>;
export type NavigationItem = {
	name: string;
	description?: string;
	href: string;
	icon: React.ForwardRefExoticComponent<Omit<React.SVGProps<SVGSVGElement>, "ref"> & {
		title?: string | undefined;
		titleId?: string | undefined;
	} & React.RefAttributes<SVGSVGElement>>;
	current: boolean | undefined;
};
export interface HeaderWithStackedFlyoutMenuProps {
	products: NavigationItem[];
	callsToAction: NavigationItem[];
	logoSrc: string;
	headerTitle?: string;
	dropdownTitle?: string;
	headerOptions?: NavigationItem[];
	headerActionButtonTitle?: string;
	headerActionButtonHandler?: () => void;
}
export interface HeaderWithFullWidthFlyoutMenuProps {
	products: NavigationItem[];
	callsToAction: NavigationItem[];
	logoSrc: string;
	headerTitle?: string;
	dropdownTitle?: string;
	headerOptions?: NavigationItem[];
	headerActionButtonTitle?: string;
	headerActionButtonHandler?: () => void;
}
export declare const HeaderWithFullWidthFlyoutMenu: React.FC<HeaderWithFullWidthFlyoutMenuProps>;
export interface HeaderSectionSimpleProps {
	theme: "light" | "dark";
	title: string;
	description: string;
	className?: string;
}
export declare const HeaderSectionSimple: React.FC<HeaderSectionSimpleProps>;
export interface HeaderSectionWithBackgroundProps {
	/**
	 * The alignment of the content.
	 */
	alignment?: "left" | "center";
	/**
	 * The main title of the support center section.
	 */
	backgroundImage?: string;
	title: string;
	description: string;
}
export declare const HeaderSectionWithBackground: React.FC<HeaderSectionWithBackgroundProps>;
/**
 * Props for the `HistoricalAccountBalanceChart` component.
 *
 * @template T A type that extends `AccountBalanceHistory`, allowing for potential extensions to the base type in the future.
 *
 * @property {T[]} historicalAccountBalance - Array of account balance history to be charted.
 * @property {string} [className] - Optional CSS class to style the component.
 */
export type HistoricalAccountBalanceChartProps<T extends AccountBalanceHistory> = {
	historicalAccountBalance: T[];
	className?: string;
	disableLabel?: boolean;
};
/**
 * State for the `HistoricalAccountBalanceChart` component.
 *
 * @property {number} counter - A sample state property, likely used for internal component operations.
 */
export type HistoricalAccountBalanceChartState = {
	counter: number;
};
/**
 * The `HistoricalAccountBalanceChart` class component visualizes the history of account balances over time.
 * It leverages the `recharts` library to plot the balances and is built with extensibility in mind, using
 * generics for its props to allow potential custom extensions of the `AccountBalanceHistory` type.
 *
 * Features:
 * - Visualizes the account balance history using a line chart.
 * - Allows for potential customization of data types via TypeScript generics.
 * - Provides a context for potential child components to access the account balance history.
 * - Can be styled further through its `className` prop.
 *
 * @remarks
 * The component contains a sample state property named `counter` and methods associated with it.
 * Its actual use-case within the component should be clarified further.
 *
 * @example Basic Usage:
 * ```tsx
 * import { HistoricalAccountBalanceChart } from './path-to-component';
 *
 * const sampleHistory = [ ... ]; // Sample data here
 *
 * function App() {
 *   return (
 *     <HistoricalAccountBalanceChart historicalAccountBalance={sampleHistory} />
 *   );
 * }
 * ```
 *
 * @example Styling the component:
 * ```tsx
 * <HistoricalAccountBalanceChart className="border rounded-md" historicalAccountBalance={sampleHistory} />
 * ```
 */
export declare class HistoricalAccountBalanceChart<T extends AccountBalanceHistory> extends Component<HistoricalAccountBalanceChartProps<T>, HistoricalAccountBalanceChartState> {
	private myRef;
	static defaultProps: {
		className: string;
		disableLabel: boolean;
	};
	constructor(props: HistoricalAccountBalanceChartProps<T>);
	/** Lifecycle method when the component is about to mount. */
	componentWillMount(): void;
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	private averageBalance;
	private totalAccumulation;
	private maxBalance;
	private minBalance;
	/**
	 * Computes the moving average of account balances.
	 * @param data The data containing the account balance histories.
	 * @param windowSize The window size for the moving average.
	 * @returns An array of moving averages for the given window size.
	 */
	private movingAverage;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type InvestmentAccountCardProps = {
	investmentAccount: InvestmentAccount;
	historicalAccountBalance?: AccountBalanceHistory[];
	enableDemoMode?: boolean;
	className?: string;
};
export type InvestmentAccountCardState = {
	investmentAccount: InvestmentAccount;
};
/**
 * @class InvestmentAccountCard
 * @extends {Component<InvestmentAccountCardProps, InvestmentAccountCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class InvestmentAccountCard extends Component<InvestmentAccountCardProps, InvestmentAccountCardState> {
	private myRef;
	static defaultProps: {
		InvestmentAccount: InvestmentAccountClass;
		historicalAccountBalance: never[];
	};
	constructor(props: InvestmentAccountCardProps);
	/** Lifecycle method when the component is about to mount. */
	componentWillMount(): void;
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type InvestmentAccountHoverLabelProps<T extends InvestmentAccount> = {
	investmentAccount: T;
	className?: string;
	enableDemoMode?: boolean;
	children?: ReactNode;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type InvestmentAccountHoverLabelState<T extends InvestmentAccount> = {
	investmentAccount: T;
};
/**
 * The `InvestmentAccountHoverLabel` is a specialized React class component
 * designed to provide detailed hover information about an investment account.
 * It is built with TypeScript and extends the React `Component` class,
 * with types specified for both props and state.
 *
 * @template T - Specifies the type of bank account this component works with,
 * extending a base Investment Account.
 *
 * @example
 * ```tsx
 * import { InvestmentAccountHoverLabel } from './InvestmentAccountHoverLabel';
import { InvestmentAccount } from '../../types/financial/investment-account';
 *
 * <InvestmentAccountHoverLabel
 *    investmentAccount={new InvestmentAccount({
 *      name: 'Savings Account',
 *      currentFunds: 5000,
 *      goals: [{name: 'Vacation', amount: 1000}]
 *    })}
 *    enableDemoMode={false}
 * />
 * ```
 *
 * @class
 * @extends {Component<InvestmentAccountHoverLabelProps<T>, InvestmentAccountHoverLabelState<T>>}
 */
export declare class InvestmentAccountHoverLabel<T extends InvestmentAccount> extends Component<InvestmentAccountHoverLabelProps<T>, InvestmentAccountHoverLabelState<T>> {
	/**
	 * A reference to the DOM element of the component.
	 * Useful for direct DOM manipulations.
	 */
	private myRef;
	/**
	 * Default properties for the InvestmentAccountHoverLabel component.
	 */
	static defaultProps: {
		bankAccount: BankAccountClass;
		contextQuestions: string[];
		enableDemoMode: boolean;
		children: null;
	};
	/**
	 * Constructs a new `InvestmentAccountHoverLabel` component.
	 *
	 * @param props - The properties passed to the component.
	 */
	constructor(props: InvestmentAccountHoverLabelProps<T>);
	/**
	 * Lifecycle method that triggers immediately after the component is added to the DOM.
	 * This method focuses the current component if it has a valid reference.
	 */
	componentDidMount(): void;
	/**
	 * Renders the `InvestmentAccountHoverLabel` component.
	 *
	 * @returns {ReactNode} The React Node representing the component's UI.
	 */
	render(): ReactNode;
}
export type InvestmentHoldingCardProps = {
	holdings: InvesmentHolding[];
	accountName: string;
	className?: string;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type InvestmentHoldingCardState = {
	holdings: InvesmentHolding[];
};
/**
 * @class InvestmentHoldingCard
 * @extends {Component<InvestmentHoldingCardProps, InvestmentHoldingCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class InvestmentHoldingCard extends Component<InvestmentHoldingCardProps, InvestmentHoldingCardState> {
	private myRef;
	static defaultProps: {
		accountName: string;
	};
	constructor(props: InvestmentHoldingCardProps);
	/** Lifecycle method when the component is about to mount. */
	componentWillMount(): void;
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	private computeTotalCostBasis;
	private computeAverageCostBasis;
	private computeTotalInstitutionValue;
	private computeTotalProfitLoss;
	private findLargestHolding;
	private findSmallestHolding;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type InvestmentSecurityCardProps = {
	security: InvestmentSecurity;
	className?: string;
};
export type InvestmentSecurityCardState = {
	security: InvestmentSecurity;
};
/**
 * @class InvestmentSecurityCard
 * @extends {Component<InvestmentSecurityCardProps, InvestmentSecurityCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class InvestmentSecurityCard extends Component<InvestmentSecurityCardProps, InvestmentSecurityCardState> {
	private myRef;
	static defaultProps: {
		security: InvestmentSecurityClass;
	};
	constructor(props: InvestmentSecurityCardProps);
	/** Lifecycle method when the component is about to mount. */
	componentWillMount(): void;
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
/**
 * Represents individual data points for the chart.
 */
export interface ChartData {
	/** The name for this data point (typically represents a unit on the X-axis, like month or day). */
	name: string;
	/** Value for the 'uv' metric. */
	uv: number;
	/** Optional value for the 'pv' metric. */
	pv?: number;
}
/**
 * Props for the CustomLineChart component.
 */
export interface CustomLineChartProps {
	/** Array of data points to plot on the chart. */
	data: ChartData[];
	/** Optional CSS class to be applied to the chart's outermost container. */
	className?: string;
	label: string;
	enableGrid?: boolean;
}
export type MortgageAccountCardProps<T> = {
	data: T;
	greeting?: string;
	className?: string;
};
export type MortgageAccountCardState = {
	counter: number;
};
/**
 * @class MortgageAccountCard
 * @extends {Component<MortgageAccountCardProps, MortgageAccountCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class MortgageAccountCard<T> extends Component<MortgageAccountCardProps<T>, MortgageAccountCardState> {
	private myRef;
	static defaultProps: {
		greeting: string;
	};
	constructor(props: MortgageAccountCardProps<T>);
	/** Lifecycle method when the component is about to mount. */
	componentWillMount(): void;
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Increments the counter state property.
	 * @private
	 */
	private incrementCounter;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export interface NotificationComponentProps {
	imageURL?: string;
	title?: string;
	message: string;
	actions: ReactNode;
	iconType?: "inbox" | "check" | "none";
	initialShow?: boolean;
}
/**
 * `CustomPieChart` Props Interface
 * @interface ICustomPieChartProps
 * @property {Array<Object>} data01 - The data for the first pie chart.
 * @property {Array<Object> | undefined} [data02] - The data for the second pie chart. Optional.
 */
export interface ICustomPieChartProps {
	data01: {
		name: string;
		value: number;
	}[];
	data02?: {
		name: string;
		value: number;
	}[];
	label: string;
	className?: string;
}
export type RecurringTransactionCardProps = {
	recurringTransaction: ReOccuringTransaction;
	className?: string;
	nextTransactionDate?: string;
	enableDetailedDisplay?: boolean;
	participantTransactions?: Transaction[];
	account?: BankAccount | CreditAccount;
};
export type RecurringTransactionCardState = {
	transaction: ReOccuringTransaction;
};
/**
 * @class RecurringTransactionCard
 * @extends {Component<RecurringTransactionCardProps, RecurringTransactionCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class RecurringTransactionCard extends Component<RecurringTransactionCardProps, RecurringTransactionCardState> {
	private myRef;
	static defaultProps: {
		nextTransactionDate: string;
		enableDetailedDisplay: boolean;
		className: string;
		participantTransactions: never[];
	};
	constructor(props: RecurringTransactionCardProps);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	private isTransactionFrequencyInvalid;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
/**
 * `CustomScatterChart` Props Interface
 * @interface ICustomScatterChartProps
 * @property {Array<Object>} data01 - The data for the "A school" scatter plot.
 * @property {Array<Object> | undefined} [data02] - The data for the "B school" scatter plot. Optional.
 */
export interface ICustomScatterChartProps {
	data01: {
		x: number;
		y: number;
		z: number;
	}[];
	data01Title: string;
	data02?: {
		x: number;
		y: number;
		z: number;
	}[];
	data02Title?: string;
	className?: string;
	label: string;
	xAxisName: string;
	yAxisName: string;
	zAxisName: string;
	xAxisUnit: string;
	yAxisUnit: string;
	zAxisUnit: string;
}
export interface BusinessNavigationItem {
	name: string;
	href: string;
	icon: React.ForwardRefExoticComponent<Omit<React.SVGProps<SVGSVGElement>, "ref"> & {
		title?: string | undefined;
		titleId?: string | undefined;
	} & React.RefAttributes<SVGSVGElement>>;
	current: boolean;
}
export interface Team {
	id: number;
	name: string;
	href: string;
	initial: string;
	current: boolean;
}
export interface UserBusinessNavigationItem {
	name: string;
	href: string;
}
export interface DashboardSidebarProps {
	navigation?: BusinessNavigationItem[];
	teams?: Team[];
	userNavigation?: UserBusinessNavigationItem[];
}
/**
 * Dashboard component that displays navigation, user details, and other dashboard related content.
 *
 * @param navigation - Array of navigation items.
 * @param teams - Array of team items.
 * @param userNavigation - Array of user navigation items.
 * @returns A Dashboard component.
 */
export declare const DashboardSidebar: React.FC<DashboardSidebarProps>;
export type SubscriptionsSidebarOption = "INFLOW" | "OUTFLOW" | "UPCOMING" | "DRILLDOWN" | "OVERVIEW";
export type InvestmentSidebarOption = "OVERVIEW" | "CRYPTO" | "STOCKS";
export interface IProps {
	className?: React.ReactNode;
	selectedOption: InvestmentSidebarOption;
	setSelectedOption: (option: InvestmentSidebarOption) => void;
}
export declare const InvestmentViewSidebar: React.FC<IProps>;
export interface SubscriptionSidebarProps {
	className?: React.ReactNode;
	setSelectedOption: (option: SubscriptionsSidebarOption) => void;
}
export declare const SubscriptionSidebar: React.FC<SubscriptionSidebarProps>;
export interface SimpleStatsCardProps {
	/** The title of the card */
	title: string;
	/** The main metric to be displayed */
	metric: string | number;
	/** Optional subtext or label for the metric */
	subtext?: string;
	/** Optional CSS class to be applied on the card */
	className?: string;
}
/**
 * The `SimpleStatsCard` component provides a minimalistic and clean way to display a key metric.
 * It presents a title followed by a large metric value.
 *
 * @remarks
 * This component is particularly suitable for dashboard interfaces or any context where the emphasis is on a single key data point.
 *
 * @param props - An object containing title, metric, an optional subtext, and an optional className.
 *
 * @example
 * ```tsx
 * <SimpleStatsCard
 *   title="Active Users"
 *   metric={200}
 *   subtext="This Month"
 * />
 * ```
 */
export declare const SimpleStatsCard: React.FC<SimpleStatsCardProps>;
export type Stat = {
	id: number;
	name: string;
	value: string;
};
export interface StatsSectionProps {
	theme?: "light" | "dark";
	stats?: Stat[];
}
export declare const StatsSection: React.FC<StatsSectionProps>;
export interface StatsSectionStackedGridProps {
	theme?: "light" | "dark";
	stats?: Stat[];
	title?: string;
	description?: string;
}
export declare const StatsSectionStackedGrid: React.FC<StatsSectionStackedGridProps>;
export type StatBlock = {
	title: string;
	value: string;
	description: string;
	bgColor: string;
	textColor: string;
	secondaryTextColor: string;
};
export interface StatsSectionHighlightProps {
	mainTitle: string;
	mainDescription: string;
	stats: StatBlock[];
}
export type TimelineItem = {
	name: string;
	description: string;
	date: string;
	dateTime: string;
};
export interface StatsSectionWithTimelineProps {
	timeline: TimelineItem[];
}
export type StudentLoanAccountCardProps = {
	studentLoanAccount: StudentLoanAccount;
	className?: string;
	children?: ReactNode;
};
export type StudentLoanAccountCardState = {
	studentLoanAccount: StudentLoanAccount;
};
/**
 * @class StudentLoanAccountCard
 * @extends {Component<StudentLoanAccountCardProps, StudentLoanAccountCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class StudentLoanAccountCard extends Component<StudentLoanAccountCardProps, StudentLoanAccountCardState> {
	private myRef;
	static defaultProps: {
		studentLoanAccount: StudentLoanAccountClass;
		children: null;
		className: string;
	};
	constructor(props: StudentLoanAccountCardProps);
	/** Lifecycle method when the component is about to mount. */
	componentWillMount(): void;
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type StudentLoanAccountHoverLabelProps<T extends StudentLoanAccount> = {
	studentLoanAccount: T;
	className?: string;
	enableDemoMode?: boolean;
	children?: ReactNode;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type StudentLoanAccountHoverLabelState<T extends StudentLoanAccount> = {
	studentLoanAccount: T;
};
/**
 * The `StudentLoanAccountHoverLabel` is a specialized React class component
 * designed to provide detailed hover information about an studentLoan account.
 * It is built with TypeScript and extends the React `Component` class,
 * with types specified for both props and state.
 *
 * @template T - Specifies the type of bank account this component works with,
 * extending a base StudentLoan Account.
 *
 * @example
 * ```tsx
 * import { StudentLoanAccountHoverLabel } from './StudentLoanAccountHoverLabel';
import { StudentLoanAccount } from '../../types/financial/investment-account';
 *
 * <StudentLoanAccountHoverLabel
 *    studentLoanAccount={new StudentLoanAccount({
 *      name: 'Savings Account',
 *      currentFunds: 5000,
 *      goals: [{name: 'Vacation', amount: 1000}]
 *    })}
 *    enableDemoMode={false}
 * />
 * ```
 *
 * @class
 * @extends {Component<StudentLoanAccountHoverLabelProps<T>, StudentLoanAccountHoverLabelState<T>>}
 */
export declare class StudentLoanAccountHoverLabel<T extends StudentLoanAccount> extends Component<StudentLoanAccountHoverLabelProps<T>, StudentLoanAccountHoverLabelState<T>> {
	/**
	 * A reference to the DOM element of the component.
	 * Useful for direct DOM manipulations.
	 */
	private myRef;
	/**
	 * Default properties for the StudentLoanAccountHoverLabel component.
	 */
	static defaultProps: {
		bankAccount: BankAccountClass;
		contextQuestions: string[];
		enableDemoMode: boolean;
		children: null;
	};
	/**
	 * Constructs a new `StudentLoanAccountHoverLabel` component.
	 *
	 * @param props - The properties passed to the component.
	 */
	constructor(props: StudentLoanAccountHoverLabelProps<T>);
	/**
	 * Lifecycle method that triggers immediately after the component is added to the DOM.
	 * This method focuses the current component if it has a valid reference.
	 */
	componentDidMount(): void;
	/**
	 * Renders the `StudentLoanAccountHoverLabel` component.
	 *
	 * @returns {ReactNode} The React Node representing the component's UI.
	 */
	render(): ReactNode;
}
export type TransactionAnalyticsByMonthProps = {
	transactions: Transaction[];
	className?: string;
};
export type TransactionAnalyticsByMonthState = {
	transactions: Transaction[];
};
/**
 * @class TransactionAnalyticsByMonth
 * @extends {Component<TransactionAnalyticsByMonthProps, TransactionAnalyticsByMonthState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class TransactionAnalyticsByMonth extends Component<TransactionAnalyticsByMonthProps, TransactionAnalyticsByMonthState> {
	private myRef;
	static defaultProps: {
		className: string;
	};
	constructor(props: TransactionAnalyticsByMonthProps);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Categorizes the provided transactions.
	 * @param transactions List of transactions to categorize.
	 * @returns A categorized array.
	 */
	private categorizeTransactions;
	/**
	 * Groups transactions by month.
	 * @param transactions List of transactions to group.
	 * @returns An array of month groups with categorized transactions.
	 */
	private groupByMonth;
	private extractCategories;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type TransactionDataTableProps = {
	transactions: Transaction[];
	className?: string;
	account?: BankAccount | CreditAccount;
};
export type TransactionDataTableState = {
	transactions: Transaction[];
};
/**
 * @class TransactionDataTable
 * @extends {Component<TransactionDataTableProps, TransactionDataTableState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class TransactionDataTable extends Component<TransactionDataTableProps, TransactionDataTableState> {
	private myRef;
	static defaultProps: {
		className: string;
	};
	constructor(props: TransactionDataTableProps);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export declare const columns: ColumnDef<Transaction>[];
export type CombinedAccounts = BankAccountClass & CreditAccountClass & StudentLoanAccountClass & InvestmentAccountClass;
export type AccountsViewProps<T extends CombinedAccounts> = {
	/** Primary data to be displayed or processed by the component. */
	account: T;
	/** Optional CSS classes for styling the component. */
	className?: string;
	transactions?: Transaction[];
	enableDemoMode?: boolean;
	historicalAccountBalance: AccountBalanceHistory[];
	children?: ReactNode;
	contextQuestions?: string[];
	userName: string;
	addGoalCallback: () => void;
	addMilestoneCallback: () => void;
};
export type AccountsViewState<T extends CombinedAccounts> = {
	/** account of interest */
	account: T;
};
/**
 * @class AccountsView
 * @extends {Component<AccountsViewProps, AccountsViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class AccountsView<T extends CombinedAccounts> extends Component<AccountsViewProps<T>, AccountsViewState<T>> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {
		children: null;
		contextQuestions: string[];
	};
	constructor(props: AccountsViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type CategorizationViewProps<T> = {
	/** Primary data to be displayed or processed by the component. */
	data: T;
	/** Optional greeting text. Defaults to 'Hello'. */
	greeting?: string;
	/** Optional CSS classes for styling the component. */
	className?: string;
};
export type CategorizationViewState = {
	/** Counter to keep track of the number of button clicks. */
	counter: number;
};
/**
 * @class CategorizationView
 * @extends {Component<CategorizationViewProps, CategorizationViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class CategorizationView<T> extends Component<CategorizationViewProps<T>, CategorizationViewState> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {
		greeting: string;
	};
	constructor(props: CategorizationViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Increments the counter state property.
	 * @private
	 */
	private incrementCounter;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type ActionableInsightsViewProps<T extends PersonalActionableInsight> = {
	/** Primary data to be displayed or processed by the component. */
	insights: T[];
	/** Optional CSS classes for styling the component. */
	className?: string;
	historicalFinancialProfile: FinancialProfile[];
};
export type ActionableInsightsViewState<T extends PersonalActionableInsight> = {
	/** Counter to keep track of the number of button clicks. */
	insights: T[];
	historicalFinancialProfile: FinancialProfile[];
};
/**
 * @class ActionableInsightsView
 * @extends {Component<ActionableInsightsViewProps, ActionableInsightsViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class ActionableInsightsView<T extends PersonalActionableInsight> extends Component<ActionableInsightsViewProps<T>, ActionableInsightsViewState<T>> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {
		greeting: string;
	};
	constructor(props: ActionableInsightsViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export declare const FinancialProfileThroughTimeChart: React.FC<{
	data: FinancialProfile[];
}>;
export type CopilotViewProps<T> = {
	/** Primary data to be displayed or processed by the component. */
	data: T;
	/** Optional greeting text. Defaults to 'Hello'. */
	greeting?: string;
	/** Optional CSS classes for styling the component. */
	className?: string;
};
export type CopilotViewState = {
	/** Counter to keep track of the number of button clicks. */
	counter: number;
};
/**
 * @class CopilotView
 * @extends {Component<CopilotViewProps, CopilotViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class CopilotView<T> extends Component<CopilotViewProps<T>, CopilotViewState> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {
		greeting: string;
	};
	constructor(props: CopilotViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Increments the counter state property.
	 * @private
	 */
	private incrementCounter;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type CompoundMetricType = ExpenseMetricsClass[] | IncomeMetricsClass[] | undefined;
export type SelectedDateRangeOfEvaluation = "30 Days" | "2 Weeks" | "1 Week";
export type ExpenseIncomeViewProps<T extends CompoundMetricType> = {
	/** Primary data to be displayed or processed by the component. */
	data: T;
	/** Optional CSS classes for styling the component. */
	className?: string;
	enableDebugMode?: boolean;
	historicalAccountBalance: AccountBalanceHistory[];
	transactions: Transaction[];
};
export type ExpenseIncomeViewState<T extends CompoundMetricType> = {
	/** Counter to keep track of the number of button clicks. */
	data: T;
	historicalAccountBalance: AccountBalanceHistory[];
	selectedDateRangeOfEvaluation: SelectedDateRangeOfEvaluation;
};
/**
 * @class ExpenseIncomeView
 * @extends {Component<ExpenseIncomeViewProps, ExpenseIncomeViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class ExpenseIncomeView<T extends CompoundMetricType> extends Component<ExpenseIncomeViewProps<T>, ExpenseIncomeViewState<T>> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {};
	constructor(props: ExpenseIncomeViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	convertToChartData(data: AccountBalanceHistory): {
		name: string;
		total: number;
	};
	getNumberOfTransactionsPerCategory(): {
		name: string;
		value: number;
	}[];
	aggregateTransactionsByMonthAndConvertToChartData(): {
		name: string;
		total: number;
	}[];
	setSelectedDateRangeOfEvaluation(selectedDateRangeOfEvaluation: SelectedDateRangeOfEvaluation): void;
	monthNumberToString(monthNumber: number): string;
	getMetricsForMonth(month: number): (ExpenseMetricsClass | IncomeMetricsClass)[];
	getTopCategories(): {
		name: string;
		transactionCount: number;
	}[];
	getHistoricalAccountBalance(): AccountBalanceHistory[];
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type TimelineEvent = {
	id: string;
	icon: ReactElement;
	content: string;
	href: string;
	target: string;
	datetime: string;
	date: string;
};
export type GoalsViewProps<T extends SmartGoal> = {
	/** Primary data to be displayed or processed by the component. */
	goal: T;
	/** Optional CSS classes for styling the component. */
	className?: string;
	enableDemoMode?: boolean;
	transactions?: Transaction[];
	timeline?: TimelineEvent[];
	addBudgetCallback: () => void;
	addMilestoneCallback: () => void;
};
export type GoalsViewState<T extends SmartGoal> = {
	/** Counter to keep track of the number of button clicks. */
	goal: T;
};
/**
 * @class GoalsView
 * @extends {Component<GoalsViewProps, GoalsViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class GoalsView<T extends SmartGoal> extends Component<GoalsViewProps<T>, GoalsViewState<T>> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {};
	constructor(props: GoalsViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	getMilestones(): Milestone[] | undefined;
	getBudgets(): (Budget | undefined)[];
	/**
	 * Computes the percentage of two numbers represented as strings, potentially prefixed with `$`.
	 *
	 * @param numeratorStr - The numerator as a string.
	 * @param denominatorStr - The denominator as a string.
	 * @returns The percentage (numerator/denominator * 100) or NaN if inputs are not valid numbers.
	 */
	computePercentage(numeratorStr: string, denominatorStr: string): number;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type TransactionsViewProps<T> = {
	/** Primary data to be displayed or processed by the component. */
	data: T;
	/** Optional greeting text. Defaults to 'Hello'. */
	greeting?: string;
	/** Optional CSS classes for styling the component. */
	className?: string;
};
export type TransactionsViewState = {
	/** Counter to keep track of the number of button clicks. */
	counter: number;
};
/**
 * @class TransactionsView
 * @extends {Component<TransactionsViewProps, TransactionsViewState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript.
 * It demonstrates context usage, dynamic styles, generic props, and more.
 */
export declare class TransactionsView<T> extends Component<TransactionsViewProps<T>, TransactionsViewState> {
	/** Reference to the main div element of the component. */
	private myRef;
	static defaultProps: {
		greeting: string;
	};
	constructor(props: TransactionsViewProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Increments the counter state property.
	 * @private
	 */
	private incrementCounter;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export type CreditAccountCardProps<CreditAccount> = {
	creditAccount: CreditAccount;
	financialProfile: FinancialProfile;
	institutionName: string;
	className?: string;
	contextQuestions?: string[];
	enableDemoMode?: boolean;
	children?: ReactNode;
	historicalAccountBalance?: AccountBalanceHistory[];
};
export type CreditAccountCardState<T extends CreditAccount> = {
	creditAccount: T;
};
/**
 * @class CreditAccountCard
 * @extends {Component<CreditAccountCardProps, CreditAccountCardState>}
 *
 * @description
 * This is a templated advanced React class component written in TypeScript
 * with TSDoc annotations. It has various features like context usage,
 * dynamic styles, generic props, and more.
 */
export declare class CreditAccountCard<T extends CreditAccount> extends Component<CreditAccountCardProps<T>, CreditAccountCardState<T>> {
	private myRef;
	static defaultProps: {
		creditAccount: CreditAccountClass;
		financialProfile: FinancialProfileClass;
		contextQuestions: string[];
		enableDemoMode: boolean;
		children: null;
	};
	constructor(props: CreditAccountCardProps<T>);
	/**
	 * Lifecycle method that runs after the component has been mounted.
	 */
	componentDidMount(): void;
	/**
	 * Renders the component.
	 * @returns {ReactNode}
	 */
	render(): ReactNode;
}
export declare const CreditAccountMiniCard: React.FC<{
	creditAccount: CreditAccount;
	institutionName: string;
	className?: string;
}>;
/**
 * @interface User Represents user details
 */
export interface User {
	name: string;
	email: string;
	imageUrl: string;
}
/**
 * @interface StackedLayoutNavigationItem Represents a navigation item
 */
export interface StackedLayoutNavigationItem {
	name: string;
	href: string;
	current?: boolean;
	icon?: React.ForwardRefExoticComponent<Omit<React.SVGProps<SVGSVGElement>, "ref"> & {
		title?: string | undefined;
		titleId?: string | undefined;
	} & React.RefAttributes<SVGSVGElement>>;
	callback?: () => void;
}
/**
 * @interface StackedLayoutNavWithPageHeaderProps Represents the props for the StackedLayoutNavWithPageHeader component
 */
export interface StackedLayoutNavWithPageHeaderProps {
	user: User;
	navigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	title: string;
}
export interface MultiColumnNarrowSidebarProps {
	navigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	enableHeader: boolean;
}
export declare const MultiColumnNarrowSidebar: React.FC<MultiColumnNarrowSidebarProps>;
export interface MultiColumnThreeWidthProps {
	navigation: StackedLayoutNavigationItem[];
	subNavigation: StackedLayoutNavigationItem[];
}
export declare const MultiColumnThreeWidth: React.FC<MultiColumnThreeWidthProps>;
export interface PanelLayoutProps {
	/** Define the background color of the card */
	bgColor?: "white" | "gray-50";
	/** Use rounded corners */
	useRounded?: boolean;
	/** Use shadow on the card */
	useShadow?: boolean;
	/** Divide sections of the card with a gray line */
	useDivider?: boolean;
	/** Less vertical padding for card headers on desktop */
	headerPadding?: boolean;
	/** Less vertical padding for card footers at all sizes */
	footerPadding?: boolean;
	/** Children elements */
	children?: ReactNode;
}
export interface SidebarBasicProps {
	navigationItems: NavigationItem[];
	userName: string;
	userProfileImage: string;
	className?: string;
	disableImage?: boolean;
}
export declare const SidebarBasic: React.FC<SidebarBasicProps>;
export interface SidebarSimpleProps {
	navigation: StackedLayoutNavigationItem[];
	subNavigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	children: React.ReactNode;
}
export declare const SidebarSimple: React.FC<SidebarSimpleProps>;
export interface SidebarWithConstrainedAreaProps {
	navigation: StackedLayoutNavigationItem[];
	subNavigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	children: React.ReactNode;
}
export declare const SidebarWithConstrainedArea: React.FC<SidebarWithConstrainedAreaProps>;
export interface SidebarWithHeaderProps {
	navigation: StackedLayoutNavigationItem[];
	subNavigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	children: React.ReactNode;
}
export declare const SidebarWithHeader: React.FC<SidebarWithHeaderProps>;
export interface ContainerLayoutProps {
	/** Use max width of 7xl or container */
	useMaxWidth7xl?: boolean;
	/** Use a container class */
	useContainer?: boolean;
	/** Use an inner div with max width of 3xl */
	useInnerMaxWidth3xl?: boolean;
	/** Padding along the x-axis */
	paddingX?: string;
	/** Children elements */
	children?: ReactNode;
}
/**
 * @interface User Represents user details
 */
export interface User {
	name: string;
	email: string;
	imageUrl: string;
}
/**
 * @interface StackedNavigationItem Represents a navigation item
 */
export interface StackedNavigationItem {
	name: string;
	href: string;
	current?: boolean;
}
/**
 * @interface StackedLayoutNavBottomBorderProps Represents the props for the StackedLayoutNavBottomBorder component
 */
export interface StackedLayoutNavBottomBorderProps {
	user: User;
	navigation: StackedNavigationItem[];
	userNavigation: StackedNavigationItem[];
	title: string;
}
/**
 * @interface StackedLayoutOverlapProps Represents the props for the StackedLayoutOverlap component
 */
export interface StackedLayoutOverlapProps {
	user: User;
	navigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	title: string;
	children: React.ReactNode;
}
/**
 * @interface StackedLayoutOverlapTwoRowsProps Represents the props for the StackedLayoutOverlapTwoRows component
 */
export interface StackedLayoutOverlapTwoRowsProps {
	user: User;
	navigation: StackedLayoutNavigationItem[];
	userNavigation: StackedLayoutNavigationItem[];
	title: string;
	children: React.ReactNode;
}
/**
 * Represents a role in a conversation with OpenAI's ChatGPT model.
 */
export type ChatGPTAgent = "user" | "system" | "assistant";
export type OpenAIModel = " gpt-4-turbo" | "gpt-4" | "gpt-3.5" | "gpt-3.5-turbo";
export type SolomonProps = {
	children: React.ReactNode;
	className?: string;
	context: any | undefined;
	sampleQuestions: string[];
	enableGlobalContext?: boolean;
	userId: string;
	userName: string;
	userAccount: UserAccount;
	financialContext: MelodyFinancialContext;
	instrumentationCallback?: () => void;
	apiToken: string;
	model: OpenAIModel;
	componentType: ComponentType;
	temperature: number;
	top_p: number;
	frequency_penalty: number;
	presence_penalty: number;
	max_tokens: number;
};
export type ComponentType = "SHEET" | "DIALOG";
/**
 * This is the main layout for the Analytic AI card.
 *
 * @param children - The child components to render within this component.
 * @param className - The CSS classes to apply to the component.
 * @param context - The context for the AI to operate in.
 *
 * @example
 * ```
 * <AskSolomonAILayout context={context}>
 *   <ChildComponent />
 * </AskSolomonAILayout>
 * ```
 */
export declare const AskSolomonAILayout: React.FC<SolomonProps>;
export declare const AskSolomon: React.FC<SolomonProps>;
export interface ChatGPTMessage {
	role: ChatGPTAgent;
	content: string;
}
export declare const LoadingChatLine: () => import("react/jsx-runtime").JSX.Element;
export declare function ChatLine({ role, content }: ChatGPTMessage): import("react/jsx-runtime").JSX.Element | null;
export type InputMessageProps = {
	input: string;
	setInput: (input: string) => void;
	sendMessage: (input: string) => void;
};
export declare const InputMessage: React.FC<InputMessageProps>;
export declare const initialMessages: ChatGPTMessage[];
export type ContextTypes = {
	contextName: string;
	context: any;
};
export type AIAgentContext = "COMPLIANCE" | "FINANCIAL" | "RISK";
export type ChatProps = {
	baseContext: ContextTypes;
	sampleQuestions: string[];
	secondaryContext?: ContextTypes[];
	className?: string;
	instrumentationCallback?: () => void;
	apiToken: string;
	model: OpenAIModel;
	userName: string;
	userAccount: UserAccount | BusinessAccount;
	temperature: number;
	top_p: number;
	frequency_penalty: number;
	presence_penalty: number;
	max_tokens: number;
	agentContext?: AIAgentContext;
	isBusinessAccount?: boolean;
};
export declare const initialAnalyticMessage: ChatGPTMessage[];
export declare const Chat: ({ baseContext, sampleQuestions, secondaryContext, className, instrumentationCallback, apiToken, model, userName, userAccount, temperature, top_p, frequency_penalty, presence_penalty, max_tokens, agentContext, isBusinessAccount, }: ChatProps) => import("react/jsx-runtime").JSX.Element;
export declare const EmbeddedContextPickerComponent: React.FC<{
	className?: string;
	messages: ChatGPTMessage[];
	selectedContext: ContextTypes;
	setContextCallback: (context: ContextTypes) => void;
	baseContext: ContextTypes;
	contextFamily: ContextTypes[];
}>;
export interface SmartTextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
	context: any;
	globalFinancialContext: MelodyFinancialContext;
	sampleQuestions: string[];
	enableGlobalContext?: boolean;
	userId: string;
	userName: string;
	userAccount: UserAccount;
	financialContext: MelodyFinancialContext;
	instrumentationCallback?: () => void;
	apiToken: string;
	model: OpenAIModel;
	temperature: number;
	top_p: number;
	frequency_penalty: number;
	presence_penalty: number;
	max_tokens: number;
}
export declare const SmartTextarea: React.ForwardRefExoticComponent<SmartTextareaProps & React.RefAttributes<HTMLTextAreaElement>>;
export interface ComplianceViewProps {
	navigation: StackedLayoutNavigationItem[];
	subNavigation: StackedLayoutNavigationItem[];
	account: BusinessAccount;
	apiToken: string;
	model: OpenAIModel;
	temperature: number;
	top_p: number;
	frequency_penalty: number;
	presence_penalty: number;
	max_tokens: number;
	globalContext: MelodyFinancialContext;
	enableHeader: boolean;
}
export declare const ComplianceView: React.FC<ComplianceViewProps>;
declare const smartGoalSchema: z.ZodObject<{
	currentAmount: z.ZodOptional<z.ZodString>;
	description: z.ZodString;
	duration: z.ZodOptional<z.ZodString>;
	endDate: z.ZodString;
	forecasts: z.ZodOptional<z.ZodArray<z.ZodObject<{
		forecastedAmount: z.ZodOptional<z.ZodString>;
		forecastedCompletionDate: z.ZodOptional<z.ZodString>;
		id: z.ZodOptional<z.ZodString>;
		varianceAmount: z.ZodOptional<z.ZodString>;
	}, "strip", z.ZodTypeAny, {
		forecastedAmount?: string | undefined;
		forecastedCompletionDate?: string | undefined;
		id?: string | undefined;
		varianceAmount?: string | undefined;
	}, {
		forecastedAmount?: string | undefined;
		forecastedCompletionDate?: string | undefined;
		id?: string | undefined;
		varianceAmount?: string | undefined;
	}>, "many">>;
	goalType: z.ZodEnum<[
		"GOAL_TYPE_SAVINGS",
		"GOAL_TYPE_INVESTMENT",
		"GOAL_TYPE_DEBT",
		"GOAL_TYPE_EXPENSE"
	]>;
	id: z.ZodOptional<z.ZodString>;
	isCompleted: z.ZodOptional<z.ZodBoolean>;
	milestones: z.ZodOptional<z.ZodArray<z.ZodObject<{
		budget: z.ZodOptional<z.ZodObject<{
			category: z.ZodOptional<z.ZodObject<{
				id: z.ZodOptional<z.ZodString>;
				name: z.ZodString;
				description: z.ZodString;
				subcategories: z.ZodArray<z.ZodString, "many">;
			}, "strip", z.ZodTypeAny, {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			}, {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			}>>;
			description: z.ZodString;
			endDate: z.ZodString;
			id: z.ZodOptional<z.ZodString>;
			name: z.ZodString;
			startDate: z.ZodString;
		}, "strip", z.ZodTypeAny, {
			name: string;
			description: string;
			endDate: string;
			startDate: string;
			category?: {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			} | undefined;
			id?: string | undefined;
		}, {
			name: string;
			description: string;
			endDate: string;
			startDate: string;
			category?: {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			} | undefined;
			id?: string | undefined;
		}>>;
		description: z.ZodString;
		id: z.ZodOptional<z.ZodString>;
		isCompleted: z.ZodOptional<z.ZodBoolean>;
		name: z.ZodString;
		targetAmount: z.ZodString;
		targetDate: z.ZodString;
	}, "strip", z.ZodTypeAny, {
		name: string;
		description: string;
		targetAmount: string;
		targetDate: string;
		budget?: {
			name: string;
			description: string;
			endDate: string;
			startDate: string;
			category?: {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			} | undefined;
			id?: string | undefined;
		} | undefined;
		id?: string | undefined;
		isCompleted?: boolean | undefined;
	}, {
		name: string;
		description: string;
		targetAmount: string;
		targetDate: string;
		budget?: {
			name: string;
			description: string;
			endDate: string;
			startDate: string;
			category?: {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			} | undefined;
			id?: string | undefined;
		} | undefined;
		id?: string | undefined;
		isCompleted?: boolean | undefined;
	}>, "many">>;
	name: z.ZodString;
	startDate: z.ZodString;
	targetAmount: z.ZodString;
	userId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
	name: string;
	description: string;
	endDate: string;
	startDate: string;
	targetAmount: string;
	goalType: "GOAL_TYPE_SAVINGS" | "GOAL_TYPE_INVESTMENT" | "GOAL_TYPE_DEBT" | "GOAL_TYPE_EXPENSE";
	currentAmount?: string | undefined;
	duration?: string | undefined;
	forecasts?: {
		forecastedAmount?: string | undefined;
		forecastedCompletionDate?: string | undefined;
		id?: string | undefined;
		varianceAmount?: string | undefined;
	}[] | undefined;
	id?: string | undefined;
	isCompleted?: boolean | undefined;
	milestones?: {
		name: string;
		description: string;
		targetAmount: string;
		targetDate: string;
		budget?: {
			name: string;
			description: string;
			endDate: string;
			startDate: string;
			category?: {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			} | undefined;
			id?: string | undefined;
		} | undefined;
		id?: string | undefined;
		isCompleted?: boolean | undefined;
	}[] | undefined;
	userId?: string | undefined;
}, {
	name: string;
	description: string;
	endDate: string;
	startDate: string;
	targetAmount: string;
	goalType: "GOAL_TYPE_SAVINGS" | "GOAL_TYPE_INVESTMENT" | "GOAL_TYPE_DEBT" | "GOAL_TYPE_EXPENSE";
	currentAmount?: string | undefined;
	duration?: string | undefined;
	forecasts?: {
		forecastedAmount?: string | undefined;
		forecastedCompletionDate?: string | undefined;
		id?: string | undefined;
		varianceAmount?: string | undefined;
	}[] | undefined;
	id?: string | undefined;
	isCompleted?: boolean | undefined;
	milestones?: {
		name: string;
		description: string;
		targetAmount: string;
		targetDate: string;
		budget?: {
			name: string;
			description: string;
			endDate: string;
			startDate: string;
			category?: {
				name: string;
				description: string;
				subcategories: string[];
				id?: string | undefined;
			} | undefined;
			id?: string | undefined;
		} | undefined;
		id?: string | undefined;
		isCompleted?: boolean | undefined;
	}[] | undefined;
	userId?: string | undefined;
}>;
export type SmartGoalZodSchema = z.infer<typeof smartGoalSchema>;
export type FormReturnProps = UseFormReturn<SmartGoalZodSchema, any, undefined>;
export declare const BankAccountSelector: React.FC<{
	accounts: BankAccount[];
	selectedAccount?: BankAccount;
	setSelectedAccount: (account: BankAccount) => void;
}>;
export declare const MultiStepSmartGoalForm: React.FC<{
	className?: string;
	callback: (smartGoal: SmartGoal) => void;
	bankAccounts: BankAccount[];
	userName: string;
	userProfileImage: string;
	globalFinancialContext: MelodyFinancialContext;
	userAccount: UserAccountClass;
	instrumentationCallback?: () => void;
	userId: string;
	apiToken: string;
	model: OpenAIModel;
	temperature: number;
	top_p: number;
	frequency_penalty: number;
	presence_penalty: number;
	max_tokens: number;
}>;
export declare const MultiStepCreateBusinessAccountForm: React.FC<{
	className?: string;
	callback: (data: CreateAccountV2RequestClass) => void;
	instrumentationCallback?: () => void;
}>;

export {};
