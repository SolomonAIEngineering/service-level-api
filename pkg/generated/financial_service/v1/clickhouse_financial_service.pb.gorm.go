package financial_servicev1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	anypb "google.golang.org/protobuf/types/known/anypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type InvestmentTransactionORM struct {
	AccountId               string
	Ammount                 string
	Amount                  float64
	CreatedAt               string
	CurrentDate             string
	Fees                    float64
	Id                      string
	InvestmentTransactionId string
	IsoCurrencyCode         string
	LinkId                  uint64
	Name                    string
	Price                   float64
	Quantity                float64
	SecurityId              string
	Sign                    int32
	Subtype                 string
	Time                    *time.Time
	Type                    string
	UnofficialCurrencyCode  string
	UserId                  uint64
}

// TableName overrides the default tablename generated by GORM
func (InvestmentTransactionORM) TableName() string {
	return "investment_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentTransaction) ToORM(ctx context.Context) (InvestmentTransactionORM, error) {
	to := InvestmentTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.CurrentDate = m.CurrentDate
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	to.CreatedAt = m.CreatedAt
	to.Sign = m.Sign
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	if posthook, ok := interface{}(m).(InvestmentTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentTransactionORM) ToPB(ctx context.Context) (InvestmentTransaction, error) {
	to := InvestmentTransaction{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.CurrentDate = m.CurrentDate
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	to.CreatedAt = m.CreatedAt
	to.Sign = m.Sign
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	if posthook, ok := interface{}(m).(InvestmentTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentTransaction the arg will be the target, the caller the one being converted from

// InvestmentTransactionBeforeToORM called before default ToORM code
type InvestmentTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentTransactionORM) error
}

// InvestmentTransactionAfterToORM called after default ToORM code
type InvestmentTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentTransactionORM) error
}

// InvestmentTransactionBeforeToPB called before default ToPB code
type InvestmentTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentTransaction) error
}

// InvestmentTransactionAfterToPB called after default ToPB code
type InvestmentTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentTransaction) error
}

type ReOccuringTransactionORM struct {
	AccountId                       string
	AverageAmount                   string
	AverageAmountIsoCurrencyCode    string
	CategoryId                      string
	Description                     string
	FirstDate                       string
	Flow                            string
	Frequency                       string
	Id                              string
	IsActive                        bool
	LastAmount                      string
	LastAmountIsoCurrencyCode       string
	LastDate                        string
	LinkId                          uint64
	MerchantName                    string
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Sign                            int32
	Status                          string
	StreamId                        string
	Time                            *time.Time
	TransactionIds                  string
	UpdatedTime                     string
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (ReOccuringTransactionORM) TableName() string {
	return "re_occuring_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReOccuringTransaction) ToORM(ctx context.Context) (ReOccuringTransactionORM, error) {
	to := ReOccuringTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(ReOccuringTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.FirstDate = m.FirstDate
	to.LastDate = m.LastDate
	to.Frequency = ReOccuringTransactionsFrequency_name[int32(m.Frequency)]
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = ReOccuringTransactionsStatus_name[int32(m.Status)]
	to.UpdatedTime = m.UpdatedTime
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = ReCurringFlow_name[int32(m.Flow)]
	to.Sign = m.Sign
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	if posthook, ok := interface{}(m).(ReOccuringTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReOccuringTransactionORM) ToPB(ctx context.Context) (ReOccuringTransaction, error) {
	to := ReOccuringTransaction{}
	var err error
	if prehook, ok := interface{}(m).(ReOccuringTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.FirstDate = m.FirstDate
	to.LastDate = m.LastDate
	to.Frequency = ReOccuringTransactionsFrequency(ReOccuringTransactionsFrequency_value[m.Frequency])
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = ReOccuringTransactionsStatus(ReOccuringTransactionsStatus_value[m.Status])
	to.UpdatedTime = m.UpdatedTime
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = ReCurringFlow(ReCurringFlow_value[m.Flow])
	to.Sign = m.Sign
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	if posthook, ok := interface{}(m).(ReOccuringTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReOccuringTransaction the arg will be the target, the caller the one being converted from

// ReOccuringTransactionBeforeToORM called before default ToORM code
type ReOccuringTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReOccuringTransactionORM) error
}

// ReOccuringTransactionAfterToORM called after default ToORM code
type ReOccuringTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *ReOccuringTransactionORM) error
}

// ReOccuringTransactionBeforeToPB called before default ToPB code
type ReOccuringTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReOccuringTransaction) error
}

// ReOccuringTransactionAfterToPB called after default ToPB code
type ReOccuringTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *ReOccuringTransaction) error
}

type TransactionORM struct {
	AccountId                       string
	AccountOwner                    string
	Amount                          float64
	AuthorizedDate                  string
	AuthorizedDatetime              string
	Categories                      pq.StringArray `gorm:"type:Array(String)"`
	CategoryId                      string
	CheckNumber                     string
	CurrentDate                     string
	CurrentDatetime                 string
	Id                              string
	IsoCurrencyCode                 string
	LinkId                          uint64
	LocationAddress                 string
	LocationCity                    string
	LocationCountry                 string
	LocationLat                     float64
	LocationLon                     float64
	LocationPostalCode              string
	LocationRegion                  string
	LocationStoreNumber             string
	MerchantName                    string
	Name                            string
	PaymentChannel                  string
	PaymentMetaByOrderOf            string
	PaymentMetaPayee                string
	PaymentMetaPayer                string
	PaymentMetaPaymentMethod        string
	PaymentMetaPaymentProcessor     string
	PaymentMetaPpdId                string
	PaymentMetaReason               string
	PaymentMetaReferenceNumber      string
	Pending                         bool
	PendingTransactionId            string
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Sign                            int32
	Time                            *time.Time
	TransactionCode                 string
	TransactionId                   string
	UnofficialCurrencyCode          string
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (TransactionORM) TableName() string {
	return "transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Transaction) ToORM(ctx context.Context) (TransactionORM, error) {
	to := TransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.CategoryId = m.CategoryId
	to.CheckNumber = m.CheckNumber
	to.CurrentDate = m.CurrentDate
	to.CurrentDatetime = m.CurrentDatetime
	to.AuthorizedDate = m.AuthorizedDate
	to.AuthorizedDatetime = m.AuthorizedDatetime
	to.Name = m.Name
	to.MerchantName = m.MerchantName
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Sign = m.Sign
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	if posthook, ok := interface{}(m).(TransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionORM) ToPB(ctx context.Context) (Transaction, error) {
	to := Transaction{}
	var err error
	if prehook, ok := interface{}(m).(TransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.CategoryId = m.CategoryId
	to.CheckNumber = m.CheckNumber
	to.CurrentDate = m.CurrentDate
	to.CurrentDatetime = m.CurrentDatetime
	to.AuthorizedDate = m.AuthorizedDate
	to.AuthorizedDatetime = m.AuthorizedDatetime
	to.Name = m.Name
	to.MerchantName = m.MerchantName
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Sign = m.Sign
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	if posthook, ok := interface{}(m).(TransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Transaction the arg will be the target, the caller the one being converted from

// TransactionBeforeToORM called before default ToORM code
type TransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionORM) error
}

// TransactionAfterToORM called after default ToORM code
type TransactionWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionORM) error
}

// TransactionBeforeToPB called before default ToPB code
type TransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Transaction) error
}

// TransactionAfterToPB called after default ToPB code
type TransactionWithAfterToPB interface {
	AfterToPB(context.Context, *Transaction) error
}

type AccountBalanceHistoryORM struct {
	AccountId       string
	Balance         float64
	Id              string
	IsoCurrencyCode string
	Sign            uint32
	Time            *time.Time
	UserId          uint64
}

// TableName overrides the default tablename generated by GORM
func (AccountBalanceHistoryORM) TableName() string {
	return "account_balance_histories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountBalanceHistory) ToORM(ctx context.Context) (AccountBalanceHistoryORM, error) {
	to := AccountBalanceHistoryORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountBalanceHistoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	to.AccountId = m.AccountId
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Balance = m.Balance
	to.UserId = m.UserId
	to.Sign = m.Sign
	to.Id = m.Id
	if posthook, ok := interface{}(m).(AccountBalanceHistoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountBalanceHistoryORM) ToPB(ctx context.Context) (AccountBalanceHistory, error) {
	to := AccountBalanceHistory{}
	var err error
	if prehook, ok := interface{}(m).(AccountBalanceHistoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	to.AccountId = m.AccountId
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Balance = m.Balance
	to.UserId = m.UserId
	to.Sign = m.Sign
	to.Id = m.Id
	if posthook, ok := interface{}(m).(AccountBalanceHistoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountBalanceHistory the arg will be the target, the caller the one being converted from

// AccountBalanceHistoryBeforeToORM called before default ToORM code
type AccountBalanceHistoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountBalanceHistoryORM) error
}

// AccountBalanceHistoryAfterToORM called after default ToORM code
type AccountBalanceHistoryWithAfterToORM interface {
	AfterToORM(context.Context, *AccountBalanceHistoryORM) error
}

// AccountBalanceHistoryBeforeToPB called before default ToPB code
type AccountBalanceHistoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountBalanceHistory) error
}

// AccountBalanceHistoryAfterToPB called after default ToPB code
type AccountBalanceHistoryWithAfterToPB interface {
	AfterToPB(context.Context, *AccountBalanceHistory) error
}

type CategoryMetricsFinancialSubProfileORM struct {
	Month                          uint32
	PersonalFinanceCategoryPrimary string
	SpentLastMonth                 float64
	SpentLastSixMonths             float64
	SpentLastTwoWeeks              float64
	SpentLastTwoYears              float64
	SpentLastWeek                  float64
	SpentLastYear                  float64
	TransactionCount               uint64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (CategoryMetricsFinancialSubProfileORM) TableName() string {
	return "category_metrics_financial_sub_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CategoryMetricsFinancialSubProfile) ToORM(ctx context.Context) (CategoryMetricsFinancialSubProfileORM, error) {
	to := CategoryMetricsFinancialSubProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMetricsFinancialSubProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMetricsFinancialSubProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryMetricsFinancialSubProfileORM) ToPB(ctx context.Context) (CategoryMetricsFinancialSubProfile, error) {
	to := CategoryMetricsFinancialSubProfile{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMetricsFinancialSubProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMetricsFinancialSubProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CategoryMetricsFinancialSubProfile the arg will be the target, the caller the one being converted from

// CategoryMetricsFinancialSubProfileBeforeToORM called before default ToORM code
type CategoryMetricsFinancialSubProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryMetricsFinancialSubProfileORM) error
}

// CategoryMetricsFinancialSubProfileAfterToORM called after default ToORM code
type CategoryMetricsFinancialSubProfileWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryMetricsFinancialSubProfileORM) error
}

// CategoryMetricsFinancialSubProfileBeforeToPB called before default ToPB code
type CategoryMetricsFinancialSubProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *CategoryMetricsFinancialSubProfile) error
}

// CategoryMetricsFinancialSubProfileAfterToPB called after default ToPB code
type CategoryMetricsFinancialSubProfileWithAfterToPB interface {
	AfterToPB(context.Context, *CategoryMetricsFinancialSubProfile) error
}

type CategoryMonthlyExpenditureORM struct {
	Month                          uint32
	PersonalFinanceCategoryPrimary string
	TotalSpending                  float64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (CategoryMonthlyExpenditureORM) TableName() string {
	return "category_monthly_expenditures"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CategoryMonthlyExpenditure) ToORM(ctx context.Context) (CategoryMonthlyExpenditureORM, error) {
	to := CategoryMonthlyExpenditureORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMonthlyExpenditureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMonthlyExpenditureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryMonthlyExpenditureORM) ToPB(ctx context.Context) (CategoryMonthlyExpenditure, error) {
	to := CategoryMonthlyExpenditure{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMonthlyExpenditureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMonthlyExpenditureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CategoryMonthlyExpenditure the arg will be the target, the caller the one being converted from

// CategoryMonthlyExpenditureBeforeToORM called before default ToORM code
type CategoryMonthlyExpenditureWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryMonthlyExpenditureORM) error
}

// CategoryMonthlyExpenditureAfterToORM called after default ToORM code
type CategoryMonthlyExpenditureWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryMonthlyExpenditureORM) error
}

// CategoryMonthlyExpenditureBeforeToPB called before default ToPB code
type CategoryMonthlyExpenditureWithBeforeToPB interface {
	BeforeToPB(context.Context, *CategoryMonthlyExpenditure) error
}

// CategoryMonthlyExpenditureAfterToPB called after default ToPB code
type CategoryMonthlyExpenditureWithAfterToPB interface {
	AfterToPB(context.Context, *CategoryMonthlyExpenditure) error
}

type CategoryMonthlyIncomeORM struct {
	Month                          uint32
	PersonalFinanceCategoryPrimary string
	TotalIncome                    float64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (CategoryMonthlyIncomeORM) TableName() string {
	return "category_monthly_incomes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CategoryMonthlyIncome) ToORM(ctx context.Context) (CategoryMonthlyIncomeORM, error) {
	to := CategoryMonthlyIncomeORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMonthlyIncomeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TotalIncome = m.TotalIncome
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMonthlyIncomeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryMonthlyIncomeORM) ToPB(ctx context.Context) (CategoryMonthlyIncome, error) {
	to := CategoryMonthlyIncome{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMonthlyIncomeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TotalIncome = m.TotalIncome
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMonthlyIncomeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CategoryMonthlyIncome the arg will be the target, the caller the one being converted from

// CategoryMonthlyIncomeBeforeToORM called before default ToORM code
type CategoryMonthlyIncomeWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryMonthlyIncomeORM) error
}

// CategoryMonthlyIncomeAfterToORM called after default ToORM code
type CategoryMonthlyIncomeWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryMonthlyIncomeORM) error
}

// CategoryMonthlyIncomeBeforeToPB called before default ToPB code
type CategoryMonthlyIncomeWithBeforeToPB interface {
	BeforeToPB(context.Context, *CategoryMonthlyIncome) error
}

// CategoryMonthlyIncomeAfterToPB called after default ToPB code
type CategoryMonthlyIncomeWithAfterToPB interface {
	AfterToPB(context.Context, *CategoryMonthlyIncome) error
}

type CategoryMonthlyTransactionCountORM struct {
	Month                          uint32
	PersonalFinanceCategoryPrimary string
	TransactionCount               uint32
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (CategoryMonthlyTransactionCountORM) TableName() string {
	return "category_monthly_transaction_counts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CategoryMonthlyTransactionCount) ToORM(ctx context.Context) (CategoryMonthlyTransactionCountORM, error) {
	to := CategoryMonthlyTransactionCountORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMonthlyTransactionCountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMonthlyTransactionCountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryMonthlyTransactionCountORM) ToPB(ctx context.Context) (CategoryMonthlyTransactionCount, error) {
	to := CategoryMonthlyTransactionCount{}
	var err error
	if prehook, ok := interface{}(m).(CategoryMonthlyTransactionCountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(CategoryMonthlyTransactionCountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CategoryMonthlyTransactionCount the arg will be the target, the caller the one being converted from

// CategoryMonthlyTransactionCountBeforeToORM called before default ToORM code
type CategoryMonthlyTransactionCountWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryMonthlyTransactionCountORM) error
}

// CategoryMonthlyTransactionCountAfterToORM called after default ToORM code
type CategoryMonthlyTransactionCountWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryMonthlyTransactionCountORM) error
}

// CategoryMonthlyTransactionCountBeforeToPB called before default ToPB code
type CategoryMonthlyTransactionCountWithBeforeToPB interface {
	BeforeToPB(context.Context, *CategoryMonthlyTransactionCount) error
}

// CategoryMonthlyTransactionCountAfterToPB called after default ToPB code
type CategoryMonthlyTransactionCountWithAfterToPB interface {
	AfterToPB(context.Context, *CategoryMonthlyTransactionCount) error
}

type DebtToIncomeRatioORM struct {
	Month  uint32
	Ratio  float64
	UserId uint64
}

// TableName overrides the default tablename generated by GORM
func (DebtToIncomeRatioORM) TableName() string {
	return "debt_to_income_ratios"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DebtToIncomeRatio) ToORM(ctx context.Context) (DebtToIncomeRatioORM, error) {
	to := DebtToIncomeRatioORM{}
	var err error
	if prehook, ok := interface{}(m).(DebtToIncomeRatioWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.Ratio = m.Ratio
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(DebtToIncomeRatioWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DebtToIncomeRatioORM) ToPB(ctx context.Context) (DebtToIncomeRatio, error) {
	to := DebtToIncomeRatio{}
	var err error
	if prehook, ok := interface{}(m).(DebtToIncomeRatioWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.Ratio = m.Ratio
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(DebtToIncomeRatioWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DebtToIncomeRatio the arg will be the target, the caller the one being converted from

// DebtToIncomeRatioBeforeToORM called before default ToORM code
type DebtToIncomeRatioWithBeforeToORM interface {
	BeforeToORM(context.Context, *DebtToIncomeRatioORM) error
}

// DebtToIncomeRatioAfterToORM called after default ToORM code
type DebtToIncomeRatioWithAfterToORM interface {
	AfterToORM(context.Context, *DebtToIncomeRatioORM) error
}

// DebtToIncomeRatioBeforeToPB called before default ToPB code
type DebtToIncomeRatioWithBeforeToPB interface {
	BeforeToPB(context.Context, *DebtToIncomeRatio) error
}

// DebtToIncomeRatioAfterToPB called after default ToPB code
type DebtToIncomeRatioWithAfterToPB interface {
	AfterToPB(context.Context, *DebtToIncomeRatio) error
}

type ExpenseMetricsORM struct {
	Month                          uint32
	PersonalFinanceCategoryPrimary string
	TotalExpenses                  float64
	TransactionCount               uint64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (ExpenseMetricsORM) TableName() string {
	return "expense_metrics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExpenseMetrics) ToORM(ctx context.Context) (ExpenseMetricsORM, error) {
	to := ExpenseMetricsORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseMetricsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.TotalExpenses = m.TotalExpenses
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(ExpenseMetricsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseMetricsORM) ToPB(ctx context.Context) (ExpenseMetrics, error) {
	to := ExpenseMetrics{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseMetricsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.TotalExpenses = m.TotalExpenses
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(ExpenseMetricsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExpenseMetrics the arg will be the target, the caller the one being converted from

// ExpenseMetricsBeforeToORM called before default ToORM code
type ExpenseMetricsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseMetricsORM) error
}

// ExpenseMetricsAfterToORM called after default ToORM code
type ExpenseMetricsWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseMetricsORM) error
}

// ExpenseMetricsBeforeToPB called before default ToPB code
type ExpenseMetricsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExpenseMetrics) error
}

// ExpenseMetricsAfterToPB called after default ToPB code
type ExpenseMetricsWithAfterToPB interface {
	AfterToPB(context.Context, *ExpenseMetrics) error
}

type ExpenseMetricsFinancialSubProfileMetricsORM struct {
	AverageMonthlyDiscretionarySpending float64
	AverageMonthlyRecurringSpending     float64
	Month                               uint32
	SpentLastMonth                      float64
	SpentLastSixMonths                  float64
	SpentLastWeek                       float64
	UserId                              uint64
}

// TableName overrides the default tablename generated by GORM
func (ExpenseMetricsFinancialSubProfileMetricsORM) TableName() string {
	return "expense_metrics_financial_sub_profile_metrics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExpenseMetricsFinancialSubProfileMetrics) ToORM(ctx context.Context) (ExpenseMetricsFinancialSubProfileMetricsORM, error) {
	to := ExpenseMetricsFinancialSubProfileMetricsORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseMetricsFinancialSubProfileMetricsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.AverageMonthlyDiscretionarySpending = m.AverageMonthlyDiscretionarySpending
	to.AverageMonthlyRecurringSpending = m.AverageMonthlyRecurringSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(ExpenseMetricsFinancialSubProfileMetricsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseMetricsFinancialSubProfileMetricsORM) ToPB(ctx context.Context) (ExpenseMetricsFinancialSubProfileMetrics, error) {
	to := ExpenseMetricsFinancialSubProfileMetrics{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseMetricsFinancialSubProfileMetricsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.AverageMonthlyDiscretionarySpending = m.AverageMonthlyDiscretionarySpending
	to.AverageMonthlyRecurringSpending = m.AverageMonthlyRecurringSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(ExpenseMetricsFinancialSubProfileMetricsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExpenseMetricsFinancialSubProfileMetrics the arg will be the target, the caller the one being converted from

// ExpenseMetricsFinancialSubProfileMetricsBeforeToORM called before default ToORM code
type ExpenseMetricsFinancialSubProfileMetricsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseMetricsFinancialSubProfileMetricsORM) error
}

// ExpenseMetricsFinancialSubProfileMetricsAfterToORM called after default ToORM code
type ExpenseMetricsFinancialSubProfileMetricsWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseMetricsFinancialSubProfileMetricsORM) error
}

// ExpenseMetricsFinancialSubProfileMetricsBeforeToPB called before default ToPB code
type ExpenseMetricsFinancialSubProfileMetricsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExpenseMetricsFinancialSubProfileMetrics) error
}

// ExpenseMetricsFinancialSubProfileMetricsAfterToPB called after default ToPB code
type ExpenseMetricsFinancialSubProfileMetricsWithAfterToPB interface {
	AfterToPB(context.Context, *ExpenseMetricsFinancialSubProfileMetrics) error
}

type FinancialProfileORM struct {
	Month                 uint32
	MostExpensiveCategory string
	NumberOfTransactions  uint64
	TotalExpenses         float64
	TotalIncome           float64
	UserId                uint64
}

// TableName overrides the default tablename generated by GORM
func (FinancialProfileORM) TableName() string {
	return "financial_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FinancialProfile) ToORM(ctx context.Context) (FinancialProfileORM, error) {
	to := FinancialProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(FinancialProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TotalIncome = m.TotalIncome
	to.TotalExpenses = m.TotalExpenses
	to.NumberOfTransactions = m.NumberOfTransactions
	to.MostExpensiveCategory = m.MostExpensiveCategory
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(FinancialProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FinancialProfileORM) ToPB(ctx context.Context) (FinancialProfile, error) {
	to := FinancialProfile{}
	var err error
	if prehook, ok := interface{}(m).(FinancialProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TotalIncome = m.TotalIncome
	to.TotalExpenses = m.TotalExpenses
	to.NumberOfTransactions = m.NumberOfTransactions
	to.MostExpensiveCategory = m.MostExpensiveCategory
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(FinancialProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FinancialProfile the arg will be the target, the caller the one being converted from

// FinancialProfileBeforeToORM called before default ToORM code
type FinancialProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *FinancialProfileORM) error
}

// FinancialProfileAfterToORM called after default ToORM code
type FinancialProfileWithAfterToORM interface {
	AfterToORM(context.Context, *FinancialProfileORM) error
}

// FinancialProfileBeforeToPB called before default ToPB code
type FinancialProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *FinancialProfile) error
}

// FinancialProfileAfterToPB called after default ToPB code
type FinancialProfileWithAfterToPB interface {
	AfterToPB(context.Context, *FinancialProfile) error
}

type IncomeExpenseRatioORM struct {
	Month  uint32
	Ratio  float64
	UserId uint64
}

// TableName overrides the default tablename generated by GORM
func (IncomeExpenseRatioORM) TableName() string {
	return "income_expense_ratios"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IncomeExpenseRatio) ToORM(ctx context.Context) (IncomeExpenseRatioORM, error) {
	to := IncomeExpenseRatioORM{}
	var err error
	if prehook, ok := interface{}(m).(IncomeExpenseRatioWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.Ratio = m.Ratio
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(IncomeExpenseRatioWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IncomeExpenseRatioORM) ToPB(ctx context.Context) (IncomeExpenseRatio, error) {
	to := IncomeExpenseRatio{}
	var err error
	if prehook, ok := interface{}(m).(IncomeExpenseRatioWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.Ratio = m.Ratio
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(IncomeExpenseRatioWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IncomeExpenseRatio the arg will be the target, the caller the one being converted from

// IncomeExpenseRatioBeforeToORM called before default ToORM code
type IncomeExpenseRatioWithBeforeToORM interface {
	BeforeToORM(context.Context, *IncomeExpenseRatioORM) error
}

// IncomeExpenseRatioAfterToORM called after default ToORM code
type IncomeExpenseRatioWithAfterToORM interface {
	AfterToORM(context.Context, *IncomeExpenseRatioORM) error
}

// IncomeExpenseRatioBeforeToPB called before default ToPB code
type IncomeExpenseRatioWithBeforeToPB interface {
	BeforeToPB(context.Context, *IncomeExpenseRatio) error
}

// IncomeExpenseRatioAfterToPB called after default ToPB code
type IncomeExpenseRatioWithAfterToPB interface {
	AfterToPB(context.Context, *IncomeExpenseRatio) error
}

type IncomeMetricsORM struct {
	Month                          uint32
	PersonalFinanceCategoryPrimary string
	TotalIncome                    float64
	TransactionCount               uint64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (IncomeMetricsORM) TableName() string {
	return "income_metrics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IncomeMetrics) ToORM(ctx context.Context) (IncomeMetricsORM, error) {
	to := IncomeMetricsORM{}
	var err error
	if prehook, ok := interface{}(m).(IncomeMetricsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.TotalIncome = m.TotalIncome
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(IncomeMetricsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IncomeMetricsORM) ToPB(ctx context.Context) (IncomeMetrics, error) {
	to := IncomeMetrics{}
	var err error
	if prehook, ok := interface{}(m).(IncomeMetricsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.TransactionCount = m.TransactionCount
	to.TotalIncome = m.TotalIncome
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(IncomeMetricsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IncomeMetrics the arg will be the target, the caller the one being converted from

// IncomeMetricsBeforeToORM called before default ToORM code
type IncomeMetricsWithBeforeToORM interface {
	BeforeToORM(context.Context, *IncomeMetricsORM) error
}

// IncomeMetricsAfterToORM called after default ToORM code
type IncomeMetricsWithAfterToORM interface {
	AfterToORM(context.Context, *IncomeMetricsORM) error
}

// IncomeMetricsBeforeToPB called before default ToPB code
type IncomeMetricsWithBeforeToPB interface {
	BeforeToPB(context.Context, *IncomeMetrics) error
}

// IncomeMetricsAfterToPB called after default ToPB code
type IncomeMetricsWithAfterToPB interface {
	AfterToPB(context.Context, *IncomeMetrics) error
}

type IncomeMetricsFinancialSubProfileORM struct {
	IncomeLastMonth     float64
	IncomeLastSixMonths float64
	IncomeLastTwoMonths float64
	IncomeLastTwoWeeks  float64
	IncomeLastYear      float64
	Month               uint32
	UserId              uint64
}

// TableName overrides the default tablename generated by GORM
func (IncomeMetricsFinancialSubProfileORM) TableName() string {
	return "income_metrics_financial_sub_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IncomeMetricsFinancialSubProfile) ToORM(ctx context.Context) (IncomeMetricsFinancialSubProfileORM, error) {
	to := IncomeMetricsFinancialSubProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(IncomeMetricsFinancialSubProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.IncomeLastTwoWeeks = m.IncomeLastTwoWeeks
	to.IncomeLastMonth = m.IncomeLastMonth
	to.IncomeLastTwoMonths = m.IncomeLastTwoMonths
	to.IncomeLastSixMonths = m.IncomeLastSixMonths
	to.IncomeLastYear = m.IncomeLastYear
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(IncomeMetricsFinancialSubProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IncomeMetricsFinancialSubProfileORM) ToPB(ctx context.Context) (IncomeMetricsFinancialSubProfile, error) {
	to := IncomeMetricsFinancialSubProfile{}
	var err error
	if prehook, ok := interface{}(m).(IncomeMetricsFinancialSubProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.IncomeLastTwoWeeks = m.IncomeLastTwoWeeks
	to.IncomeLastMonth = m.IncomeLastMonth
	to.IncomeLastTwoMonths = m.IncomeLastTwoMonths
	to.IncomeLastSixMonths = m.IncomeLastSixMonths
	to.IncomeLastYear = m.IncomeLastYear
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(IncomeMetricsFinancialSubProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IncomeMetricsFinancialSubProfile the arg will be the target, the caller the one being converted from

// IncomeMetricsFinancialSubProfileBeforeToORM called before default ToORM code
type IncomeMetricsFinancialSubProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *IncomeMetricsFinancialSubProfileORM) error
}

// IncomeMetricsFinancialSubProfileAfterToORM called after default ToORM code
type IncomeMetricsFinancialSubProfileWithAfterToORM interface {
	AfterToORM(context.Context, *IncomeMetricsFinancialSubProfileORM) error
}

// IncomeMetricsFinancialSubProfileBeforeToPB called before default ToPB code
type IncomeMetricsFinancialSubProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *IncomeMetricsFinancialSubProfile) error
}

// IncomeMetricsFinancialSubProfileAfterToPB called after default ToPB code
type IncomeMetricsFinancialSubProfileWithAfterToPB interface {
	AfterToPB(context.Context, *IncomeMetricsFinancialSubProfile) error
}

type LocationFinancialSubProfileORM struct {
	LocationCity       string
	Month              uint32
	SpentLastMonth     float64
	SpentLastSixMonths float64
	SpentLastTwoWeeks  float64
	SpentLastTwoYears  float64
	SpentLastWeek      float64
	SpentLastYear      float64
	TransactionCount   uint64
	UserId             uint64
}

// TableName overrides the default tablename generated by GORM
func (LocationFinancialSubProfileORM) TableName() string {
	return "location_financial_sub_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LocationFinancialSubProfile) ToORM(ctx context.Context) (LocationFinancialSubProfileORM, error) {
	to := LocationFinancialSubProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(LocationFinancialSubProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.LocationCity = m.LocationCity
	to.TransactionCount = m.TransactionCount
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	to.Month = m.Month
	if posthook, ok := interface{}(m).(LocationFinancialSubProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LocationFinancialSubProfileORM) ToPB(ctx context.Context) (LocationFinancialSubProfile, error) {
	to := LocationFinancialSubProfile{}
	var err error
	if prehook, ok := interface{}(m).(LocationFinancialSubProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.LocationCity = m.LocationCity
	to.TransactionCount = m.TransactionCount
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	to.Month = m.Month
	if posthook, ok := interface{}(m).(LocationFinancialSubProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LocationFinancialSubProfile the arg will be the target, the caller the one being converted from

// LocationFinancialSubProfileBeforeToORM called before default ToORM code
type LocationFinancialSubProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *LocationFinancialSubProfileORM) error
}

// LocationFinancialSubProfileAfterToORM called after default ToORM code
type LocationFinancialSubProfileWithAfterToORM interface {
	AfterToORM(context.Context, *LocationFinancialSubProfileORM) error
}

// LocationFinancialSubProfileBeforeToPB called before default ToPB code
type LocationFinancialSubProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *LocationFinancialSubProfile) error
}

// LocationFinancialSubProfileAfterToPB called after default ToPB code
type LocationFinancialSubProfileWithAfterToPB interface {
	AfterToPB(context.Context, *LocationFinancialSubProfile) error
}

type MerchantMetricsFinancialSubProfileORM struct {
	MerchantName       string
	Month              uint32
	SpentLastMonth     float64
	SpentLastSixMonths float64
	SpentLastTwoWeeks  float64
	SpentLastTwoYears  float64
	SpentLastWeek      float64
	SpentLastYear      float64
	UserId             uint64
}

// TableName overrides the default tablename generated by GORM
func (MerchantMetricsFinancialSubProfileORM) TableName() string {
	return "merchant_metrics_financial_sub_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MerchantMetricsFinancialSubProfile) ToORM(ctx context.Context) (MerchantMetricsFinancialSubProfileORM, error) {
	to := MerchantMetricsFinancialSubProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(MerchantMetricsFinancialSubProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MerchantName = m.MerchantName
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	to.Month = m.Month
	if posthook, ok := interface{}(m).(MerchantMetricsFinancialSubProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MerchantMetricsFinancialSubProfileORM) ToPB(ctx context.Context) (MerchantMetricsFinancialSubProfile, error) {
	to := MerchantMetricsFinancialSubProfile{}
	var err error
	if prehook, ok := interface{}(m).(MerchantMetricsFinancialSubProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MerchantName = m.MerchantName
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	to.Month = m.Month
	if posthook, ok := interface{}(m).(MerchantMetricsFinancialSubProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MerchantMetricsFinancialSubProfile the arg will be the target, the caller the one being converted from

// MerchantMetricsFinancialSubProfileBeforeToORM called before default ToORM code
type MerchantMetricsFinancialSubProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *MerchantMetricsFinancialSubProfileORM) error
}

// MerchantMetricsFinancialSubProfileAfterToORM called after default ToORM code
type MerchantMetricsFinancialSubProfileWithAfterToORM interface {
	AfterToORM(context.Context, *MerchantMetricsFinancialSubProfileORM) error
}

// MerchantMetricsFinancialSubProfileBeforeToPB called before default ToPB code
type MerchantMetricsFinancialSubProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *MerchantMetricsFinancialSubProfile) error
}

// MerchantMetricsFinancialSubProfileAfterToPB called after default ToPB code
type MerchantMetricsFinancialSubProfileWithAfterToPB interface {
	AfterToPB(context.Context, *MerchantMetricsFinancialSubProfile) error
}

type MerchantMonthlyExpenditureORM struct {
	MerchantName  string
	Month         uint32
	TotalSpending float64
	UserId        uint64
}

// TableName overrides the default tablename generated by GORM
func (MerchantMonthlyExpenditureORM) TableName() string {
	return "merchant_monthly_expenditures"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MerchantMonthlyExpenditure) ToORM(ctx context.Context) (MerchantMonthlyExpenditureORM, error) {
	to := MerchantMonthlyExpenditureORM{}
	var err error
	if prehook, ok := interface{}(m).(MerchantMonthlyExpenditureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.MerchantName = m.MerchantName
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MerchantMonthlyExpenditureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MerchantMonthlyExpenditureORM) ToPB(ctx context.Context) (MerchantMonthlyExpenditure, error) {
	to := MerchantMonthlyExpenditure{}
	var err error
	if prehook, ok := interface{}(m).(MerchantMonthlyExpenditureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.MerchantName = m.MerchantName
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MerchantMonthlyExpenditureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MerchantMonthlyExpenditure the arg will be the target, the caller the one being converted from

// MerchantMonthlyExpenditureBeforeToORM called before default ToORM code
type MerchantMonthlyExpenditureWithBeforeToORM interface {
	BeforeToORM(context.Context, *MerchantMonthlyExpenditureORM) error
}

// MerchantMonthlyExpenditureAfterToORM called after default ToORM code
type MerchantMonthlyExpenditureWithAfterToORM interface {
	AfterToORM(context.Context, *MerchantMonthlyExpenditureORM) error
}

// MerchantMonthlyExpenditureBeforeToPB called before default ToPB code
type MerchantMonthlyExpenditureWithBeforeToPB interface {
	BeforeToPB(context.Context, *MerchantMonthlyExpenditure) error
}

// MerchantMonthlyExpenditureAfterToPB called after default ToPB code
type MerchantMonthlyExpenditureWithAfterToPB interface {
	AfterToPB(context.Context, *MerchantMonthlyExpenditure) error
}

type MonthlyBalanceORM struct {
	Month      uint32
	NetBalance float64
	UserId     uint64
}

// TableName overrides the default tablename generated by GORM
func (MonthlyBalanceORM) TableName() string {
	return "monthly_balances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MonthlyBalance) ToORM(ctx context.Context) (MonthlyBalanceORM, error) {
	to := MonthlyBalanceORM{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyBalanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.NetBalance = m.NetBalance
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyBalanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MonthlyBalanceORM) ToPB(ctx context.Context) (MonthlyBalance, error) {
	to := MonthlyBalance{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyBalanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.NetBalance = m.NetBalance
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyBalanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MonthlyBalance the arg will be the target, the caller the one being converted from

// MonthlyBalanceBeforeToORM called before default ToORM code
type MonthlyBalanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *MonthlyBalanceORM) error
}

// MonthlyBalanceAfterToORM called after default ToORM code
type MonthlyBalanceWithAfterToORM interface {
	AfterToORM(context.Context, *MonthlyBalanceORM) error
}

// MonthlyBalanceBeforeToPB called before default ToPB code
type MonthlyBalanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *MonthlyBalance) error
}

// MonthlyBalanceAfterToPB called after default ToPB code
type MonthlyBalanceWithAfterToPB interface {
	AfterToPB(context.Context, *MonthlyBalance) error
}

type MonthlyExpenditureORM struct {
	Month         uint32
	TotalSpending float64
	UserId        uint64
}

// TableName overrides the default tablename generated by GORM
func (MonthlyExpenditureORM) TableName() string {
	return "monthly_expenditures"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MonthlyExpenditure) ToORM(ctx context.Context) (MonthlyExpenditureORM, error) {
	to := MonthlyExpenditureORM{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyExpenditureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyExpenditureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MonthlyExpenditureORM) ToPB(ctx context.Context) (MonthlyExpenditure, error) {
	to := MonthlyExpenditure{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyExpenditureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyExpenditureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MonthlyExpenditure the arg will be the target, the caller the one being converted from

// MonthlyExpenditureBeforeToORM called before default ToORM code
type MonthlyExpenditureWithBeforeToORM interface {
	BeforeToORM(context.Context, *MonthlyExpenditureORM) error
}

// MonthlyExpenditureAfterToORM called after default ToORM code
type MonthlyExpenditureWithAfterToORM interface {
	AfterToORM(context.Context, *MonthlyExpenditureORM) error
}

// MonthlyExpenditureBeforeToPB called before default ToPB code
type MonthlyExpenditureWithBeforeToPB interface {
	BeforeToPB(context.Context, *MonthlyExpenditure) error
}

// MonthlyExpenditureAfterToPB called after default ToPB code
type MonthlyExpenditureWithAfterToPB interface {
	AfterToPB(context.Context, *MonthlyExpenditure) error
}

type MonthlyIncomeORM struct {
	Month       uint32
	TotalIncome float64
	UserId      uint64
}

// TableName overrides the default tablename generated by GORM
func (MonthlyIncomeORM) TableName() string {
	return "monthly_incomes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MonthlyIncome) ToORM(ctx context.Context) (MonthlyIncomeORM, error) {
	to := MonthlyIncomeORM{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyIncomeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TotalIncome = m.TotalIncome
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyIncomeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MonthlyIncomeORM) ToPB(ctx context.Context) (MonthlyIncome, error) {
	to := MonthlyIncome{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyIncomeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TotalIncome = m.TotalIncome
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyIncomeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MonthlyIncome the arg will be the target, the caller the one being converted from

// MonthlyIncomeBeforeToORM called before default ToORM code
type MonthlyIncomeWithBeforeToORM interface {
	BeforeToORM(context.Context, *MonthlyIncomeORM) error
}

// MonthlyIncomeAfterToORM called after default ToORM code
type MonthlyIncomeWithAfterToORM interface {
	AfterToORM(context.Context, *MonthlyIncomeORM) error
}

// MonthlyIncomeBeforeToPB called before default ToPB code
type MonthlyIncomeWithBeforeToPB interface {
	BeforeToPB(context.Context, *MonthlyIncome) error
}

// MonthlyIncomeAfterToPB called after default ToPB code
type MonthlyIncomeWithAfterToPB interface {
	AfterToPB(context.Context, *MonthlyIncome) error
}

type MonthlySavingsORM struct {
	Month      uint32
	NetSavings float64
	UserId     uint64
}

// TableName overrides the default tablename generated by GORM
func (MonthlySavingsORM) TableName() string {
	return "monthly_savings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MonthlySavings) ToORM(ctx context.Context) (MonthlySavingsORM, error) {
	to := MonthlySavingsORM{}
	var err error
	if prehook, ok := interface{}(m).(MonthlySavingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.NetSavings = m.NetSavings
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlySavingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MonthlySavingsORM) ToPB(ctx context.Context) (MonthlySavings, error) {
	to := MonthlySavings{}
	var err error
	if prehook, ok := interface{}(m).(MonthlySavingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.NetSavings = m.NetSavings
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlySavingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MonthlySavings the arg will be the target, the caller the one being converted from

// MonthlySavingsBeforeToORM called before default ToORM code
type MonthlySavingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *MonthlySavingsORM) error
}

// MonthlySavingsAfterToORM called after default ToORM code
type MonthlySavingsWithAfterToORM interface {
	AfterToORM(context.Context, *MonthlySavingsORM) error
}

// MonthlySavingsBeforeToPB called before default ToPB code
type MonthlySavingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *MonthlySavings) error
}

// MonthlySavingsAfterToPB called after default ToPB code
type MonthlySavingsWithAfterToPB interface {
	AfterToPB(context.Context, *MonthlySavings) error
}

type MonthlyTotalQuantityBySecurityAndUserORM struct {
	Month         uint32
	SecurityId    string
	TotalQuantity float64
	UserId        uint64
}

// TableName overrides the default tablename generated by GORM
func (MonthlyTotalQuantityBySecurityAndUserORM) TableName() string {
	return "monthly_total_quantity_by_security_and_users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MonthlyTotalQuantityBySecurityAndUser) ToORM(ctx context.Context) (MonthlyTotalQuantityBySecurityAndUserORM, error) {
	to := MonthlyTotalQuantityBySecurityAndUserORM{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyTotalQuantityBySecurityAndUserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.SecurityId = m.SecurityId
	to.TotalQuantity = m.TotalQuantity
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyTotalQuantityBySecurityAndUserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MonthlyTotalQuantityBySecurityAndUserORM) ToPB(ctx context.Context) (MonthlyTotalQuantityBySecurityAndUser, error) {
	to := MonthlyTotalQuantityBySecurityAndUser{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyTotalQuantityBySecurityAndUserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.SecurityId = m.SecurityId
	to.TotalQuantity = m.TotalQuantity
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyTotalQuantityBySecurityAndUserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MonthlyTotalQuantityBySecurityAndUser the arg will be the target, the caller the one being converted from

// MonthlyTotalQuantityBySecurityAndUserBeforeToORM called before default ToORM code
type MonthlyTotalQuantityBySecurityAndUserWithBeforeToORM interface {
	BeforeToORM(context.Context, *MonthlyTotalQuantityBySecurityAndUserORM) error
}

// MonthlyTotalQuantityBySecurityAndUserAfterToORM called after default ToORM code
type MonthlyTotalQuantityBySecurityAndUserWithAfterToORM interface {
	AfterToORM(context.Context, *MonthlyTotalQuantityBySecurityAndUserORM) error
}

// MonthlyTotalQuantityBySecurityAndUserBeforeToPB called before default ToPB code
type MonthlyTotalQuantityBySecurityAndUserWithBeforeToPB interface {
	BeforeToPB(context.Context, *MonthlyTotalQuantityBySecurityAndUser) error
}

// MonthlyTotalQuantityBySecurityAndUserAfterToPB called after default ToPB code
type MonthlyTotalQuantityBySecurityAndUserWithAfterToPB interface {
	AfterToPB(context.Context, *MonthlyTotalQuantityBySecurityAndUser) error
}

type MonthlyTransactionCountORM struct {
	Month            uint32
	TransactionCount uint64
	UserId           uint64
}

// TableName overrides the default tablename generated by GORM
func (MonthlyTransactionCountORM) TableName() string {
	return "monthly_transaction_counts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MonthlyTransactionCount) ToORM(ctx context.Context) (MonthlyTransactionCountORM, error) {
	to := MonthlyTransactionCountORM{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyTransactionCountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TransactionCount = m.TransactionCount
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyTransactionCountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MonthlyTransactionCountORM) ToPB(ctx context.Context) (MonthlyTransactionCount, error) {
	to := MonthlyTransactionCount{}
	var err error
	if prehook, ok := interface{}(m).(MonthlyTransactionCountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.TransactionCount = m.TransactionCount
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(MonthlyTransactionCountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MonthlyTransactionCount the arg will be the target, the caller the one being converted from

// MonthlyTransactionCountBeforeToORM called before default ToORM code
type MonthlyTransactionCountWithBeforeToORM interface {
	BeforeToORM(context.Context, *MonthlyTransactionCountORM) error
}

// MonthlyTransactionCountAfterToORM called after default ToORM code
type MonthlyTransactionCountWithAfterToORM interface {
	AfterToORM(context.Context, *MonthlyTransactionCountORM) error
}

// MonthlyTransactionCountBeforeToPB called before default ToPB code
type MonthlyTransactionCountWithBeforeToPB interface {
	BeforeToPB(context.Context, *MonthlyTransactionCount) error
}

// MonthlyTransactionCountAfterToPB called after default ToPB code
type MonthlyTransactionCountWithAfterToPB interface {
	AfterToPB(context.Context, *MonthlyTransactionCount) error
}

type PaymentChannelMetricsFinancialSubProfileORM struct {
	Month              uint32
	PaymentChannel     string
	SpentLastMonth     float64
	SpentLastSixMonths float64
	SpentLastTwoWeeks  float64
	SpentLastTwoYears  float64
	SpentLastWeek      float64
	SpentLastYear      float64
	TransactionCount   uint64
	UserId             uint64
}

// TableName overrides the default tablename generated by GORM
func (PaymentChannelMetricsFinancialSubProfileORM) TableName() string {
	return "payment_channel_metrics_financial_sub_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PaymentChannelMetricsFinancialSubProfile) ToORM(ctx context.Context) (PaymentChannelMetricsFinancialSubProfileORM, error) {
	to := PaymentChannelMetricsFinancialSubProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentChannelMetricsFinancialSubProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.PaymentChannel = m.PaymentChannel
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	to.Month = m.Month
	to.TransactionCount = m.TransactionCount
	if posthook, ok := interface{}(m).(PaymentChannelMetricsFinancialSubProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentChannelMetricsFinancialSubProfileORM) ToPB(ctx context.Context) (PaymentChannelMetricsFinancialSubProfile, error) {
	to := PaymentChannelMetricsFinancialSubProfile{}
	var err error
	if prehook, ok := interface{}(m).(PaymentChannelMetricsFinancialSubProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.PaymentChannel = m.PaymentChannel
	to.SpentLastWeek = m.SpentLastWeek
	to.SpentLastTwoWeeks = m.SpentLastTwoWeeks
	to.SpentLastMonth = m.SpentLastMonth
	to.SpentLastSixMonths = m.SpentLastSixMonths
	to.SpentLastYear = m.SpentLastYear
	to.SpentLastTwoYears = m.SpentLastTwoYears
	to.UserId = m.UserId
	to.Month = m.Month
	to.TransactionCount = m.TransactionCount
	if posthook, ok := interface{}(m).(PaymentChannelMetricsFinancialSubProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PaymentChannelMetricsFinancialSubProfile the arg will be the target, the caller the one being converted from

// PaymentChannelMetricsFinancialSubProfileBeforeToORM called before default ToORM code
type PaymentChannelMetricsFinancialSubProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentChannelMetricsFinancialSubProfileORM) error
}

// PaymentChannelMetricsFinancialSubProfileAfterToORM called after default ToORM code
type PaymentChannelMetricsFinancialSubProfileWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentChannelMetricsFinancialSubProfileORM) error
}

// PaymentChannelMetricsFinancialSubProfileBeforeToPB called before default ToPB code
type PaymentChannelMetricsFinancialSubProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *PaymentChannelMetricsFinancialSubProfile) error
}

// PaymentChannelMetricsFinancialSubProfileAfterToPB called after default ToPB code
type PaymentChannelMetricsFinancialSubProfileWithAfterToPB interface {
	AfterToPB(context.Context, *PaymentChannelMetricsFinancialSubProfile) error
}

type PaymentChannelMonthlyExpenditureORM struct {
	Month          uint32
	PaymentChannel string
	TotalSpending  float64
	UserId         uint64
}

// TableName overrides the default tablename generated by GORM
func (PaymentChannelMonthlyExpenditureORM) TableName() string {
	return "payment_channel_monthly_expenditures"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PaymentChannelMonthlyExpenditure) ToORM(ctx context.Context) (PaymentChannelMonthlyExpenditureORM, error) {
	to := PaymentChannelMonthlyExpenditureORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentChannelMonthlyExpenditureWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PaymentChannel = m.PaymentChannel
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(PaymentChannelMonthlyExpenditureWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentChannelMonthlyExpenditureORM) ToPB(ctx context.Context) (PaymentChannelMonthlyExpenditure, error) {
	to := PaymentChannelMonthlyExpenditure{}
	var err error
	if prehook, ok := interface{}(m).(PaymentChannelMonthlyExpenditureWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PaymentChannel = m.PaymentChannel
	to.TotalSpending = m.TotalSpending
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(PaymentChannelMonthlyExpenditureWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PaymentChannelMonthlyExpenditure the arg will be the target, the caller the one being converted from

// PaymentChannelMonthlyExpenditureBeforeToORM called before default ToORM code
type PaymentChannelMonthlyExpenditureWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentChannelMonthlyExpenditureORM) error
}

// PaymentChannelMonthlyExpenditureAfterToORM called after default ToORM code
type PaymentChannelMonthlyExpenditureWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentChannelMonthlyExpenditureORM) error
}

// PaymentChannelMonthlyExpenditureBeforeToPB called before default ToPB code
type PaymentChannelMonthlyExpenditureWithBeforeToPB interface {
	BeforeToPB(context.Context, *PaymentChannelMonthlyExpenditure) error
}

// PaymentChannelMonthlyExpenditureAfterToPB called after default ToPB code
type PaymentChannelMonthlyExpenditureWithAfterToPB interface {
	AfterToPB(context.Context, *PaymentChannelMonthlyExpenditure) error
}

type TotalInvestmentBySecurityORM struct {
	SecurityId      string
	TotalInvestment float64
	UserId          uint64
}

// TableName overrides the default tablename generated by GORM
func (TotalInvestmentBySecurityORM) TableName() string {
	return "total_investment_by_securities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TotalInvestmentBySecurity) ToORM(ctx context.Context) (TotalInvestmentBySecurityORM, error) {
	to := TotalInvestmentBySecurityORM{}
	var err error
	if prehook, ok := interface{}(m).(TotalInvestmentBySecurityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SecurityId = m.SecurityId
	to.TotalInvestment = m.TotalInvestment
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(TotalInvestmentBySecurityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TotalInvestmentBySecurityORM) ToPB(ctx context.Context) (TotalInvestmentBySecurity, error) {
	to := TotalInvestmentBySecurity{}
	var err error
	if prehook, ok := interface{}(m).(TotalInvestmentBySecurityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.SecurityId = m.SecurityId
	to.TotalInvestment = m.TotalInvestment
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(TotalInvestmentBySecurityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TotalInvestmentBySecurity the arg will be the target, the caller the one being converted from

// TotalInvestmentBySecurityBeforeToORM called before default ToORM code
type TotalInvestmentBySecurityWithBeforeToORM interface {
	BeforeToORM(context.Context, *TotalInvestmentBySecurityORM) error
}

// TotalInvestmentBySecurityAfterToORM called after default ToORM code
type TotalInvestmentBySecurityWithAfterToORM interface {
	AfterToORM(context.Context, *TotalInvestmentBySecurityORM) error
}

// TotalInvestmentBySecurityBeforeToPB called before default ToPB code
type TotalInvestmentBySecurityWithBeforeToPB interface {
	BeforeToPB(context.Context, *TotalInvestmentBySecurity) error
}

// TotalInvestmentBySecurityAfterToPB called after default ToPB code
type TotalInvestmentBySecurityWithAfterToPB interface {
	AfterToPB(context.Context, *TotalInvestmentBySecurity) error
}

type TransactionAggregatesByMonthORM struct {
	LocationCity                   string
	MerchantName                   string
	Month                          uint32
	PaymentChannel                 string
	PersonalFinanceCategoryPrimary string
	TotalAmount                    float64
	TransactionCount               uint64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (TransactionAggregatesByMonthORM) TableName() string {
	return "transaction_aggregates_by_months"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionAggregatesByMonth) ToORM(ctx context.Context) (TransactionAggregatesByMonthORM, error) {
	to := TransactionAggregatesByMonthORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionAggregatesByMonthWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.LocationCity = m.LocationCity
	to.PaymentChannel = m.PaymentChannel
	to.MerchantName = m.MerchantName
	to.TransactionCount = m.TransactionCount
	to.TotalAmount = m.TotalAmount
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(TransactionAggregatesByMonthWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionAggregatesByMonthORM) ToPB(ctx context.Context) (TransactionAggregatesByMonth, error) {
	to := TransactionAggregatesByMonth{}
	var err error
	if prehook, ok := interface{}(m).(TransactionAggregatesByMonthWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Month = m.Month
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.LocationCity = m.LocationCity
	to.PaymentChannel = m.PaymentChannel
	to.MerchantName = m.MerchantName
	to.TransactionCount = m.TransactionCount
	to.TotalAmount = m.TotalAmount
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(TransactionAggregatesByMonthWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionAggregatesByMonth the arg will be the target, the caller the one being converted from

// TransactionAggregatesByMonthBeforeToORM called before default ToORM code
type TransactionAggregatesByMonthWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionAggregatesByMonthORM) error
}

// TransactionAggregatesByMonthAfterToORM called after default ToORM code
type TransactionAggregatesByMonthWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionAggregatesByMonthORM) error
}

// TransactionAggregatesByMonthBeforeToPB called before default ToPB code
type TransactionAggregatesByMonthWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionAggregatesByMonth) error
}

// TransactionAggregatesByMonthAfterToPB called after default ToPB code
type TransactionAggregatesByMonthWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionAggregatesByMonth) error
}

type UserFinancialHealthMetricsTableORM struct {
	DebtToIncomeRatio    float64
	MonthlyExpenses      float64
	MonthlyIncome        float64
	OverdraftFrequency   uint64
	Time                 *time.Time
	TransactionDiversity uint64
	UserId               uint64
}

// TableName overrides the default tablename generated by GORM
func (UserFinancialHealthMetricsTableORM) TableName() string {
	return "user_financial_health_metrics_tables"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserFinancialHealthMetricsTable) ToORM(ctx context.Context) (UserFinancialHealthMetricsTableORM, error) {
	to := UserFinancialHealthMetricsTableORM{}
	var err error
	if prehook, ok := interface{}(m).(UserFinancialHealthMetricsTableWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	to.UserId = m.UserId
	to.MonthlyIncome = m.MonthlyIncome
	to.MonthlyExpenses = m.MonthlyExpenses
	to.TransactionDiversity = m.TransactionDiversity
	to.DebtToIncomeRatio = m.DebtToIncomeRatio
	to.OverdraftFrequency = m.OverdraftFrequency
	if posthook, ok := interface{}(m).(UserFinancialHealthMetricsTableWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserFinancialHealthMetricsTableORM) ToPB(ctx context.Context) (UserFinancialHealthMetricsTable, error) {
	to := UserFinancialHealthMetricsTable{}
	var err error
	if prehook, ok := interface{}(m).(UserFinancialHealthMetricsTableWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	to.UserId = m.UserId
	to.MonthlyIncome = m.MonthlyIncome
	to.MonthlyExpenses = m.MonthlyExpenses
	to.TransactionDiversity = m.TransactionDiversity
	to.DebtToIncomeRatio = m.DebtToIncomeRatio
	to.OverdraftFrequency = m.OverdraftFrequency
	if posthook, ok := interface{}(m).(UserFinancialHealthMetricsTableWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserFinancialHealthMetricsTable the arg will be the target, the caller the one being converted from

// UserFinancialHealthMetricsTableBeforeToORM called before default ToORM code
type UserFinancialHealthMetricsTableWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserFinancialHealthMetricsTableORM) error
}

// UserFinancialHealthMetricsTableAfterToORM called after default ToORM code
type UserFinancialHealthMetricsTableWithAfterToORM interface {
	AfterToORM(context.Context, *UserFinancialHealthMetricsTableORM) error
}

// UserFinancialHealthMetricsTableBeforeToPB called before default ToPB code
type UserFinancialHealthMetricsTableWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserFinancialHealthMetricsTable) error
}

// UserFinancialHealthMetricsTableAfterToPB called after default ToPB code
type UserFinancialHealthMetricsTableWithAfterToPB interface {
	AfterToPB(context.Context, *UserFinancialHealthMetricsTable) error
}

// DefaultCreateInvestmentTransaction executes a basic gorm create call
func DefaultCreateInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentTransactionSet(ctx context.Context, in []*InvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentTransactionORM{})).(InvestmentTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentTransactionORM{})).(InvestmentTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentTransaction, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentTransaction, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentTransaction executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentTransaction(ctx context.Context, in *InvestmentTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentTransaction(ctx, &InvestmentTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentTransaction(ctx context.Context, objects []*InvestmentTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentTransaction(ctx context.Context, patchee *InvestmentTransaction, patcher *InvestmentTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Ammount" {
			patchee.Ammount = patcher.Ammount
			continue
		}
		if f == prefix+"InvestmentTransactionId" {
			patchee.InvestmentTransactionId = patcher.InvestmentTransactionId
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"CurrentDate" {
			patchee.CurrentDate = patcher.CurrentDate
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Fees" {
			patchee.Fees = patcher.Fees
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentTransaction executes a gorm list call
func DefaultListInvestmentTransaction(ctx context.Context, db *gorm.DB) ([]*InvestmentTransaction, error) {
	in := InvestmentTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentTransactionORM{}, &InvestmentTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentTransactionORM) error
}

// DefaultCreateReOccuringTransaction executes a basic gorm create call
func DefaultCreateReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReOccuringTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReOccuringTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReOccuringTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReOccuringTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReOccuringTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReOccuringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReOccuringTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReOccuringTransactionSet(ctx context.Context, in []*ReOccuringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReOccuringTransactionORM{})).(ReOccuringTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReOccuringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReOccuringTransactionORM{})).(ReOccuringTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReOccuringTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReOccuringTransaction, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReOccuringTransaction, *gorm.DB) error
}

// DefaultStrictUpdateReOccuringTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReOccuringTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReOccuringTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReOccuringTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReOccuringTransaction executes a basic gorm update call with patch behavior
func DefaultPatchReOccuringTransaction(ctx context.Context, in *ReOccuringTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReOccuringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReOccuringTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(ReOccuringTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReOccuringTransaction(ctx, &ReOccuringTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReOccuringTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReOccuringTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReOccuringTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReOccuringTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReOccuringTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReOccuringTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReOccuringTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReOccuringTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetReOccuringTransaction(ctx context.Context, objects []*ReOccuringTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReOccuringTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReOccuringTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReOccuringTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReOccuringTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReOccuringTransaction(ctx context.Context, patchee *ReOccuringTransaction, patcher *ReOccuringTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReOccuringTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"StreamId" {
			patchee.StreamId = patcher.StreamId
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"FirstDate" {
			patchee.FirstDate = patcher.FirstDate
			continue
		}
		if f == prefix+"LastDate" {
			patchee.LastDate = patcher.LastDate
			continue
		}
		if f == prefix+"Frequency" {
			patchee.Frequency = patcher.Frequency
			continue
		}
		if f == prefix+"TransactionIds" {
			patchee.TransactionIds = patcher.TransactionIds
			continue
		}
		if f == prefix+"AverageAmount" {
			patchee.AverageAmount = patcher.AverageAmount
			continue
		}
		if f == prefix+"AverageAmountIsoCurrencyCode" {
			patchee.AverageAmountIsoCurrencyCode = patcher.AverageAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"LastAmount" {
			patchee.LastAmount = patcher.LastAmount
			continue
		}
		if f == prefix+"LastAmountIsoCurrencyCode" {
			patchee.LastAmountIsoCurrencyCode = patcher.LastAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"UpdatedTime" {
			patchee.UpdatedTime = patcher.UpdatedTime
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Flow" {
			patchee.Flow = patcher.Flow
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReOccuringTransaction executes a gorm list call
func DefaultListReOccuringTransaction(ctx context.Context, db *gorm.DB) ([]*ReOccuringTransaction, error) {
	in := ReOccuringTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReOccuringTransactionORM{}, &ReOccuringTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReOccuringTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReOccuringTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReOccuringTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReOccuringTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReOccuringTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReOccuringTransactionORM) error
}

// DefaultCreateTransaction executes a basic gorm create call
func DefaultCreateTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransaction(ctx context.Context, in *Transaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSet(ctx context.Context, in []*Transaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionORM{})).(TransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionORM{})).(TransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Transaction, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Transaction, *gorm.DB) error
}

// DefaultStrictUpdateTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransaction(ctx context.Context, in *Transaction, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransaction executes a basic gorm update call with patch behavior
func DefaultPatchTransaction(ctx context.Context, in *Transaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*Transaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Transaction
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransaction(ctx, &Transaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Transaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransaction(ctx context.Context, objects []*Transaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Transaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Transaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransaction(ctx context.Context, patchee *Transaction, patcher *Transaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Transaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"CheckNumber" {
			patchee.CheckNumber = patcher.CheckNumber
			continue
		}
		if f == prefix+"CurrentDate" {
			patchee.CurrentDate = patcher.CurrentDate
			continue
		}
		if f == prefix+"CurrentDatetime" {
			patchee.CurrentDatetime = patcher.CurrentDatetime
			continue
		}
		if f == prefix+"AuthorizedDate" {
			patchee.AuthorizedDate = patcher.AuthorizedDate
			continue
		}
		if f == prefix+"AuthorizedDatetime" {
			patchee.AuthorizedDatetime = patcher.AuthorizedDatetime
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"Pending" {
			patchee.Pending = patcher.Pending
			continue
		}
		if f == prefix+"PendingTransactionId" {
			patchee.PendingTransactionId = patcher.PendingTransactionId
			continue
		}
		if f == prefix+"AccountOwner" {
			patchee.AccountOwner = patcher.AccountOwner
			continue
		}
		if f == prefix+"TransactionId" {
			patchee.TransactionId = patcher.TransactionId
			continue
		}
		if f == prefix+"TransactionCode" {
			patchee.TransactionCode = patcher.TransactionCode
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"LocationAddress" {
			patchee.LocationAddress = patcher.LocationAddress
			continue
		}
		if f == prefix+"LocationCity" {
			patchee.LocationCity = patcher.LocationCity
			continue
		}
		if f == prefix+"LocationRegion" {
			patchee.LocationRegion = patcher.LocationRegion
			continue
		}
		if f == prefix+"LocationPostalCode" {
			patchee.LocationPostalCode = patcher.LocationPostalCode
			continue
		}
		if f == prefix+"LocationCountry" {
			patchee.LocationCountry = patcher.LocationCountry
			continue
		}
		if f == prefix+"LocationLat" {
			patchee.LocationLat = patcher.LocationLat
			continue
		}
		if f == prefix+"LocationLon" {
			patchee.LocationLon = patcher.LocationLon
			continue
		}
		if f == prefix+"LocationStoreNumber" {
			patchee.LocationStoreNumber = patcher.LocationStoreNumber
			continue
		}
		if f == prefix+"PaymentMetaByOrderOf" {
			patchee.PaymentMetaByOrderOf = patcher.PaymentMetaByOrderOf
			continue
		}
		if f == prefix+"PaymentMetaPayee" {
			patchee.PaymentMetaPayee = patcher.PaymentMetaPayee
			continue
		}
		if f == prefix+"PaymentMetaPayer" {
			patchee.PaymentMetaPayer = patcher.PaymentMetaPayer
			continue
		}
		if f == prefix+"PaymentMetaPaymentMethod" {
			patchee.PaymentMetaPaymentMethod = patcher.PaymentMetaPaymentMethod
			continue
		}
		if f == prefix+"PaymentMetaPaymentProcessor" {
			patchee.PaymentMetaPaymentProcessor = patcher.PaymentMetaPaymentProcessor
			continue
		}
		if f == prefix+"PaymentMetaPpdId" {
			patchee.PaymentMetaPpdId = patcher.PaymentMetaPpdId
			continue
		}
		if f == prefix+"PaymentMetaReason" {
			patchee.PaymentMetaReason = patcher.PaymentMetaReason
			continue
		}
		if f == prefix+"PaymentMetaReferenceNumber" {
			patchee.PaymentMetaReferenceNumber = patcher.PaymentMetaReferenceNumber
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Categories" {
			patchee.Categories = patcher.Categories
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransaction executes a gorm list call
func DefaultListTransaction(ctx context.Context, db *gorm.DB) ([]*Transaction, error) {
	in := Transaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionORM{}, &Transaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Transaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionORM) error
}

// DefaultCreateAccountBalanceHistory executes a basic gorm create call
func DefaultCreateAccountBalanceHistory(ctx context.Context, in *AccountBalanceHistory, db *gorm.DB) (*AccountBalanceHistory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountBalanceHistoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountBalanceHistory(ctx context.Context, in *AccountBalanceHistory, db *gorm.DB) (*AccountBalanceHistory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountBalanceHistoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountBalanceHistoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountBalanceHistoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountBalanceHistoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountBalanceHistory(ctx context.Context, in *AccountBalanceHistory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountBalanceHistoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountBalanceHistoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountBalanceHistorySet(ctx context.Context, in []*AccountBalanceHistory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountBalanceHistoryORM{})).(AccountBalanceHistoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountBalanceHistoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountBalanceHistoryORM{})).(AccountBalanceHistoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountBalanceHistoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountBalanceHistory, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountBalanceHistory, *gorm.DB) error
}

// DefaultStrictUpdateAccountBalanceHistory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountBalanceHistory(ctx context.Context, in *AccountBalanceHistory, db *gorm.DB) (*AccountBalanceHistory, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountBalanceHistory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountBalanceHistoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountBalanceHistoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountBalanceHistory executes a basic gorm update call with patch behavior
func DefaultPatchAccountBalanceHistory(ctx context.Context, in *AccountBalanceHistory, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountBalanceHistory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountBalanceHistory
	var err error
	if hook, ok := interface{}(&pbObj).(AccountBalanceHistoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountBalanceHistory(ctx, &AccountBalanceHistory{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountBalanceHistoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountBalanceHistory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountBalanceHistoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountBalanceHistory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountBalanceHistoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountBalanceHistoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountBalanceHistory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountBalanceHistory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountBalanceHistory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountBalanceHistory, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountBalanceHistory executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountBalanceHistory(ctx context.Context, objects []*AccountBalanceHistory, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountBalanceHistory, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountBalanceHistory, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountBalanceHistory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountBalanceHistory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountBalanceHistory(ctx context.Context, patchee *AccountBalanceHistory, patcher *AccountBalanceHistory, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountBalanceHistory, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTime bool
	for i, f := range updateMask.Paths {
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Sign" {
			patchee.Sign = patcher.Sign
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountBalanceHistory executes a gorm list call
func DefaultListAccountBalanceHistory(ctx context.Context, db *gorm.DB) ([]*AccountBalanceHistory, error) {
	in := AccountBalanceHistory{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountBalanceHistoryORM{}, &AccountBalanceHistory{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountBalanceHistoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountBalanceHistoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountBalanceHistory{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountBalanceHistoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountBalanceHistoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountBalanceHistoryORM) error
}

// DefaultCreateCategoryMetricsFinancialSubProfile executes a basic gorm create call
func DefaultCreateCategoryMetricsFinancialSubProfile(ctx context.Context, in *CategoryMetricsFinancialSubProfile, db *gorm.DB) (*CategoryMetricsFinancialSubProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMetricsFinancialSubProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMetricsFinancialSubProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryMetricsFinancialSubProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMetricsFinancialSubProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskCategoryMetricsFinancialSubProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategoryMetricsFinancialSubProfile(ctx context.Context, patchee *CategoryMetricsFinancialSubProfile, patcher *CategoryMetricsFinancialSubProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CategoryMetricsFinancialSubProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"SpentLastWeek" {
			patchee.SpentLastWeek = patcher.SpentLastWeek
			continue
		}
		if f == prefix+"SpentLastTwoWeeks" {
			patchee.SpentLastTwoWeeks = patcher.SpentLastTwoWeeks
			continue
		}
		if f == prefix+"SpentLastMonth" {
			patchee.SpentLastMonth = patcher.SpentLastMonth
			continue
		}
		if f == prefix+"SpentLastSixMonths" {
			patchee.SpentLastSixMonths = patcher.SpentLastSixMonths
			continue
		}
		if f == prefix+"SpentLastYear" {
			patchee.SpentLastYear = patcher.SpentLastYear
			continue
		}
		if f == prefix+"SpentLastTwoYears" {
			patchee.SpentLastTwoYears = patcher.SpentLastTwoYears
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategoryMetricsFinancialSubProfile executes a gorm list call
func DefaultListCategoryMetricsFinancialSubProfile(ctx context.Context, db *gorm.DB) ([]*CategoryMetricsFinancialSubProfile, error) {
	in := CategoryMetricsFinancialSubProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMetricsFinancialSubProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryMetricsFinancialSubProfileORM{}, &CategoryMetricsFinancialSubProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMetricsFinancialSubProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []CategoryMetricsFinancialSubProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMetricsFinancialSubProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CategoryMetricsFinancialSubProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryMetricsFinancialSubProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMetricsFinancialSubProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMetricsFinancialSubProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryMetricsFinancialSubProfileORM) error
}

// DefaultCreateCategoryMonthlyExpenditure executes a basic gorm create call
func DefaultCreateCategoryMonthlyExpenditure(ctx context.Context, in *CategoryMonthlyExpenditure, db *gorm.DB) (*CategoryMonthlyExpenditure, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyExpenditureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyExpenditureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryMonthlyExpenditureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyExpenditureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskCategoryMonthlyExpenditure patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategoryMonthlyExpenditure(ctx context.Context, patchee *CategoryMonthlyExpenditure, patcher *CategoryMonthlyExpenditure, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CategoryMonthlyExpenditure, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"TotalSpending" {
			patchee.TotalSpending = patcher.TotalSpending
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategoryMonthlyExpenditure executes a gorm list call
func DefaultListCategoryMonthlyExpenditure(ctx context.Context, db *gorm.DB) ([]*CategoryMonthlyExpenditure, error) {
	in := CategoryMonthlyExpenditure{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyExpenditureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryMonthlyExpenditureORM{}, &CategoryMonthlyExpenditure{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyExpenditureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []CategoryMonthlyExpenditureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyExpenditureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CategoryMonthlyExpenditure{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryMonthlyExpenditureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyExpenditureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyExpenditureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryMonthlyExpenditureORM) error
}

// DefaultCreateCategoryMonthlyIncome executes a basic gorm create call
func DefaultCreateCategoryMonthlyIncome(ctx context.Context, in *CategoryMonthlyIncome, db *gorm.DB) (*CategoryMonthlyIncome, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyIncomeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyIncomeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryMonthlyIncomeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyIncomeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskCategoryMonthlyIncome patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategoryMonthlyIncome(ctx context.Context, patchee *CategoryMonthlyIncome, patcher *CategoryMonthlyIncome, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CategoryMonthlyIncome, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"TotalIncome" {
			patchee.TotalIncome = patcher.TotalIncome
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategoryMonthlyIncome executes a gorm list call
func DefaultListCategoryMonthlyIncome(ctx context.Context, db *gorm.DB) ([]*CategoryMonthlyIncome, error) {
	in := CategoryMonthlyIncome{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyIncomeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryMonthlyIncomeORM{}, &CategoryMonthlyIncome{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyIncomeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []CategoryMonthlyIncomeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyIncomeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CategoryMonthlyIncome{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryMonthlyIncomeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyIncomeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyIncomeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryMonthlyIncomeORM) error
}

// DefaultCreateCategoryMonthlyTransactionCount executes a basic gorm create call
func DefaultCreateCategoryMonthlyTransactionCount(ctx context.Context, in *CategoryMonthlyTransactionCount, db *gorm.DB) (*CategoryMonthlyTransactionCount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyTransactionCountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyTransactionCountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryMonthlyTransactionCountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyTransactionCountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskCategoryMonthlyTransactionCount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategoryMonthlyTransactionCount(ctx context.Context, patchee *CategoryMonthlyTransactionCount, patcher *CategoryMonthlyTransactionCount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CategoryMonthlyTransactionCount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategoryMonthlyTransactionCount executes a gorm list call
func DefaultListCategoryMonthlyTransactionCount(ctx context.Context, db *gorm.DB) ([]*CategoryMonthlyTransactionCount, error) {
	in := CategoryMonthlyTransactionCount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyTransactionCountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryMonthlyTransactionCountORM{}, &CategoryMonthlyTransactionCount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyTransactionCountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []CategoryMonthlyTransactionCountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryMonthlyTransactionCountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CategoryMonthlyTransactionCount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryMonthlyTransactionCountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyTransactionCountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryMonthlyTransactionCountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryMonthlyTransactionCountORM) error
}

// DefaultCreateDebtToIncomeRatio executes a basic gorm create call
func DefaultCreateDebtToIncomeRatio(ctx context.Context, in *DebtToIncomeRatio, db *gorm.DB) (*DebtToIncomeRatio, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DebtToIncomeRatioORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DebtToIncomeRatioORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DebtToIncomeRatioORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DebtToIncomeRatioORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskDebtToIncomeRatio patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDebtToIncomeRatio(ctx context.Context, patchee *DebtToIncomeRatio, patcher *DebtToIncomeRatio, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DebtToIncomeRatio, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"Ratio" {
			patchee.Ratio = patcher.Ratio
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDebtToIncomeRatio executes a gorm list call
func DefaultListDebtToIncomeRatio(ctx context.Context, db *gorm.DB) ([]*DebtToIncomeRatio, error) {
	in := DebtToIncomeRatio{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DebtToIncomeRatioORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DebtToIncomeRatioORM{}, &DebtToIncomeRatio{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DebtToIncomeRatioORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []DebtToIncomeRatioORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DebtToIncomeRatioORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DebtToIncomeRatio{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DebtToIncomeRatioORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DebtToIncomeRatioORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DebtToIncomeRatioORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DebtToIncomeRatioORM) error
}

// DefaultCreateExpenseMetrics executes a basic gorm create call
func DefaultCreateExpenseMetrics(ctx context.Context, in *ExpenseMetrics, db *gorm.DB) (*ExpenseMetrics, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseMetricsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseMetricsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskExpenseMetrics patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpenseMetrics(ctx context.Context, patchee *ExpenseMetrics, patcher *ExpenseMetrics, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExpenseMetrics, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"TotalExpenses" {
			patchee.TotalExpenses = patcher.TotalExpenses
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpenseMetrics executes a gorm list call
func DefaultListExpenseMetrics(ctx context.Context, db *gorm.DB) ([]*ExpenseMetrics, error) {
	in := ExpenseMetrics{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseMetricsORM{}, &ExpenseMetrics{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []ExpenseMetricsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExpenseMetrics{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseMetricsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseMetricsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseMetricsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseMetricsORM) error
}

// DefaultCreateExpenseMetricsFinancialSubProfileMetrics executes a basic gorm create call
func DefaultCreateExpenseMetricsFinancialSubProfileMetrics(ctx context.Context, in *ExpenseMetricsFinancialSubProfileMetrics, db *gorm.DB) (*ExpenseMetricsFinancialSubProfileMetrics, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsFinancialSubProfileMetricsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsFinancialSubProfileMetricsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseMetricsFinancialSubProfileMetricsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseMetricsFinancialSubProfileMetricsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskExpenseMetricsFinancialSubProfileMetrics patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpenseMetricsFinancialSubProfileMetrics(ctx context.Context, patchee *ExpenseMetricsFinancialSubProfileMetrics, patcher *ExpenseMetricsFinancialSubProfileMetrics, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExpenseMetricsFinancialSubProfileMetrics, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"SpentLastWeek" {
			patchee.SpentLastWeek = patcher.SpentLastWeek
			continue
		}
		if f == prefix+"SpentLastMonth" {
			patchee.SpentLastMonth = patcher.SpentLastMonth
			continue
		}
		if f == prefix+"SpentLastSixMonths" {
			patchee.SpentLastSixMonths = patcher.SpentLastSixMonths
			continue
		}
		if f == prefix+"AverageMonthlyDiscretionarySpending" {
			patchee.AverageMonthlyDiscretionarySpending = patcher.AverageMonthlyDiscretionarySpending
			continue
		}
		if f == prefix+"AverageMonthlyRecurringSpending" {
			patchee.AverageMonthlyRecurringSpending = patcher.AverageMonthlyRecurringSpending
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpenseMetricsFinancialSubProfileMetrics executes a gorm list call
func DefaultListExpenseMetricsFinancialSubProfileMetrics(ctx context.Context, db *gorm.DB) ([]*ExpenseMetricsFinancialSubProfileMetrics, error) {
	in := ExpenseMetricsFinancialSubProfileMetrics{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsFinancialSubProfileMetricsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseMetricsFinancialSubProfileMetricsORM{}, &ExpenseMetricsFinancialSubProfileMetrics{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsFinancialSubProfileMetricsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []ExpenseMetricsFinancialSubProfileMetricsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseMetricsFinancialSubProfileMetricsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExpenseMetricsFinancialSubProfileMetrics{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseMetricsFinancialSubProfileMetricsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseMetricsFinancialSubProfileMetricsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseMetricsFinancialSubProfileMetricsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseMetricsFinancialSubProfileMetricsORM) error
}

// DefaultCreateFinancialProfile executes a basic gorm create call
func DefaultCreateFinancialProfile(ctx context.Context, in *FinancialProfile, db *gorm.DB) (*FinancialProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FinancialProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskFinancialProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFinancialProfile(ctx context.Context, patchee *FinancialProfile, patcher *FinancialProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FinancialProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"TotalIncome" {
			patchee.TotalIncome = patcher.TotalIncome
			continue
		}
		if f == prefix+"TotalExpenses" {
			patchee.TotalExpenses = patcher.TotalExpenses
			continue
		}
		if f == prefix+"NumberOfTransactions" {
			patchee.NumberOfTransactions = patcher.NumberOfTransactions
			continue
		}
		if f == prefix+"MostExpensiveCategory" {
			patchee.MostExpensiveCategory = patcher.MostExpensiveCategory
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFinancialProfile executes a gorm list call
func DefaultListFinancialProfile(ctx context.Context, db *gorm.DB) ([]*FinancialProfile, error) {
	in := FinancialProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FinancialProfileORM{}, &FinancialProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []FinancialProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FinancialProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FinancialProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FinancialProfileORM) error
}

// DefaultCreateIncomeExpenseRatio executes a basic gorm create call
func DefaultCreateIncomeExpenseRatio(ctx context.Context, in *IncomeExpenseRatio, db *gorm.DB) (*IncomeExpenseRatio, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeExpenseRatioORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeExpenseRatioORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IncomeExpenseRatioORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeExpenseRatioORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskIncomeExpenseRatio patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIncomeExpenseRatio(ctx context.Context, patchee *IncomeExpenseRatio, patcher *IncomeExpenseRatio, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IncomeExpenseRatio, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"Ratio" {
			patchee.Ratio = patcher.Ratio
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIncomeExpenseRatio executes a gorm list call
func DefaultListIncomeExpenseRatio(ctx context.Context, db *gorm.DB) ([]*IncomeExpenseRatio, error) {
	in := IncomeExpenseRatio{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeExpenseRatioORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IncomeExpenseRatioORM{}, &IncomeExpenseRatio{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeExpenseRatioORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []IncomeExpenseRatioORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeExpenseRatioORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IncomeExpenseRatio{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IncomeExpenseRatioORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeExpenseRatioORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeExpenseRatioORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IncomeExpenseRatioORM) error
}

// DefaultCreateIncomeMetrics executes a basic gorm create call
func DefaultCreateIncomeMetrics(ctx context.Context, in *IncomeMetrics, db *gorm.DB) (*IncomeMetrics, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IncomeMetricsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeMetricsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskIncomeMetrics patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIncomeMetrics(ctx context.Context, patchee *IncomeMetrics, patcher *IncomeMetrics, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IncomeMetrics, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"TotalIncome" {
			patchee.TotalIncome = patcher.TotalIncome
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIncomeMetrics executes a gorm list call
func DefaultListIncomeMetrics(ctx context.Context, db *gorm.DB) ([]*IncomeMetrics, error) {
	in := IncomeMetrics{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IncomeMetricsORM{}, &IncomeMetrics{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []IncomeMetricsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IncomeMetrics{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IncomeMetricsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeMetricsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeMetricsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IncomeMetricsORM) error
}

// DefaultCreateIncomeMetricsFinancialSubProfile executes a basic gorm create call
func DefaultCreateIncomeMetricsFinancialSubProfile(ctx context.Context, in *IncomeMetricsFinancialSubProfile, db *gorm.DB) (*IncomeMetricsFinancialSubProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsFinancialSubProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsFinancialSubProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IncomeMetricsFinancialSubProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeMetricsFinancialSubProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskIncomeMetricsFinancialSubProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIncomeMetricsFinancialSubProfile(ctx context.Context, patchee *IncomeMetricsFinancialSubProfile, patcher *IncomeMetricsFinancialSubProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IncomeMetricsFinancialSubProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"IncomeLastTwoWeeks" {
			patchee.IncomeLastTwoWeeks = patcher.IncomeLastTwoWeeks
			continue
		}
		if f == prefix+"IncomeLastMonth" {
			patchee.IncomeLastMonth = patcher.IncomeLastMonth
			continue
		}
		if f == prefix+"IncomeLastTwoMonths" {
			patchee.IncomeLastTwoMonths = patcher.IncomeLastTwoMonths
			continue
		}
		if f == prefix+"IncomeLastSixMonths" {
			patchee.IncomeLastSixMonths = patcher.IncomeLastSixMonths
			continue
		}
		if f == prefix+"IncomeLastYear" {
			patchee.IncomeLastYear = patcher.IncomeLastYear
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIncomeMetricsFinancialSubProfile executes a gorm list call
func DefaultListIncomeMetricsFinancialSubProfile(ctx context.Context, db *gorm.DB) ([]*IncomeMetricsFinancialSubProfile, error) {
	in := IncomeMetricsFinancialSubProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsFinancialSubProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IncomeMetricsFinancialSubProfileORM{}, &IncomeMetricsFinancialSubProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsFinancialSubProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []IncomeMetricsFinancialSubProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeMetricsFinancialSubProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IncomeMetricsFinancialSubProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IncomeMetricsFinancialSubProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeMetricsFinancialSubProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeMetricsFinancialSubProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IncomeMetricsFinancialSubProfileORM) error
}

// DefaultCreateLocationFinancialSubProfile executes a basic gorm create call
func DefaultCreateLocationFinancialSubProfile(ctx context.Context, in *LocationFinancialSubProfile, db *gorm.DB) (*LocationFinancialSubProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationFinancialSubProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationFinancialSubProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LocationFinancialSubProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationFinancialSubProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskLocationFinancialSubProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLocationFinancialSubProfile(ctx context.Context, patchee *LocationFinancialSubProfile, patcher *LocationFinancialSubProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LocationFinancialSubProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"LocationCity" {
			patchee.LocationCity = patcher.LocationCity
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"SpentLastWeek" {
			patchee.SpentLastWeek = patcher.SpentLastWeek
			continue
		}
		if f == prefix+"SpentLastTwoWeeks" {
			patchee.SpentLastTwoWeeks = patcher.SpentLastTwoWeeks
			continue
		}
		if f == prefix+"SpentLastMonth" {
			patchee.SpentLastMonth = patcher.SpentLastMonth
			continue
		}
		if f == prefix+"SpentLastSixMonths" {
			patchee.SpentLastSixMonths = patcher.SpentLastSixMonths
			continue
		}
		if f == prefix+"SpentLastYear" {
			patchee.SpentLastYear = patcher.SpentLastYear
			continue
		}
		if f == prefix+"SpentLastTwoYears" {
			patchee.SpentLastTwoYears = patcher.SpentLastTwoYears
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLocationFinancialSubProfile executes a gorm list call
func DefaultListLocationFinancialSubProfile(ctx context.Context, db *gorm.DB) ([]*LocationFinancialSubProfile, error) {
	in := LocationFinancialSubProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationFinancialSubProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LocationFinancialSubProfileORM{}, &LocationFinancialSubProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationFinancialSubProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []LocationFinancialSubProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationFinancialSubProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LocationFinancialSubProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LocationFinancialSubProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationFinancialSubProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationFinancialSubProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LocationFinancialSubProfileORM) error
}

// DefaultCreateMerchantMetricsFinancialSubProfile executes a basic gorm create call
func DefaultCreateMerchantMetricsFinancialSubProfile(ctx context.Context, in *MerchantMetricsFinancialSubProfile, db *gorm.DB) (*MerchantMetricsFinancialSubProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMetricsFinancialSubProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMetricsFinancialSubProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MerchantMetricsFinancialSubProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantMetricsFinancialSubProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMerchantMetricsFinancialSubProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMerchantMetricsFinancialSubProfile(ctx context.Context, patchee *MerchantMetricsFinancialSubProfile, patcher *MerchantMetricsFinancialSubProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MerchantMetricsFinancialSubProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"SpentLastWeek" {
			patchee.SpentLastWeek = patcher.SpentLastWeek
			continue
		}
		if f == prefix+"SpentLastTwoWeeks" {
			patchee.SpentLastTwoWeeks = patcher.SpentLastTwoWeeks
			continue
		}
		if f == prefix+"SpentLastMonth" {
			patchee.SpentLastMonth = patcher.SpentLastMonth
			continue
		}
		if f == prefix+"SpentLastSixMonths" {
			patchee.SpentLastSixMonths = patcher.SpentLastSixMonths
			continue
		}
		if f == prefix+"SpentLastYear" {
			patchee.SpentLastYear = patcher.SpentLastYear
			continue
		}
		if f == prefix+"SpentLastTwoYears" {
			patchee.SpentLastTwoYears = patcher.SpentLastTwoYears
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMerchantMetricsFinancialSubProfile executes a gorm list call
func DefaultListMerchantMetricsFinancialSubProfile(ctx context.Context, db *gorm.DB) ([]*MerchantMetricsFinancialSubProfile, error) {
	in := MerchantMetricsFinancialSubProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMetricsFinancialSubProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MerchantMetricsFinancialSubProfileORM{}, &MerchantMetricsFinancialSubProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMetricsFinancialSubProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MerchantMetricsFinancialSubProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMetricsFinancialSubProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MerchantMetricsFinancialSubProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MerchantMetricsFinancialSubProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantMetricsFinancialSubProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantMetricsFinancialSubProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MerchantMetricsFinancialSubProfileORM) error
}

// DefaultCreateMerchantMonthlyExpenditure executes a basic gorm create call
func DefaultCreateMerchantMonthlyExpenditure(ctx context.Context, in *MerchantMonthlyExpenditure, db *gorm.DB) (*MerchantMonthlyExpenditure, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMonthlyExpenditureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMonthlyExpenditureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MerchantMonthlyExpenditureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantMonthlyExpenditureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMerchantMonthlyExpenditure patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMerchantMonthlyExpenditure(ctx context.Context, patchee *MerchantMonthlyExpenditure, patcher *MerchantMonthlyExpenditure, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MerchantMonthlyExpenditure, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"TotalSpending" {
			patchee.TotalSpending = patcher.TotalSpending
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMerchantMonthlyExpenditure executes a gorm list call
func DefaultListMerchantMonthlyExpenditure(ctx context.Context, db *gorm.DB) ([]*MerchantMonthlyExpenditure, error) {
	in := MerchantMonthlyExpenditure{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMonthlyExpenditureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MerchantMonthlyExpenditureORM{}, &MerchantMonthlyExpenditure{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMonthlyExpenditureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MerchantMonthlyExpenditureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantMonthlyExpenditureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MerchantMonthlyExpenditure{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MerchantMonthlyExpenditureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantMonthlyExpenditureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantMonthlyExpenditureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MerchantMonthlyExpenditureORM) error
}

// DefaultCreateMonthlyBalance executes a basic gorm create call
func DefaultCreateMonthlyBalance(ctx context.Context, in *MonthlyBalance, db *gorm.DB) (*MonthlyBalance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyBalanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyBalanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MonthlyBalanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyBalanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMonthlyBalance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMonthlyBalance(ctx context.Context, patchee *MonthlyBalance, patcher *MonthlyBalance, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MonthlyBalance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"NetBalance" {
			patchee.NetBalance = patcher.NetBalance
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMonthlyBalance executes a gorm list call
func DefaultListMonthlyBalance(ctx context.Context, db *gorm.DB) ([]*MonthlyBalance, error) {
	in := MonthlyBalance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyBalanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MonthlyBalanceORM{}, &MonthlyBalance{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyBalanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MonthlyBalanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyBalanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MonthlyBalance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MonthlyBalanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyBalanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyBalanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MonthlyBalanceORM) error
}

// DefaultCreateMonthlyExpenditure executes a basic gorm create call
func DefaultCreateMonthlyExpenditure(ctx context.Context, in *MonthlyExpenditure, db *gorm.DB) (*MonthlyExpenditure, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyExpenditureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyExpenditureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MonthlyExpenditureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyExpenditureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMonthlyExpenditure patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMonthlyExpenditure(ctx context.Context, patchee *MonthlyExpenditure, patcher *MonthlyExpenditure, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MonthlyExpenditure, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"TotalSpending" {
			patchee.TotalSpending = patcher.TotalSpending
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMonthlyExpenditure executes a gorm list call
func DefaultListMonthlyExpenditure(ctx context.Context, db *gorm.DB) ([]*MonthlyExpenditure, error) {
	in := MonthlyExpenditure{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyExpenditureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MonthlyExpenditureORM{}, &MonthlyExpenditure{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyExpenditureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MonthlyExpenditureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyExpenditureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MonthlyExpenditure{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MonthlyExpenditureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyExpenditureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyExpenditureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MonthlyExpenditureORM) error
}

// DefaultCreateMonthlyIncome executes a basic gorm create call
func DefaultCreateMonthlyIncome(ctx context.Context, in *MonthlyIncome, db *gorm.DB) (*MonthlyIncome, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyIncomeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyIncomeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MonthlyIncomeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyIncomeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMonthlyIncome patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMonthlyIncome(ctx context.Context, patchee *MonthlyIncome, patcher *MonthlyIncome, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MonthlyIncome, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"TotalIncome" {
			patchee.TotalIncome = patcher.TotalIncome
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMonthlyIncome executes a gorm list call
func DefaultListMonthlyIncome(ctx context.Context, db *gorm.DB) ([]*MonthlyIncome, error) {
	in := MonthlyIncome{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyIncomeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MonthlyIncomeORM{}, &MonthlyIncome{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyIncomeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MonthlyIncomeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyIncomeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MonthlyIncome{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MonthlyIncomeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyIncomeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyIncomeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MonthlyIncomeORM) error
}

// DefaultCreateMonthlySavings executes a basic gorm create call
func DefaultCreateMonthlySavings(ctx context.Context, in *MonthlySavings, db *gorm.DB) (*MonthlySavings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlySavingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlySavingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MonthlySavingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlySavingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMonthlySavings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMonthlySavings(ctx context.Context, patchee *MonthlySavings, patcher *MonthlySavings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MonthlySavings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"NetSavings" {
			patchee.NetSavings = patcher.NetSavings
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMonthlySavings executes a gorm list call
func DefaultListMonthlySavings(ctx context.Context, db *gorm.DB) ([]*MonthlySavings, error) {
	in := MonthlySavings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlySavingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MonthlySavingsORM{}, &MonthlySavings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlySavingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MonthlySavingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlySavingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MonthlySavings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MonthlySavingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlySavingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlySavingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MonthlySavingsORM) error
}

// DefaultCreateMonthlyTotalQuantityBySecurityAndUser executes a basic gorm create call
func DefaultCreateMonthlyTotalQuantityBySecurityAndUser(ctx context.Context, in *MonthlyTotalQuantityBySecurityAndUser, db *gorm.DB) (*MonthlyTotalQuantityBySecurityAndUser, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTotalQuantityBySecurityAndUserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTotalQuantityBySecurityAndUserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MonthlyTotalQuantityBySecurityAndUserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyTotalQuantityBySecurityAndUserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMonthlyTotalQuantityBySecurityAndUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMonthlyTotalQuantityBySecurityAndUser(ctx context.Context, patchee *MonthlyTotalQuantityBySecurityAndUser, patcher *MonthlyTotalQuantityBySecurityAndUser, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MonthlyTotalQuantityBySecurityAndUser, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"TotalQuantity" {
			patchee.TotalQuantity = patcher.TotalQuantity
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMonthlyTotalQuantityBySecurityAndUser executes a gorm list call
func DefaultListMonthlyTotalQuantityBySecurityAndUser(ctx context.Context, db *gorm.DB) ([]*MonthlyTotalQuantityBySecurityAndUser, error) {
	in := MonthlyTotalQuantityBySecurityAndUser{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTotalQuantityBySecurityAndUserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MonthlyTotalQuantityBySecurityAndUserORM{}, &MonthlyTotalQuantityBySecurityAndUser{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTotalQuantityBySecurityAndUserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MonthlyTotalQuantityBySecurityAndUserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTotalQuantityBySecurityAndUserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MonthlyTotalQuantityBySecurityAndUser{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MonthlyTotalQuantityBySecurityAndUserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyTotalQuantityBySecurityAndUserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyTotalQuantityBySecurityAndUserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MonthlyTotalQuantityBySecurityAndUserORM) error
}

// DefaultCreateMonthlyTransactionCount executes a basic gorm create call
func DefaultCreateMonthlyTransactionCount(ctx context.Context, in *MonthlyTransactionCount, db *gorm.DB) (*MonthlyTransactionCount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTransactionCountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTransactionCountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MonthlyTransactionCountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyTransactionCountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskMonthlyTransactionCount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMonthlyTransactionCount(ctx context.Context, patchee *MonthlyTransactionCount, patcher *MonthlyTransactionCount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MonthlyTransactionCount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMonthlyTransactionCount executes a gorm list call
func DefaultListMonthlyTransactionCount(ctx context.Context, db *gorm.DB) ([]*MonthlyTransactionCount, error) {
	in := MonthlyTransactionCount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTransactionCountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MonthlyTransactionCountORM{}, &MonthlyTransactionCount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTransactionCountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []MonthlyTransactionCountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MonthlyTransactionCountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MonthlyTransactionCount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MonthlyTransactionCountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyTransactionCountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MonthlyTransactionCountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MonthlyTransactionCountORM) error
}

// DefaultCreatePaymentChannelMetricsFinancialSubProfile executes a basic gorm create call
func DefaultCreatePaymentChannelMetricsFinancialSubProfile(ctx context.Context, in *PaymentChannelMetricsFinancialSubProfile, db *gorm.DB) (*PaymentChannelMetricsFinancialSubProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMetricsFinancialSubProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMetricsFinancialSubProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentChannelMetricsFinancialSubProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentChannelMetricsFinancialSubProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskPaymentChannelMetricsFinancialSubProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPaymentChannelMetricsFinancialSubProfile(ctx context.Context, patchee *PaymentChannelMetricsFinancialSubProfile, patcher *PaymentChannelMetricsFinancialSubProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PaymentChannelMetricsFinancialSubProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"SpentLastWeek" {
			patchee.SpentLastWeek = patcher.SpentLastWeek
			continue
		}
		if f == prefix+"SpentLastTwoWeeks" {
			patchee.SpentLastTwoWeeks = patcher.SpentLastTwoWeeks
			continue
		}
		if f == prefix+"SpentLastMonth" {
			patchee.SpentLastMonth = patcher.SpentLastMonth
			continue
		}
		if f == prefix+"SpentLastSixMonths" {
			patchee.SpentLastSixMonths = patcher.SpentLastSixMonths
			continue
		}
		if f == prefix+"SpentLastYear" {
			patchee.SpentLastYear = patcher.SpentLastYear
			continue
		}
		if f == prefix+"SpentLastTwoYears" {
			patchee.SpentLastTwoYears = patcher.SpentLastTwoYears
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPaymentChannelMetricsFinancialSubProfile executes a gorm list call
func DefaultListPaymentChannelMetricsFinancialSubProfile(ctx context.Context, db *gorm.DB) ([]*PaymentChannelMetricsFinancialSubProfile, error) {
	in := PaymentChannelMetricsFinancialSubProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMetricsFinancialSubProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PaymentChannelMetricsFinancialSubProfileORM{}, &PaymentChannelMetricsFinancialSubProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMetricsFinancialSubProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []PaymentChannelMetricsFinancialSubProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMetricsFinancialSubProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PaymentChannelMetricsFinancialSubProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentChannelMetricsFinancialSubProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentChannelMetricsFinancialSubProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentChannelMetricsFinancialSubProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentChannelMetricsFinancialSubProfileORM) error
}

// DefaultCreatePaymentChannelMonthlyExpenditure executes a basic gorm create call
func DefaultCreatePaymentChannelMonthlyExpenditure(ctx context.Context, in *PaymentChannelMonthlyExpenditure, db *gorm.DB) (*PaymentChannelMonthlyExpenditure, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMonthlyExpenditureORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMonthlyExpenditureORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentChannelMonthlyExpenditureORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentChannelMonthlyExpenditureORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskPaymentChannelMonthlyExpenditure patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPaymentChannelMonthlyExpenditure(ctx context.Context, patchee *PaymentChannelMonthlyExpenditure, patcher *PaymentChannelMonthlyExpenditure, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PaymentChannelMonthlyExpenditure, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"TotalSpending" {
			patchee.TotalSpending = patcher.TotalSpending
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPaymentChannelMonthlyExpenditure executes a gorm list call
func DefaultListPaymentChannelMonthlyExpenditure(ctx context.Context, db *gorm.DB) ([]*PaymentChannelMonthlyExpenditure, error) {
	in := PaymentChannelMonthlyExpenditure{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMonthlyExpenditureORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PaymentChannelMonthlyExpenditureORM{}, &PaymentChannelMonthlyExpenditure{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMonthlyExpenditureORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []PaymentChannelMonthlyExpenditureORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentChannelMonthlyExpenditureORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PaymentChannelMonthlyExpenditure{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentChannelMonthlyExpenditureORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentChannelMonthlyExpenditureORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentChannelMonthlyExpenditureORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentChannelMonthlyExpenditureORM) error
}

// DefaultCreateTotalInvestmentBySecurity executes a basic gorm create call
func DefaultCreateTotalInvestmentBySecurity(ctx context.Context, in *TotalInvestmentBySecurity, db *gorm.DB) (*TotalInvestmentBySecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TotalInvestmentBySecurityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TotalInvestmentBySecurityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TotalInvestmentBySecurityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TotalInvestmentBySecurityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskTotalInvestmentBySecurity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTotalInvestmentBySecurity(ctx context.Context, patchee *TotalInvestmentBySecurity, patcher *TotalInvestmentBySecurity, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TotalInvestmentBySecurity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"TotalInvestment" {
			patchee.TotalInvestment = patcher.TotalInvestment
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTotalInvestmentBySecurity executes a gorm list call
func DefaultListTotalInvestmentBySecurity(ctx context.Context, db *gorm.DB) ([]*TotalInvestmentBySecurity, error) {
	in := TotalInvestmentBySecurity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TotalInvestmentBySecurityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TotalInvestmentBySecurityORM{}, &TotalInvestmentBySecurity{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TotalInvestmentBySecurityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []TotalInvestmentBySecurityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TotalInvestmentBySecurityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TotalInvestmentBySecurity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TotalInvestmentBySecurityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TotalInvestmentBySecurityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TotalInvestmentBySecurityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TotalInvestmentBySecurityORM) error
}

// DefaultCreateTransactionAggregatesByMonth executes a basic gorm create call
func DefaultCreateTransactionAggregatesByMonth(ctx context.Context, in *TransactionAggregatesByMonth, db *gorm.DB) (*TransactionAggregatesByMonth, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionAggregatesByMonthORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionAggregatesByMonthORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionAggregatesByMonthORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionAggregatesByMonthORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskTransactionAggregatesByMonth patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionAggregatesByMonth(ctx context.Context, patchee *TransactionAggregatesByMonth, patcher *TransactionAggregatesByMonth, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionAggregatesByMonth, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Month" {
			patchee.Month = patcher.Month
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"LocationCity" {
			patchee.LocationCity = patcher.LocationCity
			continue
		}
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"TransactionCount" {
			patchee.TransactionCount = patcher.TransactionCount
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionAggregatesByMonth executes a gorm list call
func DefaultListTransactionAggregatesByMonth(ctx context.Context, db *gorm.DB) ([]*TransactionAggregatesByMonth, error) {
	in := TransactionAggregatesByMonth{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionAggregatesByMonthORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionAggregatesByMonthORM{}, &TransactionAggregatesByMonth{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionAggregatesByMonthORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []TransactionAggregatesByMonthORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionAggregatesByMonthORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionAggregatesByMonth{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionAggregatesByMonthORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionAggregatesByMonthORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionAggregatesByMonthORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionAggregatesByMonthORM) error
}

// DefaultCreateUserFinancialHealthMetricsTable executes a basic gorm create call
func DefaultCreateUserFinancialHealthMetricsTable(ctx context.Context, in *UserFinancialHealthMetricsTable, db *gorm.DB) (*UserFinancialHealthMetricsTable, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserFinancialHealthMetricsTableORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserFinancialHealthMetricsTableORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserFinancialHealthMetricsTableORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserFinancialHealthMetricsTableORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskUserFinancialHealthMetricsTable patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserFinancialHealthMetricsTable(ctx context.Context, patchee *UserFinancialHealthMetricsTable, patcher *UserFinancialHealthMetricsTable, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserFinancialHealthMetricsTable, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTime bool
	for i, f := range updateMask.Paths {
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"MonthlyIncome" {
			patchee.MonthlyIncome = patcher.MonthlyIncome
			continue
		}
		if f == prefix+"MonthlyExpenses" {
			patchee.MonthlyExpenses = patcher.MonthlyExpenses
			continue
		}
		if f == prefix+"TransactionDiversity" {
			patchee.TransactionDiversity = patcher.TransactionDiversity
			continue
		}
		if f == prefix+"DebtToIncomeRatio" {
			patchee.DebtToIncomeRatio = patcher.DebtToIncomeRatio
			continue
		}
		if f == prefix+"OverdraftFrequency" {
			patchee.OverdraftFrequency = patcher.OverdraftFrequency
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserFinancialHealthMetricsTable executes a gorm list call
func DefaultListUserFinancialHealthMetricsTable(ctx context.Context, db *gorm.DB) ([]*UserFinancialHealthMetricsTable, error) {
	in := UserFinancialHealthMetricsTable{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserFinancialHealthMetricsTableORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserFinancialHealthMetricsTableORM{}, &UserFinancialHealthMetricsTable{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserFinancialHealthMetricsTableORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []UserFinancialHealthMetricsTableORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserFinancialHealthMetricsTableORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserFinancialHealthMetricsTable{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserFinancialHealthMetricsTableORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserFinancialHealthMetricsTableORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserFinancialHealthMetricsTableORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserFinancialHealthMetricsTableORM) error
}
