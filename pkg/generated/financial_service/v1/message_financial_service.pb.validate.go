// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: financial_service/v1/message_financial_service.proto

package financial_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on StripeSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StripeSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StripeSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StripeSubscriptionMultiError, or nil if none found.
func (m *StripeSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *StripeSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for StripeSubscriptionId

	// no validation rules for StripeSubscriptionStatus

	// no validation rules for StripeSubscriptionActiveUntil

	// no validation rules for StripeWebhookLatestTimestamp

	// no validation rules for IsTrialing

	if len(errors) > 0 {
		return StripeSubscriptionMultiError(errors)
	}

	return nil
}

// StripeSubscriptionMultiError is an error wrapping multiple validation errors
// returned by StripeSubscription.ValidateAll() if the designated constraints
// aren't met.
type StripeSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StripeSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StripeSubscriptionMultiError) AllErrors() []error { return m }

// StripeSubscriptionValidationError is the validation error returned by
// StripeSubscription.Validate if the designated constraints aren't met.
type StripeSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StripeSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StripeSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StripeSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StripeSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StripeSubscriptionValidationError) ErrorName() string {
	return "StripeSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e StripeSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStripeSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StripeSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StripeSubscriptionValidationError{}

// Validate checks the field values on FinancialUserProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinancialUserProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinancialUserProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinancialUserProfileMultiError, or nil if none found.
func (m *FinancialUserProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *FinancialUserProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := FinancialUserProfileValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StripeCustomerId

	if all {
		switch v := interface{}(m.GetStripeSubscriptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinancialUserProfileValidationError{
					field:  "StripeSubscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinancialUserProfileValidationError{
					field:  "StripeSubscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStripeSubscriptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinancialUserProfileValidationError{
				field:  "StripeSubscriptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLink() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("Link[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("Link[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinancialUserProfileValidationError{
					field:  fmt.Sprintf("Link[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetActionableInsights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("ActionableInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("ActionableInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinancialUserProfileValidationError{
					field:  fmt.Sprintf("ActionableInsights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Email

	for idx, item := range m.GetMergeLiink() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("MergeLiink[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("MergeLiink[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinancialUserProfileValidationError{
					field:  fmt.Sprintf("MergeLiink[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetActionablePersonalInsights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("ActionablePersonalInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinancialUserProfileValidationError{
						field:  fmt.Sprintf("ActionablePersonalInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinancialUserProfileValidationError{
					field:  fmt.Sprintf("ActionablePersonalInsights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return FinancialUserProfileMultiError(errors)
	}

	return nil
}

// FinancialUserProfileMultiError is an error wrapping multiple validation
// errors returned by FinancialUserProfile.ValidateAll() if the designated
// constraints aren't met.
type FinancialUserProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinancialUserProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinancialUserProfileMultiError) AllErrors() []error { return m }

// FinancialUserProfileValidationError is the validation error returned by
// FinancialUserProfile.Validate if the designated constraints aren't met.
type FinancialUserProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinancialUserProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinancialUserProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinancialUserProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinancialUserProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinancialUserProfileValidationError) ErrorName() string {
	return "FinancialUserProfileValidationError"
}

// Error satisfies the builtin error interface
func (e FinancialUserProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinancialUserProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinancialUserProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinancialUserProfileValidationError{}

// Validate checks the field values on ActionableInsight with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActionableInsight) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionableInsight with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActionableInsightMultiError, or nil if none found.
func (m *ActionableInsight) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionableInsight) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DetailedAction

	// no validation rules for SummarizedAction

	if all {
		switch v := interface{}(m.GetGeneratedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeneratedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionableInsightValidationError{
				field:  "GeneratedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ActionableInsightMultiError(errors)
	}

	return nil
}

// ActionableInsightMultiError is an error wrapping multiple validation errors
// returned by ActionableInsight.ValidateAll() if the designated constraints
// aren't met.
type ActionableInsightMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionableInsightMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionableInsightMultiError) AllErrors() []error { return m }

// ActionableInsightValidationError is the validation error returned by
// ActionableInsight.Validate if the designated constraints aren't met.
type ActionableInsightValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionableInsightValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionableInsightValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionableInsightValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionableInsightValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionableInsightValidationError) ErrorName() string {
	return "ActionableInsightValidationError"
}

// Error satisfies the builtin error interface
func (e ActionableInsightValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionableInsight.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionableInsightValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionableInsightValidationError{}

// Validate checks the field values on PersonalActionableInsight with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PersonalActionableInsight) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PersonalActionableInsight with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PersonalActionableInsightMultiError, or nil if none found.
func (m *PersonalActionableInsight) ValidateAll() error {
	return m.validate(true)
}

func (m *PersonalActionableInsight) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InsightName

	// no validation rules for Description

	// no validation rules for Takeaway

	// no validation rules for Action

	// no validation rules for ExpectedBenefit

	if all {
		switch v := interface{}(m.GetGeneratedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PersonalActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PersonalActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeneratedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PersonalActionableInsightValidationError{
				field:  "GeneratedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PersonalActionableInsightMultiError(errors)
	}

	return nil
}

// PersonalActionableInsightMultiError is an error wrapping multiple validation
// errors returned by PersonalActionableInsight.ValidateAll() if the
// designated constraints aren't met.
type PersonalActionableInsightMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PersonalActionableInsightMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PersonalActionableInsightMultiError) AllErrors() []error { return m }

// PersonalActionableInsightValidationError is the validation error returned by
// PersonalActionableInsight.Validate if the designated constraints aren't met.
type PersonalActionableInsightValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PersonalActionableInsightValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PersonalActionableInsightValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PersonalActionableInsightValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PersonalActionableInsightValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PersonalActionableInsightValidationError) ErrorName() string {
	return "PersonalActionableInsightValidationError"
}

// Error satisfies the builtin error interface
func (e PersonalActionableInsightValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPersonalActionableInsight.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PersonalActionableInsightValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PersonalActionableInsightValidationError{}

// Validate checks the field values on Link with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Link) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Link with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LinkMultiError, or nil if none found.
func (m *Link) ValidateAll() error {
	return m.validate(true)
}

func (m *Link) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetPlaidSync()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidSync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidSync",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlaidSync()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "PlaidSync",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LinkStatus

	if all {
		switch v := interface{}(m.GetPlaidLink()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidLink",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "PlaidLink",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlaidLink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "PlaidLink",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PlaidNewAccountsAvailable

	// no validation rules for ExpirationDate

	// no validation rules for InstitutionName

	// no validation rules for CustomInstitutionName

	// no validation rules for Description

	// no validation rules for LastManualSync

	// no validation rules for LastSuccessfulUpdate

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBankAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("BankAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvestmentAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCreditAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("CreditAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("CreditAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("CreditAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMortgageAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("MortgageAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("MortgageAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("MortgageAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStudentLoanAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkValidationError{
						field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkValidationError{
					field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PlaidInstitutionId

	// no validation rules for LinkType

	// no validation rules for ErrorCode

	// no validation rules for UpdatedAt

	// no validation rules for NewAccountsAvailable

	// no validation rules for ShouldBeUpdated

	if len(errors) > 0 {
		return LinkMultiError(errors)
	}

	return nil
}

// LinkMultiError is an error wrapping multiple validation errors returned by
// Link.ValidateAll() if the designated constraints aren't met.
type LinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkMultiError) AllErrors() []error { return m }

// LinkValidationError is the validation error returned by Link.Validate if the
// designated constraints aren't met.
type LinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkValidationError) ErrorName() string { return "LinkValidationError" }

// Error satisfies the builtin error interface
func (e LinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkValidationError{}

// Validate checks the field values on PlaidSync with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlaidSync) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidSync with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlaidSyncMultiError, or nil
// if none found.
func (m *PlaidSync) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidSync) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TimeStamp

	// no validation rules for Trigger

	// no validation rules for NextCursor

	// no validation rules for Added

	// no validation rules for Removed

	// no validation rules for Modified

	if len(errors) > 0 {
		return PlaidSyncMultiError(errors)
	}

	return nil
}

// PlaidSyncMultiError is an error wrapping multiple validation errors returned
// by PlaidSync.ValidateAll() if the designated constraints aren't met.
type PlaidSyncMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidSyncMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidSyncMultiError) AllErrors() []error { return m }

// PlaidSyncValidationError is the validation error returned by
// PlaidSync.Validate if the designated constraints aren't met.
type PlaidSyncValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidSyncValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidSyncValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidSyncValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidSyncValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidSyncValidationError) ErrorName() string { return "PlaidSyncValidationError" }

// Error satisfies the builtin error interface
func (e PlaidSyncValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidSync.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidSyncValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidSyncValidationError{}

// Validate checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Token) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TokenMultiError, or nil if none found.
func (m *Token) ValidateAll() error {
	return m.validate(true)
}

func (m *Token) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ItemId

	// no validation rules for KeyId

	// no validation rules for AccessToken

	// no validation rules for Version

	// no validation rules for MergeEndUserOriginId

	// no validation rules for MergeIntegrationSlug

	if all {
		switch v := interface{}(m.GetLastMergeCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenValidationError{
					field:  "LastMergeCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenValidationError{
					field:  "LastMergeCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastMergeCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenValidationError{
				field:  "LastMergeCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenMultiError(errors)
	}

	return nil
}

// TokenMultiError is an error wrapping multiple validation errors returned by
// Token.ValidateAll() if the designated constraints aren't met.
type TokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenMultiError) AllErrors() []error { return m }

// TokenValidationError is the validation error returned by Token.Validate if
// the designated constraints aren't met.
type TokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenValidationError) ErrorName() string { return "TokenValidationError" }

// Error satisfies the builtin error interface
func (e TokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenValidationError{}

// Validate checks the field values on PlaidLink with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlaidLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidLink with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlaidLinkMultiError, or nil
// if none found.
func (m *PlaidLink) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for WebhookUrl

	// no validation rules for InstitutionId

	// no validation rules for InstitutionName

	// no validation rules for UsePlaidSync

	// no validation rules for ItemId

	if len(errors) > 0 {
		return PlaidLinkMultiError(errors)
	}

	return nil
}

// PlaidLinkMultiError is an error wrapping multiple validation errors returned
// by PlaidLink.ValidateAll() if the designated constraints aren't met.
type PlaidLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidLinkMultiError) AllErrors() []error { return m }

// PlaidLinkValidationError is the validation error returned by
// PlaidLink.Validate if the designated constraints aren't met.
type PlaidLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidLinkValidationError) ErrorName() string { return "PlaidLinkValidationError" }

// Error satisfies the builtin error interface
func (e PlaidLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidLinkValidationError{}

// Validate checks the field values on StudentLoanAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StudentLoanAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StudentLoanAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StudentLoanAccountMultiError, or nil if none found.
func (m *StudentLoanAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *StudentLoanAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlaidAccountId

	// no validation rules for ExpectedPayoffDate

	// no validation rules for Guarantor

	// no validation rules for InterestRatePercentage

	// no validation rules for IsOverdue

	// no validation rules for LastPaymentAmount

	// no validation rules for LastPaymentDate

	// no validation rules for LastStatementIssueDate

	// no validation rules for LoanName

	// no validation rules for LoanEndDate

	// no validation rules for MinimumPaymentAmount

	// no validation rules for NextPaymentDueDate

	// no validation rules for OriginationDate

	// no validation rules for OriginationPrincipalAmount

	// no validation rules for OutstandingInterestAmount

	// no validation rules for PaymentReferenceNumber

	// no validation rules for SequenceNumber

	// no validation rules for YtdInterestPaid

	// no validation rules for YtdPrincipalPaid

	// no validation rules for LoanType

	// no validation rules for PslfStatusEstimatedEligibilityDate

	// no validation rules for PslfStatusPaymentsMade

	// no validation rules for PslfStatusPaymentsRemaining

	// no validation rules for RepaymentPlanType

	// no validation rules for RepaymentPlanDescription

	// no validation rules for ServicerAddressCity

	// no validation rules for ServicerAddressPostalCode

	// no validation rules for ServicerAddressState

	// no validation rules for ServicerAddressStreet

	// no validation rules for ServicerAddressRegion

	// no validation rules for ServicerAddressCountry

	// no validation rules for UserId

	// no validation rules for Name

	// no validation rules for Status

	if len(errors) > 0 {
		return StudentLoanAccountMultiError(errors)
	}

	return nil
}

// StudentLoanAccountMultiError is an error wrapping multiple validation errors
// returned by StudentLoanAccount.ValidateAll() if the designated constraints
// aren't met.
type StudentLoanAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StudentLoanAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StudentLoanAccountMultiError) AllErrors() []error { return m }

// StudentLoanAccountValidationError is the validation error returned by
// StudentLoanAccount.Validate if the designated constraints aren't met.
type StudentLoanAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StudentLoanAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StudentLoanAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StudentLoanAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StudentLoanAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StudentLoanAccountValidationError) ErrorName() string {
	return "StudentLoanAccountValidationError"
}

// Error satisfies the builtin error interface
func (e StudentLoanAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStudentLoanAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StudentLoanAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StudentLoanAccountValidationError{}

// Validate checks the field values on CreditAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditAccountMultiError, or
// nil if none found.
func (m *CreditAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for CurrentFunds

	// no validation rules for BalanceLimit

	// no validation rules for PlaidAccountId

	// no validation rules for Subtype

	// no validation rules for IsOverdue

	// no validation rules for LastPaymentAmount

	// no validation rules for LastPaymentDate

	// no validation rules for LastStatementIssueDate

	// no validation rules for MinimumAmountDueDate

	// no validation rules for NextPaymentDate

	for idx, item := range m.GetAprs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreditAccountValidationError{
						field:  fmt.Sprintf("Aprs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreditAccountValidationError{
						field:  fmt.Sprintf("Aprs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreditAccountValidationError{
					field:  fmt.Sprintf("Aprs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LastStatementBalance

	// no validation rules for MinimumPaymentAmount

	// no validation rules for NextPaymentDueDate

	// no validation rules for Status

	if len(errors) > 0 {
		return CreditAccountMultiError(errors)
	}

	return nil
}

// CreditAccountMultiError is an error wrapping multiple validation errors
// returned by CreditAccount.ValidateAll() if the designated constraints
// aren't met.
type CreditAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditAccountMultiError) AllErrors() []error { return m }

// CreditAccountValidationError is the validation error returned by
// CreditAccount.Validate if the designated constraints aren't met.
type CreditAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditAccountValidationError) ErrorName() string { return "CreditAccountValidationError" }

// Error satisfies the builtin error interface
func (e CreditAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditAccountValidationError{}

// Validate checks the field values on MortgageAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MortgageAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MortgageAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MortgageAccountMultiError, or nil if none found.
func (m *MortgageAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *MortgageAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PlaidAccountId

	// no validation rules for AccountNumber

	// no validation rules for CurrentLateFee

	// no validation rules for EscrowBalance

	// no validation rules for HasPmi

	// no validation rules for HasPrepaymentPenalty

	// no validation rules for LastPaymentAmount

	// no validation rules for LastPaymentDate

	// no validation rules for LoanTerm

	// no validation rules for LoanTypeDescription

	// no validation rules for MaturityDate

	// no validation rules for NextMonthlyPayment

	// no validation rules for NextPaymentDueDate

	// no validation rules for OriginalPrincipalBalance

	// no validation rules for OriginalPropertyValue

	// no validation rules for OutstandingPrincipalBalance

	// no validation rules for PaymentAmount

	// no validation rules for PaymentDate

	// no validation rules for OriginationDate

	// no validation rules for OriginationPrincipalAmount

	// no validation rules for PastDueAmount

	// no validation rules for YtdInterestPaid

	// no validation rules for YtdPrincipalPaid

	// no validation rules for PropertyAddressCity

	// no validation rules for PropertyAddressState

	// no validation rules for PropertyAddressStreet

	// no validation rules for PropertyAddressPostalCode

	// no validation rules for PropertyRegion

	// no validation rules for PropertyCountry

	// no validation rules for InterestRatePercentage

	// no validation rules for InterestRateType

	// no validation rules for Status

	if len(errors) > 0 {
		return MortgageAccountMultiError(errors)
	}

	return nil
}

// MortgageAccountMultiError is an error wrapping multiple validation errors
// returned by MortgageAccount.ValidateAll() if the designated constraints
// aren't met.
type MortgageAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MortgageAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MortgageAccountMultiError) AllErrors() []error { return m }

// MortgageAccountValidationError is the validation error returned by
// MortgageAccount.Validate if the designated constraints aren't met.
type MortgageAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MortgageAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MortgageAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MortgageAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MortgageAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MortgageAccountValidationError) ErrorName() string { return "MortgageAccountValidationError" }

// Error satisfies the builtin error interface
func (e MortgageAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMortgageAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MortgageAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MortgageAccountValidationError{}

// Validate checks the field values on InvestmentAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvestmentAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvestmentAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvestmentAccountMultiError, or nil if none found.
func (m *InvestmentAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *InvestmentAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for CurrentFunds

	// no validation rules for BalanceLimit

	// no validation rules for PlaidAccountId

	// no validation rules for Subtype

	for idx, item := range m.GetHoldings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Holdings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Holdings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvestmentAccountValidationError{
					field:  fmt.Sprintf("Holdings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSecurities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvestmentAccountValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvestmentAccountValidationError{
					field:  fmt.Sprintf("Securities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if len(errors) > 0 {
		return InvestmentAccountMultiError(errors)
	}

	return nil
}

// InvestmentAccountMultiError is an error wrapping multiple validation errors
// returned by InvestmentAccount.ValidateAll() if the designated constraints
// aren't met.
type InvestmentAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvestmentAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvestmentAccountMultiError) AllErrors() []error { return m }

// InvestmentAccountValidationError is the validation error returned by
// InvestmentAccount.Validate if the designated constraints aren't met.
type InvestmentAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvestmentAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvestmentAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvestmentAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvestmentAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvestmentAccountValidationError) ErrorName() string {
	return "InvestmentAccountValidationError"
}

// Error satisfies the builtin error interface
func (e InvestmentAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvestmentAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvestmentAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvestmentAccountValidationError{}

// Validate checks the field values on BankAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BankAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BankAccountMultiError, or
// nil if none found.
func (m *BankAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *BankAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := BankAccountValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	// no validation rules for Balance

	// no validation rules for Currency

	// no validation rules for CurrentFunds

	// no validation rules for BalanceLimit

	for idx, item := range m.GetPockets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BankAccountValidationError{
						field:  fmt.Sprintf("Pockets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BankAccountValidationError{
						field:  fmt.Sprintf("Pockets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BankAccountValidationError{
					field:  fmt.Sprintf("Pockets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PlaidAccountId

	// no validation rules for Subtype

	// no validation rules for Status

	if len(errors) > 0 {
		return BankAccountMultiError(errors)
	}

	return nil
}

// BankAccountMultiError is an error wrapping multiple validation errors
// returned by BankAccount.ValidateAll() if the designated constraints aren't met.
type BankAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankAccountMultiError) AllErrors() []error { return m }

// BankAccountValidationError is the validation error returned by
// BankAccount.Validate if the designated constraints aren't met.
type BankAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankAccountValidationError) ErrorName() string { return "BankAccountValidationError" }

// Error satisfies the builtin error interface
func (e BankAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankAccountValidationError{}

// Validate checks the field values on Pocket with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pocket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pocket with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PocketMultiError, or nil if none found.
func (m *Pocket) ValidateAll() error {
	return m.validate(true)
}

func (m *Pocket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetGoals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PocketValidationError{
						field:  fmt.Sprintf("Goals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PocketValidationError{
						field:  fmt.Sprintf("Goals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PocketValidationError{
					field:  fmt.Sprintf("Goals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Type

	if len(errors) > 0 {
		return PocketMultiError(errors)
	}

	return nil
}

// PocketMultiError is an error wrapping multiple validation errors returned by
// Pocket.ValidateAll() if the designated constraints aren't met.
type PocketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PocketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PocketMultiError) AllErrors() []error { return m }

// PocketValidationError is the validation error returned by Pocket.Validate if
// the designated constraints aren't met.
type PocketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PocketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PocketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PocketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PocketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PocketValidationError) ErrorName() string { return "PocketValidationError" }

// Error satisfies the builtin error interface
func (e PocketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPocket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PocketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PocketValidationError{}

// Validate checks the field values on SmartGoal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SmartGoal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmartGoal with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SmartGoalMultiError, or nil
// if none found.
func (m *SmartGoal) ValidateAll() error {
	return m.validate(true)
}

func (m *SmartGoal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	if len(m.GetName()) < 3 {
		err := SmartGoalValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 3 {
		err := SmartGoalValidationError{
			field:  "Description",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsCompleted

	// no validation rules for GoalType

	if len(m.GetDuration()) < 3 {
		err := SmartGoalValidationError{
			field:  "Duration",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetStartDate()) < 3 {
		err := SmartGoalValidationError{
			field:  "StartDate",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetEndDate()) < 3 {
		err := SmartGoalValidationError{
			field:  "EndDate",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTargetAmount()) < 1 {
		err := SmartGoalValidationError{
			field:  "TargetAmount",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCurrentAmount()) < 0 {
		err := SmartGoalValidationError{
			field:  "CurrentAmount",
			reason: "value length must be at least 0 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMilestones() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SmartGoalValidationError{
						field:  fmt.Sprintf("Milestones[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SmartGoalValidationError{
						field:  fmt.Sprintf("Milestones[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SmartGoalValidationError{
					field:  fmt.Sprintf("Milestones[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetForecasts()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmartGoalValidationError{
					field:  "Forecasts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmartGoalValidationError{
					field:  "Forecasts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForecasts()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmartGoalValidationError{
				field:  "Forecasts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SmartGoalValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SmartGoalValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SmartGoalValidationError{
					field:  fmt.Sprintf("Notes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SmartGoalMultiError(errors)
	}

	return nil
}

// SmartGoalMultiError is an error wrapping multiple validation errors returned
// by SmartGoal.ValidateAll() if the designated constraints aren't met.
type SmartGoalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmartGoalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmartGoalMultiError) AllErrors() []error { return m }

// SmartGoalValidationError is the validation error returned by
// SmartGoal.Validate if the designated constraints aren't met.
type SmartGoalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmartGoalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmartGoalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmartGoalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmartGoalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmartGoalValidationError) ErrorName() string { return "SmartGoalValidationError" }

// Error satisfies the builtin error interface
func (e SmartGoalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmartGoal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmartGoalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmartGoalValidationError{}

// Validate checks the field values on SmartNote with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SmartNote) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SmartNote with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SmartNoteMultiError, or nil
// if none found.
func (m *SmartNote) ValidateAll() error {
	return m.validate(true)
}

func (m *SmartNote) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	if len(m.GetContent()) < 3 {
		err := SmartNoteValidationError{
			field:  "Content",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmartNoteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmartNoteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmartNoteValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SmartNoteValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SmartNoteValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SmartNoteValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SmartNoteMultiError(errors)
	}

	return nil
}

// SmartNoteMultiError is an error wrapping multiple validation errors returned
// by SmartNote.ValidateAll() if the designated constraints aren't met.
type SmartNoteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SmartNoteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SmartNoteMultiError) AllErrors() []error { return m }

// SmartNoteValidationError is the validation error returned by
// SmartNote.Validate if the designated constraints aren't met.
type SmartNoteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SmartNoteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SmartNoteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SmartNoteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SmartNoteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SmartNoteValidationError) ErrorName() string { return "SmartNoteValidationError" }

// Error satisfies the builtin error interface
func (e SmartNoteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSmartNote.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SmartNoteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SmartNoteValidationError{}

// Validate checks the field values on Forecast with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Forecast) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Forecast with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ForecastMultiError, or nil
// if none found.
func (m *Forecast) ValidateAll() error {
	return m.validate(true)
}

func (m *Forecast) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetForecastedAmount()) < 3 {
		err := ForecastValidationError{
			field:  "ForecastedAmount",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetForecastedCompletionDate()) < 3 {
		err := ForecastValidationError{
			field:  "ForecastedCompletionDate",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetVarianceAmount()) < 3 {
		err := ForecastValidationError{
			field:  "VarianceAmount",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ForecastMultiError(errors)
	}

	return nil
}

// ForecastMultiError is an error wrapping multiple validation errors returned
// by Forecast.ValidateAll() if the designated constraints aren't met.
type ForecastMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForecastMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForecastMultiError) AllErrors() []error { return m }

// ForecastValidationError is the validation error returned by
// Forecast.Validate if the designated constraints aren't met.
type ForecastValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForecastValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForecastValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForecastValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForecastValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForecastValidationError) ErrorName() string { return "ForecastValidationError" }

// Error satisfies the builtin error interface
func (e ForecastValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForecast.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForecastValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForecastValidationError{}

// Validate checks the field values on Milestone with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Milestone) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Milestone with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MilestoneMultiError, or nil
// if none found.
func (m *Milestone) ValidateAll() error {
	return m.validate(true)
}

func (m *Milestone) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := MilestoneValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 3 {
		err := MilestoneValidationError{
			field:  "Description",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTargetDate()) < 10 {
		err := MilestoneValidationError{
			field:  "TargetDate",
			reason: "value length must be at least 10 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTargetAmount()) < 3 {
		err := MilestoneValidationError{
			field:  "TargetAmount",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IsCompleted

	if all {
		switch v := interface{}(m.GetBudget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MilestoneValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MilestoneValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBudget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MilestoneValidationError{
				field:  "Budget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MilestoneMultiError(errors)
	}

	return nil
}

// MilestoneMultiError is an error wrapping multiple validation errors returned
// by Milestone.ValidateAll() if the designated constraints aren't met.
type MilestoneMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MilestoneMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MilestoneMultiError) AllErrors() []error { return m }

// MilestoneValidationError is the validation error returned by
// Milestone.Validate if the designated constraints aren't met.
type MilestoneValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MilestoneValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MilestoneValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MilestoneValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MilestoneValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MilestoneValidationError) ErrorName() string { return "MilestoneValidationError" }

// Error satisfies the builtin error interface
func (e MilestoneValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMilestone.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MilestoneValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MilestoneValidationError{}

// Validate checks the field values on Budget with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Budget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Budget with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BudgetMultiError, or nil if none found.
func (m *Budget) ValidateAll() error {
	return m.validate(true)
}

func (m *Budget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 10 {
		err := BudgetValidationError{
			field:  "Name",
			reason: "value length must be at least 10 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for StartDate

	// no validation rules for EndDate

	if all {
		switch v := interface{}(m.GetCategory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BudgetValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BudgetValidationError{
					field:  "Category",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BudgetValidationError{
				field:  "Category",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BudgetMultiError(errors)
	}

	return nil
}

// BudgetMultiError is an error wrapping multiple validation errors returned by
// Budget.ValidateAll() if the designated constraints aren't met.
type BudgetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BudgetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BudgetMultiError) AllErrors() []error { return m }

// BudgetValidationError is the validation error returned by Budget.Validate if
// the designated constraints aren't met.
type BudgetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BudgetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BudgetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BudgetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BudgetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BudgetValidationError) ErrorName() string { return "BudgetValidationError" }

// Error satisfies the builtin error interface
func (e BudgetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBudget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BudgetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BudgetValidationError{}

// Validate checks the field values on Category with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Category) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Category with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryMultiError, or nil
// if none found.
func (m *Category) ValidateAll() error {
	return m.validate(true)
}

func (m *Category) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := CategoryValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 10 {
		err := CategoryValidationError{
			field:  "Description",
			reason: "value length must be at least 10 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CategoryMultiError(errors)
	}

	return nil
}

// CategoryMultiError is an error wrapping multiple validation errors returned
// by Category.ValidateAll() if the designated constraints aren't met.
type CategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMultiError) AllErrors() []error { return m }

// CategoryValidationError is the validation error returned by
// Category.Validate if the designated constraints aren't met.
type CategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryValidationError) ErrorName() string { return "CategoryValidationError" }

// Error satisfies the builtin error interface
func (e CategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryValidationError{}

// Validate checks the field values on InvesmentHolding with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvesmentHolding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvesmentHolding with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvesmentHoldingMultiError, or nil if none found.
func (m *InvesmentHolding) ValidateAll() error {
	return m.validate(true)
}

func (m *InvesmentHolding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := InvesmentHoldingValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlaidAccountId

	// no validation rules for CostBasis

	// no validation rules for InstitutionPrice

	// no validation rules for InstitutionPriceAsOf

	// no validation rules for InstitutionPriceDatetime

	// no validation rules for InstitutionValue

	// no validation rules for IsoCurrencyCode

	// no validation rules for Quantity

	// no validation rules for SecurityId

	// no validation rules for UnofficialCurrencyCode

	if len(errors) > 0 {
		return InvesmentHoldingMultiError(errors)
	}

	return nil
}

// InvesmentHoldingMultiError is an error wrapping multiple validation errors
// returned by InvesmentHolding.ValidateAll() if the designated constraints
// aren't met.
type InvesmentHoldingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvesmentHoldingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvesmentHoldingMultiError) AllErrors() []error { return m }

// InvesmentHoldingValidationError is the validation error returned by
// InvesmentHolding.Validate if the designated constraints aren't met.
type InvesmentHoldingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvesmentHoldingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvesmentHoldingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvesmentHoldingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvesmentHoldingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvesmentHoldingValidationError) ErrorName() string { return "InvesmentHoldingValidationError" }

// Error satisfies the builtin error interface
func (e InvesmentHoldingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvesmentHolding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvesmentHoldingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvesmentHoldingValidationError{}

// Validate checks the field values on InvestmentSecurity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvestmentSecurity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvestmentSecurity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvestmentSecurityMultiError, or nil if none found.
func (m *InvestmentSecurity) ValidateAll() error {
	return m.validate(true)
}

func (m *InvestmentSecurity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ClosePrice

	// no validation rules for ClosePriceAsOf

	// no validation rules for Cusip

	// no validation rules for InstitutionId

	// no validation rules for InstitutionSecurityId

	// no validation rules for IsCashEquivalent

	// no validation rules for Isin

	// no validation rules for IsoCurrencyCode

	// no validation rules for Name

	// no validation rules for ProxySecurityId

	// no validation rules for SecurityId

	// no validation rules for Sedol

	// no validation rules for TickerSymbol

	// no validation rules for Type

	// no validation rules for UnofficialCurrencyCode

	// no validation rules for UpdateDatetime

	if len(errors) > 0 {
		return InvestmentSecurityMultiError(errors)
	}

	return nil
}

// InvestmentSecurityMultiError is an error wrapping multiple validation errors
// returned by InvestmentSecurity.ValidateAll() if the designated constraints
// aren't met.
type InvestmentSecurityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvestmentSecurityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvestmentSecurityMultiError) AllErrors() []error { return m }

// InvestmentSecurityValidationError is the validation error returned by
// InvestmentSecurity.Validate if the designated constraints aren't met.
type InvestmentSecurityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvestmentSecurityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvestmentSecurityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvestmentSecurityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvestmentSecurityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvestmentSecurityValidationError) ErrorName() string {
	return "InvestmentSecurityValidationError"
}

// Error satisfies the builtin error interface
func (e InvestmentSecurityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvestmentSecurity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvestmentSecurityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvestmentSecurityValidationError{}

// Validate checks the field values on Apr with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Apr) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Apr with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AprMultiError, or nil if none found.
func (m *Apr) ValidateAll() error {
	return m.validate(true)
}

func (m *Apr) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Percentage

	// no validation rules for Type

	// no validation rules for BalanceSubjectToApr

	// no validation rules for InterestChargeAmount

	if len(errors) > 0 {
		return AprMultiError(errors)
	}

	return nil
}

// AprMultiError is an error wrapping multiple validation errors returned by
// Apr.ValidateAll() if the designated constraints aren't met.
type AprMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AprMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AprMultiError) AllErrors() []error { return m }

// AprValidationError is the validation error returned by Apr.Validate if the
// designated constraints aren't met.
type AprValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AprValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AprValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AprValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AprValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AprValidationError) ErrorName() string { return "AprValidationError" }

// Error satisfies the builtin error interface
func (e AprValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApr.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AprValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AprValidationError{}

// Validate checks the field values on MergeLink with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MergeLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeLink with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MergeLinkMultiError, or nil
// if none found.
func (m *MergeLink) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Integration

	// no validation rules for IntegrationSlug

	// no validation rules for Category

	// no validation rules for EndUserOriginId

	// no validation rules for EndUserOrganizationName

	// no validation rules for EndUserEmailAddress

	// no validation rules for Status

	// no validation rules for WebhookListenerUrl

	// no validation rules for IsDuplicate

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeLinkValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IntegrationName

	// no validation rules for IntegrationImage

	// no validation rules for IntegrationSquareImage

	for idx, item := range m.GetAccount() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeLinkValidationError{
						field:  fmt.Sprintf("Account[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeLinkValidationError{
						field:  fmt.Sprintf("Account[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeLinkValidationError{
					field:  fmt.Sprintf("Account[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MergeLinkedAccountId

	if len(errors) > 0 {
		return MergeLinkMultiError(errors)
	}

	return nil
}

// MergeLinkMultiError is an error wrapping multiple validation errors returned
// by MergeLink.ValidateAll() if the designated constraints aren't met.
type MergeLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeLinkMultiError) AllErrors() []error { return m }

// MergeLinkValidationError is the validation error returned by
// MergeLink.Validate if the designated constraints aren't met.
type MergeLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeLinkValidationError) ErrorName() string { return "MergeLinkValidationError" }

// Error satisfies the builtin error interface
func (e MergeLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeLinkValidationError{}

// Validate checks the field values on LinkedAccountingAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LinkedAccountingAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkedAccountingAccount with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinkedAccountingAccountMultiError, or nil if none found.
func (m *LinkedAccountingAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkedAccountingAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCompanyInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CompanyInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CompanyInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("CompanyInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPurchaseOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReportDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReportDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReportDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkedAccountingAccountValidationError{
				field:  "ReportDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReferenceDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReferenceDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReferenceDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReferenceDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkedAccountingAccountValidationError{
				field:  "ReferenceDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransactionsDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "TransactionsDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "TransactionsDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionsDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkedAccountingAccountValidationError{
				field:  "TransactionsDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LinkedAccountingAccountMultiError(errors)
	}

	return nil
}

// LinkedAccountingAccountMultiError is an error wrapping multiple validation
// errors returned by LinkedAccountingAccount.ValidateAll() if the designated
// constraints aren't met.
type LinkedAccountingAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkedAccountingAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkedAccountingAccountMultiError) AllErrors() []error { return m }

// LinkedAccountingAccountValidationError is the validation error returned by
// LinkedAccountingAccount.Validate if the designated constraints aren't met.
type LinkedAccountingAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkedAccountingAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkedAccountingAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkedAccountingAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkedAccountingAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkedAccountingAccountValidationError) ErrorName() string {
	return "LinkedAccountingAccountValidationError"
}

// Error satisfies the builtin error interface
func (e LinkedAccountingAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkedAccountingAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkedAccountingAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkedAccountingAccountValidationError{}

// Validate checks the field values on TransactionDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionDetailsMultiError, or nil if none found.
func (m *TransactionDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetInvoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Invoices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPayments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Payments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Payments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Payments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Expenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetJournalEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("JournalEntries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("JournalEntries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("JournalEntries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVendorCredits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("VendorCredits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("VendorCredits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("VendorCredits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCreditNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("CreditNotes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("CreditNotes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("CreditNotes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionDetailsMultiError(errors)
	}

	return nil
}

// TransactionDetailsMultiError is an error wrapping multiple validation errors
// returned by TransactionDetails.ValidateAll() if the designated constraints
// aren't met.
type TransactionDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionDetailsMultiError) AllErrors() []error { return m }

// TransactionDetailsValidationError is the validation error returned by
// TransactionDetails.Validate if the designated constraints aren't met.
type TransactionDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionDetailsValidationError) ErrorName() string {
	return "TransactionDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionDetailsValidationError{}

// Validate checks the field values on ReferenceDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceDetailsMultiError, or nil if none found.
func (m *ReferenceDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetChartOfAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTaxRates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("TaxRates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("TaxRates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("TaxRates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetContacts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Contacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Contacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("Contacts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceDetailsMultiError(errors)
	}

	return nil
}

// ReferenceDetailsMultiError is an error wrapping multiple validation errors
// returned by ReferenceDetails.ValidateAll() if the designated constraints
// aren't met.
type ReferenceDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceDetailsMultiError) AllErrors() []error { return m }

// ReferenceDetailsValidationError is the validation error returned by
// ReferenceDetails.Validate if the designated constraints aren't met.
type ReferenceDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceDetailsValidationError) ErrorName() string { return "ReferenceDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceDetailsValidationError{}

// Validate checks the field values on ReportDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportDetailsMultiError, or
// nil if none found.
func (m *ReportDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetBalanceSheets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("BalanceSheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("BalanceSheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportDetailsValidationError{
					field:  fmt.Sprintf("BalanceSheets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCashFlowStatements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportDetailsValidationError{
					field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIncomeStatements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("IncomeStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("IncomeStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportDetailsValidationError{
					field:  fmt.Sprintf("IncomeStatements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReportDetailsMultiError(errors)
	}

	return nil
}

// ReportDetailsMultiError is an error wrapping multiple validation errors
// returned by ReportDetails.ValidateAll() if the designated constraints
// aren't met.
type ReportDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportDetailsMultiError) AllErrors() []error { return m }

// ReportDetailsValidationError is the validation error returned by
// ReportDetails.Validate if the designated constraints aren't met.
type ReportDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportDetailsValidationError) ErrorName() string { return "ReportDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ReportDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportDetailsValidationError{}

// Validate checks the field values on BusinessChartOfAccounts with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessChartOfAccounts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessChartOfAccounts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessChartOfAccountsMultiError, or nil if none found.
func (m *BusinessChartOfAccounts) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessChartOfAccounts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Classification

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for CurrentBalance

	// no validation rules for Currency

	// no validation rules for AccountNumber

	// no validation rules for ParentAccountId

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessChartOfAccountsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessChartOfAccountsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessChartOfAccountsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if len(errors) > 0 {
		return BusinessChartOfAccountsMultiError(errors)
	}

	return nil
}

// BusinessChartOfAccountsMultiError is an error wrapping multiple validation
// errors returned by BusinessChartOfAccounts.ValidateAll() if the designated
// constraints aren't met.
type BusinessChartOfAccountsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessChartOfAccountsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessChartOfAccountsMultiError) AllErrors() []error { return m }

// BusinessChartOfAccountsValidationError is the validation error returned by
// BusinessChartOfAccounts.Validate if the designated constraints aren't met.
type BusinessChartOfAccountsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessChartOfAccountsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessChartOfAccountsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessChartOfAccountsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessChartOfAccountsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessChartOfAccountsValidationError) ErrorName() string {
	return "BusinessChartOfAccountsValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessChartOfAccountsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessChartOfAccounts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessChartOfAccountsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessChartOfAccountsValidationError{}

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Address) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddressMultiError, or nil if none found.
func (m *Address) ValidateAll() error {
	return m.validate(true)
}

func (m *Address) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Street_1

	// no validation rules for Street_2

	// no validation rules for City

	// no validation rules for State

	// no validation rules for CountrySubdivision

	// no validation rules for Country

	// no validation rules for ZipCode

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}

	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.ValidateAll() if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on Attachments with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Attachments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Attachments with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AttachmentsMultiError, or
// nil if none found.
func (m *Attachments) ValidateAll() error {
	return m.validate(true)
}

func (m *Attachments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	// no validation rules for FileName

	// no validation rules for FileUrl

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AttachmentsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AttachmentsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AttachmentsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AttachmentsMultiError(errors)
	}

	return nil
}

// AttachmentsMultiError is an error wrapping multiple validation errors
// returned by Attachments.ValidateAll() if the designated constraints aren't met.
type AttachmentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachmentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachmentsMultiError) AllErrors() []error { return m }

// AttachmentsValidationError is the validation error returned by
// Attachments.Validate if the designated constraints aren't met.
type AttachmentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachmentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachmentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachmentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachmentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachmentsValidationError) ErrorName() string { return "AttachmentsValidationError" }

// Error satisfies the builtin error interface
func (e AttachmentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachmentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachmentsValidationError{}

// Validate checks the field values on BalanceSheet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceSheet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceSheet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceSheetMultiError, or
// nil if none found.
func (m *BalanceSheet) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceSheet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetAssets

	for idx, item := range m.GetAssets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Assets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLiabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Liabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Liabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Liabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEquity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Equity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Equity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Equity[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteGeneratedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteGeneratedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "RemoteGeneratedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return BalanceSheetMultiError(errors)
	}

	return nil
}

// BalanceSheetMultiError is an error wrapping multiple validation errors
// returned by BalanceSheet.ValidateAll() if the designated constraints aren't met.
type BalanceSheetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceSheetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceSheetMultiError) AllErrors() []error { return m }

// BalanceSheetValidationError is the validation error returned by
// BalanceSheet.Validate if the designated constraints aren't met.
type BalanceSheetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceSheetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceSheetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceSheetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceSheetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceSheetValidationError) ErrorName() string { return "BalanceSheetValidationError" }

// Error satisfies the builtin error interface
func (e BalanceSheetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceSheet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceSheetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceSheetValidationError{}

// Validate checks the field values on ReportItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportItemMultiError, or
// nil if none found.
func (m *ReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Value

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportItemMultiError(errors)
	}

	return nil
}

// ReportItemMultiError is an error wrapping multiple validation errors
// returned by ReportItem.ValidateAll() if the designated constraints aren't met.
type ReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportItemMultiError) AllErrors() []error { return m }

// ReportItemValidationError is the validation error returned by
// ReportItem.Validate if the designated constraints aren't met.
type ReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportItemValidationError) ErrorName() string { return "ReportItemValidationError" }

// Error satisfies the builtin error interface
func (e ReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportItemValidationError{}

// Validate checks the field values on CashFlowStatements with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CashFlowStatements) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CashFlowStatements with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CashFlowStatementsMultiError, or nil if none found.
func (m *CashFlowStatements) ValidateAll() error {
	return m.validate(true)
}

func (m *CashFlowStatements) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetStartPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "StartPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "EndPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CashAtBeginningOfPeriod

	// no validation rules for CashAtEndOfPeriod

	for idx, item := range m.GetOperatingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("OperatingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("OperatingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementsValidationError{
					field:  fmt.Sprintf("OperatingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvestingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("InvestingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("InvestingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementsValidationError{
					field:  fmt.Sprintf("InvestingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFinancingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("FinancingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("FinancingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementsValidationError{
					field:  fmt.Sprintf("FinancingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteGeneratedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteGeneratedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "RemoteGeneratedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return CashFlowStatementsMultiError(errors)
	}

	return nil
}

// CashFlowStatementsMultiError is an error wrapping multiple validation errors
// returned by CashFlowStatements.ValidateAll() if the designated constraints
// aren't met.
type CashFlowStatementsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CashFlowStatementsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CashFlowStatementsMultiError) AllErrors() []error { return m }

// CashFlowStatementsValidationError is the validation error returned by
// CashFlowStatements.Validate if the designated constraints aren't met.
type CashFlowStatementsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CashFlowStatementsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CashFlowStatementsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CashFlowStatementsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CashFlowStatementsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CashFlowStatementsValidationError) ErrorName() string {
	return "CashFlowStatementsValidationError"
}

// Error satisfies the builtin error interface
func (e CashFlowStatementsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCashFlowStatements.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CashFlowStatementsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CashFlowStatementsValidationError{}

// Validate checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyInfoMultiError, or
// nil if none found.
func (m *CompanyInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for LegalName

	// no validation rules for TaxNumber

	// no validation rules for FiscalYearEndMonth

	// no validation rules for FiscalYearEndDay

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyInfoValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompanyInfoValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyInfoValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return CompanyInfoMultiError(errors)
	}

	return nil
}

// CompanyInfoMultiError is an error wrapping multiple validation errors
// returned by CompanyInfo.ValidateAll() if the designated constraints aren't met.
type CompanyInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyInfoMultiError) AllErrors() []error { return m }

// CompanyInfoValidationError is the validation error returned by
// CompanyInfo.Validate if the designated constraints aren't met.
type CompanyInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyInfoValidationError) ErrorName() string { return "CompanyInfoValidationError" }

// Error satisfies the builtin error interface
func (e CompanyInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyInfoValidationError{}

// Validate checks the field values on AccountingAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountingAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountingAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccountingAttachmentMultiError, or nil if none found.
func (m *AccountingAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountingAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for FileName

	// no validation rules for FileUrl

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	// no validation rules for ModifiedAt

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return AccountingAttachmentMultiError(errors)
	}

	return nil
}

// AccountingAttachmentMultiError is an error wrapping multiple validation
// errors returned by AccountingAttachment.ValidateAll() if the designated
// constraints aren't met.
type AccountingAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountingAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountingAttachmentMultiError) AllErrors() []error { return m }

// AccountingAttachmentValidationError is the validation error returned by
// AccountingAttachment.Validate if the designated constraints aren't met.
type AccountingAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountingAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountingAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountingAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountingAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountingAttachmentValidationError) ErrorName() string {
	return "AccountingAttachmentValidationError"
}

// Error satisfies the builtin error interface
func (e AccountingAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountingAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountingAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountingAttachmentValidationError{}

// Validate checks the field values on Contacts with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Contacts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Contacts with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContactsMultiError, or nil
// if none found.
func (m *Contacts) ValidateAll() error {
	return m.validate(true)
}

func (m *Contacts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for IsSupplier

	// no validation rules for IsCustomer

	// no validation rules for EmailAddress

	// no validation rules for TaxNumber

	// no validation rules for Status

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContactsValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContactsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return ContactsMultiError(errors)
	}

	return nil
}

// ContactsMultiError is an error wrapping multiple validation errors returned
// by Contacts.ValidateAll() if the designated constraints aren't met.
type ContactsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContactsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContactsMultiError) AllErrors() []error { return m }

// ContactsValidationError is the validation error returned by
// Contacts.Validate if the designated constraints aren't met.
type ContactsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContactsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContactsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContactsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContactsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContactsValidationError) ErrorName() string { return "ContactsValidationError" }

// Error satisfies the builtin error interface
func (e ContactsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContacts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContactsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContactsValidationError{}

// Validate checks the field values on CreditNote with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditNote) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditNote with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditNoteMultiError, or
// nil if none found.
func (m *CreditNote) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditNote) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Number

	// no validation rules for Contact

	// no validation rules for Company

	// no validation rules for ExchangeRate

	// no validation rules for TotalAmount

	// no validation rules for RemainingCredit

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreditNoteValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreditNoteValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreditNoteValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return CreditNoteMultiError(errors)
	}

	return nil
}

// CreditNoteMultiError is an error wrapping multiple validation errors
// returned by CreditNote.ValidateAll() if the designated constraints aren't met.
type CreditNoteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditNoteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditNoteMultiError) AllErrors() []error { return m }

// CreditNoteValidationError is the validation error returned by
// CreditNote.Validate if the designated constraints aren't met.
type CreditNoteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditNoteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditNoteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditNoteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditNoteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditNoteValidationError) ErrorName() string { return "CreditNoteValidationError" }

// Error satisfies the builtin error interface
func (e CreditNoteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditNote.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditNoteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditNoteValidationError{}

// Validate checks the field values on CreditNoteLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreditNoteLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditNoteLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreditNoteLineItemMultiError, or nil if none found.
func (m *CreditNoteLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditNoteLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Quantity

	// no validation rules for UnitPrice

	// no validation rules for TaxRate

	// no validation rules for TotalLineAmount

	// no validation rules for TrackingCategory

	// no validation rules for Account

	// no validation rules for Company

	// no validation rules for RemoteId

	// no validation rules for Item

	if len(errors) > 0 {
		return CreditNoteLineItemMultiError(errors)
	}

	return nil
}

// CreditNoteLineItemMultiError is an error wrapping multiple validation errors
// returned by CreditNoteLineItem.ValidateAll() if the designated constraints
// aren't met.
type CreditNoteLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditNoteLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditNoteLineItemMultiError) AllErrors() []error { return m }

// CreditNoteLineItemValidationError is the validation error returned by
// CreditNoteLineItem.Validate if the designated constraints aren't met.
type CreditNoteLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditNoteLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditNoteLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditNoteLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditNoteLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditNoteLineItemValidationError) ErrorName() string {
	return "CreditNoteLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e CreditNoteLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditNoteLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditNoteLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditNoteLineItemValidationError{}

// Validate checks the field values on Expense with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expense) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expense with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExpenseMultiError, or nil if none found.
func (m *Expense) ValidateAll() error {
	return m.validate(true)
}

func (m *Expense) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for TotalAmount

	// no validation rules for SubTotal

	// no validation rules for TotalTaxAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	// no validation rules for Memo

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpenseValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpenseValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpenseValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return ExpenseMultiError(errors)
	}

	return nil
}

// ExpenseMultiError is an error wrapping multiple validation errors returned
// by Expense.ValidateAll() if the designated constraints aren't met.
type ExpenseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseMultiError) AllErrors() []error { return m }

// ExpenseValidationError is the validation error returned by Expense.Validate
// if the designated constraints aren't met.
type ExpenseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseValidationError) ErrorName() string { return "ExpenseValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpense.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseValidationError{}

// Validate checks the field values on ExpenseLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpenseLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpenseLineMultiError, or
// nil if none found.
func (m *ExpenseLine) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Company

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for Description

	// no validation rules for ExchangeRate

	// no validation rules for RemoteId

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpenseLineMultiError(errors)
	}

	return nil
}

// ExpenseLineMultiError is an error wrapping multiple validation errors
// returned by ExpenseLine.ValidateAll() if the designated constraints aren't met.
type ExpenseLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseLineMultiError) AllErrors() []error { return m }

// ExpenseLineValidationError is the validation error returned by
// ExpenseLine.Validate if the designated constraints aren't met.
type ExpenseLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseLineValidationError) ErrorName() string { return "ExpenseLineValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseLineValidationError{}

// Validate checks the field values on IncomeStatement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IncomeStatement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncomeStatement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IncomeStatementMultiError, or nil if none found.
func (m *IncomeStatement) ValidateAll() error {
	return m.validate(true)
}

func (m *IncomeStatement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetStartPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "StartPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "EndPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetIncome() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("Income[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCostOfSales() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("CostOfSales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("CostOfSales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("CostOfSales[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for GrossProfit

	for idx, item := range m.GetOperatingExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NetOperatingIncome

	for idx, item := range m.GetNonOperatingExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NetIncome

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IncomeStatementMultiError(errors)
	}

	return nil
}

// IncomeStatementMultiError is an error wrapping multiple validation errors
// returned by IncomeStatement.ValidateAll() if the designated constraints
// aren't met.
type IncomeStatementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncomeStatementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncomeStatementMultiError) AllErrors() []error { return m }

// IncomeStatementValidationError is the validation error returned by
// IncomeStatement.Validate if the designated constraints aren't met.
type IncomeStatementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncomeStatementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncomeStatementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncomeStatementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncomeStatementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncomeStatementValidationError) ErrorName() string { return "IncomeStatementValidationError" }

// Error satisfies the builtin error interface
func (e IncomeStatementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncomeStatement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncomeStatementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncomeStatementValidationError{}

// Validate checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InvoiceMultiError, or nil if none found.
func (m *Invoice) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Contact

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "DueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaidOnDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidOnDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidOnDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaidOnDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "PaidOnDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Memo

	// no validation rules for Company

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for TotalDiscount

	// no validation rules for SubTotal

	// no validation rules for Status

	// no validation rules for TotalTaxAmount

	// no validation rules for TotalAmount

	// no validation rules for Balance

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvoiceValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvoiceValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvoiceValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return InvoiceMultiError(errors)
	}

	return nil
}

// InvoiceMultiError is an error wrapping multiple validation errors returned
// by Invoice.ValidateAll() if the designated constraints aren't met.
type InvoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceMultiError) AllErrors() []error { return m }

// InvoiceValidationError is the validation error returned by Invoice.Validate
// if the designated constraints aren't met.
type InvoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceValidationError) ErrorName() string { return "InvoiceValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceValidationError{}

// Validate checks the field values on InvoiceLineItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemMultiError, or nil if none found.
func (m *InvoiceLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for UnitPrice

	// no validation rules for Quantity

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for Company

	// no validation rules for MergeAccountId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineItemMultiError(errors)
	}

	return nil
}

// InvoiceLineItemMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItem.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemMultiError) AllErrors() []error { return m }

// InvoiceLineItemValidationError is the validation error returned by
// InvoiceLineItem.Validate if the designated constraints aren't met.
type InvoiceLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemValidationError) ErrorName() string { return "InvoiceLineItemValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemValidationError{}

// Validate checks the field values on Item with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Item) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Item with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ItemMultiError, or nil if none found.
func (m *Item) ValidateAll() error {
	return m.validate(true)
}

func (m *Item) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for UnitPrice

	// no validation rules for PurchasePrice

	// no validation rules for PurchaseAccount

	// no validation rules for SalesAccount

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return ItemMultiError(errors)
	}

	return nil
}

// ItemMultiError is an error wrapping multiple validation errors returned by
// Item.ValidateAll() if the designated constraints aren't met.
type ItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemMultiError) AllErrors() []error { return m }

// ItemValidationError is the validation error returned by Item.Validate if the
// designated constraints aren't met.
type ItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemValidationError) ErrorName() string { return "ItemValidationError" }

// Error satisfies the builtin error interface
func (e ItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemValidationError{}

// Validate checks the field values on JournalEntry with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JournalEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JournalEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JournalEntryMultiError, or
// nil if none found.
func (m *JournalEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *JournalEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Memo

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JournalEntryValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JournalEntryValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JournalEntryValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for JournalNumber

	// no validation rules for RemoteWasDeleted

	// no validation rules for PostingStatus

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return JournalEntryMultiError(errors)
	}

	return nil
}

// JournalEntryMultiError is an error wrapping multiple validation errors
// returned by JournalEntry.ValidateAll() if the designated constraints aren't met.
type JournalEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JournalEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JournalEntryMultiError) AllErrors() []error { return m }

// JournalEntryValidationError is the validation error returned by
// JournalEntry.Validate if the designated constraints aren't met.
type JournalEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JournalEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JournalEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JournalEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JournalEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JournalEntryValidationError) ErrorName() string { return "JournalEntryValidationError" }

// Error satisfies the builtin error interface
func (e JournalEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJournalEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JournalEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JournalEntryValidationError{}

// Validate checks the field values on JournalLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JournalLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JournalLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JournalLineMultiError, or
// nil if none found.
func (m *JournalLine) ValidateAll() error {
	return m.validate(true)
}

func (m *JournalLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Account

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Contact

	// no validation rules for Company

	// no validation rules for Description

	// no validation rules for ExchangeRate

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JournalLineMultiError(errors)
	}

	return nil
}

// JournalLineMultiError is an error wrapping multiple validation errors
// returned by JournalLine.ValidateAll() if the designated constraints aren't met.
type JournalLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JournalLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JournalLineMultiError) AllErrors() []error { return m }

// JournalLineValidationError is the validation error returned by
// JournalLine.Validate if the designated constraints aren't met.
type JournalLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JournalLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JournalLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JournalLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JournalLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JournalLineValidationError) ErrorName() string { return "JournalLineValidationError" }

// Error satisfies the builtin error interface
func (e JournalLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJournalLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JournalLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JournalLineValidationError{}

// Validate checks the field values on Payment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PaymentMultiError, or nil if none found.
func (m *Payment) ValidateAll() error {
	return m.validate(true)
}

func (m *Payment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Contact

	// no validation rules for Account

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	// no validation rules for TotalAmount

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return PaymentMultiError(errors)
	}

	return nil
}

// PaymentMultiError is an error wrapping multiple validation errors returned
// by Payment.ValidateAll() if the designated constraints aren't met.
type PaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentMultiError) AllErrors() []error { return m }

// PaymentValidationError is the validation error returned by Payment.Validate
// if the designated constraints aren't met.
type PaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentValidationError) ErrorName() string { return "PaymentValidationError" }

// Error satisfies the builtin error interface
func (e PaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentValidationError{}

// Validate checks the field values on PurchaseOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PurchaseOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PurchaseOrder with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PurchaseOrderMultiError, or
// nil if none found.
func (m *PurchaseOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *PurchaseOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeAccountId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PurchaseOrderNumber

	if all {
		switch v := interface{}(m.GetDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "DeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeliveryAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "DeliveryAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Customer

	// no validation rules for Vendor

	// no validation rules for Memo

	// no validation rules for Company

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PurchaseOrderValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PurchaseOrderValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PurchaseOrderValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PurchaseOrderMultiError(errors)
	}

	return nil
}

// PurchaseOrderMultiError is an error wrapping multiple validation errors
// returned by PurchaseOrder.ValidateAll() if the designated constraints
// aren't met.
type PurchaseOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PurchaseOrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PurchaseOrderMultiError) AllErrors() []error { return m }

// PurchaseOrderValidationError is the validation error returned by
// PurchaseOrder.Validate if the designated constraints aren't met.
type PurchaseOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PurchaseOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PurchaseOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PurchaseOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PurchaseOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PurchaseOrderValidationError) ErrorName() string { return "PurchaseOrderValidationError" }

// Error satisfies the builtin error interface
func (e PurchaseOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPurchaseOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PurchaseOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PurchaseOrderValidationError{}

// Validate checks the field values on PurchaseOrderLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PurchaseOrderLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PurchaseOrderLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PurchaseOrderLineItemMultiError, or nil if none found.
func (m *PurchaseOrderLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PurchaseOrderLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for Quantity

	// no validation rules for UnitPrice

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for TaxAmount

	// no validation rules for TotalLineAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PurchaseOrderLineItemMultiError(errors)
	}

	return nil
}

// PurchaseOrderLineItemMultiError is an error wrapping multiple validation
// errors returned by PurchaseOrderLineItem.ValidateAll() if the designated
// constraints aren't met.
type PurchaseOrderLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PurchaseOrderLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PurchaseOrderLineItemMultiError) AllErrors() []error { return m }

// PurchaseOrderLineItemValidationError is the validation error returned by
// PurchaseOrderLineItem.Validate if the designated constraints aren't met.
type PurchaseOrderLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PurchaseOrderLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PurchaseOrderLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PurchaseOrderLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PurchaseOrderLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PurchaseOrderLineItemValidationError) ErrorName() string {
	return "PurchaseOrderLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e PurchaseOrderLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPurchaseOrderLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PurchaseOrderLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PurchaseOrderLineItemValidationError{}

// Validate checks the field values on TaxRate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxRate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaxRateMultiError, or nil if none found.
func (m *TaxRate) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for TotalTaxRate

	// no validation rules for EffectiveTaxRate

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxRateValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return TaxRateMultiError(errors)
	}

	return nil
}

// TaxRateMultiError is an error wrapping multiple validation errors returned
// by TaxRate.ValidateAll() if the designated constraints aren't met.
type TaxRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxRateMultiError) AllErrors() []error { return m }

// TaxRateValidationError is the validation error returned by TaxRate.Validate
// if the designated constraints aren't met.
type TaxRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxRateValidationError) ErrorName() string { return "TaxRateValidationError" }

// Error satisfies the builtin error interface
func (e TaxRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxRateValidationError{}

// Validate checks the field values on TrackingCategory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TrackingCategory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackingCategory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackingCategoryMultiError, or nil if none found.
func (m *TrackingCategory) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackingCategory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for MergeAccountId

	// no validation rules for CategoryType

	// no validation rules for ParentCategory

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackingCategoryValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackingCategoryMultiError(errors)
	}

	return nil
}

// TrackingCategoryMultiError is an error wrapping multiple validation errors
// returned by TrackingCategory.ValidateAll() if the designated constraints
// aren't met.
type TrackingCategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackingCategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackingCategoryMultiError) AllErrors() []error { return m }

// TrackingCategoryValidationError is the validation error returned by
// TrackingCategory.Validate if the designated constraints aren't met.
type TrackingCategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackingCategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackingCategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackingCategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackingCategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackingCategoryValidationError) ErrorName() string { return "TrackingCategoryValidationError" }

// Error satisfies the builtin error interface
func (e TrackingCategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackingCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackingCategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackingCategoryValidationError{}

// Validate checks the field values on BusinessTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessTransactionMultiError, or nil if none found.
func (m *BusinessTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TransactionType

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BusinessTransactionValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BusinessTransactionValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BusinessTransactionValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BusinessTransactionMultiError(errors)
	}

	return nil
}

// BusinessTransactionMultiError is an error wrapping multiple validation
// errors returned by BusinessTransaction.ValidateAll() if the designated
// constraints aren't met.
type BusinessTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessTransactionMultiError) AllErrors() []error { return m }

// BusinessTransactionValidationError is the validation error returned by
// BusinessTransaction.Validate if the designated constraints aren't met.
type BusinessTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessTransactionValidationError) ErrorName() string {
	return "BusinessTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessTransactionValidationError{}

// Validate checks the field values on TransactionLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionLineItemMultiError, or nil if none found.
func (m *TransactionLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Memo

	// no validation rules for UnitPrice

	// no validation rules for Quantity

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for TotalLineAmount

	// no validation rules for TaxRate

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionLineItemMultiError(errors)
	}

	return nil
}

// TransactionLineItemMultiError is an error wrapping multiple validation
// errors returned by TransactionLineItem.ValidateAll() if the designated
// constraints aren't met.
type TransactionLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionLineItemMultiError) AllErrors() []error { return m }

// TransactionLineItemValidationError is the validation error returned by
// TransactionLineItem.Validate if the designated constraints aren't met.
type TransactionLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionLineItemValidationError) ErrorName() string {
	return "TransactionLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionLineItemValidationError{}

// Validate checks the field values on VendorCredit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorCredit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorCredit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorCreditMultiError, or
// nil if none found.
func (m *VendorCredit) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorCredit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Vendor

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VendorCreditValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VendorCreditValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VendorCreditValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorCreditMultiError(errors)
	}

	return nil
}

// VendorCreditMultiError is an error wrapping multiple validation errors
// returned by VendorCredit.ValidateAll() if the designated constraints aren't met.
type VendorCreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorCreditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorCreditMultiError) AllErrors() []error { return m }

// VendorCreditValidationError is the validation error returned by
// VendorCredit.Validate if the designated constraints aren't met.
type VendorCreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorCreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorCreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorCreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorCreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorCreditValidationError) ErrorName() string { return "VendorCreditValidationError" }

// Error satisfies the builtin error interface
func (e VendorCreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorCredit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorCreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorCreditValidationError{}

// Validate checks the field values on VendorCreditLine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VendorCreditLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorCreditLine with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VendorCreditLineMultiError, or nil if none found.
func (m *VendorCreditLine) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorCreditLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RemoteId

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Description

	// no validation rules for Account

	// no validation rules for Company

	// no validation rules for ExchangeRate

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorCreditLineMultiError(errors)
	}

	return nil
}

// VendorCreditLineMultiError is an error wrapping multiple validation errors
// returned by VendorCreditLine.ValidateAll() if the designated constraints
// aren't met.
type VendorCreditLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorCreditLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorCreditLineMultiError) AllErrors() []error { return m }

// VendorCreditLineValidationError is the validation error returned by
// VendorCreditLine.Validate if the designated constraints aren't met.
type VendorCreditLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorCreditLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorCreditLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorCreditLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorCreditLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorCreditLineValidationError) ErrorName() string { return "VendorCreditLineValidationError" }

// Error satisfies the builtin error interface
func (e VendorCreditLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorCreditLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorCreditLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorCreditLineValidationError{}

// Validate checks the field values on PlaidAccountInvestmentTransaction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PlaidAccountInvestmentTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidAccountInvestmentTransaction
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PlaidAccountInvestmentTransactionMultiError, or nil if none found.
func (m *PlaidAccountInvestmentTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidAccountInvestmentTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Ammount

	// no validation rules for InvestmentTransactionId

	// no validation rules for SecurityId

	// no validation rules for CurrentDate

	// no validation rules for Name

	// no validation rules for Quantity

	// no validation rules for Amount

	// no validation rules for Price

	// no validation rules for Fees

	// no validation rules for Type

	// no validation rules for Subtype

	// no validation rules for IsoCurrencyCode

	// no validation rules for UnofficialCurrencyCode

	if m.GetLinkId() <= 0 {
		err := PlaidAccountInvestmentTransactionValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := PlaidAccountInvestmentTransactionValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatedAt

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlaidAccountInvestmentTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlaidAccountInvestmentTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlaidAccountInvestmentTransactionValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlaidAccountInvestmentTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlaidAccountInvestmentTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlaidAccountInvestmentTransactionValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PlaidAccountInvestmentTransactionMultiError(errors)
	}

	return nil
}

// PlaidAccountInvestmentTransactionMultiError is an error wrapping multiple
// validation errors returned by
// PlaidAccountInvestmentTransaction.ValidateAll() if the designated
// constraints aren't met.
type PlaidAccountInvestmentTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidAccountInvestmentTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidAccountInvestmentTransactionMultiError) AllErrors() []error { return m }

// PlaidAccountInvestmentTransactionValidationError is the validation error
// returned by PlaidAccountInvestmentTransaction.Validate if the designated
// constraints aren't met.
type PlaidAccountInvestmentTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidAccountInvestmentTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidAccountInvestmentTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidAccountInvestmentTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidAccountInvestmentTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidAccountInvestmentTransactionValidationError) ErrorName() string {
	return "PlaidAccountInvestmentTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidAccountInvestmentTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidAccountInvestmentTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidAccountInvestmentTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidAccountInvestmentTransactionValidationError{}

// Validate checks the field values on PlaidAccountRecurringTransaction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PlaidAccountRecurringTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidAccountRecurringTransaction with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PlaidAccountRecurringTransactionMultiError, or nil if none found.
func (m *PlaidAccountRecurringTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidAccountRecurringTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for StreamId

	// no validation rules for CategoryId

	// no validation rules for Description

	// no validation rules for MerchantName

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for PersonalFinanceCategoryDetailed

	// no validation rules for FirstDate

	// no validation rules for LastDate

	// no validation rules for Frequency

	// no validation rules for TransactionIds

	// no validation rules for AverageAmount

	// no validation rules for AverageAmountIsoCurrencyCode

	// no validation rules for LastAmount

	// no validation rules for LastAmountIsoCurrencyCode

	// no validation rules for IsActive

	// no validation rules for Status

	// no validation rules for UpdatedTime

	if m.GetUserId() <= 0 {
		err := PlaidAccountRecurringTransactionValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := PlaidAccountRecurringTransactionValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	// no validation rules for Flow

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlaidAccountRecurringTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlaidAccountRecurringTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlaidAccountRecurringTransactionValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlaidAccountRecurringTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlaidAccountRecurringTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlaidAccountRecurringTransactionValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PlaidAccountRecurringTransactionMultiError(errors)
	}

	return nil
}

// PlaidAccountRecurringTransactionMultiError is an error wrapping multiple
// validation errors returned by
// PlaidAccountRecurringTransaction.ValidateAll() if the designated
// constraints aren't met.
type PlaidAccountRecurringTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidAccountRecurringTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidAccountRecurringTransactionMultiError) AllErrors() []error { return m }

// PlaidAccountRecurringTransactionValidationError is the validation error
// returned by PlaidAccountRecurringTransaction.Validate if the designated
// constraints aren't met.
type PlaidAccountRecurringTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidAccountRecurringTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidAccountRecurringTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidAccountRecurringTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidAccountRecurringTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidAccountRecurringTransactionValidationError) ErrorName() string {
	return "PlaidAccountRecurringTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidAccountRecurringTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidAccountRecurringTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidAccountRecurringTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidAccountRecurringTransactionValidationError{}

// Validate checks the field values on PlaidAccountTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlaidAccountTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidAccountTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlaidAccountTransactionMultiError, or nil if none found.
func (m *PlaidAccountTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidAccountTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Amount

	// no validation rules for IsoCurrencyCode

	// no validation rules for UnofficialCurrencyCode

	// no validation rules for TransactionId

	// no validation rules for TransactionCode

	// no validation rules for CurrentDate

	// no validation rules for CurrentDatetime

	// no validation rules for AuthorizedDate

	// no validation rules for AuthorizedDatetime

	// no validation rules for CategoryId

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for PersonalFinanceCategoryDetailed

	// no validation rules for Name

	// no validation rules for MerchantName

	// no validation rules for CheckNumber

	// no validation rules for PaymentChannel

	// no validation rules for Pending

	// no validation rules for PendingTransactionId

	// no validation rules for AccountOwner

	// no validation rules for PaymentMetaByOrderOf

	// no validation rules for PaymentMetaPayee

	// no validation rules for PaymentMetaPayer

	// no validation rules for PaymentMetaPaymentMethod

	// no validation rules for PaymentMetaPaymentProcessor

	// no validation rules for PaymentMetaPpdId

	// no validation rules for PaymentMetaReason

	// no validation rules for PaymentMetaReferenceNumber

	// no validation rules for LocationAddress

	// no validation rules for LocationCity

	// no validation rules for LocationRegion

	// no validation rules for LocationPostalCode

	// no validation rules for LocationCountry

	// no validation rules for LocationLat

	// no validation rules for LocationLon

	// no validation rules for LocationStoreNumber

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlaidAccountTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlaidAccountTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlaidAccountTransactionValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlaidAccountTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlaidAccountTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlaidAccountTransactionValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := PlaidAccountTransactionValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := PlaidAccountTransactionValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PlaidAccountTransactionMultiError(errors)
	}

	return nil
}

// PlaidAccountTransactionMultiError is an error wrapping multiple validation
// errors returned by PlaidAccountTransaction.ValidateAll() if the designated
// constraints aren't met.
type PlaidAccountTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidAccountTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidAccountTransactionMultiError) AllErrors() []error { return m }

// PlaidAccountTransactionValidationError is the validation error returned by
// PlaidAccountTransaction.Validate if the designated constraints aren't met.
type PlaidAccountTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidAccountTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidAccountTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidAccountTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidAccountTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidAccountTransactionValidationError) ErrorName() string {
	return "PlaidAccountTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidAccountTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidAccountTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidAccountTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidAccountTransactionValidationError{}
