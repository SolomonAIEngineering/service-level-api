// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: financial_service/v1/clickhouse_financial_service.proto

package financial_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on InvestmentTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvestmentTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvestmentTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvestmentTransactionMultiError, or nil if none found.
func (m *InvestmentTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *InvestmentTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Ammount

	// no validation rules for InvestmentTransactionId

	// no validation rules for SecurityId

	// no validation rules for CurrentDate

	// no validation rules for Name

	// no validation rules for Quantity

	// no validation rules for Amount

	// no validation rules for Price

	// no validation rules for Fees

	// no validation rules for Type

	// no validation rules for Subtype

	// no validation rules for IsoCurrencyCode

	// no validation rules for UnofficialCurrencyCode

	if m.GetLinkId() <= 0 {
		err := InvestmentTransactionValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := InvestmentTransactionValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatedAt

	// no validation rules for Sign

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvestmentTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvestmentTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvestmentTransactionValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvestmentTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvestmentTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvestmentTransactionValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvestmentTransactionMultiError(errors)
	}

	return nil
}

// InvestmentTransactionMultiError is an error wrapping multiple validation
// errors returned by InvestmentTransaction.ValidateAll() if the designated
// constraints aren't met.
type InvestmentTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvestmentTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvestmentTransactionMultiError) AllErrors() []error { return m }

// InvestmentTransactionValidationError is the validation error returned by
// InvestmentTransaction.Validate if the designated constraints aren't met.
type InvestmentTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvestmentTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvestmentTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvestmentTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvestmentTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvestmentTransactionValidationError) ErrorName() string {
	return "InvestmentTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e InvestmentTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvestmentTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvestmentTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvestmentTransactionValidationError{}

// Validate checks the field values on ReOccuringTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReOccuringTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReOccuringTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReOccuringTransactionMultiError, or nil if none found.
func (m *ReOccuringTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *ReOccuringTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for StreamId

	// no validation rules for CategoryId

	// no validation rules for Description

	// no validation rules for MerchantName

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for PersonalFinanceCategoryDetailed

	// no validation rules for FirstDate

	// no validation rules for LastDate

	// no validation rules for Frequency

	// no validation rules for TransactionIds

	// no validation rules for AverageAmount

	// no validation rules for AverageAmountIsoCurrencyCode

	// no validation rules for LastAmount

	// no validation rules for LastAmountIsoCurrencyCode

	// no validation rules for IsActive

	// no validation rules for Status

	// no validation rules for UpdatedTime

	if m.GetUserId() <= 0 {
		err := ReOccuringTransactionValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := ReOccuringTransactionValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Id

	// no validation rules for Flow

	// no validation rules for Sign

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReOccuringTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReOccuringTransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReOccuringTransactionValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReOccuringTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReOccuringTransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReOccuringTransactionValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReOccuringTransactionMultiError(errors)
	}

	return nil
}

// ReOccuringTransactionMultiError is an error wrapping multiple validation
// errors returned by ReOccuringTransaction.ValidateAll() if the designated
// constraints aren't met.
type ReOccuringTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReOccuringTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReOccuringTransactionMultiError) AllErrors() []error { return m }

// ReOccuringTransactionValidationError is the validation error returned by
// ReOccuringTransaction.Validate if the designated constraints aren't met.
type ReOccuringTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReOccuringTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReOccuringTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReOccuringTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReOccuringTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReOccuringTransactionValidationError) ErrorName() string {
	return "ReOccuringTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e ReOccuringTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReOccuringTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReOccuringTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReOccuringTransactionValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Amount

	// no validation rules for IsoCurrencyCode

	// no validation rules for UnofficialCurrencyCode

	// no validation rules for CategoryId

	// no validation rules for CheckNumber

	// no validation rules for CurrentDate

	// no validation rules for CurrentDatetime

	// no validation rules for AuthorizedDate

	// no validation rules for AuthorizedDatetime

	// no validation rules for Name

	// no validation rules for MerchantName

	// no validation rules for PaymentChannel

	// no validation rules for Pending

	// no validation rules for PendingTransactionId

	// no validation rules for AccountOwner

	// no validation rules for TransactionId

	// no validation rules for TransactionCode

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := TransactionValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := TransactionValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Sign

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for PersonalFinanceCategoryDetailed

	// no validation rules for LocationAddress

	// no validation rules for LocationCity

	// no validation rules for LocationRegion

	// no validation rules for LocationPostalCode

	// no validation rules for LocationCountry

	// no validation rules for LocationLat

	// no validation rules for LocationLon

	// no validation rules for LocationStoreNumber

	// no validation rules for PaymentMetaByOrderOf

	// no validation rules for PaymentMetaPayee

	// no validation rules for PaymentMetaPayer

	// no validation rules for PaymentMetaPaymentMethod

	// no validation rules for PaymentMetaPaymentProcessor

	// no validation rules for PaymentMetaPpdId

	// no validation rules for PaymentMetaReason

	// no validation rules for PaymentMetaReferenceNumber

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAdditionalProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AdditionalProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdditionalProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "AdditionalProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on AccountBalanceHistory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountBalanceHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountBalanceHistory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccountBalanceHistoryMultiError, or nil if none found.
func (m *AccountBalanceHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountBalanceHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountBalanceHistoryValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountBalanceHistoryValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountBalanceHistoryValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	// no validation rules for IsoCurrencyCode

	// no validation rules for Balance

	// no validation rules for UserId

	// no validation rules for Sign

	// no validation rules for Id

	if len(errors) > 0 {
		return AccountBalanceHistoryMultiError(errors)
	}

	return nil
}

// AccountBalanceHistoryMultiError is an error wrapping multiple validation
// errors returned by AccountBalanceHistory.ValidateAll() if the designated
// constraints aren't met.
type AccountBalanceHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountBalanceHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountBalanceHistoryMultiError) AllErrors() []error { return m }

// AccountBalanceHistoryValidationError is the validation error returned by
// AccountBalanceHistory.Validate if the designated constraints aren't met.
type AccountBalanceHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountBalanceHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountBalanceHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountBalanceHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountBalanceHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountBalanceHistoryValidationError) ErrorName() string {
	return "AccountBalanceHistoryValidationError"
}

// Error satisfies the builtin error interface
func (e AccountBalanceHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountBalanceHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountBalanceHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountBalanceHistoryValidationError{}

// Validate checks the field values on CategoryMetricsFinancialSubProfile with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CategoryMetricsFinancialSubProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoryMetricsFinancialSubProfile
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CategoryMetricsFinancialSubProfileMultiError, or nil if none found.
func (m *CategoryMetricsFinancialSubProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoryMetricsFinancialSubProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for TransactionCount

	// no validation rules for SpentLastWeek

	// no validation rules for SpentLastTwoWeeks

	// no validation rules for SpentLastMonth

	// no validation rules for SpentLastSixMonths

	// no validation rules for SpentLastYear

	// no validation rules for SpentLastTwoYears

	// no validation rules for UserId

	if len(errors) > 0 {
		return CategoryMetricsFinancialSubProfileMultiError(errors)
	}

	return nil
}

// CategoryMetricsFinancialSubProfileMultiError is an error wrapping multiple
// validation errors returned by
// CategoryMetricsFinancialSubProfile.ValidateAll() if the designated
// constraints aren't met.
type CategoryMetricsFinancialSubProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMetricsFinancialSubProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMetricsFinancialSubProfileMultiError) AllErrors() []error { return m }

// CategoryMetricsFinancialSubProfileValidationError is the validation error
// returned by CategoryMetricsFinancialSubProfile.Validate if the designated
// constraints aren't met.
type CategoryMetricsFinancialSubProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryMetricsFinancialSubProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryMetricsFinancialSubProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryMetricsFinancialSubProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryMetricsFinancialSubProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryMetricsFinancialSubProfileValidationError) ErrorName() string {
	return "CategoryMetricsFinancialSubProfileValidationError"
}

// Error satisfies the builtin error interface
func (e CategoryMetricsFinancialSubProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoryMetricsFinancialSubProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryMetricsFinancialSubProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryMetricsFinancialSubProfileValidationError{}

// Validate checks the field values on CategoryMonthlyExpenditure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CategoryMonthlyExpenditure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoryMonthlyExpenditure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CategoryMonthlyExpenditureMultiError, or nil if none found.
func (m *CategoryMonthlyExpenditure) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoryMonthlyExpenditure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for TotalSpending

	// no validation rules for UserId

	if len(errors) > 0 {
		return CategoryMonthlyExpenditureMultiError(errors)
	}

	return nil
}

// CategoryMonthlyExpenditureMultiError is an error wrapping multiple
// validation errors returned by CategoryMonthlyExpenditure.ValidateAll() if
// the designated constraints aren't met.
type CategoryMonthlyExpenditureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMonthlyExpenditureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMonthlyExpenditureMultiError) AllErrors() []error { return m }

// CategoryMonthlyExpenditureValidationError is the validation error returned
// by CategoryMonthlyExpenditure.Validate if the designated constraints aren't met.
type CategoryMonthlyExpenditureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryMonthlyExpenditureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryMonthlyExpenditureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryMonthlyExpenditureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryMonthlyExpenditureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryMonthlyExpenditureValidationError) ErrorName() string {
	return "CategoryMonthlyExpenditureValidationError"
}

// Error satisfies the builtin error interface
func (e CategoryMonthlyExpenditureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoryMonthlyExpenditure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryMonthlyExpenditureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryMonthlyExpenditureValidationError{}

// Validate checks the field values on CategoryMonthlyIncome with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CategoryMonthlyIncome) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoryMonthlyIncome with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CategoryMonthlyIncomeMultiError, or nil if none found.
func (m *CategoryMonthlyIncome) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoryMonthlyIncome) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for TotalIncome

	// no validation rules for UserId

	if len(errors) > 0 {
		return CategoryMonthlyIncomeMultiError(errors)
	}

	return nil
}

// CategoryMonthlyIncomeMultiError is an error wrapping multiple validation
// errors returned by CategoryMonthlyIncome.ValidateAll() if the designated
// constraints aren't met.
type CategoryMonthlyIncomeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMonthlyIncomeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMonthlyIncomeMultiError) AllErrors() []error { return m }

// CategoryMonthlyIncomeValidationError is the validation error returned by
// CategoryMonthlyIncome.Validate if the designated constraints aren't met.
type CategoryMonthlyIncomeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryMonthlyIncomeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryMonthlyIncomeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryMonthlyIncomeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryMonthlyIncomeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryMonthlyIncomeValidationError) ErrorName() string {
	return "CategoryMonthlyIncomeValidationError"
}

// Error satisfies the builtin error interface
func (e CategoryMonthlyIncomeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoryMonthlyIncome.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryMonthlyIncomeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryMonthlyIncomeValidationError{}

// Validate checks the field values on CategoryMonthlyTransactionCount with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CategoryMonthlyTransactionCount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoryMonthlyTransactionCount with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CategoryMonthlyTransactionCountMultiError, or nil if none found.
func (m *CategoryMonthlyTransactionCount) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoryMonthlyTransactionCount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for TransactionCount

	// no validation rules for UserId

	if len(errors) > 0 {
		return CategoryMonthlyTransactionCountMultiError(errors)
	}

	return nil
}

// CategoryMonthlyTransactionCountMultiError is an error wrapping multiple
// validation errors returned by CategoryMonthlyTransactionCount.ValidateAll()
// if the designated constraints aren't met.
type CategoryMonthlyTransactionCountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMonthlyTransactionCountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMonthlyTransactionCountMultiError) AllErrors() []error { return m }

// CategoryMonthlyTransactionCountValidationError is the validation error
// returned by CategoryMonthlyTransactionCount.Validate if the designated
// constraints aren't met.
type CategoryMonthlyTransactionCountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryMonthlyTransactionCountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryMonthlyTransactionCountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryMonthlyTransactionCountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryMonthlyTransactionCountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryMonthlyTransactionCountValidationError) ErrorName() string {
	return "CategoryMonthlyTransactionCountValidationError"
}

// Error satisfies the builtin error interface
func (e CategoryMonthlyTransactionCountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoryMonthlyTransactionCount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryMonthlyTransactionCountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryMonthlyTransactionCountValidationError{}

// Validate checks the field values on DebtToIncomeRatio with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DebtToIncomeRatio) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebtToIncomeRatio with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebtToIncomeRatioMultiError, or nil if none found.
func (m *DebtToIncomeRatio) ValidateAll() error {
	return m.validate(true)
}

func (m *DebtToIncomeRatio) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for Ratio

	// no validation rules for UserId

	if len(errors) > 0 {
		return DebtToIncomeRatioMultiError(errors)
	}

	return nil
}

// DebtToIncomeRatioMultiError is an error wrapping multiple validation errors
// returned by DebtToIncomeRatio.ValidateAll() if the designated constraints
// aren't met.
type DebtToIncomeRatioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebtToIncomeRatioMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebtToIncomeRatioMultiError) AllErrors() []error { return m }

// DebtToIncomeRatioValidationError is the validation error returned by
// DebtToIncomeRatio.Validate if the designated constraints aren't met.
type DebtToIncomeRatioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebtToIncomeRatioValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebtToIncomeRatioValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebtToIncomeRatioValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebtToIncomeRatioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebtToIncomeRatioValidationError) ErrorName() string {
	return "DebtToIncomeRatioValidationError"
}

// Error satisfies the builtin error interface
func (e DebtToIncomeRatioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebtToIncomeRatio.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebtToIncomeRatioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebtToIncomeRatioValidationError{}

// Validate checks the field values on ExpenseMetrics with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpenseMetrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseMetrics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpenseMetricsMultiError,
// or nil if none found.
func (m *ExpenseMetrics) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseMetrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for TransactionCount

	// no validation rules for TotalExpenses

	// no validation rules for UserId

	if len(errors) > 0 {
		return ExpenseMetricsMultiError(errors)
	}

	return nil
}

// ExpenseMetricsMultiError is an error wrapping multiple validation errors
// returned by ExpenseMetrics.ValidateAll() if the designated constraints
// aren't met.
type ExpenseMetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseMetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseMetricsMultiError) AllErrors() []error { return m }

// ExpenseMetricsValidationError is the validation error returned by
// ExpenseMetrics.Validate if the designated constraints aren't met.
type ExpenseMetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseMetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseMetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseMetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseMetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseMetricsValidationError) ErrorName() string { return "ExpenseMetricsValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseMetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseMetrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseMetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseMetricsValidationError{}

// Validate checks the field values on ExpenseMetricsFinancialSubProfileMetrics
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExpenseMetricsFinancialSubProfileMetrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExpenseMetricsFinancialSubProfileMetrics with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ExpenseMetricsFinancialSubProfileMetricsMultiError, or nil if none found.
func (m *ExpenseMetricsFinancialSubProfileMetrics) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseMetricsFinancialSubProfileMetrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for SpentLastWeek

	// no validation rules for SpentLastMonth

	// no validation rules for SpentLastSixMonths

	// no validation rules for AverageMonthlyDiscretionarySpending

	// no validation rules for AverageMonthlyRecurringSpending

	// no validation rules for UserId

	if len(errors) > 0 {
		return ExpenseMetricsFinancialSubProfileMetricsMultiError(errors)
	}

	return nil
}

// ExpenseMetricsFinancialSubProfileMetricsMultiError is an error wrapping
// multiple validation errors returned by
// ExpenseMetricsFinancialSubProfileMetrics.ValidateAll() if the designated
// constraints aren't met.
type ExpenseMetricsFinancialSubProfileMetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseMetricsFinancialSubProfileMetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseMetricsFinancialSubProfileMetricsMultiError) AllErrors() []error { return m }

// ExpenseMetricsFinancialSubProfileMetricsValidationError is the validation
// error returned by ExpenseMetricsFinancialSubProfileMetrics.Validate if the
// designated constraints aren't met.
type ExpenseMetricsFinancialSubProfileMetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseMetricsFinancialSubProfileMetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseMetricsFinancialSubProfileMetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseMetricsFinancialSubProfileMetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseMetricsFinancialSubProfileMetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseMetricsFinancialSubProfileMetricsValidationError) ErrorName() string {
	return "ExpenseMetricsFinancialSubProfileMetricsValidationError"
}

// Error satisfies the builtin error interface
func (e ExpenseMetricsFinancialSubProfileMetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseMetricsFinancialSubProfileMetrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseMetricsFinancialSubProfileMetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseMetricsFinancialSubProfileMetricsValidationError{}

// Validate checks the field values on FinancialProfile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FinancialProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinancialProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinancialProfileMultiError, or nil if none found.
func (m *FinancialProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *FinancialProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for TotalIncome

	// no validation rules for TotalExpenses

	// no validation rules for NumberOfTransactions

	// no validation rules for MostExpensiveCategory

	// no validation rules for UserId

	if len(errors) > 0 {
		return FinancialProfileMultiError(errors)
	}

	return nil
}

// FinancialProfileMultiError is an error wrapping multiple validation errors
// returned by FinancialProfile.ValidateAll() if the designated constraints
// aren't met.
type FinancialProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinancialProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinancialProfileMultiError) AllErrors() []error { return m }

// FinancialProfileValidationError is the validation error returned by
// FinancialProfile.Validate if the designated constraints aren't met.
type FinancialProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinancialProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinancialProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinancialProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinancialProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinancialProfileValidationError) ErrorName() string { return "FinancialProfileValidationError" }

// Error satisfies the builtin error interface
func (e FinancialProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinancialProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinancialProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinancialProfileValidationError{}

// Validate checks the field values on IncomeExpenseRatio with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IncomeExpenseRatio) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncomeExpenseRatio with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IncomeExpenseRatioMultiError, or nil if none found.
func (m *IncomeExpenseRatio) ValidateAll() error {
	return m.validate(true)
}

func (m *IncomeExpenseRatio) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for Ratio

	// no validation rules for UserId

	if len(errors) > 0 {
		return IncomeExpenseRatioMultiError(errors)
	}

	return nil
}

// IncomeExpenseRatioMultiError is an error wrapping multiple validation errors
// returned by IncomeExpenseRatio.ValidateAll() if the designated constraints
// aren't met.
type IncomeExpenseRatioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncomeExpenseRatioMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncomeExpenseRatioMultiError) AllErrors() []error { return m }

// IncomeExpenseRatioValidationError is the validation error returned by
// IncomeExpenseRatio.Validate if the designated constraints aren't met.
type IncomeExpenseRatioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncomeExpenseRatioValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncomeExpenseRatioValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncomeExpenseRatioValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncomeExpenseRatioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncomeExpenseRatioValidationError) ErrorName() string {
	return "IncomeExpenseRatioValidationError"
}

// Error satisfies the builtin error interface
func (e IncomeExpenseRatioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncomeExpenseRatio.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncomeExpenseRatioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncomeExpenseRatioValidationError{}

// Validate checks the field values on IncomeMetrics with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IncomeMetrics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncomeMetrics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IncomeMetricsMultiError, or
// nil if none found.
func (m *IncomeMetrics) ValidateAll() error {
	return m.validate(true)
}

func (m *IncomeMetrics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for TransactionCount

	// no validation rules for TotalIncome

	// no validation rules for UserId

	if len(errors) > 0 {
		return IncomeMetricsMultiError(errors)
	}

	return nil
}

// IncomeMetricsMultiError is an error wrapping multiple validation errors
// returned by IncomeMetrics.ValidateAll() if the designated constraints
// aren't met.
type IncomeMetricsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncomeMetricsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncomeMetricsMultiError) AllErrors() []error { return m }

// IncomeMetricsValidationError is the validation error returned by
// IncomeMetrics.Validate if the designated constraints aren't met.
type IncomeMetricsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncomeMetricsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncomeMetricsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncomeMetricsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncomeMetricsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncomeMetricsValidationError) ErrorName() string { return "IncomeMetricsValidationError" }

// Error satisfies the builtin error interface
func (e IncomeMetricsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncomeMetrics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncomeMetricsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncomeMetricsValidationError{}

// Validate checks the field values on IncomeMetricsFinancialSubProfile with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IncomeMetricsFinancialSubProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncomeMetricsFinancialSubProfile with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IncomeMetricsFinancialSubProfileMultiError, or nil if none found.
func (m *IncomeMetricsFinancialSubProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *IncomeMetricsFinancialSubProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for IncomeLastTwoWeeks

	// no validation rules for IncomeLastMonth

	// no validation rules for IncomeLastTwoMonths

	// no validation rules for IncomeLastSixMonths

	// no validation rules for IncomeLastYear

	// no validation rules for UserId

	if len(errors) > 0 {
		return IncomeMetricsFinancialSubProfileMultiError(errors)
	}

	return nil
}

// IncomeMetricsFinancialSubProfileMultiError is an error wrapping multiple
// validation errors returned by
// IncomeMetricsFinancialSubProfile.ValidateAll() if the designated
// constraints aren't met.
type IncomeMetricsFinancialSubProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncomeMetricsFinancialSubProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncomeMetricsFinancialSubProfileMultiError) AllErrors() []error { return m }

// IncomeMetricsFinancialSubProfileValidationError is the validation error
// returned by IncomeMetricsFinancialSubProfile.Validate if the designated
// constraints aren't met.
type IncomeMetricsFinancialSubProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncomeMetricsFinancialSubProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncomeMetricsFinancialSubProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncomeMetricsFinancialSubProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncomeMetricsFinancialSubProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncomeMetricsFinancialSubProfileValidationError) ErrorName() string {
	return "IncomeMetricsFinancialSubProfileValidationError"
}

// Error satisfies the builtin error interface
func (e IncomeMetricsFinancialSubProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncomeMetricsFinancialSubProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncomeMetricsFinancialSubProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncomeMetricsFinancialSubProfileValidationError{}

// Validate checks the field values on LocationFinancialSubProfile with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LocationFinancialSubProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocationFinancialSubProfile with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocationFinancialSubProfileMultiError, or nil if none found.
func (m *LocationFinancialSubProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *LocationFinancialSubProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LocationCity

	// no validation rules for TransactionCount

	// no validation rules for SpentLastWeek

	// no validation rules for SpentLastTwoWeeks

	// no validation rules for SpentLastMonth

	// no validation rules for SpentLastSixMonths

	// no validation rules for SpentLastYear

	// no validation rules for SpentLastTwoYears

	// no validation rules for UserId

	// no validation rules for Month

	if len(errors) > 0 {
		return LocationFinancialSubProfileMultiError(errors)
	}

	return nil
}

// LocationFinancialSubProfileMultiError is an error wrapping multiple
// validation errors returned by LocationFinancialSubProfile.ValidateAll() if
// the designated constraints aren't met.
type LocationFinancialSubProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationFinancialSubProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationFinancialSubProfileMultiError) AllErrors() []error { return m }

// LocationFinancialSubProfileValidationError is the validation error returned
// by LocationFinancialSubProfile.Validate if the designated constraints
// aren't met.
type LocationFinancialSubProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationFinancialSubProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationFinancialSubProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationFinancialSubProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationFinancialSubProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationFinancialSubProfileValidationError) ErrorName() string {
	return "LocationFinancialSubProfileValidationError"
}

// Error satisfies the builtin error interface
func (e LocationFinancialSubProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocationFinancialSubProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationFinancialSubProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationFinancialSubProfileValidationError{}

// Validate checks the field values on MerchantMetricsFinancialSubProfile with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MerchantMetricsFinancialSubProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantMetricsFinancialSubProfile
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MerchantMetricsFinancialSubProfileMultiError, or nil if none found.
func (m *MerchantMetricsFinancialSubProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantMetricsFinancialSubProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MerchantName

	// no validation rules for SpentLastWeek

	// no validation rules for SpentLastTwoWeeks

	// no validation rules for SpentLastMonth

	// no validation rules for SpentLastSixMonths

	// no validation rules for SpentLastYear

	// no validation rules for SpentLastTwoYears

	// no validation rules for UserId

	// no validation rules for Month

	if len(errors) > 0 {
		return MerchantMetricsFinancialSubProfileMultiError(errors)
	}

	return nil
}

// MerchantMetricsFinancialSubProfileMultiError is an error wrapping multiple
// validation errors returned by
// MerchantMetricsFinancialSubProfile.ValidateAll() if the designated
// constraints aren't met.
type MerchantMetricsFinancialSubProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantMetricsFinancialSubProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantMetricsFinancialSubProfileMultiError) AllErrors() []error { return m }

// MerchantMetricsFinancialSubProfileValidationError is the validation error
// returned by MerchantMetricsFinancialSubProfile.Validate if the designated
// constraints aren't met.
type MerchantMetricsFinancialSubProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantMetricsFinancialSubProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantMetricsFinancialSubProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantMetricsFinancialSubProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantMetricsFinancialSubProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantMetricsFinancialSubProfileValidationError) ErrorName() string {
	return "MerchantMetricsFinancialSubProfileValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantMetricsFinancialSubProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantMetricsFinancialSubProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantMetricsFinancialSubProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantMetricsFinancialSubProfileValidationError{}

// Validate checks the field values on MerchantMonthlyExpenditure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MerchantMonthlyExpenditure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MerchantMonthlyExpenditure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MerchantMonthlyExpenditureMultiError, or nil if none found.
func (m *MerchantMonthlyExpenditure) ValidateAll() error {
	return m.validate(true)
}

func (m *MerchantMonthlyExpenditure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for MerchantName

	// no validation rules for TotalSpending

	// no validation rules for UserId

	if len(errors) > 0 {
		return MerchantMonthlyExpenditureMultiError(errors)
	}

	return nil
}

// MerchantMonthlyExpenditureMultiError is an error wrapping multiple
// validation errors returned by MerchantMonthlyExpenditure.ValidateAll() if
// the designated constraints aren't met.
type MerchantMonthlyExpenditureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MerchantMonthlyExpenditureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MerchantMonthlyExpenditureMultiError) AllErrors() []error { return m }

// MerchantMonthlyExpenditureValidationError is the validation error returned
// by MerchantMonthlyExpenditure.Validate if the designated constraints aren't met.
type MerchantMonthlyExpenditureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MerchantMonthlyExpenditureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MerchantMonthlyExpenditureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MerchantMonthlyExpenditureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MerchantMonthlyExpenditureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MerchantMonthlyExpenditureValidationError) ErrorName() string {
	return "MerchantMonthlyExpenditureValidationError"
}

// Error satisfies the builtin error interface
func (e MerchantMonthlyExpenditureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMerchantMonthlyExpenditure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MerchantMonthlyExpenditureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MerchantMonthlyExpenditureValidationError{}

// Validate checks the field values on MonthlyBalance with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MonthlyBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonthlyBalance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MonthlyBalanceMultiError,
// or nil if none found.
func (m *MonthlyBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *MonthlyBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for NetBalance

	// no validation rules for UserId

	if len(errors) > 0 {
		return MonthlyBalanceMultiError(errors)
	}

	return nil
}

// MonthlyBalanceMultiError is an error wrapping multiple validation errors
// returned by MonthlyBalance.ValidateAll() if the designated constraints
// aren't met.
type MonthlyBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonthlyBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonthlyBalanceMultiError) AllErrors() []error { return m }

// MonthlyBalanceValidationError is the validation error returned by
// MonthlyBalance.Validate if the designated constraints aren't met.
type MonthlyBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonthlyBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonthlyBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonthlyBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonthlyBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonthlyBalanceValidationError) ErrorName() string { return "MonthlyBalanceValidationError" }

// Error satisfies the builtin error interface
func (e MonthlyBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonthlyBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonthlyBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonthlyBalanceValidationError{}

// Validate checks the field values on MonthlyExpenditure with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MonthlyExpenditure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonthlyExpenditure with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MonthlyExpenditureMultiError, or nil if none found.
func (m *MonthlyExpenditure) ValidateAll() error {
	return m.validate(true)
}

func (m *MonthlyExpenditure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for TotalSpending

	// no validation rules for UserId

	if len(errors) > 0 {
		return MonthlyExpenditureMultiError(errors)
	}

	return nil
}

// MonthlyExpenditureMultiError is an error wrapping multiple validation errors
// returned by MonthlyExpenditure.ValidateAll() if the designated constraints
// aren't met.
type MonthlyExpenditureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonthlyExpenditureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonthlyExpenditureMultiError) AllErrors() []error { return m }

// MonthlyExpenditureValidationError is the validation error returned by
// MonthlyExpenditure.Validate if the designated constraints aren't met.
type MonthlyExpenditureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonthlyExpenditureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonthlyExpenditureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonthlyExpenditureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonthlyExpenditureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonthlyExpenditureValidationError) ErrorName() string {
	return "MonthlyExpenditureValidationError"
}

// Error satisfies the builtin error interface
func (e MonthlyExpenditureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonthlyExpenditure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonthlyExpenditureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonthlyExpenditureValidationError{}

// Validate checks the field values on MonthlyIncome with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MonthlyIncome) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonthlyIncome with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MonthlyIncomeMultiError, or
// nil if none found.
func (m *MonthlyIncome) ValidateAll() error {
	return m.validate(true)
}

func (m *MonthlyIncome) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for TotalIncome

	// no validation rules for UserId

	if len(errors) > 0 {
		return MonthlyIncomeMultiError(errors)
	}

	return nil
}

// MonthlyIncomeMultiError is an error wrapping multiple validation errors
// returned by MonthlyIncome.ValidateAll() if the designated constraints
// aren't met.
type MonthlyIncomeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonthlyIncomeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonthlyIncomeMultiError) AllErrors() []error { return m }

// MonthlyIncomeValidationError is the validation error returned by
// MonthlyIncome.Validate if the designated constraints aren't met.
type MonthlyIncomeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonthlyIncomeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonthlyIncomeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonthlyIncomeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonthlyIncomeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonthlyIncomeValidationError) ErrorName() string { return "MonthlyIncomeValidationError" }

// Error satisfies the builtin error interface
func (e MonthlyIncomeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonthlyIncome.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonthlyIncomeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonthlyIncomeValidationError{}

// Validate checks the field values on MonthlySavings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MonthlySavings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonthlySavings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MonthlySavingsMultiError,
// or nil if none found.
func (m *MonthlySavings) ValidateAll() error {
	return m.validate(true)
}

func (m *MonthlySavings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for NetSavings

	// no validation rules for UserId

	if len(errors) > 0 {
		return MonthlySavingsMultiError(errors)
	}

	return nil
}

// MonthlySavingsMultiError is an error wrapping multiple validation errors
// returned by MonthlySavings.ValidateAll() if the designated constraints
// aren't met.
type MonthlySavingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonthlySavingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonthlySavingsMultiError) AllErrors() []error { return m }

// MonthlySavingsValidationError is the validation error returned by
// MonthlySavings.Validate if the designated constraints aren't met.
type MonthlySavingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonthlySavingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonthlySavingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonthlySavingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonthlySavingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonthlySavingsValidationError) ErrorName() string { return "MonthlySavingsValidationError" }

// Error satisfies the builtin error interface
func (e MonthlySavingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonthlySavings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonthlySavingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonthlySavingsValidationError{}

// Validate checks the field values on MonthlyTotalQuantityBySecurityAndUser
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MonthlyTotalQuantityBySecurityAndUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonthlyTotalQuantityBySecurityAndUser
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MonthlyTotalQuantityBySecurityAndUserMultiError, or nil if none found.
func (m *MonthlyTotalQuantityBySecurityAndUser) ValidateAll() error {
	return m.validate(true)
}

func (m *MonthlyTotalQuantityBySecurityAndUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for SecurityId

	// no validation rules for TotalQuantity

	// no validation rules for UserId

	if len(errors) > 0 {
		return MonthlyTotalQuantityBySecurityAndUserMultiError(errors)
	}

	return nil
}

// MonthlyTotalQuantityBySecurityAndUserMultiError is an error wrapping
// multiple validation errors returned by
// MonthlyTotalQuantityBySecurityAndUser.ValidateAll() if the designated
// constraints aren't met.
type MonthlyTotalQuantityBySecurityAndUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonthlyTotalQuantityBySecurityAndUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonthlyTotalQuantityBySecurityAndUserMultiError) AllErrors() []error { return m }

// MonthlyTotalQuantityBySecurityAndUserValidationError is the validation error
// returned by MonthlyTotalQuantityBySecurityAndUser.Validate if the
// designated constraints aren't met.
type MonthlyTotalQuantityBySecurityAndUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonthlyTotalQuantityBySecurityAndUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonthlyTotalQuantityBySecurityAndUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonthlyTotalQuantityBySecurityAndUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonthlyTotalQuantityBySecurityAndUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonthlyTotalQuantityBySecurityAndUserValidationError) ErrorName() string {
	return "MonthlyTotalQuantityBySecurityAndUserValidationError"
}

// Error satisfies the builtin error interface
func (e MonthlyTotalQuantityBySecurityAndUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonthlyTotalQuantityBySecurityAndUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonthlyTotalQuantityBySecurityAndUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonthlyTotalQuantityBySecurityAndUserValidationError{}

// Validate checks the field values on MonthlyTransactionCount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MonthlyTransactionCount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonthlyTransactionCount with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MonthlyTransactionCountMultiError, or nil if none found.
func (m *MonthlyTransactionCount) ValidateAll() error {
	return m.validate(true)
}

func (m *MonthlyTransactionCount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for TransactionCount

	// no validation rules for UserId

	if len(errors) > 0 {
		return MonthlyTransactionCountMultiError(errors)
	}

	return nil
}

// MonthlyTransactionCountMultiError is an error wrapping multiple validation
// errors returned by MonthlyTransactionCount.ValidateAll() if the designated
// constraints aren't met.
type MonthlyTransactionCountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonthlyTransactionCountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonthlyTransactionCountMultiError) AllErrors() []error { return m }

// MonthlyTransactionCountValidationError is the validation error returned by
// MonthlyTransactionCount.Validate if the designated constraints aren't met.
type MonthlyTransactionCountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonthlyTransactionCountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonthlyTransactionCountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonthlyTransactionCountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonthlyTransactionCountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonthlyTransactionCountValidationError) ErrorName() string {
	return "MonthlyTransactionCountValidationError"
}

// Error satisfies the builtin error interface
func (e MonthlyTransactionCountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonthlyTransactionCount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonthlyTransactionCountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonthlyTransactionCountValidationError{}

// Validate checks the field values on PaymentChannelMetricsFinancialSubProfile
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *PaymentChannelMetricsFinancialSubProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaymentChannelMetricsFinancialSubProfile with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// PaymentChannelMetricsFinancialSubProfileMultiError, or nil if none found.
func (m *PaymentChannelMetricsFinancialSubProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentChannelMetricsFinancialSubProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentChannel

	// no validation rules for SpentLastWeek

	// no validation rules for SpentLastTwoWeeks

	// no validation rules for SpentLastMonth

	// no validation rules for SpentLastSixMonths

	// no validation rules for SpentLastYear

	// no validation rules for SpentLastTwoYears

	// no validation rules for UserId

	// no validation rules for Month

	// no validation rules for TransactionCount

	if len(errors) > 0 {
		return PaymentChannelMetricsFinancialSubProfileMultiError(errors)
	}

	return nil
}

// PaymentChannelMetricsFinancialSubProfileMultiError is an error wrapping
// multiple validation errors returned by
// PaymentChannelMetricsFinancialSubProfile.ValidateAll() if the designated
// constraints aren't met.
type PaymentChannelMetricsFinancialSubProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentChannelMetricsFinancialSubProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentChannelMetricsFinancialSubProfileMultiError) AllErrors() []error { return m }

// PaymentChannelMetricsFinancialSubProfileValidationError is the validation
// error returned by PaymentChannelMetricsFinancialSubProfile.Validate if the
// designated constraints aren't met.
type PaymentChannelMetricsFinancialSubProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentChannelMetricsFinancialSubProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentChannelMetricsFinancialSubProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentChannelMetricsFinancialSubProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentChannelMetricsFinancialSubProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentChannelMetricsFinancialSubProfileValidationError) ErrorName() string {
	return "PaymentChannelMetricsFinancialSubProfileValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentChannelMetricsFinancialSubProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentChannelMetricsFinancialSubProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentChannelMetricsFinancialSubProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentChannelMetricsFinancialSubProfileValidationError{}

// Validate checks the field values on PaymentChannelMonthlyExpenditure with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PaymentChannelMonthlyExpenditure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentChannelMonthlyExpenditure with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PaymentChannelMonthlyExpenditureMultiError, or nil if none found.
func (m *PaymentChannelMonthlyExpenditure) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentChannelMonthlyExpenditure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PaymentChannel

	// no validation rules for TotalSpending

	// no validation rules for UserId

	if len(errors) > 0 {
		return PaymentChannelMonthlyExpenditureMultiError(errors)
	}

	return nil
}

// PaymentChannelMonthlyExpenditureMultiError is an error wrapping multiple
// validation errors returned by
// PaymentChannelMonthlyExpenditure.ValidateAll() if the designated
// constraints aren't met.
type PaymentChannelMonthlyExpenditureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentChannelMonthlyExpenditureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentChannelMonthlyExpenditureMultiError) AllErrors() []error { return m }

// PaymentChannelMonthlyExpenditureValidationError is the validation error
// returned by PaymentChannelMonthlyExpenditure.Validate if the designated
// constraints aren't met.
type PaymentChannelMonthlyExpenditureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentChannelMonthlyExpenditureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentChannelMonthlyExpenditureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentChannelMonthlyExpenditureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentChannelMonthlyExpenditureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentChannelMonthlyExpenditureValidationError) ErrorName() string {
	return "PaymentChannelMonthlyExpenditureValidationError"
}

// Error satisfies the builtin error interface
func (e PaymentChannelMonthlyExpenditureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentChannelMonthlyExpenditure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentChannelMonthlyExpenditureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentChannelMonthlyExpenditureValidationError{}

// Validate checks the field values on TotalInvestmentBySecurity with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TotalInvestmentBySecurity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TotalInvestmentBySecurity with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TotalInvestmentBySecurityMultiError, or nil if none found.
func (m *TotalInvestmentBySecurity) ValidateAll() error {
	return m.validate(true)
}

func (m *TotalInvestmentBySecurity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecurityId

	// no validation rules for TotalInvestment

	// no validation rules for UserId

	if len(errors) > 0 {
		return TotalInvestmentBySecurityMultiError(errors)
	}

	return nil
}

// TotalInvestmentBySecurityMultiError is an error wrapping multiple validation
// errors returned by TotalInvestmentBySecurity.ValidateAll() if the
// designated constraints aren't met.
type TotalInvestmentBySecurityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TotalInvestmentBySecurityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TotalInvestmentBySecurityMultiError) AllErrors() []error { return m }

// TotalInvestmentBySecurityValidationError is the validation error returned by
// TotalInvestmentBySecurity.Validate if the designated constraints aren't met.
type TotalInvestmentBySecurityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TotalInvestmentBySecurityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TotalInvestmentBySecurityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TotalInvestmentBySecurityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TotalInvestmentBySecurityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TotalInvestmentBySecurityValidationError) ErrorName() string {
	return "TotalInvestmentBySecurityValidationError"
}

// Error satisfies the builtin error interface
func (e TotalInvestmentBySecurityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTotalInvestmentBySecurity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TotalInvestmentBySecurityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TotalInvestmentBySecurityValidationError{}

// Validate checks the field values on TransactionAggregatesByMonth with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionAggregatesByMonth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionAggregatesByMonth with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionAggregatesByMonthMultiError, or nil if none found.
func (m *TransactionAggregatesByMonth) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionAggregatesByMonth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Month

	// no validation rules for PersonalFinanceCategoryPrimary

	// no validation rules for LocationCity

	// no validation rules for PaymentChannel

	// no validation rules for MerchantName

	// no validation rules for TransactionCount

	// no validation rules for TotalAmount

	// no validation rules for UserId

	if len(errors) > 0 {
		return TransactionAggregatesByMonthMultiError(errors)
	}

	return nil
}

// TransactionAggregatesByMonthMultiError is an error wrapping multiple
// validation errors returned by TransactionAggregatesByMonth.ValidateAll() if
// the designated constraints aren't met.
type TransactionAggregatesByMonthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionAggregatesByMonthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionAggregatesByMonthMultiError) AllErrors() []error { return m }

// TransactionAggregatesByMonthValidationError is the validation error returned
// by TransactionAggregatesByMonth.Validate if the designated constraints
// aren't met.
type TransactionAggregatesByMonthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionAggregatesByMonthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionAggregatesByMonthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionAggregatesByMonthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionAggregatesByMonthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionAggregatesByMonthValidationError) ErrorName() string {
	return "TransactionAggregatesByMonthValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionAggregatesByMonthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionAggregatesByMonth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionAggregatesByMonthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionAggregatesByMonthValidationError{}

// Validate checks the field values on UserFinancialHealthMetricsTable with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserFinancialHealthMetricsTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserFinancialHealthMetricsTable with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UserFinancialHealthMetricsTableMultiError, or nil if none found.
func (m *UserFinancialHealthMetricsTable) ValidateAll() error {
	return m.validate(true)
}

func (m *UserFinancialHealthMetricsTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserFinancialHealthMetricsTableValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserFinancialHealthMetricsTableValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserFinancialHealthMetricsTableValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for MonthlyIncome

	// no validation rules for MonthlyExpenses

	// no validation rules for TransactionDiversity

	// no validation rules for DebtToIncomeRatio

	// no validation rules for OverdraftFrequency

	if len(errors) > 0 {
		return UserFinancialHealthMetricsTableMultiError(errors)
	}

	return nil
}

// UserFinancialHealthMetricsTableMultiError is an error wrapping multiple
// validation errors returned by UserFinancialHealthMetricsTable.ValidateAll()
// if the designated constraints aren't met.
type UserFinancialHealthMetricsTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserFinancialHealthMetricsTableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserFinancialHealthMetricsTableMultiError) AllErrors() []error { return m }

// UserFinancialHealthMetricsTableValidationError is the validation error
// returned by UserFinancialHealthMetricsTable.Validate if the designated
// constraints aren't met.
type UserFinancialHealthMetricsTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserFinancialHealthMetricsTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserFinancialHealthMetricsTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserFinancialHealthMetricsTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserFinancialHealthMetricsTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserFinancialHealthMetricsTableValidationError) ErrorName() string {
	return "UserFinancialHealthMetricsTableValidationError"
}

// Error satisfies the builtin error interface
func (e UserFinancialHealthMetricsTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserFinancialHealthMetricsTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserFinancialHealthMetricsTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserFinancialHealthMetricsTableValidationError{}

// Validate checks the field values on MelodyFinancialContext with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MelodyFinancialContext) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MelodyFinancialContext with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MelodyFinancialContextMultiError, or nil if none found.
func (m *MelodyFinancialContext) ValidateAll() error {
	return m.validate(true)
}

func (m *MelodyFinancialContext) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCategories() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Categories[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("Categories[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("Expenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIncome() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("Income[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLocations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Locations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Locations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("Locations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMerchants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Merchants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("Merchants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("Merchants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPaymentChannels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("PaymentChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("PaymentChannels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("PaymentChannels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBankAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("BankAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvestmentAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("InvestmentAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCreditAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("CreditAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("CreditAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("CreditAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMortgageLoanAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("MortgageLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("MortgageLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("MortgageLoanAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetStudentLoanAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MelodyFinancialContextValidationError{
						field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MelodyFinancialContextValidationError{
					field:  fmt.Sprintf("StudentLoanAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FinancialUserProfileType

	if len(errors) > 0 {
		return MelodyFinancialContextMultiError(errors)
	}

	return nil
}

// MelodyFinancialContextMultiError is an error wrapping multiple validation
// errors returned by MelodyFinancialContext.ValidateAll() if the designated
// constraints aren't met.
type MelodyFinancialContextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MelodyFinancialContextMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MelodyFinancialContextMultiError) AllErrors() []error { return m }

// MelodyFinancialContextValidationError is the validation error returned by
// MelodyFinancialContext.Validate if the designated constraints aren't met.
type MelodyFinancialContextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MelodyFinancialContextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MelodyFinancialContextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MelodyFinancialContextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MelodyFinancialContextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MelodyFinancialContextValidationError) ErrorName() string {
	return "MelodyFinancialContextValidationError"
}

// Error satisfies the builtin error interface
func (e MelodyFinancialContextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMelodyFinancialContext.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MelodyFinancialContextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MelodyFinancialContextValidationError{}
