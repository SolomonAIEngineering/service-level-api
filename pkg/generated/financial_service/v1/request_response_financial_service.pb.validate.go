// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: financial_service/v1/request_response_financial_service.proto

package financial_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserProfileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserProfileRequestMultiError, or nil if none found.
func (m *CreateUserProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProfile() == nil {
		err := CreateUserProfileRequestValidationError{
			field:  "Profile",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserProfileRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserProfileRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserProfileRequestValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = CreateUserProfileRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserProfileRequestMultiError(errors)
	}

	return nil
}

func (m *CreateUserProfileRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserProfileRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserProfileRequestMultiError is an error wrapping multiple validation
// errors returned by CreateUserProfileRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateUserProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserProfileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserProfileRequestMultiError) AllErrors() []error { return m }

// CreateUserProfileRequestValidationError is the validation error returned by
// CreateUserProfileRequest.Validate if the designated constraints aren't met.
type CreateUserProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserProfileRequestValidationError) ErrorName() string {
	return "CreateUserProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserProfileRequestValidationError{}

// Validate checks the field values on CreateUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserProfileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserProfileResponseMultiError, or nil if none found.
func (m *CreateUserProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if len(errors) > 0 {
		return CreateUserProfileResponseMultiError(errors)
	}

	return nil
}

// CreateUserProfileResponseMultiError is an error wrapping multiple validation
// errors returned by CreateUserProfileResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateUserProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserProfileResponseMultiError) AllErrors() []error { return m }

// CreateUserProfileResponseValidationError is the validation error returned by
// CreateUserProfileResponse.Validate if the designated constraints aren't met.
type CreateUserProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserProfileResponseValidationError) ErrorName() string {
	return "CreateUserProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserProfileResponseValidationError{}

// Validate checks the field values on GetUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileRequestMultiError, or nil if none found.
func (m *GetUserProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetUserProfileRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetUserProfileRequestMultiError(errors)
	}

	return nil
}

// GetUserProfileRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileRequestMultiError) AllErrors() []error { return m }

// GetUserProfileRequestValidationError is the validation error returned by
// GetUserProfileRequest.Validate if the designated constraints aren't met.
type GetUserProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileRequestValidationError) ErrorName() string {
	return "GetUserProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileRequestValidationError{}

// Validate checks the field values on GetUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserProfileResponseMultiError, or nil if none found.
func (m *GetUserProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserProfileResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserProfileResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserProfileResponseValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetFinancialContext() == nil {
		err := GetUserProfileResponseValidationError{
			field:  "FinancialContext",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetFinancialContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserProfileResponseValidationError{
					field:  "FinancialContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserProfileResponseValidationError{
					field:  "FinancialContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinancialContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserProfileResponseValidationError{
				field:  "FinancialContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserProfileResponseMultiError(errors)
	}

	return nil
}

// GetUserProfileResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserProfileResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserProfileResponseMultiError) AllErrors() []error { return m }

// GetUserProfileResponseValidationError is the validation error returned by
// GetUserProfileResponse.Validate if the designated constraints aren't met.
type GetUserProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserProfileResponseValidationError) ErrorName() string {
	return "GetUserProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserProfileResponseValidationError{}

// Validate checks the field values on DeleteUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserProfileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserProfileRequestMultiError, or nil if none found.
func (m *DeleteUserProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := DeleteUserProfileRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return DeleteUserProfileRequestMultiError(errors)
	}

	return nil
}

// DeleteUserProfileRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteUserProfileRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteUserProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserProfileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserProfileRequestMultiError) AllErrors() []error { return m }

// DeleteUserProfileRequestValidationError is the validation error returned by
// DeleteUserProfileRequest.Validate if the designated constraints aren't met.
type DeleteUserProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserProfileRequestValidationError) ErrorName() string {
	return "DeleteUserProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserProfileRequestValidationError{}

// Validate checks the field values on DeleteUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteUserProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteUserProfileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteUserProfileResponseMultiError, or nil if none found.
func (m *DeleteUserProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteUserProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProfileDeleted

	if len(errors) > 0 {
		return DeleteUserProfileResponseMultiError(errors)
	}

	return nil
}

// DeleteUserProfileResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteUserProfileResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteUserProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteUserProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteUserProfileResponseMultiError) AllErrors() []error { return m }

// DeleteUserProfileResponseValidationError is the validation error returned by
// DeleteUserProfileResponse.Validate if the designated constraints aren't met.
type DeleteUserProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteUserProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteUserProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteUserProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteUserProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteUserProfileResponseValidationError) ErrorName() string {
	return "DeleteUserProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteUserProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteUserProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteUserProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteUserProfileResponseValidationError{}

// Validate checks the field values on UpdateUserProfileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserProfileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserProfileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserProfileRequestMultiError, or nil if none found.
func (m *UpdateUserProfileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserProfileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProfile() == nil {
		err := UpdateUserProfileRequestValidationError{
			field:  "Profile",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserProfileRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserProfileRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserProfileRequestValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserProfileRequestMultiError(errors)
	}

	return nil
}

// UpdateUserProfileRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateUserProfileRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateUserProfileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserProfileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserProfileRequestMultiError) AllErrors() []error { return m }

// UpdateUserProfileRequestValidationError is the validation error returned by
// UpdateUserProfileRequest.Validate if the designated constraints aren't met.
type UpdateUserProfileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserProfileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserProfileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserProfileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserProfileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserProfileRequestValidationError) ErrorName() string {
	return "UpdateUserProfileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserProfileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserProfileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserProfileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserProfileRequestValidationError{}

// Validate checks the field values on UpdateUserProfileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserProfileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserProfileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserProfileResponseMultiError, or nil if none found.
func (m *UpdateUserProfileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserProfileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProfileUpdated

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserProfileResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserProfileResponseValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserProfileResponseValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserProfileResponseMultiError(errors)
	}

	return nil
}

// UpdateUserProfileResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateUserProfileResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateUserProfileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserProfileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserProfileResponseMultiError) AllErrors() []error { return m }

// UpdateUserProfileResponseValidationError is the validation error returned by
// UpdateUserProfileResponse.Validate if the designated constraints aren't met.
type UpdateUserProfileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserProfileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserProfileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserProfileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserProfileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserProfileResponseValidationError) ErrorName() string {
	return "UpdateUserProfileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserProfileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserProfileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserProfileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserProfileResponseValidationError{}

// Validate checks the field values on CreateBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBankAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBankAccountRequestMultiError, or nil if none found.
func (m *CreateBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CreateBankAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetBankAccount() == nil {
		err := CreateBankAccountRequestValidationError{
			field:  "BankAccount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBankAccountRequestValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBankAccountRequestValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBankAccountRequestValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProfileType

	if m.GetLinkId() <= 0 {
		err := CreateBankAccountRequestValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateBankAccountRequestMultiError(errors)
	}

	return nil
}

// CreateBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBankAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBankAccountRequestMultiError) AllErrors() []error { return m }

// CreateBankAccountRequestValidationError is the validation error returned by
// CreateBankAccountRequest.Validate if the designated constraints aren't met.
type CreateBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBankAccountRequestValidationError) ErrorName() string {
	return "CreateBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBankAccountRequestValidationError{}

// Validate checks the field values on CreateBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBankAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBankAccountResponseMultiError, or nil if none found.
func (m *CreateBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BankAccountId

	if len(errors) > 0 {
		return CreateBankAccountResponseMultiError(errors)
	}

	return nil
}

// CreateBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by CreateBankAccountResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBankAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBankAccountResponseMultiError) AllErrors() []error { return m }

// CreateBankAccountResponseValidationError is the validation error returned by
// CreateBankAccountResponse.Validate if the designated constraints aren't met.
type CreateBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBankAccountResponseValidationError) ErrorName() string {
	return "CreateBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBankAccountResponseValidationError{}

// Validate checks the field values on GetBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBankAccountRequestMultiError, or nil if none found.
func (m *GetBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBankAccountId() <= 0 {
		err := GetBankAccountRequestValidationError{
			field:  "BankAccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetBankAccountRequestMultiError(errors)
	}

	return nil
}

// GetBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by GetBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBankAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBankAccountRequestMultiError) AllErrors() []error { return m }

// GetBankAccountRequestValidationError is the validation error returned by
// GetBankAccountRequest.Validate if the designated constraints aren't met.
type GetBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBankAccountRequestValidationError) ErrorName() string {
	return "GetBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBankAccountRequestValidationError{}

// Validate checks the field values on GetBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBankAccountResponseMultiError, or nil if none found.
func (m *GetBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBankAccountResponseValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBankAccountResponseMultiError(errors)
	}

	return nil
}

// GetBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by GetBankAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBankAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBankAccountResponseMultiError) AllErrors() []error { return m }

// GetBankAccountResponseValidationError is the validation error returned by
// GetBankAccountResponse.Validate if the designated constraints aren't met.
type GetBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBankAccountResponseValidationError) ErrorName() string {
	return "GetBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBankAccountResponseValidationError{}

// Validate checks the field values on DeleteBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBankAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBankAccountRequestMultiError, or nil if none found.
func (m *DeleteBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := DeleteBankAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetBankAccountId() <= 0 {
		err := DeleteBankAccountRequestValidationError{
			field:  "BankAccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return DeleteBankAccountRequestMultiError(errors)
	}

	return nil
}

// DeleteBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBankAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBankAccountRequestMultiError) AllErrors() []error { return m }

// DeleteBankAccountRequestValidationError is the validation error returned by
// DeleteBankAccountRequest.Validate if the designated constraints aren't met.
type DeleteBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBankAccountRequestValidationError) ErrorName() string {
	return "DeleteBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBankAccountRequestValidationError{}

// Validate checks the field values on DeleteBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBankAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBankAccountResponseMultiError, or nil if none found.
func (m *DeleteBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteBankAccountResponseMultiError(errors)
	}

	return nil
}

// DeleteBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteBankAccountResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBankAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBankAccountResponseMultiError) AllErrors() []error { return m }

// DeleteBankAccountResponseValidationError is the validation error returned by
// DeleteBankAccountResponse.Validate if the designated constraints aren't met.
type DeleteBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBankAccountResponseValidationError) ErrorName() string {
	return "DeleteBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBankAccountResponseValidationError{}

// Validate checks the field values on UpdateBankAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBankAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBankAccountRequestMultiError, or nil if none found.
func (m *UpdateBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBankAccountRequestValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBankAccountRequestValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBankAccountRequestValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBankAccountRequestMultiError(errors)
	}

	return nil
}

// UpdateBankAccountRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBankAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBankAccountRequestMultiError) AllErrors() []error { return m }

// UpdateBankAccountRequestValidationError is the validation error returned by
// UpdateBankAccountRequest.Validate if the designated constraints aren't met.
type UpdateBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBankAccountRequestValidationError) ErrorName() string {
	return "UpdateBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBankAccountRequestValidationError{}

// Validate checks the field values on UpdateBankAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBankAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBankAccountResponseMultiError, or nil if none found.
func (m *UpdateBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Updated

	if all {
		switch v := interface{}(m.GetBankAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBankAccountResponseValidationError{
				field:  "BankAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBankAccountResponseMultiError(errors)
	}

	return nil
}

// UpdateBankAccountResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateBankAccountResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBankAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBankAccountResponseMultiError) AllErrors() []error { return m }

// UpdateBankAccountResponseValidationError is the validation error returned by
// UpdateBankAccountResponse.Validate if the designated constraints aren't met.
type UpdateBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBankAccountResponseValidationError) ErrorName() string {
	return "UpdateBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBankAccountResponseValidationError{}

// Validate checks the field values on GetPocketRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPocketRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPocketRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPocketRequestMultiError, or nil if none found.
func (m *GetPocketRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPocketRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPocketId() <= 0 {
		err := GetPocketRequestValidationError{
			field:  "PocketId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPocketRequestMultiError(errors)
	}

	return nil
}

// GetPocketRequestMultiError is an error wrapping multiple validation errors
// returned by GetPocketRequest.ValidateAll() if the designated constraints
// aren't met.
type GetPocketRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPocketRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPocketRequestMultiError) AllErrors() []error { return m }

// GetPocketRequestValidationError is the validation error returned by
// GetPocketRequest.Validate if the designated constraints aren't met.
type GetPocketRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPocketRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPocketRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPocketRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPocketRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPocketRequestValidationError) ErrorName() string { return "GetPocketRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetPocketRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPocketRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPocketRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPocketRequestValidationError{}

// Validate checks the field values on GetPocketResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPocketResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPocketResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPocketResponseMultiError, or nil if none found.
func (m *GetPocketResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPocketResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPocket()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPocketResponseValidationError{
					field:  "Pocket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPocketResponseValidationError{
					field:  "Pocket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPocket()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPocketResponseValidationError{
				field:  "Pocket",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPocketResponseMultiError(errors)
	}

	return nil
}

// GetPocketResponseMultiError is an error wrapping multiple validation errors
// returned by GetPocketResponse.ValidateAll() if the designated constraints
// aren't met.
type GetPocketResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPocketResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPocketResponseMultiError) AllErrors() []error { return m }

// GetPocketResponseValidationError is the validation error returned by
// GetPocketResponse.Validate if the designated constraints aren't met.
type GetPocketResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPocketResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPocketResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPocketResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPocketResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPocketResponseValidationError) ErrorName() string {
	return "GetPocketResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPocketResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPocketResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPocketResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPocketResponseValidationError{}

// Validate checks the field values on GetSmartGoalsByPocketIdRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSmartGoalsByPocketIdRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSmartGoalsByPocketIdRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSmartGoalsByPocketIdRequestMultiError, or nil if none found.
func (m *GetSmartGoalsByPocketIdRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSmartGoalsByPocketIdRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPocketId() <= 0 {
		err := GetSmartGoalsByPocketIdRequestValidationError{
			field:  "PocketId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSmartGoalsByPocketIdRequestMultiError(errors)
	}

	return nil
}

// GetSmartGoalsByPocketIdRequestMultiError is an error wrapping multiple
// validation errors returned by GetSmartGoalsByPocketIdRequest.ValidateAll()
// if the designated constraints aren't met.
type GetSmartGoalsByPocketIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSmartGoalsByPocketIdRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSmartGoalsByPocketIdRequestMultiError) AllErrors() []error { return m }

// GetSmartGoalsByPocketIdRequestValidationError is the validation error
// returned by GetSmartGoalsByPocketIdRequest.Validate if the designated
// constraints aren't met.
type GetSmartGoalsByPocketIdRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSmartGoalsByPocketIdRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSmartGoalsByPocketIdRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSmartGoalsByPocketIdRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSmartGoalsByPocketIdRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSmartGoalsByPocketIdRequestValidationError) ErrorName() string {
	return "GetSmartGoalsByPocketIdRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSmartGoalsByPocketIdRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSmartGoalsByPocketIdRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSmartGoalsByPocketIdRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSmartGoalsByPocketIdRequestValidationError{}

// Validate checks the field values on GetSmartGoalsByPocketIdResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSmartGoalsByPocketIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSmartGoalsByPocketIdResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSmartGoalsByPocketIdResponseMultiError, or nil if none found.
func (m *GetSmartGoalsByPocketIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSmartGoalsByPocketIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSmartGoals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSmartGoalsByPocketIdResponseValidationError{
						field:  fmt.Sprintf("SmartGoals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSmartGoalsByPocketIdResponseValidationError{
						field:  fmt.Sprintf("SmartGoals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSmartGoalsByPocketIdResponseValidationError{
					field:  fmt.Sprintf("SmartGoals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSmartGoalsByPocketIdResponseMultiError(errors)
	}

	return nil
}

// GetSmartGoalsByPocketIdResponseMultiError is an error wrapping multiple
// validation errors returned by GetSmartGoalsByPocketIdResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSmartGoalsByPocketIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSmartGoalsByPocketIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSmartGoalsByPocketIdResponseMultiError) AllErrors() []error { return m }

// GetSmartGoalsByPocketIdResponseValidationError is the validation error
// returned by GetSmartGoalsByPocketIdResponse.Validate if the designated
// constraints aren't met.
type GetSmartGoalsByPocketIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSmartGoalsByPocketIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSmartGoalsByPocketIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSmartGoalsByPocketIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSmartGoalsByPocketIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSmartGoalsByPocketIdResponseValidationError) ErrorName() string {
	return "GetSmartGoalsByPocketIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSmartGoalsByPocketIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSmartGoalsByPocketIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSmartGoalsByPocketIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSmartGoalsByPocketIdResponseValidationError{}

// Validate checks the field values on CreateSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSmartGoalRequestMultiError, or nil if none found.
func (m *CreateSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPocketId() <= 0 {
		err := CreateSmartGoalRequestValidationError{
			field:  "PocketId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSmartGoal() == nil {
		err := CreateSmartGoalRequestValidationError{
			field:  "SmartGoal",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSmartGoal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSmartGoalRequestValidationError{
					field:  "SmartGoal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSmartGoalRequestValidationError{
					field:  "SmartGoal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSmartGoal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSmartGoalRequestValidationError{
				field:  "SmartGoal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSmartGoalRequestMultiError(errors)
	}

	return nil
}

// CreateSmartGoalRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSmartGoalRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSmartGoalRequestMultiError) AllErrors() []error { return m }

// CreateSmartGoalRequestValidationError is the validation error returned by
// CreateSmartGoalRequest.Validate if the designated constraints aren't met.
type CreateSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSmartGoalRequestValidationError) ErrorName() string {
	return "CreateSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSmartGoalRequestValidationError{}

// Validate checks the field values on CreateSmartGoalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSmartGoalResponseMultiError, or nil if none found.
func (m *CreateSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SmartGoalId

	if len(errors) > 0 {
		return CreateSmartGoalResponseMultiError(errors)
	}

	return nil
}

// CreateSmartGoalResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSmartGoalResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSmartGoalResponseMultiError) AllErrors() []error { return m }

// CreateSmartGoalResponseValidationError is the validation error returned by
// CreateSmartGoalResponse.Validate if the designated constraints aren't met.
type CreateSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSmartGoalResponseValidationError) ErrorName() string {
	return "CreateSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSmartGoalResponseValidationError{}

// Validate checks the field values on UpdateSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSmartGoalRequestMultiError, or nil if none found.
func (m *UpdateSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoal() == nil {
		err := UpdateSmartGoalRequestValidationError{
			field:  "SmartGoal",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSmartGoal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSmartGoalRequestValidationError{
					field:  "SmartGoal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSmartGoalRequestValidationError{
					field:  "SmartGoal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSmartGoal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSmartGoalRequestValidationError{
				field:  "SmartGoal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSmartGoalRequestMultiError(errors)
	}

	return nil
}

// UpdateSmartGoalRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSmartGoalRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSmartGoalRequestMultiError) AllErrors() []error { return m }

// UpdateSmartGoalRequestValidationError is the validation error returned by
// UpdateSmartGoalRequest.Validate if the designated constraints aren't met.
type UpdateSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSmartGoalRequestValidationError) ErrorName() string {
	return "UpdateSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSmartGoalRequestValidationError{}

// Validate checks the field values on UpdateSmartGoalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSmartGoalResponseMultiError, or nil if none found.
func (m *UpdateSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SmartGoalId

	if len(errors) > 0 {
		return UpdateSmartGoalResponseMultiError(errors)
	}

	return nil
}

// UpdateSmartGoalResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateSmartGoalResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSmartGoalResponseMultiError) AllErrors() []error { return m }

// UpdateSmartGoalResponseValidationError is the validation error returned by
// UpdateSmartGoalResponse.Validate if the designated constraints aren't met.
type UpdateSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSmartGoalResponseValidationError) ErrorName() string {
	return "UpdateSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSmartGoalResponseValidationError{}

// Validate checks the field values on DeleteSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSmartGoalRequestMultiError, or nil if none found.
func (m *DeleteSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := DeleteSmartGoalRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteSmartGoalRequestMultiError(errors)
	}

	return nil
}

// DeleteSmartGoalRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSmartGoalRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSmartGoalRequestMultiError) AllErrors() []error { return m }

// DeleteSmartGoalRequestValidationError is the validation error returned by
// DeleteSmartGoalRequest.Validate if the designated constraints aren't met.
type DeleteSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSmartGoalRequestValidationError) ErrorName() string {
	return "DeleteSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSmartGoalRequestValidationError{}

// Validate checks the field values on DeleteSmartGoalResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSmartGoalResponseMultiError, or nil if none found.
func (m *DeleteSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteSmartGoalResponseMultiError(errors)
	}

	return nil
}

// DeleteSmartGoalResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteSmartGoalResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSmartGoalResponseMultiError) AllErrors() []error { return m }

// DeleteSmartGoalResponseValidationError is the validation error returned by
// DeleteSmartGoalResponse.Validate if the designated constraints aren't met.
type DeleteSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSmartGoalResponseValidationError) ErrorName() string {
	return "DeleteSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSmartGoalResponseValidationError{}

// Validate checks the field values on CreateMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateMilestoneRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMilestoneRequestMultiError, or nil if none found.
func (m *CreateMilestoneRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMilestoneRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := CreateMilestoneRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMilestone() == nil {
		err := CreateMilestoneRequestValidationError{
			field:  "Milestone",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMilestone()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateMilestoneRequestValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateMilestoneRequestValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMilestone()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateMilestoneRequestValidationError{
				field:  "Milestone",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateMilestoneRequestMultiError(errors)
	}

	return nil
}

// CreateMilestoneRequestMultiError is an error wrapping multiple validation
// errors returned by CreateMilestoneRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateMilestoneRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMilestoneRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMilestoneRequestMultiError) AllErrors() []error { return m }

// CreateMilestoneRequestValidationError is the validation error returned by
// CreateMilestoneRequest.Validate if the designated constraints aren't met.
type CreateMilestoneRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMilestoneRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMilestoneRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMilestoneRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMilestoneRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMilestoneRequestValidationError) ErrorName() string {
	return "CreateMilestoneRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMilestoneRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMilestoneRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMilestoneRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMilestoneRequestValidationError{}

// Validate checks the field values on CreateMilestoneResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateMilestoneResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateMilestoneResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateMilestoneResponseMultiError, or nil if none found.
func (m *CreateMilestoneResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateMilestoneResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MilestoneId

	if len(errors) > 0 {
		return CreateMilestoneResponseMultiError(errors)
	}

	return nil
}

// CreateMilestoneResponseMultiError is an error wrapping multiple validation
// errors returned by CreateMilestoneResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateMilestoneResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateMilestoneResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateMilestoneResponseMultiError) AllErrors() []error { return m }

// CreateMilestoneResponseValidationError is the validation error returned by
// CreateMilestoneResponse.Validate if the designated constraints aren't met.
type CreateMilestoneResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateMilestoneResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateMilestoneResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateMilestoneResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateMilestoneResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateMilestoneResponseValidationError) ErrorName() string {
	return "CreateMilestoneResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateMilestoneResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateMilestoneResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateMilestoneResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateMilestoneResponseValidationError{}

// Validate checks the field values on DeleteMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMilestoneRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMilestoneRequestMultiError, or nil if none found.
func (m *DeleteMilestoneRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMilestoneRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMilestoneId() <= 0 {
		err := DeleteMilestoneRequestValidationError{
			field:  "MilestoneId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteMilestoneRequestMultiError(errors)
	}

	return nil
}

// DeleteMilestoneRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteMilestoneRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteMilestoneRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMilestoneRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMilestoneRequestMultiError) AllErrors() []error { return m }

// DeleteMilestoneRequestValidationError is the validation error returned by
// DeleteMilestoneRequest.Validate if the designated constraints aren't met.
type DeleteMilestoneRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMilestoneRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMilestoneRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMilestoneRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMilestoneRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMilestoneRequestValidationError) ErrorName() string {
	return "DeleteMilestoneRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMilestoneRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMilestoneRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMilestoneRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMilestoneRequestValidationError{}

// Validate checks the field values on DeleteMilestoneResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteMilestoneResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteMilestoneResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteMilestoneResponseMultiError, or nil if none found.
func (m *DeleteMilestoneResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteMilestoneResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteMilestoneResponseMultiError(errors)
	}

	return nil
}

// DeleteMilestoneResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteMilestoneResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteMilestoneResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteMilestoneResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteMilestoneResponseMultiError) AllErrors() []error { return m }

// DeleteMilestoneResponseValidationError is the validation error returned by
// DeleteMilestoneResponse.Validate if the designated constraints aren't met.
type DeleteMilestoneResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteMilestoneResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteMilestoneResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteMilestoneResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteMilestoneResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteMilestoneResponseValidationError) ErrorName() string {
	return "DeleteMilestoneResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteMilestoneResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteMilestoneResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteMilestoneResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteMilestoneResponseValidationError{}

// Validate checks the field values on UpdateMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMilestoneRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMilestoneRequestMultiError, or nil if none found.
func (m *UpdateMilestoneRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMilestoneRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMilestone() == nil {
		err := UpdateMilestoneRequestValidationError{
			field:  "Milestone",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMilestone()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMilestoneRequestValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMilestoneRequestValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMilestone()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMilestoneRequestValidationError{
				field:  "Milestone",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMilestoneRequestMultiError(errors)
	}

	return nil
}

// UpdateMilestoneRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateMilestoneRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateMilestoneRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMilestoneRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMilestoneRequestMultiError) AllErrors() []error { return m }

// UpdateMilestoneRequestValidationError is the validation error returned by
// UpdateMilestoneRequest.Validate if the designated constraints aren't met.
type UpdateMilestoneRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMilestoneRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMilestoneRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMilestoneRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMilestoneRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMilestoneRequestValidationError) ErrorName() string {
	return "UpdateMilestoneRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMilestoneRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMilestoneRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMilestoneRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMilestoneRequestValidationError{}

// Validate checks the field values on UpdateMilestoneResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMilestoneResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMilestoneResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMilestoneResponseMultiError, or nil if none found.
func (m *UpdateMilestoneResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMilestoneResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMilestone()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMilestoneResponseValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMilestoneResponseValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMilestone()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMilestoneResponseValidationError{
				field:  "Milestone",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMilestoneResponseMultiError(errors)
	}

	return nil
}

// UpdateMilestoneResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateMilestoneResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateMilestoneResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMilestoneResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMilestoneResponseMultiError) AllErrors() []error { return m }

// UpdateMilestoneResponseValidationError is the validation error returned by
// UpdateMilestoneResponse.Validate if the designated constraints aren't met.
type UpdateMilestoneResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMilestoneResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMilestoneResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMilestoneResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMilestoneResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMilestoneResponseValidationError) ErrorName() string {
	return "UpdateMilestoneResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMilestoneResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMilestoneResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMilestoneResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMilestoneResponseValidationError{}

// Validate checks the field values on GetMilestonesBySmartGoalIdRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetMilestonesBySmartGoalIdRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMilestonesBySmartGoalIdRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetMilestonesBySmartGoalIdRequestMultiError, or nil if none found.
func (m *GetMilestonesBySmartGoalIdRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMilestonesBySmartGoalIdRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := GetMilestonesBySmartGoalIdRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMilestonesBySmartGoalIdRequestMultiError(errors)
	}

	return nil
}

// GetMilestonesBySmartGoalIdRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetMilestonesBySmartGoalIdRequest.ValidateAll() if the designated
// constraints aren't met.
type GetMilestonesBySmartGoalIdRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMilestonesBySmartGoalIdRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMilestonesBySmartGoalIdRequestMultiError) AllErrors() []error { return m }

// GetMilestonesBySmartGoalIdRequestValidationError is the validation error
// returned by GetMilestonesBySmartGoalIdRequest.Validate if the designated
// constraints aren't met.
type GetMilestonesBySmartGoalIdRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMilestonesBySmartGoalIdRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMilestonesBySmartGoalIdRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMilestonesBySmartGoalIdRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMilestonesBySmartGoalIdRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMilestonesBySmartGoalIdRequestValidationError) ErrorName() string {
	return "GetMilestonesBySmartGoalIdRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMilestonesBySmartGoalIdRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMilestonesBySmartGoalIdRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMilestonesBySmartGoalIdRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMilestonesBySmartGoalIdRequestValidationError{}

// Validate checks the field values on GetMilestonesBySmartGoalIdResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetMilestonesBySmartGoalIdResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMilestonesBySmartGoalIdResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetMilestonesBySmartGoalIdResponseMultiError, or nil if none found.
func (m *GetMilestonesBySmartGoalIdResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMilestonesBySmartGoalIdResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMilestones() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMilestonesBySmartGoalIdResponseValidationError{
						field:  fmt.Sprintf("Milestones[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMilestonesBySmartGoalIdResponseValidationError{
						field:  fmt.Sprintf("Milestones[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMilestonesBySmartGoalIdResponseValidationError{
					field:  fmt.Sprintf("Milestones[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMilestonesBySmartGoalIdResponseMultiError(errors)
	}

	return nil
}

// GetMilestonesBySmartGoalIdResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetMilestonesBySmartGoalIdResponse.ValidateAll() if the designated
// constraints aren't met.
type GetMilestonesBySmartGoalIdResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMilestonesBySmartGoalIdResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMilestonesBySmartGoalIdResponseMultiError) AllErrors() []error { return m }

// GetMilestonesBySmartGoalIdResponseValidationError is the validation error
// returned by GetMilestonesBySmartGoalIdResponse.Validate if the designated
// constraints aren't met.
type GetMilestonesBySmartGoalIdResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMilestonesBySmartGoalIdResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMilestonesBySmartGoalIdResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMilestonesBySmartGoalIdResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMilestonesBySmartGoalIdResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMilestonesBySmartGoalIdResponseValidationError) ErrorName() string {
	return "GetMilestonesBySmartGoalIdResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMilestonesBySmartGoalIdResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMilestonesBySmartGoalIdResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMilestonesBySmartGoalIdResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMilestonesBySmartGoalIdResponseValidationError{}

// Validate checks the field values on GetMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMilestoneRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMilestoneRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMilestoneRequestMultiError, or nil if none found.
func (m *GetMilestoneRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMilestoneRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMilestoneId() <= 0 {
		err := GetMilestoneRequestValidationError{
			field:  "MilestoneId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMilestoneRequestMultiError(errors)
	}

	return nil
}

// GetMilestoneRequestMultiError is an error wrapping multiple validation
// errors returned by GetMilestoneRequest.ValidateAll() if the designated
// constraints aren't met.
type GetMilestoneRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMilestoneRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMilestoneRequestMultiError) AllErrors() []error { return m }

// GetMilestoneRequestValidationError is the validation error returned by
// GetMilestoneRequest.Validate if the designated constraints aren't met.
type GetMilestoneRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMilestoneRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMilestoneRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMilestoneRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMilestoneRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMilestoneRequestValidationError) ErrorName() string {
	return "GetMilestoneRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMilestoneRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMilestoneRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMilestoneRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMilestoneRequestValidationError{}

// Validate checks the field values on GetMilestoneResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMilestoneResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMilestoneResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMilestoneResponseMultiError, or nil if none found.
func (m *GetMilestoneResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMilestoneResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMilestone()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMilestoneResponseValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMilestoneResponseValidationError{
					field:  "Milestone",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMilestone()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMilestoneResponseValidationError{
				field:  "Milestone",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMilestoneResponseMultiError(errors)
	}

	return nil
}

// GetMilestoneResponseMultiError is an error wrapping multiple validation
// errors returned by GetMilestoneResponse.ValidateAll() if the designated
// constraints aren't met.
type GetMilestoneResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMilestoneResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMilestoneResponseMultiError) AllErrors() []error { return m }

// GetMilestoneResponseValidationError is the validation error returned by
// GetMilestoneResponse.Validate if the designated constraints aren't met.
type GetMilestoneResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMilestoneResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMilestoneResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMilestoneResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMilestoneResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMilestoneResponseValidationError) ErrorName() string {
	return "GetMilestoneResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMilestoneResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMilestoneResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMilestoneResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMilestoneResponseValidationError{}

// Validate checks the field values on GetForecastRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetForecastRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetForecastRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetForecastRequestMultiError, or nil if none found.
func (m *GetForecastRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetForecastRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := GetForecastRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetForecastRequestMultiError(errors)
	}

	return nil
}

// GetForecastRequestMultiError is an error wrapping multiple validation errors
// returned by GetForecastRequest.ValidateAll() if the designated constraints
// aren't met.
type GetForecastRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetForecastRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetForecastRequestMultiError) AllErrors() []error { return m }

// GetForecastRequestValidationError is the validation error returned by
// GetForecastRequest.Validate if the designated constraints aren't met.
type GetForecastRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetForecastRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetForecastRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetForecastRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetForecastRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetForecastRequestValidationError) ErrorName() string {
	return "GetForecastRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetForecastRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetForecastRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetForecastRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetForecastRequestValidationError{}

// Validate checks the field values on GetForecastResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetForecastResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetForecastResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetForecastResponseMultiError, or nil if none found.
func (m *GetForecastResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetForecastResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetForecast()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponseValidationError{
					field:  "Forecast",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponseValidationError{
					field:  "Forecast",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetForecast()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponseValidationError{
				field:  "Forecast",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetForecastResponseMultiError(errors)
	}

	return nil
}

// GetForecastResponseMultiError is an error wrapping multiple validation
// errors returned by GetForecastResponse.ValidateAll() if the designated
// constraints aren't met.
type GetForecastResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetForecastResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetForecastResponseMultiError) AllErrors() []error { return m }

// GetForecastResponseValidationError is the validation error returned by
// GetForecastResponse.Validate if the designated constraints aren't met.
type GetForecastResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetForecastResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetForecastResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetForecastResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetForecastResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetForecastResponseValidationError) ErrorName() string {
	return "GetForecastResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetForecastResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetForecastResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetForecastResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetForecastResponseValidationError{}

// Validate checks the field values on CreateBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBudgetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBudgetRequestMultiError, or nil if none found.
func (m *CreateBudgetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBudgetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMilestroneId() <= 0 {
		err := CreateBudgetRequestValidationError{
			field:  "MilestroneId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetBudget() == nil {
		err := CreateBudgetRequestValidationError{
			field:  "Budget",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBudget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBudgetRequestValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBudgetRequestValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBudget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBudgetRequestValidationError{
				field:  "Budget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateBudgetRequestMultiError(errors)
	}

	return nil
}

// CreateBudgetRequestMultiError is an error wrapping multiple validation
// errors returned by CreateBudgetRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBudgetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBudgetRequestMultiError) AllErrors() []error { return m }

// CreateBudgetRequestValidationError is the validation error returned by
// CreateBudgetRequest.Validate if the designated constraints aren't met.
type CreateBudgetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBudgetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBudgetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBudgetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBudgetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBudgetRequestValidationError) ErrorName() string {
	return "CreateBudgetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBudgetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBudgetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBudgetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBudgetRequestValidationError{}

// Validate checks the field values on CreateBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBudgetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBudgetResponseMultiError, or nil if none found.
func (m *CreateBudgetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBudgetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BudgetId

	if len(errors) > 0 {
		return CreateBudgetResponseMultiError(errors)
	}

	return nil
}

// CreateBudgetResponseMultiError is an error wrapping multiple validation
// errors returned by CreateBudgetResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBudgetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBudgetResponseMultiError) AllErrors() []error { return m }

// CreateBudgetResponseValidationError is the validation error returned by
// CreateBudgetResponse.Validate if the designated constraints aren't met.
type CreateBudgetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBudgetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBudgetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBudgetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBudgetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBudgetResponseValidationError) ErrorName() string {
	return "CreateBudgetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBudgetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBudgetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBudgetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBudgetResponseValidationError{}

// Validate checks the field values on UpdateBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBudgetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBudgetRequestMultiError, or nil if none found.
func (m *UpdateBudgetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBudgetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBudget() == nil {
		err := UpdateBudgetRequestValidationError{
			field:  "Budget",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBudget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBudgetRequestValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBudgetRequestValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBudget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBudgetRequestValidationError{
				field:  "Budget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBudgetRequestMultiError(errors)
	}

	return nil
}

// UpdateBudgetRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateBudgetRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBudgetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBudgetRequestMultiError) AllErrors() []error { return m }

// UpdateBudgetRequestValidationError is the validation error returned by
// UpdateBudgetRequest.Validate if the designated constraints aren't met.
type UpdateBudgetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBudgetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBudgetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBudgetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBudgetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBudgetRequestValidationError) ErrorName() string {
	return "UpdateBudgetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBudgetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBudgetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBudgetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBudgetRequestValidationError{}

// Validate checks the field values on UpdateBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateBudgetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateBudgetResponseMultiError, or nil if none found.
func (m *UpdateBudgetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateBudgetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBudget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateBudgetResponseValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateBudgetResponseValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBudget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateBudgetResponseValidationError{
				field:  "Budget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateBudgetResponseMultiError(errors)
	}

	return nil
}

// UpdateBudgetResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateBudgetResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateBudgetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateBudgetResponseMultiError) AllErrors() []error { return m }

// UpdateBudgetResponseValidationError is the validation error returned by
// UpdateBudgetResponse.Validate if the designated constraints aren't met.
type UpdateBudgetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateBudgetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateBudgetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateBudgetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateBudgetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateBudgetResponseValidationError) ErrorName() string {
	return "UpdateBudgetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateBudgetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateBudgetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateBudgetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateBudgetResponseValidationError{}

// Validate checks the field values on DeleteBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBudgetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBudgetRequestMultiError, or nil if none found.
func (m *DeleteBudgetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBudgetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBudgetId() <= 0 {
		err := DeleteBudgetRequestValidationError{
			field:  "BudgetId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteBudgetRequestMultiError(errors)
	}

	return nil
}

// DeleteBudgetRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBudgetRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBudgetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBudgetRequestMultiError) AllErrors() []error { return m }

// DeleteBudgetRequestValidationError is the validation error returned by
// DeleteBudgetRequest.Validate if the designated constraints aren't met.
type DeleteBudgetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBudgetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBudgetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBudgetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBudgetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBudgetRequestValidationError) ErrorName() string {
	return "DeleteBudgetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBudgetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBudgetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBudgetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBudgetRequestValidationError{}

// Validate checks the field values on DeleteBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBudgetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBudgetResponseMultiError, or nil if none found.
func (m *DeleteBudgetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBudgetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteBudgetResponseMultiError(errors)
	}

	return nil
}

// DeleteBudgetResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteBudgetResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBudgetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBudgetResponseMultiError) AllErrors() []error { return m }

// DeleteBudgetResponseValidationError is the validation error returned by
// DeleteBudgetResponse.Validate if the designated constraints aren't met.
type DeleteBudgetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBudgetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBudgetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBudgetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBudgetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBudgetResponseValidationError) ErrorName() string {
	return "DeleteBudgetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBudgetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBudgetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBudgetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBudgetResponseValidationError{}

// Validate checks the field values on GetBudgetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBudgetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBudgetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBudgetRequestMultiError, or nil if none found.
func (m *GetBudgetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBudgetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBudgetId() <= 0 {
		err := GetBudgetRequestValidationError{
			field:  "BudgetId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetBudgetRequestMultiError(errors)
	}

	return nil
}

// GetBudgetRequestMultiError is an error wrapping multiple validation errors
// returned by GetBudgetRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBudgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBudgetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBudgetRequestMultiError) AllErrors() []error { return m }

// GetBudgetRequestValidationError is the validation error returned by
// GetBudgetRequest.Validate if the designated constraints aren't met.
type GetBudgetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBudgetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBudgetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBudgetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBudgetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBudgetRequestValidationError) ErrorName() string { return "GetBudgetRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetBudgetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBudgetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBudgetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBudgetRequestValidationError{}

// Validate checks the field values on GetBudgetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBudgetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBudgetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBudgetResponseMultiError, or nil if none found.
func (m *GetBudgetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBudgetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBudget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBudgetResponseValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBudgetResponseValidationError{
					field:  "Budget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBudget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBudgetResponseValidationError{
				field:  "Budget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBudgetResponseMultiError(errors)
	}

	return nil
}

// GetBudgetResponseMultiError is an error wrapping multiple validation errors
// returned by GetBudgetResponse.ValidateAll() if the designated constraints
// aren't met.
type GetBudgetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBudgetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBudgetResponseMultiError) AllErrors() []error { return m }

// GetBudgetResponseValidationError is the validation error returned by
// GetBudgetResponse.Validate if the designated constraints aren't met.
type GetBudgetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBudgetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBudgetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBudgetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBudgetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBudgetResponseValidationError) ErrorName() string {
	return "GetBudgetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBudgetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBudgetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBudgetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBudgetResponseValidationError{}

// Validate checks the field values on GetAllBudgetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllBudgetsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllBudgetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllBudgetsRequestMultiError, or nil if none found.
func (m *GetAllBudgetsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllBudgetsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPocketId() <= 0 {
		err := GetAllBudgetsRequestValidationError{
			field:  "PocketId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSmartGoalId() <= 0 {
		err := GetAllBudgetsRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMilestoneId() <= 0 {
		err := GetAllBudgetsRequestValidationError{
			field:  "MilestoneId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAllBudgetsRequestMultiError(errors)
	}

	return nil
}

// GetAllBudgetsRequestMultiError is an error wrapping multiple validation
// errors returned by GetAllBudgetsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAllBudgetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllBudgetsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllBudgetsRequestMultiError) AllErrors() []error { return m }

// GetAllBudgetsRequestValidationError is the validation error returned by
// GetAllBudgetsRequest.Validate if the designated constraints aren't met.
type GetAllBudgetsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllBudgetsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllBudgetsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllBudgetsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllBudgetsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllBudgetsRequestValidationError) ErrorName() string {
	return "GetAllBudgetsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllBudgetsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllBudgetsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllBudgetsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllBudgetsRequestValidationError{}

// Validate checks the field values on GetAllBudgetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllBudgetsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllBudgetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllBudgetsResponseMultiError, or nil if none found.
func (m *GetAllBudgetsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllBudgetsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBudgets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAllBudgetsResponseValidationError{
						field:  fmt.Sprintf("Budgets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAllBudgetsResponseValidationError{
						field:  fmt.Sprintf("Budgets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAllBudgetsResponseValidationError{
					field:  fmt.Sprintf("Budgets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAllBudgetsResponseMultiError(errors)
	}

	return nil
}

// GetAllBudgetsResponseMultiError is an error wrapping multiple validation
// errors returned by GetAllBudgetsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAllBudgetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllBudgetsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllBudgetsResponseMultiError) AllErrors() []error { return m }

// GetAllBudgetsResponseValidationError is the validation error returned by
// GetAllBudgetsResponse.Validate if the designated constraints aren't met.
type GetAllBudgetsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllBudgetsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllBudgetsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllBudgetsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllBudgetsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllBudgetsResponseValidationError) ErrorName() string {
	return "GetAllBudgetsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllBudgetsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllBudgetsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllBudgetsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllBudgetsResponseValidationError{}

// Validate checks the field values on HealthCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheckRequestMultiError, or nil if none found.
func (m *HealthCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HealthCheckRequestMultiError(errors)
	}

	return nil
}

// HealthCheckRequestMultiError is an error wrapping multiple validation errors
// returned by HealthCheckRequest.ValidateAll() if the designated constraints
// aren't met.
type HealthCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheckRequestMultiError) AllErrors() []error { return m }

// HealthCheckRequestValidationError is the validation error returned by
// HealthCheckRequest.Validate if the designated constraints aren't met.
type HealthCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheckRequestValidationError) ErrorName() string {
	return "HealthCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheckRequestValidationError{}

// Validate checks the field values on HealthCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HealthCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HealthCheckResponseMultiError, or nil if none found.
func (m *HealthCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Healthy

	if len(errors) > 0 {
		return HealthCheckResponseMultiError(errors)
	}

	return nil
}

// HealthCheckResponseMultiError is an error wrapping multiple validation
// errors returned by HealthCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type HealthCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheckResponseMultiError) AllErrors() []error { return m }

// HealthCheckResponseValidationError is the validation error returned by
// HealthCheckResponse.Validate if the designated constraints aren't met.
type HealthCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheckResponseValidationError) ErrorName() string {
	return "HealthCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HealthCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheckResponseValidationError{}

// Validate checks the field values on ReadynessCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadynessCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadynessCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadynessCheckRequestMultiError, or nil if none found.
func (m *ReadynessCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadynessCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReadynessCheckRequestMultiError(errors)
	}

	return nil
}

// ReadynessCheckRequestMultiError is an error wrapping multiple validation
// errors returned by ReadynessCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type ReadynessCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadynessCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadynessCheckRequestMultiError) AllErrors() []error { return m }

// ReadynessCheckRequestValidationError is the validation error returned by
// ReadynessCheckRequest.Validate if the designated constraints aren't met.
type ReadynessCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadynessCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadynessCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadynessCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadynessCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadynessCheckRequestValidationError) ErrorName() string {
	return "ReadynessCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadynessCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadynessCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadynessCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadynessCheckRequestValidationError{}

// Validate checks the field values on ReadynessCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadynessCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadynessCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadynessCheckResponseMultiError, or nil if none found.
func (m *ReadynessCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadynessCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Healthy

	if len(errors) > 0 {
		return ReadynessCheckResponseMultiError(errors)
	}

	return nil
}

// ReadynessCheckResponseMultiError is an error wrapping multiple validation
// errors returned by ReadynessCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type ReadynessCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadynessCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadynessCheckResponseMultiError) AllErrors() []error { return m }

// ReadynessCheckResponseValidationError is the validation error returned by
// ReadynessCheckResponse.Validate if the designated constraints aren't met.
type ReadynessCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadynessCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadynessCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadynessCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadynessCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadynessCheckResponseValidationError) ErrorName() string {
	return "ReadynessCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadynessCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadynessCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadynessCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadynessCheckResponseValidationError{}

// Validate checks the field values on PlaidInitiateTokenExchangeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PlaidInitiateTokenExchangeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidInitiateTokenExchangeRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PlaidInitiateTokenExchangeRequestMultiError, or nil if none found.
func (m *PlaidInitiateTokenExchangeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidInitiateTokenExchangeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := PlaidInitiateTokenExchangeRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FullName

	// no validation rules for Email

	// no validation rules for PhoneNumber

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return PlaidInitiateTokenExchangeRequestMultiError(errors)
	}

	return nil
}

// PlaidInitiateTokenExchangeRequestMultiError is an error wrapping multiple
// validation errors returned by
// PlaidInitiateTokenExchangeRequest.ValidateAll() if the designated
// constraints aren't met.
type PlaidInitiateTokenExchangeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidInitiateTokenExchangeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidInitiateTokenExchangeRequestMultiError) AllErrors() []error { return m }

// PlaidInitiateTokenExchangeRequestValidationError is the validation error
// returned by PlaidInitiateTokenExchangeRequest.Validate if the designated
// constraints aren't met.
type PlaidInitiateTokenExchangeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidInitiateTokenExchangeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidInitiateTokenExchangeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidInitiateTokenExchangeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidInitiateTokenExchangeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidInitiateTokenExchangeRequestValidationError) ErrorName() string {
	return "PlaidInitiateTokenExchangeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidInitiateTokenExchangeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidInitiateTokenExchangeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidInitiateTokenExchangeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidInitiateTokenExchangeRequestValidationError{}

// Validate checks the field values on PlaidInitiateTokenExchangeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PlaidInitiateTokenExchangeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidInitiateTokenExchangeResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PlaidInitiateTokenExchangeResponseMultiError, or nil if none found.
func (m *PlaidInitiateTokenExchangeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidInitiateTokenExchangeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LinkToken

	// no validation rules for Expiration

	// no validation rules for PlaidRequestId

	if len(errors) > 0 {
		return PlaidInitiateTokenExchangeResponseMultiError(errors)
	}

	return nil
}

// PlaidInitiateTokenExchangeResponseMultiError is an error wrapping multiple
// validation errors returned by
// PlaidInitiateTokenExchangeResponse.ValidateAll() if the designated
// constraints aren't met.
type PlaidInitiateTokenExchangeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidInitiateTokenExchangeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidInitiateTokenExchangeResponseMultiError) AllErrors() []error { return m }

// PlaidInitiateTokenExchangeResponseValidationError is the validation error
// returned by PlaidInitiateTokenExchangeResponse.Validate if the designated
// constraints aren't met.
type PlaidInitiateTokenExchangeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidInitiateTokenExchangeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidInitiateTokenExchangeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidInitiateTokenExchangeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidInitiateTokenExchangeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidInitiateTokenExchangeResponseValidationError) ErrorName() string {
	return "PlaidInitiateTokenExchangeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidInitiateTokenExchangeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidInitiateTokenExchangeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidInitiateTokenExchangeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidInitiateTokenExchangeResponseValidationError{}

// Validate checks the field values on PlaidInitiateTokenUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlaidInitiateTokenUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidInitiateTokenUpdateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PlaidInitiateTokenUpdateRequestMultiError, or nil if none found.
func (m *PlaidInitiateTokenUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidInitiateTokenUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := PlaidInitiateTokenUpdateRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := PlaidInitiateTokenUpdateRequestValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return PlaidInitiateTokenUpdateRequestMultiError(errors)
	}

	return nil
}

// PlaidInitiateTokenUpdateRequestMultiError is an error wrapping multiple
// validation errors returned by PlaidInitiateTokenUpdateRequest.ValidateAll()
// if the designated constraints aren't met.
type PlaidInitiateTokenUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidInitiateTokenUpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidInitiateTokenUpdateRequestMultiError) AllErrors() []error { return m }

// PlaidInitiateTokenUpdateRequestValidationError is the validation error
// returned by PlaidInitiateTokenUpdateRequest.Validate if the designated
// constraints aren't met.
type PlaidInitiateTokenUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidInitiateTokenUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidInitiateTokenUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidInitiateTokenUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidInitiateTokenUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidInitiateTokenUpdateRequestValidationError) ErrorName() string {
	return "PlaidInitiateTokenUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidInitiateTokenUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidInitiateTokenUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidInitiateTokenUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidInitiateTokenUpdateRequestValidationError{}

// Validate checks the field values on PlaidInitiateTokenUpdateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PlaidInitiateTokenUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidInitiateTokenUpdateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PlaidInitiateTokenUpdateResponseMultiError, or nil if none found.
func (m *PlaidInitiateTokenUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidInitiateTokenUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LinkToken

	// no validation rules for Expiration

	if len(errors) > 0 {
		return PlaidInitiateTokenUpdateResponseMultiError(errors)
	}

	return nil
}

// PlaidInitiateTokenUpdateResponseMultiError is an error wrapping multiple
// validation errors returned by
// PlaidInitiateTokenUpdateResponse.ValidateAll() if the designated
// constraints aren't met.
type PlaidInitiateTokenUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidInitiateTokenUpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidInitiateTokenUpdateResponseMultiError) AllErrors() []error { return m }

// PlaidInitiateTokenUpdateResponseValidationError is the validation error
// returned by PlaidInitiateTokenUpdateResponse.Validate if the designated
// constraints aren't met.
type PlaidInitiateTokenUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidInitiateTokenUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidInitiateTokenUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidInitiateTokenUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidInitiateTokenUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidInitiateTokenUpdateResponseValidationError) ErrorName() string {
	return "PlaidInitiateTokenUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidInitiateTokenUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidInitiateTokenUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidInitiateTokenUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidInitiateTokenUpdateResponseValidationError{}

// Validate checks the field values on PlaidExchangeTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlaidExchangeTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidExchangeTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlaidExchangeTokenRequestMultiError, or nil if none found.
func (m *PlaidExchangeTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidExchangeTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := PlaidExchangeTokenRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPublicToken()) < 1 {
		err := PlaidExchangeTokenRequestValidationError{
			field:  "PublicToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for InstitutionId

	// no validation rules for InstitutionName

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return PlaidExchangeTokenRequestMultiError(errors)
	}

	return nil
}

// PlaidExchangeTokenRequestMultiError is an error wrapping multiple validation
// errors returned by PlaidExchangeTokenRequest.ValidateAll() if the
// designated constraints aren't met.
type PlaidExchangeTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidExchangeTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidExchangeTokenRequestMultiError) AllErrors() []error { return m }

// PlaidExchangeTokenRequestValidationError is the validation error returned by
// PlaidExchangeTokenRequest.Validate if the designated constraints aren't met.
type PlaidExchangeTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidExchangeTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidExchangeTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidExchangeTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidExchangeTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidExchangeTokenRequestValidationError) ErrorName() string {
	return "PlaidExchangeTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidExchangeTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidExchangeTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidExchangeTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidExchangeTokenRequestValidationError{}

// Validate checks the field values on PlaidExchangeTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PlaidExchangeTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlaidExchangeTokenResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PlaidExchangeTokenResponseMultiError, or nil if none found.
func (m *PlaidExchangeTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PlaidExchangeTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for TaskId

	if len(errors) > 0 {
		return PlaidExchangeTokenResponseMultiError(errors)
	}

	return nil
}

// PlaidExchangeTokenResponseMultiError is an error wrapping multiple
// validation errors returned by PlaidExchangeTokenResponse.ValidateAll() if
// the designated constraints aren't met.
type PlaidExchangeTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlaidExchangeTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlaidExchangeTokenResponseMultiError) AllErrors() []error { return m }

// PlaidExchangeTokenResponseValidationError is the validation error returned
// by PlaidExchangeTokenResponse.Validate if the designated constraints aren't met.
type PlaidExchangeTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlaidExchangeTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlaidExchangeTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlaidExchangeTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlaidExchangeTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlaidExchangeTokenResponseValidationError) ErrorName() string {
	return "PlaidExchangeTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PlaidExchangeTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlaidExchangeTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlaidExchangeTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlaidExchangeTokenResponseValidationError{}

// Validate checks the field values on GetInvestmentAcccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvestmentAcccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvestmentAcccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvestmentAcccountRequestMultiError, or nil if none found.
func (m *GetInvestmentAcccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvestmentAcccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetInvestmentAcccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetInvestmentAccountId() <= 0 {
		err := GetInvestmentAcccountRequestValidationError{
			field:  "InvestmentAccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetInvestmentAcccountRequestMultiError(errors)
	}

	return nil
}

// GetInvestmentAcccountRequestMultiError is an error wrapping multiple
// validation errors returned by GetInvestmentAcccountRequest.ValidateAll() if
// the designated constraints aren't met.
type GetInvestmentAcccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvestmentAcccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvestmentAcccountRequestMultiError) AllErrors() []error { return m }

// GetInvestmentAcccountRequestValidationError is the validation error returned
// by GetInvestmentAcccountRequest.Validate if the designated constraints
// aren't met.
type GetInvestmentAcccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvestmentAcccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvestmentAcccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvestmentAcccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvestmentAcccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvestmentAcccountRequestValidationError) ErrorName() string {
	return "GetInvestmentAcccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvestmentAcccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvestmentAcccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvestmentAcccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvestmentAcccountRequestValidationError{}

// Validate checks the field values on GetInvestmentAcccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvestmentAcccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvestmentAcccountResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetInvestmentAcccountResponseMultiError, or nil if none found.
func (m *GetInvestmentAcccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvestmentAcccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvestmentAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvestmentAcccountResponseValidationError{
					field:  "InvestmentAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvestmentAcccountResponseValidationError{
					field:  "InvestmentAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvestmentAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvestmentAcccountResponseValidationError{
				field:  "InvestmentAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvestmentAcccountResponseMultiError(errors)
	}

	return nil
}

// GetInvestmentAcccountResponseMultiError is an error wrapping multiple
// validation errors returned by GetInvestmentAcccountResponse.ValidateAll()
// if the designated constraints aren't met.
type GetInvestmentAcccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvestmentAcccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvestmentAcccountResponseMultiError) AllErrors() []error { return m }

// GetInvestmentAcccountResponseValidationError is the validation error
// returned by GetInvestmentAcccountResponse.Validate if the designated
// constraints aren't met.
type GetInvestmentAcccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvestmentAcccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvestmentAcccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvestmentAcccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvestmentAcccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvestmentAcccountResponseValidationError) ErrorName() string {
	return "GetInvestmentAcccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvestmentAcccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvestmentAcccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvestmentAcccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvestmentAcccountResponseValidationError{}

// Validate checks the field values on GetMortgageAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMortgageAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMortgageAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMortgageAccountRequestMultiError, or nil if none found.
func (m *GetMortgageAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMortgageAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetMortgageAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetMortgageAccountId() <= 0 {
		err := GetMortgageAccountRequestValidationError{
			field:  "MortgageAccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetMortgageAccountRequestMultiError(errors)
	}

	return nil
}

// GetMortgageAccountRequestMultiError is an error wrapping multiple validation
// errors returned by GetMortgageAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type GetMortgageAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMortgageAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMortgageAccountRequestMultiError) AllErrors() []error { return m }

// GetMortgageAccountRequestValidationError is the validation error returned by
// GetMortgageAccountRequest.Validate if the designated constraints aren't met.
type GetMortgageAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMortgageAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMortgageAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMortgageAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMortgageAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMortgageAccountRequestValidationError) ErrorName() string {
	return "GetMortgageAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMortgageAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMortgageAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMortgageAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMortgageAccountRequestValidationError{}

// Validate checks the field values on GetMortgageAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMortgageAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMortgageAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMortgageAccountResponseMultiError, or nil if none found.
func (m *GetMortgageAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMortgageAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMortageAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMortgageAccountResponseValidationError{
					field:  "MortageAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMortgageAccountResponseValidationError{
					field:  "MortageAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMortageAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMortgageAccountResponseValidationError{
				field:  "MortageAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMortgageAccountResponseMultiError(errors)
	}

	return nil
}

// GetMortgageAccountResponseMultiError is an error wrapping multiple
// validation errors returned by GetMortgageAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type GetMortgageAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMortgageAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMortgageAccountResponseMultiError) AllErrors() []error { return m }

// GetMortgageAccountResponseValidationError is the validation error returned
// by GetMortgageAccountResponse.Validate if the designated constraints aren't met.
type GetMortgageAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMortgageAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMortgageAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMortgageAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMortgageAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMortgageAccountResponseValidationError) ErrorName() string {
	return "GetMortgageAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMortgageAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMortgageAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMortgageAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMortgageAccountResponseValidationError{}

// Validate checks the field values on GetLiabilityAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLiabilityAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLiabilityAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLiabilityAccountRequestMultiError, or nil if none found.
func (m *GetLiabilityAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLiabilityAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetLiabilityAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLiabilityAccountId() <= 0 {
		err := GetLiabilityAccountRequestValidationError{
			field:  "LiabilityAccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetLiabilityAccountRequestMultiError(errors)
	}

	return nil
}

// GetLiabilityAccountRequestMultiError is an error wrapping multiple
// validation errors returned by GetLiabilityAccountRequest.ValidateAll() if
// the designated constraints aren't met.
type GetLiabilityAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLiabilityAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLiabilityAccountRequestMultiError) AllErrors() []error { return m }

// GetLiabilityAccountRequestValidationError is the validation error returned
// by GetLiabilityAccountRequest.Validate if the designated constraints aren't met.
type GetLiabilityAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLiabilityAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLiabilityAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLiabilityAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLiabilityAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLiabilityAccountRequestValidationError) ErrorName() string {
	return "GetLiabilityAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLiabilityAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLiabilityAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLiabilityAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLiabilityAccountRequestValidationError{}

// Validate checks the field values on GetLiabilityAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLiabilityAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLiabilityAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLiabilityAccountResponseMultiError, or nil if none found.
func (m *GetLiabilityAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLiabilityAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLiabilityAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLiabilityAccountResponseValidationError{
					field:  "LiabilityAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLiabilityAccountResponseValidationError{
					field:  "LiabilityAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLiabilityAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLiabilityAccountResponseValidationError{
				field:  "LiabilityAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLiabilityAccountResponseMultiError(errors)
	}

	return nil
}

// GetLiabilityAccountResponseMultiError is an error wrapping multiple
// validation errors returned by GetLiabilityAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type GetLiabilityAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLiabilityAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLiabilityAccountResponseMultiError) AllErrors() []error { return m }

// GetLiabilityAccountResponseValidationError is the validation error returned
// by GetLiabilityAccountResponse.Validate if the designated constraints
// aren't met.
type GetLiabilityAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLiabilityAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLiabilityAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLiabilityAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLiabilityAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLiabilityAccountResponseValidationError) ErrorName() string {
	return "GetLiabilityAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLiabilityAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLiabilityAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLiabilityAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLiabilityAccountResponseValidationError{}

// Validate checks the field values on GetStudentLoanAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStudentLoanAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStudentLoanAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStudentLoanAccountRequestMultiError, or nil if none found.
func (m *GetStudentLoanAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStudentLoanAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetStudentLoanAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetStudentLoanAccountId() <= 0 {
		err := GetStudentLoanAccountRequestValidationError{
			field:  "StudentLoanAccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetStudentLoanAccountRequestMultiError(errors)
	}

	return nil
}

// GetStudentLoanAccountRequestMultiError is an error wrapping multiple
// validation errors returned by GetStudentLoanAccountRequest.ValidateAll() if
// the designated constraints aren't met.
type GetStudentLoanAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStudentLoanAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStudentLoanAccountRequestMultiError) AllErrors() []error { return m }

// GetStudentLoanAccountRequestValidationError is the validation error returned
// by GetStudentLoanAccountRequest.Validate if the designated constraints
// aren't met.
type GetStudentLoanAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStudentLoanAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStudentLoanAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStudentLoanAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStudentLoanAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStudentLoanAccountRequestValidationError) ErrorName() string {
	return "GetStudentLoanAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetStudentLoanAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStudentLoanAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStudentLoanAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStudentLoanAccountRequestValidationError{}

// Validate checks the field values on GetStudentLoanAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetStudentLoanAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStudentLoanAccountResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetStudentLoanAccountResponseMultiError, or nil if none found.
func (m *GetStudentLoanAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStudentLoanAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStudentLoanAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetStudentLoanAccountResponseValidationError{
					field:  "StudentLoanAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetStudentLoanAccountResponseValidationError{
					field:  "StudentLoanAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStudentLoanAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetStudentLoanAccountResponseValidationError{
				field:  "StudentLoanAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetStudentLoanAccountResponseMultiError(errors)
	}

	return nil
}

// GetStudentLoanAccountResponseMultiError is an error wrapping multiple
// validation errors returned by GetStudentLoanAccountResponse.ValidateAll()
// if the designated constraints aren't met.
type GetStudentLoanAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStudentLoanAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStudentLoanAccountResponseMultiError) AllErrors() []error { return m }

// GetStudentLoanAccountResponseValidationError is the validation error
// returned by GetStudentLoanAccountResponse.Validate if the designated
// constraints aren't met.
type GetStudentLoanAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStudentLoanAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStudentLoanAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStudentLoanAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStudentLoanAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStudentLoanAccountResponseValidationError) ErrorName() string {
	return "GetStudentLoanAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetStudentLoanAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStudentLoanAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStudentLoanAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStudentLoanAccountResponseValidationError{}

// Validate checks the field values on CreateManualLinkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateManualLinkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateManualLinkRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateManualLinkRequestMultiError, or nil if none found.
func (m *CreateManualLinkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateManualLinkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CreateManualLinkRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetManualAccountLink() == nil {
		err := CreateManualLinkRequestValidationError{
			field:  "ManualAccountLink",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetManualAccountLink()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateManualLinkRequestValidationError{
					field:  "ManualAccountLink",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateManualLinkRequestValidationError{
					field:  "ManualAccountLink",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManualAccountLink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateManualLinkRequestValidationError{
				field:  "ManualAccountLink",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return CreateManualLinkRequestMultiError(errors)
	}

	return nil
}

// CreateManualLinkRequestMultiError is an error wrapping multiple validation
// errors returned by CreateManualLinkRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateManualLinkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateManualLinkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateManualLinkRequestMultiError) AllErrors() []error { return m }

// CreateManualLinkRequestValidationError is the validation error returned by
// CreateManualLinkRequest.Validate if the designated constraints aren't met.
type CreateManualLinkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateManualLinkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateManualLinkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateManualLinkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateManualLinkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateManualLinkRequestValidationError) ErrorName() string {
	return "CreateManualLinkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateManualLinkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateManualLinkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateManualLinkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateManualLinkRequestValidationError{}

// Validate checks the field values on CreateManualLinkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateManualLinkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateManualLinkResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateManualLinkResponseMultiError, or nil if none found.
func (m *CreateManualLinkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateManualLinkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LinkId

	if len(errors) > 0 {
		return CreateManualLinkResponseMultiError(errors)
	}

	return nil
}

// CreateManualLinkResponseMultiError is an error wrapping multiple validation
// errors returned by CreateManualLinkResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateManualLinkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateManualLinkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateManualLinkResponseMultiError) AllErrors() []error { return m }

// CreateManualLinkResponseValidationError is the validation error returned by
// CreateManualLinkResponse.Validate if the designated constraints aren't met.
type CreateManualLinkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateManualLinkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateManualLinkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateManualLinkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateManualLinkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateManualLinkResponseValidationError) ErrorName() string {
	return "CreateManualLinkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateManualLinkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateManualLinkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateManualLinkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateManualLinkResponseValidationError{}

// Validate checks the field values on GetLinkRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLinkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLinkRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLinkRequestMultiError,
// or nil if none found.
func (m *GetLinkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLinkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetLinkRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := GetLinkRequestValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetLinkRequestMultiError(errors)
	}

	return nil
}

// GetLinkRequestMultiError is an error wrapping multiple validation errors
// returned by GetLinkRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLinkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLinkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLinkRequestMultiError) AllErrors() []error { return m }

// GetLinkRequestValidationError is the validation error returned by
// GetLinkRequest.Validate if the designated constraints aren't met.
type GetLinkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLinkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLinkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLinkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLinkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLinkRequestValidationError) ErrorName() string { return "GetLinkRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLinkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLinkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLinkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLinkRequestValidationError{}

// Validate checks the field values on GetLinkResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLinkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLinkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLinkResponseMultiError, or nil if none found.
func (m *GetLinkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLinkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLink()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLinkResponseValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLinkResponseValidationError{
					field:  "Link",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLink()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLinkResponseValidationError{
				field:  "Link",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLinkResponseMultiError(errors)
	}

	return nil
}

// GetLinkResponseMultiError is an error wrapping multiple validation errors
// returned by GetLinkResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLinkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLinkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLinkResponseMultiError) AllErrors() []error { return m }

// GetLinkResponseValidationError is the validation error returned by
// GetLinkResponse.Validate if the designated constraints aren't met.
type GetLinkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLinkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLinkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLinkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLinkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLinkResponseValidationError) ErrorName() string { return "GetLinkResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetLinkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLinkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLinkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLinkResponseValidationError{}

// Validate checks the field values on GetLinksRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLinksRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLinksRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLinksRequestMultiError, or nil if none found.
func (m *GetLinksRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLinksRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetLinksRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetLinksRequestMultiError(errors)
	}

	return nil
}

// GetLinksRequestMultiError is an error wrapping multiple validation errors
// returned by GetLinksRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLinksRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLinksRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLinksRequestMultiError) AllErrors() []error { return m }

// GetLinksRequestValidationError is the validation error returned by
// GetLinksRequest.Validate if the designated constraints aren't met.
type GetLinksRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLinksRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLinksRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLinksRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLinksRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLinksRequestValidationError) ErrorName() string { return "GetLinksRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLinksRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLinksRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLinksRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLinksRequestValidationError{}

// Validate checks the field values on GetLinksResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLinksResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLinksResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLinksResponseMultiError, or nil if none found.
func (m *GetLinksResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLinksResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLinksResponseValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLinksResponseValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLinksResponseValidationError{
					field:  fmt.Sprintf("Links[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetLinksResponseMultiError(errors)
	}

	return nil
}

// GetLinksResponseMultiError is an error wrapping multiple validation errors
// returned by GetLinksResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLinksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLinksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLinksResponseMultiError) AllErrors() []error { return m }

// GetLinksResponseValidationError is the validation error returned by
// GetLinksResponse.Validate if the designated constraints aren't met.
type GetLinksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLinksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLinksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLinksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLinksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLinksResponseValidationError) ErrorName() string { return "GetLinksResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetLinksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLinksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLinksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLinksResponseValidationError{}

// Validate checks the field values on DeleteLinkRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteLinkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLinkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLinkRequestMultiError, or nil if none found.
func (m *DeleteLinkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLinkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := DeleteLinkRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLinkId() <= 0 {
		err := DeleteLinkRequestValidationError{
			field:  "LinkId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return DeleteLinkRequestMultiError(errors)
	}

	return nil
}

// DeleteLinkRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteLinkRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteLinkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLinkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLinkRequestMultiError) AllErrors() []error { return m }

// DeleteLinkRequestValidationError is the validation error returned by
// DeleteLinkRequest.Validate if the designated constraints aren't met.
type DeleteLinkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLinkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLinkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLinkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLinkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLinkRequestValidationError) ErrorName() string {
	return "DeleteLinkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLinkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLinkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLinkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLinkRequestValidationError{}

// Validate checks the field values on DeleteLinkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLinkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLinkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLinkResponseMultiError, or nil if none found.
func (m *DeleteLinkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLinkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LinkId

	if len(errors) > 0 {
		return DeleteLinkResponseMultiError(errors)
	}

	return nil
}

// DeleteLinkResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteLinkResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteLinkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLinkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLinkResponseMultiError) AllErrors() []error { return m }

// DeleteLinkResponseValidationError is the validation error returned by
// DeleteLinkResponse.Validate if the designated constraints aren't met.
type DeleteLinkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLinkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLinkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLinkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLinkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLinkResponseValidationError) ErrorName() string {
	return "DeleteLinkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLinkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLinkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLinkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLinkResponseValidationError{}

// Validate checks the field values on GetReCurringTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReCurringTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReCurringTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReCurringTransactionsRequestMultiError, or nil if none found.
func (m *GetReCurringTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReCurringTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetReCurringTransactionsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetReCurringTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetReCurringTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by GetReCurringTransactionsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetReCurringTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReCurringTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReCurringTransactionsRequestMultiError) AllErrors() []error { return m }

// GetReCurringTransactionsRequestValidationError is the validation error
// returned by GetReCurringTransactionsRequest.Validate if the designated
// constraints aren't met.
type GetReCurringTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReCurringTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReCurringTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReCurringTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReCurringTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReCurringTransactionsRequestValidationError) ErrorName() string {
	return "GetReCurringTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReCurringTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReCurringTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReCurringTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReCurringTransactionsRequestValidationError{}

// Validate checks the field values on GetReCurringTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetReCurringTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReCurringTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReCurringTransactionsResponseMultiError, or nil if none found.
func (m *GetReCurringTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReCurringTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReCcuringTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReCurringTransactionsResponseValidationError{
						field:  fmt.Sprintf("ReCcuringTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReCurringTransactionsResponseValidationError{
						field:  fmt.Sprintf("ReCcuringTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReCurringTransactionsResponseValidationError{
					field:  fmt.Sprintf("ReCcuringTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetReCurringTransactionsResponseMultiError(errors)
	}

	return nil
}

// GetReCurringTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetReCurringTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetReCurringTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReCurringTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReCurringTransactionsResponseMultiError) AllErrors() []error { return m }

// GetReCurringTransactionsResponseValidationError is the validation error
// returned by GetReCurringTransactionsResponse.Validate if the designated
// constraints aren't met.
type GetReCurringTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReCurringTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReCurringTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReCurringTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReCurringTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReCurringTransactionsResponseValidationError) ErrorName() string {
	return "GetReCurringTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReCurringTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReCurringTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReCurringTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReCurringTransactionsResponseValidationError{}

// Validate checks the field values on GetTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionsRequestMultiError, or nil if none found.
func (m *GetTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetTransactionsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsRequestMultiError) AllErrors() []error { return m }

// GetTransactionsRequestValidationError is the validation error returned by
// GetTransactionsRequest.Validate if the designated constraints aren't met.
type GetTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsRequestValidationError) ErrorName() string {
	return "GetTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsRequestValidationError{}

// Validate checks the field values on GetTransactionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionsResponseMultiError, or nil if none found.
func (m *GetTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageNumber

	if len(errors) > 0 {
		return GetTransactionsResponseMultiError(errors)
	}

	return nil
}

// GetTransactionsResponseMultiError is an error wrapping multiple validation
// errors returned by GetTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsResponseMultiError) AllErrors() []error { return m }

// GetTransactionsResponseValidationError is the validation error returned by
// GetTransactionsResponse.Validate if the designated constraints aren't met.
type GetTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsResponseValidationError) ErrorName() string {
	return "GetTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsResponseValidationError{}

// Validate checks the field values on CreateSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubscriptionRequestMultiError, or nil if none found.
func (m *CreateSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CreateSubscriptionRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPriceId()) < 1 {
		err := CreateSubscriptionRequestValidationError{
			field:  "PriceId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return CreateSubscriptionRequestMultiError(errors)
	}

	return nil
}

// CreateSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubscriptionRequestMultiError) AllErrors() []error { return m }

// CreateSubscriptionRequestValidationError is the validation error returned by
// CreateSubscriptionRequest.Validate if the designated constraints aren't met.
type CreateSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubscriptionRequestValidationError) ErrorName() string {
	return "CreateSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubscriptionRequestValidationError{}

// Validate checks the field values on CreateSubscriptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubscriptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubscriptionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubscriptionResponseMultiError, or nil if none found.
func (m *CreateSubscriptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubscriptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionId

	// no validation rules for PaymentIntentClientSecret

	if len(errors) > 0 {
		return CreateSubscriptionResponseMultiError(errors)
	}

	return nil
}

// CreateSubscriptionResponseMultiError is an error wrapping multiple
// validation errors returned by CreateSubscriptionResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateSubscriptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubscriptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubscriptionResponseMultiError) AllErrors() []error { return m }

// CreateSubscriptionResponseValidationError is the validation error returned
// by CreateSubscriptionResponse.Validate if the designated constraints aren't met.
type CreateSubscriptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubscriptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubscriptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubscriptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubscriptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubscriptionResponseValidationError) ErrorName() string {
	return "CreateSubscriptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubscriptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubscriptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubscriptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubscriptionResponseValidationError{}

// Validate checks the field values on GetTransactionsForBankAccountRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTransactionsForBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsForBankAccountRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTransactionsForBankAccountRequestMultiError, or nil if none found.
func (m *GetTransactionsForBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsForBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetTransactionsForBankAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPlaidAccountId()) < 1 {
		err := GetTransactionsForBankAccountRequestValidationError{
			field:  "PlaidAccountId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetTransactionsForBankAccountRequestMultiError(errors)
	}

	return nil
}

// GetTransactionsForBankAccountRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetTransactionsForBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsForBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsForBankAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsForBankAccountRequestMultiError) AllErrors() []error { return m }

// GetTransactionsForBankAccountRequestValidationError is the validation error
// returned by GetTransactionsForBankAccountRequest.Validate if the designated
// constraints aren't met.
type GetTransactionsForBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsForBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsForBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsForBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsForBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsForBankAccountRequestValidationError) ErrorName() string {
	return "GetTransactionsForBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsForBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsForBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsForBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsForBankAccountRequestValidationError{}

// Validate checks the field values on GetTransactionsForBankAccountResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTransactionsForBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsForBankAccountResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTransactionsForBankAccountResponseMultiError, or nil if none found.
func (m *GetTransactionsForBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsForBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsForBankAccountResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsForBankAccountResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsForBankAccountResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageNumber

	if len(errors) > 0 {
		return GetTransactionsForBankAccountResponseMultiError(errors)
	}

	return nil
}

// GetTransactionsForBankAccountResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetTransactionsForBankAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsForBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsForBankAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsForBankAccountResponseMultiError) AllErrors() []error { return m }

// GetTransactionsForBankAccountResponseValidationError is the validation error
// returned by GetTransactionsForBankAccountResponse.Validate if the
// designated constraints aren't met.
type GetTransactionsForBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsForBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsForBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsForBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsForBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsForBankAccountResponseValidationError) ErrorName() string {
	return "GetTransactionsForBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsForBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsForBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsForBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsForBankAccountResponseValidationError{}

// Validate checks the field values on AddDefaultPocketsToBankAccountRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AddDefaultPocketsToBankAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddDefaultPocketsToBankAccountRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// AddDefaultPocketsToBankAccountRequestMultiError, or nil if none found.
func (m *AddDefaultPocketsToBankAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddDefaultPocketsToBankAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := AddDefaultPocketsToBankAccountRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PlaidAccountId

	// no validation rules for ProfileType

	if _, ok := _AddDefaultPocketsToBankAccountRequest_FinancialAccountType_NotInLookup[m.GetFinancialAccountType()]; ok {
		err := AddDefaultPocketsToBankAccountRequestValidationError{
			field:  "FinancialAccountType",
			reason: "value must not be in list [FINANCIAL_ACCOUNT_TYPE_UNSPECIFIED FINANCIAL_ACCOUNT_TYPE_INVESTMENT FINANCIAL_ACCOUNT_TYPE_MORTGAGE FINANCIAL_ACCOUNT_TYPE_STUDENT_LOAN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddDefaultPocketsToBankAccountRequestMultiError(errors)
	}

	return nil
}

// AddDefaultPocketsToBankAccountRequestMultiError is an error wrapping
// multiple validation errors returned by
// AddDefaultPocketsToBankAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type AddDefaultPocketsToBankAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddDefaultPocketsToBankAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddDefaultPocketsToBankAccountRequestMultiError) AllErrors() []error { return m }

// AddDefaultPocketsToBankAccountRequestValidationError is the validation error
// returned by AddDefaultPocketsToBankAccountRequest.Validate if the
// designated constraints aren't met.
type AddDefaultPocketsToBankAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddDefaultPocketsToBankAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddDefaultPocketsToBankAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddDefaultPocketsToBankAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddDefaultPocketsToBankAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddDefaultPocketsToBankAccountRequestValidationError) ErrorName() string {
	return "AddDefaultPocketsToBankAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddDefaultPocketsToBankAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddDefaultPocketsToBankAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddDefaultPocketsToBankAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddDefaultPocketsToBankAccountRequestValidationError{}

var _AddDefaultPocketsToBankAccountRequest_FinancialAccountType_NotInLookup = map[FinancialAccountType]struct{}{
	0: {},
	2: {},
	4: {},
	5: {},
}

// Validate checks the field values on AddDefaultPocketsToBankAccountResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AddDefaultPocketsToBankAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AddDefaultPocketsToBankAccountResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// AddDefaultPocketsToBankAccountResponseMultiError, or nil if none found.
func (m *AddDefaultPocketsToBankAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddDefaultPocketsToBankAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Account.(type) {
	case *AddDefaultPocketsToBankAccountResponse_BankAccount:
		if v == nil {
			err := AddDefaultPocketsToBankAccountResponseValidationError{
				field:  "Account",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBankAccount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddDefaultPocketsToBankAccountResponseValidationError{
						field:  "BankAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddDefaultPocketsToBankAccountResponseValidationError{
						field:  "BankAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBankAccount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddDefaultPocketsToBankAccountResponseValidationError{
					field:  "BankAccount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AddDefaultPocketsToBankAccountResponse_CreditAccount:
		if v == nil {
			err := AddDefaultPocketsToBankAccountResponseValidationError{
				field:  "Account",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCreditAccount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddDefaultPocketsToBankAccountResponseValidationError{
						field:  "CreditAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddDefaultPocketsToBankAccountResponseValidationError{
						field:  "CreditAccount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreditAccount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddDefaultPocketsToBankAccountResponseValidationError{
					field:  "CreditAccount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AddDefaultPocketsToBankAccountResponseMultiError(errors)
	}

	return nil
}

// AddDefaultPocketsToBankAccountResponseMultiError is an error wrapping
// multiple validation errors returned by
// AddDefaultPocketsToBankAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type AddDefaultPocketsToBankAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddDefaultPocketsToBankAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddDefaultPocketsToBankAccountResponseMultiError) AllErrors() []error { return m }

// AddDefaultPocketsToBankAccountResponseValidationError is the validation
// error returned by AddDefaultPocketsToBankAccountResponse.Validate if the
// designated constraints aren't met.
type AddDefaultPocketsToBankAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddDefaultPocketsToBankAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddDefaultPocketsToBankAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddDefaultPocketsToBankAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddDefaultPocketsToBankAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddDefaultPocketsToBankAccountResponseValidationError) ErrorName() string {
	return "AddDefaultPocketsToBankAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddDefaultPocketsToBankAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddDefaultPocketsToBankAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddDefaultPocketsToBankAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddDefaultPocketsToBankAccountResponseValidationError{}

// Validate checks the field values on DeletePocketRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePocketRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePocketRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePocketRequestMultiError, or nil if none found.
func (m *DeletePocketRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePocketRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPocketId() <= 0 {
		err := DeletePocketRequestValidationError{
			field:  "PocketId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePocketRequestMultiError(errors)
	}

	return nil
}

// DeletePocketRequestMultiError is an error wrapping multiple validation
// errors returned by DeletePocketRequest.ValidateAll() if the designated
// constraints aren't met.
type DeletePocketRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePocketRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePocketRequestMultiError) AllErrors() []error { return m }

// DeletePocketRequestValidationError is the validation error returned by
// DeletePocketRequest.Validate if the designated constraints aren't met.
type DeletePocketRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePocketRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePocketRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePocketRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePocketRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePocketRequestValidationError) ErrorName() string {
	return "DeletePocketRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePocketRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePocketRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePocketRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePocketRequestValidationError{}

// Validate checks the field values on DeletePocketResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePocketResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePocketResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePocketResponseMultiError, or nil if none found.
func (m *DeletePocketResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePocketResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeletePocketResponseMultiError(errors)
	}

	return nil
}

// DeletePocketResponseMultiError is an error wrapping multiple validation
// errors returned by DeletePocketResponse.ValidateAll() if the designated
// constraints aren't met.
type DeletePocketResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePocketResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePocketResponseMultiError) AllErrors() []error { return m }

// DeletePocketResponseValidationError is the validation error returned by
// DeletePocketResponse.Validate if the designated constraints aren't met.
type DeletePocketResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePocketResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePocketResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePocketResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePocketResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePocketResponseValidationError) ErrorName() string {
	return "DeletePocketResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePocketResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePocketResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePocketResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePocketResponseValidationError{}

// Validate checks the field values on UpdatePocketRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePocketRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePocketRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePocketRequestMultiError, or nil if none found.
func (m *UpdatePocketRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePocketRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPocket() == nil {
		err := UpdatePocketRequestValidationError{
			field:  "Pocket",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPocket()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePocketRequestValidationError{
					field:  "Pocket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePocketRequestValidationError{
					field:  "Pocket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPocket()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePocketRequestValidationError{
				field:  "Pocket",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePocketRequestMultiError(errors)
	}

	return nil
}

// UpdatePocketRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePocketRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePocketRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePocketRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePocketRequestMultiError) AllErrors() []error { return m }

// UpdatePocketRequestValidationError is the validation error returned by
// UpdatePocketRequest.Validate if the designated constraints aren't met.
type UpdatePocketRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePocketRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePocketRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePocketRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePocketRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePocketRequestValidationError) ErrorName() string {
	return "UpdatePocketRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePocketRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePocketRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePocketRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePocketRequestValidationError{}

// Validate checks the field values on UpdatePocketResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePocketResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePocketResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePocketResponseMultiError, or nil if none found.
func (m *UpdatePocketResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePocketResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPocket()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdatePocketResponseValidationError{
					field:  "Pocket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdatePocketResponseValidationError{
					field:  "Pocket",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPocket()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdatePocketResponseValidationError{
				field:  "Pocket",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdatePocketResponseMultiError(errors)
	}

	return nil
}

// UpdatePocketResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePocketResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePocketResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePocketResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePocketResponseMultiError) AllErrors() []error { return m }

// UpdatePocketResponseValidationError is the validation error returned by
// UpdatePocketResponse.Validate if the designated constraints aren't met.
type UpdatePocketResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePocketResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePocketResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePocketResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePocketResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePocketResponseValidationError) ErrorName() string {
	return "UpdatePocketResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePocketResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePocketResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePocketResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePocketResponseValidationError{}

// Validate checks the field values on GetTransactionsBetweenTimeRangesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTransactionsBetweenTimeRangesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetTransactionsBetweenTimeRangesRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetTransactionsBetweenTimeRangesRequestMultiError, or nil if none found.
func (m *GetTransactionsBetweenTimeRangesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsBetweenTimeRangesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlaidAccountId()) < 1 {
		err := GetTransactionsBetweenTimeRangesRequestValidationError{
			field:  "PlaidAccountId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserId() <= 0 {
		err := GetTransactionsBetweenTimeRangesRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionsBetweenTimeRangesRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionsBetweenTimeRangesRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionsBetweenTimeRangesRequestValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionsBetweenTimeRangesRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionsBetweenTimeRangesRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionsBetweenTimeRangesRequestValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for ProfileType

	// no validation rules for FinancialAccountType

	if len(errors) > 0 {
		return GetTransactionsBetweenTimeRangesRequestMultiError(errors)
	}

	return nil
}

// GetTransactionsBetweenTimeRangesRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetTransactionsBetweenTimeRangesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsBetweenTimeRangesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsBetweenTimeRangesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsBetweenTimeRangesRequestMultiError) AllErrors() []error { return m }

// GetTransactionsBetweenTimeRangesRequestValidationError is the validation
// error returned by GetTransactionsBetweenTimeRangesRequest.Validate if the
// designated constraints aren't met.
type GetTransactionsBetweenTimeRangesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsBetweenTimeRangesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsBetweenTimeRangesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsBetweenTimeRangesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsBetweenTimeRangesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsBetweenTimeRangesRequestValidationError) ErrorName() string {
	return "GetTransactionsBetweenTimeRangesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsBetweenTimeRangesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsBetweenTimeRangesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsBetweenTimeRangesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsBetweenTimeRangesRequestValidationError{}

// Validate checks the field values on GetTransactionsBetweenTimeRangesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTransactionsBetweenTimeRangesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetTransactionsBetweenTimeRangesResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetTransactionsBetweenTimeRangesResponseMultiError, or nil if none found.
func (m *GetTransactionsBetweenTimeRangesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsBetweenTimeRangesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsBetweenTimeRangesResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsBetweenTimeRangesResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsBetweenTimeRangesResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CurrentPage

	// no validation rules for TotalAges

	// no validation rules for TotalTransactions

	if len(errors) > 0 {
		return GetTransactionsBetweenTimeRangesResponseMultiError(errors)
	}

	return nil
}

// GetTransactionsBetweenTimeRangesResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetTransactionsBetweenTimeRangesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsBetweenTimeRangesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsBetweenTimeRangesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsBetweenTimeRangesResponseMultiError) AllErrors() []error { return m }

// GetTransactionsBetweenTimeRangesResponseValidationError is the validation
// error returned by GetTransactionsBetweenTimeRangesResponse.Validate if the
// designated constraints aren't met.
type GetTransactionsBetweenTimeRangesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsBetweenTimeRangesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsBetweenTimeRangesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsBetweenTimeRangesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsBetweenTimeRangesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsBetweenTimeRangesResponseValidationError) ErrorName() string {
	return "GetTransactionsBetweenTimeRangesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsBetweenTimeRangesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsBetweenTimeRangesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsBetweenTimeRangesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsBetweenTimeRangesResponseValidationError{}

// Validate checks the field values on GetTransactionsForPastWeekRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetTransactionsForPastWeekRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsForPastWeekRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTransactionsForPastWeekRequestMultiError, or nil if none found.
func (m *GetTransactionsForPastWeekRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsForPastWeekRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlaidAccountId()) < 1 {
		err := GetTransactionsForPastWeekRequestValidationError{
			field:  "PlaidAccountId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserId() <= 0 {
		err := GetTransactionsForPastWeekRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for ProfileType

	// no validation rules for FinancialAccountType

	if len(errors) > 0 {
		return GetTransactionsForPastWeekRequestMultiError(errors)
	}

	return nil
}

// GetTransactionsForPastWeekRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetTransactionsForPastWeekRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsForPastWeekRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsForPastWeekRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsForPastWeekRequestMultiError) AllErrors() []error { return m }

// GetTransactionsForPastWeekRequestValidationError is the validation error
// returned by GetTransactionsForPastWeekRequest.Validate if the designated
// constraints aren't met.
type GetTransactionsForPastWeekRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsForPastWeekRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsForPastWeekRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsForPastWeekRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsForPastWeekRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsForPastWeekRequestValidationError) ErrorName() string {
	return "GetTransactionsForPastWeekRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsForPastWeekRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsForPastWeekRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsForPastWeekRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsForPastWeekRequestValidationError{}

// Validate checks the field values on GetTransactionsForPastWeekResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetTransactionsForPastWeekResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsForPastWeekResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTransactionsForPastWeekResponseMultiError, or nil if none found.
func (m *GetTransactionsForPastWeekResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsForPastWeekResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsForPastWeekResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsForPastWeekResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsForPastWeekResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CurrentPage

	// no validation rules for TotalPages

	// no validation rules for TotalTransactions

	if len(errors) > 0 {
		return GetTransactionsForPastWeekResponseMultiError(errors)
	}

	return nil
}

// GetTransactionsForPastWeekResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetTransactionsForPastWeekResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsForPastWeekResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsForPastWeekResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsForPastWeekResponseMultiError) AllErrors() []error { return m }

// GetTransactionsForPastWeekResponseValidationError is the validation error
// returned by GetTransactionsForPastWeekResponse.Validate if the designated
// constraints aren't met.
type GetTransactionsForPastWeekResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsForPastWeekResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsForPastWeekResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsForPastWeekResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsForPastWeekResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsForPastWeekResponseValidationError) ErrorName() string {
	return "GetTransactionsForPastWeekResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsForPastWeekResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsForPastWeekResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsForPastWeekResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsForPastWeekResponseValidationError{}

// Validate checks the field values on GetTransactionsForPastMonthRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetTransactionsForPastMonthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsForPastMonthRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTransactionsForPastMonthRequestMultiError, or nil if none found.
func (m *GetTransactionsForPastMonthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsForPastMonthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlaidAccountId()) < 1 {
		err := GetTransactionsForPastMonthRequestValidationError{
			field:  "PlaidAccountId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserId() <= 0 {
		err := GetTransactionsForPastMonthRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Page

	// no validation rules for Limit

	// no validation rules for ProfileType

	// no validation rules for FinancialAccountType

	if len(errors) > 0 {
		return GetTransactionsForPastMonthRequestMultiError(errors)
	}

	return nil
}

// GetTransactionsForPastMonthRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetTransactionsForPastMonthRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsForPastMonthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsForPastMonthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsForPastMonthRequestMultiError) AllErrors() []error { return m }

// GetTransactionsForPastMonthRequestValidationError is the validation error
// returned by GetTransactionsForPastMonthRequest.Validate if the designated
// constraints aren't met.
type GetTransactionsForPastMonthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsForPastMonthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsForPastMonthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsForPastMonthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsForPastMonthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsForPastMonthRequestValidationError) ErrorName() string {
	return "GetTransactionsForPastMonthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsForPastMonthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsForPastMonthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsForPastMonthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsForPastMonthRequestValidationError{}

// Validate checks the field values on GetTransactionsForPastMonthResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetTransactionsForPastMonthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionsForPastMonthResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTransactionsForPastMonthResponseMultiError, or nil if none found.
func (m *GetTransactionsForPastMonthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionsForPastMonthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionsForPastMonthResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionsForPastMonthResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionsForPastMonthResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CurrentPage

	// no validation rules for TotalPages

	// no validation rules for TotalTransactions

	if len(errors) > 0 {
		return GetTransactionsForPastMonthResponseMultiError(errors)
	}

	return nil
}

// GetTransactionsForPastMonthResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetTransactionsForPastMonthResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionsForPastMonthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionsForPastMonthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionsForPastMonthResponseMultiError) AllErrors() []error { return m }

// GetTransactionsForPastMonthResponseValidationError is the validation error
// returned by GetTransactionsForPastMonthResponse.Validate if the designated
// constraints aren't met.
type GetTransactionsForPastMonthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionsForPastMonthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionsForPastMonthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionsForPastMonthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionsForPastMonthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionsForPastMonthResponseValidationError) ErrorName() string {
	return "GetTransactionsForPastMonthResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionsForPastMonthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionsForPastMonthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionsForPastMonthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionsForPastMonthResponseValidationError{}

// Validate checks the field values on AddNoteToSmartGoalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddNoteToSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNoteToSmartGoalRequestMultiError, or nil if none found.
func (m *AddNoteToSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := AddNoteToSmartGoalRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNote() == nil {
		err := AddNoteToSmartGoalRequestValidationError{
			field:  "Note",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToSmartGoalRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToSmartGoalRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToSmartGoalRequestValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToSmartGoalRequestMultiError(errors)
	}

	return nil
}

// AddNoteToSmartGoalRequestMultiError is an error wrapping multiple validation
// errors returned by AddNoteToSmartGoalRequest.ValidateAll() if the
// designated constraints aren't met.
type AddNoteToSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToSmartGoalRequestMultiError) AllErrors() []error { return m }

// AddNoteToSmartGoalRequestValidationError is the validation error returned by
// AddNoteToSmartGoalRequest.Validate if the designated constraints aren't met.
type AddNoteToSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToSmartGoalRequestValidationError) ErrorName() string {
	return "AddNoteToSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToSmartGoalRequestValidationError{}

// Validate checks the field values on AddNoteToSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddNoteToSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNoteToSmartGoalResponseMultiError, or nil if none found.
func (m *AddNoteToSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGoal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToSmartGoalResponseValidationError{
					field:  "Goal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToSmartGoalResponseValidationError{
					field:  "Goal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGoal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToSmartGoalResponseValidationError{
				field:  "Goal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToSmartGoalResponseMultiError(errors)
	}

	return nil
}

// AddNoteToSmartGoalResponseMultiError is an error wrapping multiple
// validation errors returned by AddNoteToSmartGoalResponse.ValidateAll() if
// the designated constraints aren't met.
type AddNoteToSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToSmartGoalResponseMultiError) AllErrors() []error { return m }

// AddNoteToSmartGoalResponseValidationError is the validation error returned
// by AddNoteToSmartGoalResponse.Validate if the designated constraints aren't met.
type AddNoteToSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToSmartGoalResponseValidationError) ErrorName() string {
	return "AddNoteToSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToSmartGoalResponseValidationError{}

// Validate checks the field values on UpdateNoteToSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNoteToSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNoteToSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateNoteToSmartGoalRequestMultiError, or nil if none found.
func (m *UpdateNoteToSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNoteToSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNote() == nil {
		err := UpdateNoteToSmartGoalRequestValidationError{
			field:  "Note",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNoteToSmartGoalRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNoteToSmartGoalRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNoteToSmartGoalRequestValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNoteToSmartGoalRequestMultiError(errors)
	}

	return nil
}

// UpdateNoteToSmartGoalRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateNoteToSmartGoalRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateNoteToSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNoteToSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNoteToSmartGoalRequestMultiError) AllErrors() []error { return m }

// UpdateNoteToSmartGoalRequestValidationError is the validation error returned
// by UpdateNoteToSmartGoalRequest.Validate if the designated constraints
// aren't met.
type UpdateNoteToSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNoteToSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNoteToSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNoteToSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNoteToSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNoteToSmartGoalRequestValidationError) ErrorName() string {
	return "UpdateNoteToSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNoteToSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNoteToSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNoteToSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNoteToSmartGoalRequestValidationError{}

// Validate checks the field values on UpdateNoteToSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNoteToSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNoteToSmartGoalResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNoteToSmartGoalResponseMultiError, or nil if none found.
func (m *UpdateNoteToSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNoteToSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNoteToSmartGoalResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNoteToSmartGoalResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNoteToSmartGoalResponseValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNoteToSmartGoalResponseMultiError(errors)
	}

	return nil
}

// UpdateNoteToSmartGoalResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateNoteToSmartGoalResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateNoteToSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNoteToSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNoteToSmartGoalResponseMultiError) AllErrors() []error { return m }

// UpdateNoteToSmartGoalResponseValidationError is the validation error
// returned by UpdateNoteToSmartGoalResponse.Validate if the designated
// constraints aren't met.
type UpdateNoteToSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNoteToSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNoteToSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNoteToSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNoteToSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNoteToSmartGoalResponseValidationError) ErrorName() string {
	return "UpdateNoteToSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNoteToSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNoteToSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNoteToSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNoteToSmartGoalResponseValidationError{}

// Validate checks the field values on DeleteNoteFromSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNoteFromSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNoteFromSmartGoalRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNoteFromSmartGoalRequestMultiError, or nil if none found.
func (m *DeleteNoteFromSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteFromSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := DeleteNoteFromSmartGoalRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNoteId() <= 0 {
		err := DeleteNoteFromSmartGoalRequestValidationError{
			field:  "NoteId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNoteFromSmartGoalRequestMultiError(errors)
	}

	return nil
}

// DeleteNoteFromSmartGoalRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteNoteFromSmartGoalRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteNoteFromSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteFromSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteFromSmartGoalRequestMultiError) AllErrors() []error { return m }

// DeleteNoteFromSmartGoalRequestValidationError is the validation error
// returned by DeleteNoteFromSmartGoalRequest.Validate if the designated
// constraints aren't met.
type DeleteNoteFromSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteFromSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteFromSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteFromSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteFromSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteFromSmartGoalRequestValidationError) ErrorName() string {
	return "DeleteNoteFromSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteFromSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteFromSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteFromSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteFromSmartGoalRequestValidationError{}

// Validate checks the field values on DeleteNoteFromSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteNoteFromSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNoteFromSmartGoalResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNoteFromSmartGoalResponseMultiError, or nil if none found.
func (m *DeleteNoteFromSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteFromSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteNoteFromSmartGoalResponseMultiError(errors)
	}

	return nil
}

// DeleteNoteFromSmartGoalResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteNoteFromSmartGoalResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteNoteFromSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteFromSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteFromSmartGoalResponseMultiError) AllErrors() []error { return m }

// DeleteNoteFromSmartGoalResponseValidationError is the validation error
// returned by DeleteNoteFromSmartGoalResponse.Validate if the designated
// constraints aren't met.
type DeleteNoteFromSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteFromSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteFromSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteFromSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteFromSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteFromSmartGoalResponseValidationError) ErrorName() string {
	return "DeleteNoteFromSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteFromSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteFromSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteFromSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteFromSmartGoalResponseValidationError{}

// Validate checks the field values on GetNotesFromSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNotesFromSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNotesFromSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNotesFromSmartGoalRequestMultiError, or nil if none found.
func (m *GetNotesFromSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNotesFromSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSmartGoalId() <= 0 {
		err := GetNotesFromSmartGoalRequestValidationError{
			field:  "SmartGoalId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNotesFromSmartGoalRequestMultiError(errors)
	}

	return nil
}

// GetNotesFromSmartGoalRequestMultiError is an error wrapping multiple
// validation errors returned by GetNotesFromSmartGoalRequest.ValidateAll() if
// the designated constraints aren't met.
type GetNotesFromSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNotesFromSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNotesFromSmartGoalRequestMultiError) AllErrors() []error { return m }

// GetNotesFromSmartGoalRequestValidationError is the validation error returned
// by GetNotesFromSmartGoalRequest.Validate if the designated constraints
// aren't met.
type GetNotesFromSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNotesFromSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNotesFromSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNotesFromSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNotesFromSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNotesFromSmartGoalRequestValidationError) ErrorName() string {
	return "GetNotesFromSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNotesFromSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNotesFromSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNotesFromSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNotesFromSmartGoalRequestValidationError{}

// Validate checks the field values on GetNotesFromSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNotesFromSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNotesFromSmartGoalResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetNotesFromSmartGoalResponseMultiError, or nil if none found.
func (m *GetNotesFromSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNotesFromSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetNotesFromSmartGoalResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetNotesFromSmartGoalResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetNotesFromSmartGoalResponseValidationError{
					field:  fmt.Sprintf("Notes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetNotesFromSmartGoalResponseMultiError(errors)
	}

	return nil
}

// GetNotesFromSmartGoalResponseMultiError is an error wrapping multiple
// validation errors returned by GetNotesFromSmartGoalResponse.ValidateAll()
// if the designated constraints aren't met.
type GetNotesFromSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNotesFromSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNotesFromSmartGoalResponseMultiError) AllErrors() []error { return m }

// GetNotesFromSmartGoalResponseValidationError is the validation error
// returned by GetNotesFromSmartGoalResponse.Validate if the designated
// constraints aren't met.
type GetNotesFromSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNotesFromSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNotesFromSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNotesFromSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNotesFromSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNotesFromSmartGoalResponseValidationError) ErrorName() string {
	return "GetNotesFromSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNotesFromSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNotesFromSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNotesFromSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNotesFromSmartGoalResponseValidationError{}

// Validate checks the field values on GetNoteFromSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNoteFromSmartGoalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNoteFromSmartGoalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNoteFromSmartGoalRequestMultiError, or nil if none found.
func (m *GetNoteFromSmartGoalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNoteFromSmartGoalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNoteId() <= 0 {
		err := GetNoteFromSmartGoalRequestValidationError{
			field:  "NoteId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNoteFromSmartGoalRequestMultiError(errors)
	}

	return nil
}

// GetNoteFromSmartGoalRequestMultiError is an error wrapping multiple
// validation errors returned by GetNoteFromSmartGoalRequest.ValidateAll() if
// the designated constraints aren't met.
type GetNoteFromSmartGoalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNoteFromSmartGoalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNoteFromSmartGoalRequestMultiError) AllErrors() []error { return m }

// GetNoteFromSmartGoalRequestValidationError is the validation error returned
// by GetNoteFromSmartGoalRequest.Validate if the designated constraints
// aren't met.
type GetNoteFromSmartGoalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNoteFromSmartGoalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNoteFromSmartGoalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNoteFromSmartGoalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNoteFromSmartGoalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNoteFromSmartGoalRequestValidationError) ErrorName() string {
	return "GetNoteFromSmartGoalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNoteFromSmartGoalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNoteFromSmartGoalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNoteFromSmartGoalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNoteFromSmartGoalRequestValidationError{}

// Validate checks the field values on GetNoteFromSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNoteFromSmartGoalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNoteFromSmartGoalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetNoteFromSmartGoalResponseMultiError, or nil if none found.
func (m *GetNoteFromSmartGoalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNoteFromSmartGoalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNoteFromSmartGoalResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNoteFromSmartGoalResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNoteFromSmartGoalResponseValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNoteFromSmartGoalResponseMultiError(errors)
	}

	return nil
}

// GetNoteFromSmartGoalResponseMultiError is an error wrapping multiple
// validation errors returned by GetNoteFromSmartGoalResponse.ValidateAll() if
// the designated constraints aren't met.
type GetNoteFromSmartGoalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNoteFromSmartGoalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNoteFromSmartGoalResponseMultiError) AllErrors() []error { return m }

// GetNoteFromSmartGoalResponseValidationError is the validation error returned
// by GetNoteFromSmartGoalResponse.Validate if the designated constraints
// aren't met.
type GetNoteFromSmartGoalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNoteFromSmartGoalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNoteFromSmartGoalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNoteFromSmartGoalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNoteFromSmartGoalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNoteFromSmartGoalResponseValidationError) ErrorName() string {
	return "GetNoteFromSmartGoalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNoteFromSmartGoalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNoteFromSmartGoalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNoteFromSmartGoalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNoteFromSmartGoalResponseValidationError{}

// Validate checks the field values on ListTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionsRequestMultiError, or nil if none found.
func (m *ListTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := ListTransactionsRequestValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserId() <= 0 {
		err := ListTransactionsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for ProfileType

	// no validation rules for FinancialAccountType

	if len(errors) > 0 {
		return ListTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsRequestMultiError) AllErrors() []error { return m }

// ListTransactionsRequestValidationError is the validation error returned by
// ListTransactionsRequest.Validate if the designated constraints aren't met.
type ListTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsRequestValidationError) ErrorName() string {
	return "ListTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsRequestValidationError{}

// Validate checks the field values on ListTransactionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionsResponseMultiError, or nil if none found.
func (m *ListTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextPage

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListTransactionsResponseMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsResponseMultiError) AllErrors() []error { return m }

// ListTransactionsResponseValidationError is the validation error returned by
// ListTransactionsResponse.Validate if the designated constraints aren't met.
type ListTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsResponseValidationError) ErrorName() string {
	return "ListTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsResponseValidationError{}

// Validate checks the field values on ListTransactionsAcrossAllAccountsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListTransactionsAcrossAllAccountsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListTransactionsAcrossAllAccountsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListTransactionsAcrossAllAccountsRequestMultiError, or nil if none found.
func (m *ListTransactionsAcrossAllAccountsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionsAcrossAllAccountsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := ListTransactionsAcrossAllAccountsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return ListTransactionsAcrossAllAccountsRequestMultiError(errors)
	}

	return nil
}

// ListTransactionsAcrossAllAccountsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListTransactionsAcrossAllAccountsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsAcrossAllAccountsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsAcrossAllAccountsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsAcrossAllAccountsRequestMultiError) AllErrors() []error { return m }

// ListTransactionsAcrossAllAccountsRequestValidationError is the validation
// error returned by ListTransactionsAcrossAllAccountsRequest.Validate if the
// designated constraints aren't met.
type ListTransactionsAcrossAllAccountsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsAcrossAllAccountsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsAcrossAllAccountsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsAcrossAllAccountsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsAcrossAllAccountsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsAcrossAllAccountsRequestValidationError) ErrorName() string {
	return "ListTransactionsAcrossAllAccountsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsAcrossAllAccountsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsAcrossAllAccountsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsAcrossAllAccountsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsAcrossAllAccountsRequestValidationError{}

// Validate checks the field values on
// ListTransactionsAcrossAllAccountsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsAcrossAllAccountsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListTransactionsAcrossAllAccountsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListTransactionsAcrossAllAccountsResponseMultiError, or nil if none found.
func (m *ListTransactionsAcrossAllAccountsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionsAcrossAllAccountsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextPage

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionsAcrossAllAccountsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionsAcrossAllAccountsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionsAcrossAllAccountsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionsAcrossAllAccountsResponseMultiError(errors)
	}

	return nil
}

// ListTransactionsAcrossAllAccountsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListTransactionsAcrossAllAccountsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsAcrossAllAccountsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsAcrossAllAccountsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsAcrossAllAccountsResponseMultiError) AllErrors() []error { return m }

// ListTransactionsAcrossAllAccountsResponseValidationError is the validation
// error returned by ListTransactionsAcrossAllAccountsResponse.Validate if the
// designated constraints aren't met.
type ListTransactionsAcrossAllAccountsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsAcrossAllAccountsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsAcrossAllAccountsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsAcrossAllAccountsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsAcrossAllAccountsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsAcrossAllAccountsResponseValidationError) ErrorName() string {
	return "ListTransactionsAcrossAllAccountsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsAcrossAllAccountsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsAcrossAllAccountsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsAcrossAllAccountsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsAcrossAllAccountsResponseValidationError{}

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionRequestMultiError, or nil if none found.
func (m *GetTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := GetTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTransactionRequestMultiError(errors)
	}

	return nil
}

// GetTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequestMultiError) AllErrors() []error { return m }

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string {
	return "GetTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequestValidationError{}

// Validate checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionResponseMultiError, or nil if none found.
func (m *GetTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransactionResponseMultiError(errors)
	}

	return nil
}

// GetTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by GetTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionResponseMultiError) AllErrors() []error { return m }

// GetTransactionResponseValidationError is the validation error returned by
// GetTransactionResponse.Validate if the designated constraints aren't met.
type GetTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionResponseValidationError) ErrorName() string {
	return "GetTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionResponseValidationError{}

// Validate checks the field values on UpdateTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTransactionRequestMultiError, or nil if none found.
func (m *UpdateTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransaction() == nil {
		err := UpdateTransactionRequestValidationError{
			field:  "Transaction",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTransactionRequestValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTransactionRequestValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTransactionRequestValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTransactionRequestMultiError(errors)
	}

	return nil
}

// UpdateTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTransactionRequestMultiError) AllErrors() []error { return m }

// UpdateTransactionRequestValidationError is the validation error returned by
// UpdateTransactionRequest.Validate if the designated constraints aren't met.
type UpdateTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTransactionRequestValidationError) ErrorName() string {
	return "UpdateTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTransactionRequestValidationError{}

// Validate checks the field values on UpdateTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateTransactionResponseMultiError, or nil if none found.
func (m *UpdateTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateTransactionResponseMultiError(errors)
	}

	return nil
}

// UpdateTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateTransactionResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTransactionResponseMultiError) AllErrors() []error { return m }

// UpdateTransactionResponseValidationError is the validation error returned by
// UpdateTransactionResponse.Validate if the designated constraints aren't met.
type UpdateTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTransactionResponseValidationError) ErrorName() string {
	return "UpdateTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTransactionResponseValidationError{}

// Validate checks the field values on BulkUpdateTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkUpdateTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkUpdateTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BulkUpdateTransactionRequestMultiError, or nil if none found.
func (m *BulkUpdateTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkUpdateTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetTransactions()) < 1 {
		err := BulkUpdateTransactionRequestValidationError{
			field:  "Transactions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkUpdateTransactionRequestValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkUpdateTransactionRequestValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkUpdateTransactionRequestValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkUpdateTransactionRequestMultiError(errors)
	}

	return nil
}

// BulkUpdateTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by BulkUpdateTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type BulkUpdateTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkUpdateTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkUpdateTransactionRequestMultiError) AllErrors() []error { return m }

// BulkUpdateTransactionRequestValidationError is the validation error returned
// by BulkUpdateTransactionRequest.Validate if the designated constraints
// aren't met.
type BulkUpdateTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkUpdateTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkUpdateTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkUpdateTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkUpdateTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkUpdateTransactionRequestValidationError) ErrorName() string {
	return "BulkUpdateTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkUpdateTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkUpdateTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkUpdateTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkUpdateTransactionRequestValidationError{}

// Validate checks the field values on BulkUpdateTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BulkUpdateTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkUpdateTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BulkUpdateTransactionResponseMultiError, or nil if none found.
func (m *BulkUpdateTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkUpdateTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkUpdateTransactionResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkUpdateTransactionResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkUpdateTransactionResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkUpdateTransactionResponseMultiError(errors)
	}

	return nil
}

// BulkUpdateTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by BulkUpdateTransactionResponse.ValidateAll()
// if the designated constraints aren't met.
type BulkUpdateTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkUpdateTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkUpdateTransactionResponseMultiError) AllErrors() []error { return m }

// BulkUpdateTransactionResponseValidationError is the validation error
// returned by BulkUpdateTransactionResponse.Validate if the designated
// constraints aren't met.
type BulkUpdateTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkUpdateTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkUpdateTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkUpdateTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkUpdateTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkUpdateTransactionResponseValidationError) ErrorName() string {
	return "BulkUpdateTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkUpdateTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkUpdateTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkUpdateTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkUpdateTransactionResponseValidationError{}

// Validate checks the field values on DeleteTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTransactionRequestMultiError, or nil if none found.
func (m *DeleteTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := DeleteTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteTransactionRequestMultiError(errors)
	}

	return nil
}

// DeleteTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTransactionRequestMultiError) AllErrors() []error { return m }

// DeleteTransactionRequestValidationError is the validation error returned by
// DeleteTransactionRequest.Validate if the designated constraints aren't met.
type DeleteTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTransactionRequestValidationError) ErrorName() string {
	return "DeleteTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTransactionRequestValidationError{}

// Validate checks the field values on DeleteTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTransactionResponseMultiError, or nil if none found.
func (m *DeleteTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteTransactionResponseMultiError(errors)
	}

	return nil
}

// DeleteTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteTransactionResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTransactionResponseMultiError) AllErrors() []error { return m }

// DeleteTransactionResponseValidationError is the validation error returned by
// DeleteTransactionResponse.Validate if the designated constraints aren't met.
type DeleteTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTransactionResponseValidationError) ErrorName() string {
	return "DeleteTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTransactionResponseValidationError{}

// Validate checks the field values on AddNoteToTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddNoteToTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNoteToTransactionRequestMultiError, or nil if none found.
func (m *AddNoteToTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := AddNoteToTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNote() == nil {
		err := AddNoteToTransactionRequestValidationError{
			field:  "Note",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToTransactionRequestValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToTransactionRequestMultiError(errors)
	}

	return nil
}

// AddNoteToTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by AddNoteToTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type AddNoteToTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToTransactionRequestMultiError) AllErrors() []error { return m }

// AddNoteToTransactionRequestValidationError is the validation error returned
// by AddNoteToTransactionRequest.Validate if the designated constraints
// aren't met.
type AddNoteToTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToTransactionRequestValidationError) ErrorName() string {
	return "AddNoteToTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToTransactionRequestValidationError{}

// Validate checks the field values on AddNoteToTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddNoteToTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddNoteToTransactionResponseMultiError, or nil if none found.
func (m *AddNoteToTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToTransactionResponseMultiError(errors)
	}

	return nil
}

// AddNoteToTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by AddNoteToTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type AddNoteToTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToTransactionResponseMultiError) AllErrors() []error { return m }

// AddNoteToTransactionResponseValidationError is the validation error returned
// by AddNoteToTransactionResponse.Validate if the designated constraints
// aren't met.
type AddNoteToTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToTransactionResponseValidationError) ErrorName() string {
	return "AddNoteToTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToTransactionResponseValidationError{}

// Validate checks the field values on UpdateNoteToTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNoteToTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNoteToTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNoteToTransactionRequestMultiError, or nil if none found.
func (m *UpdateNoteToTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNoteToTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNote() == nil {
		err := UpdateNoteToTransactionRequestValidationError{
			field:  "Note",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNoteToTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNoteToTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNoteToTransactionRequestValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNoteToTransactionRequestMultiError(errors)
	}

	return nil
}

// UpdateNoteToTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateNoteToTransactionRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateNoteToTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNoteToTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNoteToTransactionRequestMultiError) AllErrors() []error { return m }

// UpdateNoteToTransactionRequestValidationError is the validation error
// returned by UpdateNoteToTransactionRequest.Validate if the designated
// constraints aren't met.
type UpdateNoteToTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNoteToTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNoteToTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNoteToTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNoteToTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNoteToTransactionRequestValidationError) ErrorName() string {
	return "UpdateNoteToTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNoteToTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNoteToTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNoteToTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNoteToTransactionRequestValidationError{}

// Validate checks the field values on UpdateNoteToTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateNoteToTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateNoteToTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateNoteToTransactionResponseMultiError, or nil if none found.
func (m *UpdateNoteToTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNoteToTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNoteToTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNoteToTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNoteToTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNoteToTransactionResponseMultiError(errors)
	}

	return nil
}

// UpdateNoteToTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateNoteToTransactionResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateNoteToTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNoteToTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNoteToTransactionResponseMultiError) AllErrors() []error { return m }

// UpdateNoteToTransactionResponseValidationError is the validation error
// returned by UpdateNoteToTransactionResponse.Validate if the designated
// constraints aren't met.
type UpdateNoteToTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNoteToTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNoteToTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNoteToTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNoteToTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNoteToTransactionResponseValidationError) ErrorName() string {
	return "UpdateNoteToTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNoteToTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNoteToTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNoteToTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNoteToTransactionResponseValidationError{}

// Validate checks the field values on DeleteNoteFromTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteNoteFromTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNoteFromTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteNoteFromTransactionRequestMultiError, or nil if none found.
func (m *DeleteNoteFromTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteFromTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := DeleteNoteFromTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNoteId() <= 0 {
		err := DeleteNoteFromTransactionRequestValidationError{
			field:  "NoteId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNoteFromTransactionRequestMultiError(errors)
	}

	return nil
}

// DeleteNoteFromTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteNoteFromTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteNoteFromTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteFromTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteFromTransactionRequestMultiError) AllErrors() []error { return m }

// DeleteNoteFromTransactionRequestValidationError is the validation error
// returned by DeleteNoteFromTransactionRequest.Validate if the designated
// constraints aren't met.
type DeleteNoteFromTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteFromTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteFromTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteFromTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteFromTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteFromTransactionRequestValidationError) ErrorName() string {
	return "DeleteNoteFromTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteFromTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteFromTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteFromTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteFromTransactionRequestValidationError{}

// Validate checks the field values on DeleteNoteFromTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteNoteFromTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteNoteFromTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteNoteFromTransactionResponseMultiError, or nil if none found.
func (m *DeleteNoteFromTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteFromTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteNoteFromTransactionResponseMultiError(errors)
	}

	return nil
}

// DeleteNoteFromTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteNoteFromTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNoteFromTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteFromTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteFromTransactionResponseMultiError) AllErrors() []error { return m }

// DeleteNoteFromTransactionResponseValidationError is the validation error
// returned by DeleteNoteFromTransactionResponse.Validate if the designated
// constraints aren't met.
type DeleteNoteFromTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteFromTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteFromTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteFromTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteFromTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteFromTransactionResponseValidationError) ErrorName() string {
	return "DeleteNoteFromTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteFromTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteFromTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteFromTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteFromTransactionResponseValidationError{}

// Validate checks the field values on ListTransactionNotesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionNotesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionNotesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionNotesRequestMultiError, or nil if none found.
func (m *ListTransactionNotesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionNotesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := ListTransactionNotesRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListTransactionNotesRequestMultiError(errors)
	}

	return nil
}

// ListTransactionNotesRequestMultiError is an error wrapping multiple
// validation errors returned by ListTransactionNotesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListTransactionNotesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionNotesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionNotesRequestMultiError) AllErrors() []error { return m }

// ListTransactionNotesRequestValidationError is the validation error returned
// by ListTransactionNotesRequest.Validate if the designated constraints
// aren't met.
type ListTransactionNotesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionNotesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionNotesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionNotesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionNotesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionNotesRequestValidationError) ErrorName() string {
	return "ListTransactionNotesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionNotesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionNotesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionNotesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionNotesRequestValidationError{}

// Validate checks the field values on ListTransactionNotesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionNotesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionNotesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionNotesResponseMultiError, or nil if none found.
func (m *ListTransactionNotesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionNotesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionNotesResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionNotesResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionNotesResponseValidationError{
					field:  fmt.Sprintf("Notes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionNotesResponseMultiError(errors)
	}

	return nil
}

// ListTransactionNotesResponseMultiError is an error wrapping multiple
// validation errors returned by ListTransactionNotesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListTransactionNotesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionNotesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionNotesResponseMultiError) AllErrors() []error { return m }

// ListTransactionNotesResponseValidationError is the validation error returned
// by ListTransactionNotesResponse.Validate if the designated constraints
// aren't met.
type ListTransactionNotesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionNotesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionNotesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionNotesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionNotesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionNotesResponseValidationError) ErrorName() string {
	return "ListTransactionNotesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionNotesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionNotesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionNotesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionNotesResponseValidationError{}

// Validate checks the field values on GetNoteFromTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNoteFromTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNoteFromTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetNoteFromTransactionRequestMultiError, or nil if none found.
func (m *GetNoteFromTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNoteFromTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNoteId() <= 0 {
		err := GetNoteFromTransactionRequestValidationError{
			field:  "NoteId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTransactionId() <= 0 {
		err := GetNoteFromTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetNoteFromTransactionRequestMultiError(errors)
	}

	return nil
}

// GetNoteFromTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by GetNoteFromTransactionRequest.ValidateAll()
// if the designated constraints aren't met.
type GetNoteFromTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNoteFromTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNoteFromTransactionRequestMultiError) AllErrors() []error { return m }

// GetNoteFromTransactionRequestValidationError is the validation error
// returned by GetNoteFromTransactionRequest.Validate if the designated
// constraints aren't met.
type GetNoteFromTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNoteFromTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNoteFromTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNoteFromTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNoteFromTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNoteFromTransactionRequestValidationError) ErrorName() string {
	return "GetNoteFromTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetNoteFromTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNoteFromTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNoteFromTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNoteFromTransactionRequestValidationError{}

// Validate checks the field values on GetNoteFromTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetNoteFromTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetNoteFromTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetNoteFromTransactionResponseMultiError, or nil if none found.
func (m *GetNoteFromTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetNoteFromTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetNoteFromTransactionResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetNoteFromTransactionResponseValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetNoteFromTransactionResponseValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetNoteFromTransactionResponseMultiError(errors)
	}

	return nil
}

// GetNoteFromTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by GetNoteFromTransactionResponse.ValidateAll()
// if the designated constraints aren't met.
type GetNoteFromTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetNoteFromTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetNoteFromTransactionResponseMultiError) AllErrors() []error { return m }

// GetNoteFromTransactionResponseValidationError is the validation error
// returned by GetNoteFromTransactionResponse.Validate if the designated
// constraints aren't met.
type GetNoteFromTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetNoteFromTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetNoteFromTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetNoteFromTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetNoteFromTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetNoteFromTransactionResponseValidationError) ErrorName() string {
	return "GetNoteFromTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetNoteFromTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetNoteFromTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetNoteFromTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetNoteFromTransactionResponseValidationError{}

// Validate checks the field values on SplitTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SplitTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SplitTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SplitTransactionRequestMultiError, or nil if none found.
func (m *SplitTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SplitTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := SplitTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSplitTransactions()) < 1 {
		err := SplitTransactionRequestValidationError{
			field:  "SplitTransactions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSplitTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SplitTransactionRequestValidationError{
						field:  fmt.Sprintf("SplitTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SplitTransactionRequestValidationError{
						field:  fmt.Sprintf("SplitTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SplitTransactionRequestValidationError{
					field:  fmt.Sprintf("SplitTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SplitTransactionRequestMultiError(errors)
	}

	return nil
}

// SplitTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SplitTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type SplitTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SplitTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SplitTransactionRequestMultiError) AllErrors() []error { return m }

// SplitTransactionRequestValidationError is the validation error returned by
// SplitTransactionRequest.Validate if the designated constraints aren't met.
type SplitTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SplitTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SplitTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SplitTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SplitTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SplitTransactionRequestValidationError) ErrorName() string {
	return "SplitTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SplitTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSplitTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SplitTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SplitTransactionRequestValidationError{}

// Validate checks the field values on SplitTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SplitTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SplitTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SplitTransactionResponseMultiError, or nil if none found.
func (m *SplitTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SplitTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SplitTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SplitTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SplitTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SplitTransactionResponseMultiError(errors)
	}

	return nil
}

// SplitTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by SplitTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type SplitTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SplitTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SplitTransactionResponseMultiError) AllErrors() []error { return m }

// SplitTransactionResponseValidationError is the validation error returned by
// SplitTransactionResponse.Validate if the designated constraints aren't met.
type SplitTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SplitTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SplitTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SplitTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SplitTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SplitTransactionResponseValidationError) ErrorName() string {
	return "SplitTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SplitTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSplitTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SplitTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SplitTransactionResponseValidationError{}

// Validate checks the field values on UnSplitTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnSplitTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnSplitTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnSplitTransactionsRequestMultiError, or nil if none found.
func (m *UnSplitTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnSplitTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := UnSplitTransactionsRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UnSplitTransactionsRequestMultiError(errors)
	}

	return nil
}

// UnSplitTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by UnSplitTransactionsRequest.ValidateAll() if
// the designated constraints aren't met.
type UnSplitTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnSplitTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnSplitTransactionsRequestMultiError) AllErrors() []error { return m }

// UnSplitTransactionsRequestValidationError is the validation error returned
// by UnSplitTransactionsRequest.Validate if the designated constraints aren't met.
type UnSplitTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnSplitTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnSplitTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnSplitTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnSplitTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnSplitTransactionsRequestValidationError) ErrorName() string {
	return "UnSplitTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnSplitTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnSplitTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnSplitTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnSplitTransactionsRequestValidationError{}

// Validate checks the field values on UnSplitTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnSplitTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnSplitTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnSplitTransactionsResponseMultiError, or nil if none found.
func (m *UnSplitTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnSplitTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnSplitTransactionsResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnSplitTransactionsResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnSplitTransactionsResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnSplitTransactionsResponseMultiError(errors)
	}

	return nil
}

// UnSplitTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by UnSplitTransactionsResponse.ValidateAll() if
// the designated constraints aren't met.
type UnSplitTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnSplitTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnSplitTransactionsResponseMultiError) AllErrors() []error { return m }

// UnSplitTransactionsResponseValidationError is the validation error returned
// by UnSplitTransactionsResponse.Validate if the designated constraints
// aren't met.
type UnSplitTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnSplitTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnSplitTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnSplitTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnSplitTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnSplitTransactionsResponseValidationError) ErrorName() string {
	return "UnSplitTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnSplitTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnSplitTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnSplitTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnSplitTransactionsResponseValidationError{}

// Validate checks the field values on GetSplitTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSplitTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSplitTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSplitTransactionRequestMultiError, or nil if none found.
func (m *GetSplitTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSplitTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := GetSplitTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSplitTransactionRequestMultiError(errors)
	}

	return nil
}

// GetSplitTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by GetSplitTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type GetSplitTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSplitTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSplitTransactionRequestMultiError) AllErrors() []error { return m }

// GetSplitTransactionRequestValidationError is the validation error returned
// by GetSplitTransactionRequest.Validate if the designated constraints aren't met.
type GetSplitTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSplitTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSplitTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSplitTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSplitTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSplitTransactionRequestValidationError) ErrorName() string {
	return "GetSplitTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSplitTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSplitTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSplitTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSplitTransactionRequestValidationError{}

// Validate checks the field values on GetSplitTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSplitTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSplitTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSplitTransactionResponseMultiError, or nil if none found.
func (m *GetSplitTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSplitTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSplitTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSplitTransactionResponseValidationError{
						field:  fmt.Sprintf("SplitTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSplitTransactionResponseValidationError{
						field:  fmt.Sprintf("SplitTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSplitTransactionResponseValidationError{
					field:  fmt.Sprintf("SplitTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSplitTransactionResponseMultiError(errors)
	}

	return nil
}

// GetSplitTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by GetSplitTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type GetSplitTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSplitTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSplitTransactionResponseMultiError) AllErrors() []error { return m }

// GetSplitTransactionResponseValidationError is the validation error returned
// by GetSplitTransactionResponse.Validate if the designated constraints
// aren't met.
type GetSplitTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSplitTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSplitTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSplitTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSplitTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSplitTransactionResponseValidationError) ErrorName() string {
	return "GetSplitTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSplitTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSplitTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSplitTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSplitTransactionResponseValidationError{}

// Validate checks the field values on SearchTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchTransactionsRequestMultiError, or nil if none found.
func (m *SearchTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := SearchTransactionsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for MinAmount

	// no validation rules for MaxAmount

	// no validation rules for Category

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchTransactionsRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchTransactionsRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchTransactionsRequestValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchTransactionsRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchTransactionsRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchTransactionsRequestValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FinancialAccountType

	if len(errors) > 0 {
		return SearchTransactionsRequestMultiError(errors)
	}

	return nil
}

// SearchTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by SearchTransactionsRequest.ValidateAll() if the
// designated constraints aren't met.
type SearchTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchTransactionsRequestMultiError) AllErrors() []error { return m }

// SearchTransactionsRequestValidationError is the validation error returned by
// SearchTransactionsRequest.Validate if the designated constraints aren't met.
type SearchTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchTransactionsRequestValidationError) ErrorName() string {
	return "SearchTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchTransactionsRequestValidationError{}

// Validate checks the field values on SearchTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchTransactionsResponseMultiError, or nil if none found.
func (m *SearchTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageNumber

	if len(errors) > 0 {
		return SearchTransactionsResponseMultiError(errors)
	}

	return nil
}

// SearchTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by SearchTransactionsResponse.ValidateAll() if
// the designated constraints aren't met.
type SearchTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchTransactionsResponseMultiError) AllErrors() []error { return m }

// SearchTransactionsResponseValidationError is the validation error returned
// by SearchTransactionsResponse.Validate if the designated constraints aren't met.
type SearchTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchTransactionsResponseValidationError) ErrorName() string {
	return "SearchTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchTransactionsResponseValidationError{}

// Validate checks the field values on ListRecurringTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListRecurringTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecurringTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListRecurringTransactionsRequestMultiError, or nil if none found.
func (m *ListRecurringTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecurringTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetAccountId() <= 0 {
		err := ListRecurringTransactionsRequestValidationError{
			field:  "AccountId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserId() <= 0 {
		err := ListRecurringTransactionsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for ProfileType

	// no validation rules for FinancialAccountType

	if len(errors) > 0 {
		return ListRecurringTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListRecurringTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListRecurringTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListRecurringTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecurringTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecurringTransactionsRequestMultiError) AllErrors() []error { return m }

// ListRecurringTransactionsRequestValidationError is the validation error
// returned by ListRecurringTransactionsRequest.Validate if the designated
// constraints aren't met.
type ListRecurringTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecurringTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecurringTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecurringTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecurringTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecurringTransactionsRequestValidationError) ErrorName() string {
	return "ListRecurringTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecurringTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecurringTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecurringTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecurringTransactionsRequestValidationError{}

// Validate checks the field values on ListRecurringTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListRecurringTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecurringTransactionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListRecurringTransactionsResponseMultiError, or nil if none found.
func (m *ListRecurringTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecurringTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NextPage

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRecurringTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRecurringTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRecurringTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRecurringTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListRecurringTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListRecurringTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRecurringTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecurringTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecurringTransactionsResponseMultiError) AllErrors() []error { return m }

// ListRecurringTransactionsResponseValidationError is the validation error
// returned by ListRecurringTransactionsResponse.Validate if the designated
// constraints aren't met.
type ListRecurringTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecurringTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecurringTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecurringTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecurringTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecurringTransactionsResponseValidationError) ErrorName() string {
	return "ListRecurringTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecurringTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecurringTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecurringTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecurringTransactionsResponseValidationError{}

// Validate checks the field values on GetRecurringTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRecurringTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRecurringTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetRecurringTransactionsRequestMultiError, or nil if none found.
func (m *GetRecurringTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRecurringTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetRecurringTransactionsRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageNumber

	// no validation rules for PageSize

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return GetRecurringTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetRecurringTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by GetRecurringTransactionsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetRecurringTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecurringTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecurringTransactionsRequestMultiError) AllErrors() []error { return m }

// GetRecurringTransactionsRequestValidationError is the validation error
// returned by GetRecurringTransactionsRequest.Validate if the designated
// constraints aren't met.
type GetRecurringTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecurringTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecurringTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecurringTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecurringTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecurringTransactionsRequestValidationError) ErrorName() string {
	return "GetRecurringTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecurringTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecurringTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecurringTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecurringTransactionsRequestValidationError{}

// Validate checks the field values on GetRecurringTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetRecurringTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRecurringTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetRecurringTransactionsResponseMultiError, or nil if none found.
func (m *GetRecurringTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRecurringTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetRecurringTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetRecurringTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetRecurringTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageNumber

	if len(errors) > 0 {
		return GetRecurringTransactionsResponseMultiError(errors)
	}

	return nil
}

// GetRecurringTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetRecurringTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetRecurringTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecurringTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecurringTransactionsResponseMultiError) AllErrors() []error { return m }

// GetRecurringTransactionsResponseValidationError is the validation error
// returned by GetRecurringTransactionsResponse.Validate if the designated
// constraints aren't met.
type GetRecurringTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecurringTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecurringTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecurringTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecurringTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecurringTransactionsResponseValidationError) ErrorName() string {
	return "GetRecurringTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecurringTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecurringTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecurringTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecurringTransactionsResponseValidationError{}

// Validate checks the field values on UpdateRecurringTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateRecurringTransactionRequestMultiError, or nil if none found.
func (m *UpdateRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransaction() == nil {
		err := UpdateRecurringTransactionRequestValidationError{
			field:  "Transaction",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRecurringTransactionRequestValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRecurringTransactionRequestValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRecurringTransactionRequestValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// UpdateRecurringTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateRecurringTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// UpdateRecurringTransactionRequestValidationError is the validation error
// returned by UpdateRecurringTransactionRequest.Validate if the designated
// constraints aren't met.
type UpdateRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRecurringTransactionRequestValidationError) ErrorName() string {
	return "UpdateRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRecurringTransactionRequestValidationError{}

// Validate checks the field values on UpdateRecurringTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRecurringTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateRecurringTransactionResponseMultiError, or nil if none found.
func (m *UpdateRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRecurringTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// UpdateRecurringTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateRecurringTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// UpdateRecurringTransactionResponseValidationError is the validation error
// returned by UpdateRecurringTransactionResponse.Validate if the designated
// constraints aren't met.
type UpdateRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRecurringTransactionResponseValidationError) ErrorName() string {
	return "UpdateRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRecurringTransactionResponseValidationError{}

// Validate checks the field values on BulkUpdateRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *BulkUpdateRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BulkUpdateRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BulkUpdateRecurringTransactionRequestMultiError, or nil if none found.
func (m *BulkUpdateRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkUpdateRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetTransactions()) < 1 {
		err := BulkUpdateRecurringTransactionRequestValidationError{
			field:  "Transactions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkUpdateRecurringTransactionRequestValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkUpdateRecurringTransactionRequestValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkUpdateRecurringTransactionRequestValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkUpdateRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// BulkUpdateRecurringTransactionRequestMultiError is an error wrapping
// multiple validation errors returned by
// BulkUpdateRecurringTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type BulkUpdateRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkUpdateRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkUpdateRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// BulkUpdateRecurringTransactionRequestValidationError is the validation error
// returned by BulkUpdateRecurringTransactionRequest.Validate if the
// designated constraints aren't met.
type BulkUpdateRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkUpdateRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkUpdateRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkUpdateRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkUpdateRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkUpdateRecurringTransactionRequestValidationError) ErrorName() string {
	return "BulkUpdateRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BulkUpdateRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkUpdateRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkUpdateRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkUpdateRecurringTransactionRequestValidationError{}

// Validate checks the field values on BulkUpdateRecurringTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *BulkUpdateRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// BulkUpdateRecurringTransactionResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// BulkUpdateRecurringTransactionResponseMultiError, or nil if none found.
func (m *BulkUpdateRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BulkUpdateRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BulkUpdateRecurringTransactionResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BulkUpdateRecurringTransactionResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BulkUpdateRecurringTransactionResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BulkUpdateRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// BulkUpdateRecurringTransactionResponseMultiError is an error wrapping
// multiple validation errors returned by
// BulkUpdateRecurringTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type BulkUpdateRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BulkUpdateRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BulkUpdateRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// BulkUpdateRecurringTransactionResponseValidationError is the validation
// error returned by BulkUpdateRecurringTransactionResponse.Validate if the
// designated constraints aren't met.
type BulkUpdateRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BulkUpdateRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BulkUpdateRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BulkUpdateRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BulkUpdateRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BulkUpdateRecurringTransactionResponseValidationError) ErrorName() string {
	return "BulkUpdateRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BulkUpdateRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBulkUpdateRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BulkUpdateRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BulkUpdateRecurringTransactionResponseValidationError{}

// Validate checks the field values on DeleteRecurringTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteRecurringTransactionRequestMultiError, or nil if none found.
func (m *DeleteRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := DeleteRecurringTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// DeleteRecurringTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteRecurringTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// DeleteRecurringTransactionRequestValidationError is the validation error
// returned by DeleteRecurringTransactionRequest.Validate if the designated
// constraints aren't met.
type DeleteRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRecurringTransactionRequestValidationError) ErrorName() string {
	return "DeleteRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRecurringTransactionRequestValidationError{}

// Validate checks the field values on DeleteRecurringTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeleteRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRecurringTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DeleteRecurringTransactionResponseMultiError, or nil if none found.
func (m *DeleteRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// DeleteRecurringTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by
// DeleteRecurringTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// DeleteRecurringTransactionResponseValidationError is the validation error
// returned by DeleteRecurringTransactionResponse.Validate if the designated
// constraints aren't met.
type DeleteRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRecurringTransactionResponseValidationError) ErrorName() string {
	return "DeleteRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRecurringTransactionResponseValidationError{}

// Validate checks the field values on AddNoteToRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AddNoteToRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// AddNoteToRecurringTransactionRequestMultiError, or nil if none found.
func (m *AddNoteToRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := AddNoteToRecurringTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNote() == nil {
		err := AddNoteToRecurringTransactionRequestValidationError{
			field:  "Note",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToRecurringTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToRecurringTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToRecurringTransactionRequestValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// AddNoteToRecurringTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by
// AddNoteToRecurringTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type AddNoteToRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// AddNoteToRecurringTransactionRequestValidationError is the validation error
// returned by AddNoteToRecurringTransactionRequest.Validate if the designated
// constraints aren't met.
type AddNoteToRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToRecurringTransactionRequestValidationError) ErrorName() string {
	return "AddNoteToRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToRecurringTransactionRequestValidationError{}

// Validate checks the field values on AddNoteToRecurringTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *AddNoteToRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddNoteToRecurringTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// AddNoteToRecurringTransactionResponseMultiError, or nil if none found.
func (m *AddNoteToRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddNoteToRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddNoteToRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddNoteToRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddNoteToRecurringTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddNoteToRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// AddNoteToRecurringTransactionResponseMultiError is an error wrapping
// multiple validation errors returned by
// AddNoteToRecurringTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type AddNoteToRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddNoteToRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddNoteToRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// AddNoteToRecurringTransactionResponseValidationError is the validation error
// returned by AddNoteToRecurringTransactionResponse.Validate if the
// designated constraints aren't met.
type AddNoteToRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddNoteToRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddNoteToRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddNoteToRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddNoteToRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddNoteToRecurringTransactionResponseValidationError) ErrorName() string {
	return "AddNoteToRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddNoteToRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddNoteToRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddNoteToRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddNoteToRecurringTransactionResponseValidationError{}

// Validate checks the field values on UpdateNoteToRecurringTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateNoteToRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateNoteToRecurringTransactionRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// UpdateNoteToRecurringTransactionRequestMultiError, or nil if none found.
func (m *UpdateNoteToRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNoteToRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetNote() == nil {
		err := UpdateNoteToRecurringTransactionRequestValidationError{
			field:  "Note",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNote()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNoteToRecurringTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNoteToRecurringTransactionRequestValidationError{
					field:  "Note",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNote()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNoteToRecurringTransactionRequestValidationError{
				field:  "Note",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNoteToRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// UpdateNoteToRecurringTransactionRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateNoteToRecurringTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateNoteToRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNoteToRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNoteToRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// UpdateNoteToRecurringTransactionRequestValidationError is the validation
// error returned by UpdateNoteToRecurringTransactionRequest.Validate if the
// designated constraints aren't met.
type UpdateNoteToRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNoteToRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNoteToRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNoteToRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNoteToRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNoteToRecurringTransactionRequestValidationError) ErrorName() string {
	return "UpdateNoteToRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNoteToRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNoteToRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNoteToRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNoteToRecurringTransactionRequestValidationError{}

// Validate checks the field values on UpdateNoteToRecurringTransactionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateNoteToRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateNoteToRecurringTransactionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateNoteToRecurringTransactionResponseMultiError, or nil if none found.
func (m *UpdateNoteToRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateNoteToRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateNoteToRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateNoteToRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateNoteToRecurringTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateNoteToRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// UpdateNoteToRecurringTransactionResponseMultiError is an error wrapping
// multiple validation errors returned by
// UpdateNoteToRecurringTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateNoteToRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateNoteToRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateNoteToRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// UpdateNoteToRecurringTransactionResponseValidationError is the validation
// error returned by UpdateNoteToRecurringTransactionResponse.Validate if the
// designated constraints aren't met.
type UpdateNoteToRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateNoteToRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateNoteToRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateNoteToRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateNoteToRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateNoteToRecurringTransactionResponseValidationError) ErrorName() string {
	return "UpdateNoteToRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateNoteToRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateNoteToRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateNoteToRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateNoteToRecurringTransactionResponseValidationError{}

// Validate checks the field values on
// DeleteNoteFromRecurringTransactionRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteNoteFromRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteNoteFromRecurringTransactionRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeleteNoteFromRecurringTransactionRequestMultiError, or nil if none found.
func (m *DeleteNoteFromRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteFromRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := DeleteNoteFromRecurringTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetNoteId() <= 0 {
		err := DeleteNoteFromRecurringTransactionRequestValidationError{
			field:  "NoteId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteNoteFromRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// DeleteNoteFromRecurringTransactionRequestMultiError is an error wrapping
// multiple validation errors returned by
// DeleteNoteFromRecurringTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteNoteFromRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteFromRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteFromRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// DeleteNoteFromRecurringTransactionRequestValidationError is the validation
// error returned by DeleteNoteFromRecurringTransactionRequest.Validate if the
// designated constraints aren't met.
type DeleteNoteFromRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteFromRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteFromRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteFromRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteFromRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteFromRecurringTransactionRequestValidationError) ErrorName() string {
	return "DeleteNoteFromRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteFromRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteFromRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteFromRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteFromRecurringTransactionRequestValidationError{}

// Validate checks the field values on
// DeleteNoteFromRecurringTransactionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteNoteFromRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteNoteFromRecurringTransactionResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeleteNoteFromRecurringTransactionResponseMultiError, or nil if none found.
func (m *DeleteNoteFromRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteNoteFromRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteNoteFromRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// DeleteNoteFromRecurringTransactionResponseMultiError is an error wrapping
// multiple validation errors returned by
// DeleteNoteFromRecurringTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteNoteFromRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteNoteFromRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteNoteFromRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// DeleteNoteFromRecurringTransactionResponseValidationError is the validation
// error returned by DeleteNoteFromRecurringTransactionResponse.Validate if
// the designated constraints aren't met.
type DeleteNoteFromRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteNoteFromRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteNoteFromRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteNoteFromRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteNoteFromRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteNoteFromRecurringTransactionResponseValidationError) ErrorName() string {
	return "DeleteNoteFromRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteNoteFromRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteNoteFromRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteNoteFromRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteNoteFromRecurringTransactionResponseValidationError{}

// Validate checks the field values on ListRecurringTransactionNotesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListRecurringTransactionNotesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecurringTransactionNotesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListRecurringTransactionNotesRequestMultiError, or nil if none found.
func (m *ListRecurringTransactionNotesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecurringTransactionNotesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := ListRecurringTransactionNotesRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRecurringTransactionNotesRequestMultiError(errors)
	}

	return nil
}

// ListRecurringTransactionNotesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListRecurringTransactionNotesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListRecurringTransactionNotesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecurringTransactionNotesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecurringTransactionNotesRequestMultiError) AllErrors() []error { return m }

// ListRecurringTransactionNotesRequestValidationError is the validation error
// returned by ListRecurringTransactionNotesRequest.Validate if the designated
// constraints aren't met.
type ListRecurringTransactionNotesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecurringTransactionNotesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecurringTransactionNotesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecurringTransactionNotesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecurringTransactionNotesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecurringTransactionNotesRequestValidationError) ErrorName() string {
	return "ListRecurringTransactionNotesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecurringTransactionNotesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecurringTransactionNotesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecurringTransactionNotesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecurringTransactionNotesRequestValidationError{}

// Validate checks the field values on ListRecurringTransactionNotesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListRecurringTransactionNotesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRecurringTransactionNotesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListRecurringTransactionNotesResponseMultiError, or nil if none found.
func (m *ListRecurringTransactionNotesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRecurringTransactionNotesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRecurringTransactionNotesResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRecurringTransactionNotesResponseValidationError{
						field:  fmt.Sprintf("Notes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRecurringTransactionNotesResponseValidationError{
					field:  fmt.Sprintf("Notes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRecurringTransactionNotesResponseMultiError(errors)
	}

	return nil
}

// ListRecurringTransactionNotesResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListRecurringTransactionNotesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRecurringTransactionNotesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRecurringTransactionNotesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRecurringTransactionNotesResponseMultiError) AllErrors() []error { return m }

// ListRecurringTransactionNotesResponseValidationError is the validation error
// returned by ListRecurringTransactionNotesResponse.Validate if the
// designated constraints aren't met.
type ListRecurringTransactionNotesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRecurringTransactionNotesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRecurringTransactionNotesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRecurringTransactionNotesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRecurringTransactionNotesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRecurringTransactionNotesResponseValidationError) ErrorName() string {
	return "ListRecurringTransactionNotesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRecurringTransactionNotesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRecurringTransactionNotesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRecurringTransactionNotesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRecurringTransactionNotesResponseValidationError{}

// Validate checks the field values on GetRecurringTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRecurringTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRecurringTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetRecurringTransactionRequestMultiError, or nil if none found.
func (m *GetRecurringTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRecurringTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTransactionId() <= 0 {
		err := GetRecurringTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRecurringTransactionRequestMultiError(errors)
	}

	return nil
}

// GetRecurringTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by GetRecurringTransactionRequest.ValidateAll()
// if the designated constraints aren't met.
type GetRecurringTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecurringTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecurringTransactionRequestMultiError) AllErrors() []error { return m }

// GetRecurringTransactionRequestValidationError is the validation error
// returned by GetRecurringTransactionRequest.Validate if the designated
// constraints aren't met.
type GetRecurringTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecurringTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecurringTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecurringTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecurringTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecurringTransactionRequestValidationError) ErrorName() string {
	return "GetRecurringTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecurringTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecurringTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecurringTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecurringTransactionRequestValidationError{}

// Validate checks the field values on GetRecurringTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRecurringTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRecurringTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetRecurringTransactionResponseMultiError, or nil if none found.
func (m *GetRecurringTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRecurringTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRecurringTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRecurringTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRecurringTransactionResponseMultiError(errors)
	}

	return nil
}

// GetRecurringTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by GetRecurringTransactionResponse.ValidateAll()
// if the designated constraints aren't met.
type GetRecurringTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecurringTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecurringTransactionResponseMultiError) AllErrors() []error { return m }

// GetRecurringTransactionResponseValidationError is the validation error
// returned by GetRecurringTransactionResponse.Validate if the designated
// constraints aren't met.
type GetRecurringTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecurringTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecurringTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecurringTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecurringTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecurringTransactionResponseValidationError) ErrorName() string {
	return "GetRecurringTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecurringTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecurringTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecurringTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecurringTransactionResponseValidationError{}

// Validate checks the field values on PollAsyncTaskExecutionStatusRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PollAsyncTaskExecutionStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PollAsyncTaskExecutionStatusRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PollAsyncTaskExecutionStatusRequestMultiError, or nil if none found.
func (m *PollAsyncTaskExecutionStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PollAsyncTaskExecutionStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if len(errors) > 0 {
		return PollAsyncTaskExecutionStatusRequestMultiError(errors)
	}

	return nil
}

// PollAsyncTaskExecutionStatusRequestMultiError is an error wrapping multiple
// validation errors returned by
// PollAsyncTaskExecutionStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type PollAsyncTaskExecutionStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PollAsyncTaskExecutionStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PollAsyncTaskExecutionStatusRequestMultiError) AllErrors() []error { return m }

// PollAsyncTaskExecutionStatusRequestValidationError is the validation error
// returned by PollAsyncTaskExecutionStatusRequest.Validate if the designated
// constraints aren't met.
type PollAsyncTaskExecutionStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PollAsyncTaskExecutionStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PollAsyncTaskExecutionStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PollAsyncTaskExecutionStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PollAsyncTaskExecutionStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PollAsyncTaskExecutionStatusRequestValidationError) ErrorName() string {
	return "PollAsyncTaskExecutionStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PollAsyncTaskExecutionStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPollAsyncTaskExecutionStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PollAsyncTaskExecutionStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PollAsyncTaskExecutionStatusRequestValidationError{}

// Validate checks the field values on PollAsyncTaskExecutionStatusResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *PollAsyncTaskExecutionStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PollAsyncTaskExecutionStatusResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// PollAsyncTaskExecutionStatusResponseMultiError, or nil if none found.
func (m *PollAsyncTaskExecutionStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PollAsyncTaskExecutionStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	// no validation rules for Status

	if len(errors) > 0 {
		return PollAsyncTaskExecutionStatusResponseMultiError(errors)
	}

	return nil
}

// PollAsyncTaskExecutionStatusResponseMultiError is an error wrapping multiple
// validation errors returned by
// PollAsyncTaskExecutionStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type PollAsyncTaskExecutionStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PollAsyncTaskExecutionStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PollAsyncTaskExecutionStatusResponseMultiError) AllErrors() []error { return m }

// PollAsyncTaskExecutionStatusResponseValidationError is the validation error
// returned by PollAsyncTaskExecutionStatusResponse.Validate if the designated
// constraints aren't met.
type PollAsyncTaskExecutionStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PollAsyncTaskExecutionStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PollAsyncTaskExecutionStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PollAsyncTaskExecutionStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PollAsyncTaskExecutionStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PollAsyncTaskExecutionStatusResponseValidationError) ErrorName() string {
	return "PollAsyncTaskExecutionStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PollAsyncTaskExecutionStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPollAsyncTaskExecutionStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PollAsyncTaskExecutionStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PollAsyncTaskExecutionStatusResponseValidationError{}

// Validate checks the field values on RecordAskCopilotQuestionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecordAskCopilotQuestionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordAskCopilotQuestionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RecordAskCopilotQuestionRequestMultiError, or nil if none found.
func (m *RecordAskCopilotQuestionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordAskCopilotQuestionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := RecordAskCopilotQuestionRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return RecordAskCopilotQuestionRequestMultiError(errors)
	}

	return nil
}

// RecordAskCopilotQuestionRequestMultiError is an error wrapping multiple
// validation errors returned by RecordAskCopilotQuestionRequest.ValidateAll()
// if the designated constraints aren't met.
type RecordAskCopilotQuestionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordAskCopilotQuestionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordAskCopilotQuestionRequestMultiError) AllErrors() []error { return m }

// RecordAskCopilotQuestionRequestValidationError is the validation error
// returned by RecordAskCopilotQuestionRequest.Validate if the designated
// constraints aren't met.
type RecordAskCopilotQuestionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordAskCopilotQuestionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordAskCopilotQuestionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordAskCopilotQuestionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordAskCopilotQuestionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordAskCopilotQuestionRequestValidationError) ErrorName() string {
	return "RecordAskCopilotQuestionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RecordAskCopilotQuestionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordAskCopilotQuestionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordAskCopilotQuestionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordAskCopilotQuestionRequestValidationError{}

// Validate checks the field values on RecordAskCopilotQuestionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *RecordAskCopilotQuestionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordAskCopilotQuestionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RecordAskCopilotQuestionResponseMultiError, or nil if none found.
func (m *RecordAskCopilotQuestionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordAskCopilotQuestionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for RemainingQuota

	if len(errors) > 0 {
		return RecordAskCopilotQuestionResponseMultiError(errors)
	}

	return nil
}

// RecordAskCopilotQuestionResponseMultiError is an error wrapping multiple
// validation errors returned by
// RecordAskCopilotQuestionResponse.ValidateAll() if the designated
// constraints aren't met.
type RecordAskCopilotQuestionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordAskCopilotQuestionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordAskCopilotQuestionResponseMultiError) AllErrors() []error { return m }

// RecordAskCopilotQuestionResponseValidationError is the validation error
// returned by RecordAskCopilotQuestionResponse.Validate if the designated
// constraints aren't met.
type RecordAskCopilotQuestionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordAskCopilotQuestionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordAskCopilotQuestionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordAskCopilotQuestionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordAskCopilotQuestionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordAskCopilotQuestionResponseValidationError) ErrorName() string {
	return "RecordAskCopilotQuestionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RecordAskCopilotQuestionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordAskCopilotQuestionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordAskCopilotQuestionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordAskCopilotQuestionResponseValidationError{}

// Validate checks the field values on CheckIfQuotaExceededRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckIfQuotaExceededRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckIfQuotaExceededRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckIfQuotaExceededRequestMultiError, or nil if none found.
func (m *CheckIfQuotaExceededRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckIfQuotaExceededRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := CheckIfQuotaExceededRequestValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProfileType

	if len(errors) > 0 {
		return CheckIfQuotaExceededRequestMultiError(errors)
	}

	return nil
}

// CheckIfQuotaExceededRequestMultiError is an error wrapping multiple
// validation errors returned by CheckIfQuotaExceededRequest.ValidateAll() if
// the designated constraints aren't met.
type CheckIfQuotaExceededRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckIfQuotaExceededRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckIfQuotaExceededRequestMultiError) AllErrors() []error { return m }

// CheckIfQuotaExceededRequestValidationError is the validation error returned
// by CheckIfQuotaExceededRequest.Validate if the designated constraints
// aren't met.
type CheckIfQuotaExceededRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckIfQuotaExceededRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckIfQuotaExceededRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckIfQuotaExceededRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckIfQuotaExceededRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckIfQuotaExceededRequestValidationError) ErrorName() string {
	return "CheckIfQuotaExceededRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckIfQuotaExceededRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckIfQuotaExceededRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckIfQuotaExceededRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckIfQuotaExceededRequestValidationError{}

// Validate checks the field values on CheckIfQuotaExceededResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckIfQuotaExceededResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckIfQuotaExceededResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckIfQuotaExceededResponseMultiError, or nil if none found.
func (m *CheckIfQuotaExceededResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckIfQuotaExceededResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exceeded

	if len(errors) > 0 {
		return CheckIfQuotaExceededResponseMultiError(errors)
	}

	return nil
}

// CheckIfQuotaExceededResponseMultiError is an error wrapping multiple
// validation errors returned by CheckIfQuotaExceededResponse.ValidateAll() if
// the designated constraints aren't met.
type CheckIfQuotaExceededResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckIfQuotaExceededResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckIfQuotaExceededResponseMultiError) AllErrors() []error { return m }

// CheckIfQuotaExceededResponseValidationError is the validation error returned
// by CheckIfQuotaExceededResponse.Validate if the designated constraints
// aren't met.
type CheckIfQuotaExceededResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckIfQuotaExceededResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckIfQuotaExceededResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckIfQuotaExceededResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckIfQuotaExceededResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckIfQuotaExceededResponseValidationError) ErrorName() string {
	return "CheckIfQuotaExceededResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckIfQuotaExceededResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckIfQuotaExceededResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckIfQuotaExceededResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckIfQuotaExceededResponseValidationError{}

// Validate checks the field values on
// GetReCurringTransactionsResponse_ParticipantReCurringTransactions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReCurringTransactionsResponse_ParticipantReCurringTransactions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetReCurringTransactionsResponse_ParticipantReCurringTransactions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReCurringTransactionsResponse_ParticipantReCurringTransactionsMultiError,
// or nil if none found.
func (m *GetReCurringTransactionsResponse_ParticipantReCurringTransactions) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReCurringTransactionsResponse_ParticipantReCurringTransactions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReocurringTransactionId

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetReCurringTransactionsResponse_ParticipantReCurringTransactionsMultiError(errors)
	}

	return nil
}

// GetReCurringTransactionsResponse_ParticipantReCurringTransactionsMultiError
// is an error wrapping multiple validation errors returned by
// GetReCurringTransactionsResponse_ParticipantReCurringTransactions.ValidateAll()
// if the designated constraints aren't met.
type GetReCurringTransactionsResponse_ParticipantReCurringTransactionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReCurringTransactionsResponse_ParticipantReCurringTransactionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReCurringTransactionsResponse_ParticipantReCurringTransactionsMultiError) AllErrors() []error {
	return m
}

// GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError
// is the validation error returned by
// GetReCurringTransactionsResponse_ParticipantReCurringTransactions.Validate
// if the designated constraints aren't met.
type GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError) ErrorName() string {
	return "GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError"
}

// Error satisfies the builtin error interface
func (e GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReCurringTransactionsResponse_ParticipantReCurringTransactions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReCurringTransactionsResponse_ParticipantReCurringTransactionsValidationError{}
