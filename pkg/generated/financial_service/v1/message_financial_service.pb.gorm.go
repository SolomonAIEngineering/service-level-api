package financial_servicev1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	anypb "google.golang.org/protobuf/types/known/anypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type StripeSubscriptionORM struct {
	FinancialUserProfileId        *uint64
	Id                            uint64
	IsTrialing                    bool
	StripeSubscriptionActiveUntil string
	StripeSubscriptionId          string
	StripeSubscriptionStatus      string
	StripeWebhookLatestTimestamp  string
}

// TableName overrides the default tablename generated by GORM
func (StripeSubscriptionORM) TableName() string {
	return "stripe_subscriptions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StripeSubscription) ToORM(ctx context.Context) (StripeSubscriptionORM, error) {
	to := StripeSubscriptionORM{}
	var err error
	if prehook, ok := interface{}(m).(StripeSubscriptionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.StripeSubscriptionId = m.StripeSubscriptionId
	to.StripeSubscriptionStatus = StripeSubscriptionStatus_name[int32(m.StripeSubscriptionStatus)]
	to.StripeSubscriptionActiveUntil = m.StripeSubscriptionActiveUntil
	to.StripeWebhookLatestTimestamp = m.StripeWebhookLatestTimestamp
	to.IsTrialing = m.IsTrialing
	if posthook, ok := interface{}(m).(StripeSubscriptionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StripeSubscriptionORM) ToPB(ctx context.Context) (StripeSubscription, error) {
	to := StripeSubscription{}
	var err error
	if prehook, ok := interface{}(m).(StripeSubscriptionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.StripeSubscriptionId = m.StripeSubscriptionId
	to.StripeSubscriptionStatus = StripeSubscriptionStatus(StripeSubscriptionStatus_value[m.StripeSubscriptionStatus])
	to.StripeSubscriptionActiveUntil = m.StripeSubscriptionActiveUntil
	to.StripeWebhookLatestTimestamp = m.StripeWebhookLatestTimestamp
	to.IsTrialing = m.IsTrialing
	if posthook, ok := interface{}(m).(StripeSubscriptionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StripeSubscription the arg will be the target, the caller the one being converted from

// StripeSubscriptionBeforeToORM called before default ToORM code
type StripeSubscriptionWithBeforeToORM interface {
	BeforeToORM(context.Context, *StripeSubscriptionORM) error
}

// StripeSubscriptionAfterToORM called after default ToORM code
type StripeSubscriptionWithAfterToORM interface {
	AfterToORM(context.Context, *StripeSubscriptionORM) error
}

// StripeSubscriptionBeforeToPB called before default ToPB code
type StripeSubscriptionWithBeforeToPB interface {
	BeforeToPB(context.Context, *StripeSubscription) error
}

// StripeSubscriptionAfterToPB called after default ToPB code
type StripeSubscriptionWithAfterToPB interface {
	AfterToPB(context.Context, *StripeSubscription) error
}

type FinancialUserProfileORM struct {
	ActionableInsights         []*ActionableInsightORM         `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id;preload:true"`
	ActionablePersonalInsights []*PersonalActionableInsightORM `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id;preload:true"`
	Email                      string
	Id                         uint64
	Link                       []*LinkORM      `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id;preload:true"`
	MergeLiink                 []*MergeLinkORM `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id"`
	ProfileType                string
	StripeCustomerId           string
	StripeSubscriptions        *StripeSubscriptionORM `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id"`
	UserId                     uint64
}

// TableName overrides the default tablename generated by GORM
func (FinancialUserProfileORM) TableName() string {
	return "financial_user_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FinancialUserProfile) ToORM(ctx context.Context) (FinancialUserProfileORM, error) {
	to := FinancialUserProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(FinancialUserProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.StripeCustomerId = m.StripeCustomerId
	if m.StripeSubscriptions != nil {
		tempStripeSubscriptions, err := m.StripeSubscriptions.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.StripeSubscriptions = &tempStripeSubscriptions
	}
	for _, v := range m.Link {
		if v != nil {
			if tempLink, cErr := v.ToORM(ctx); cErr == nil {
				to.Link = append(to.Link, &tempLink)
			} else {
				return to, cErr
			}
		} else {
			to.Link = append(to.Link, nil)
		}
	}
	for _, v := range m.ActionableInsights {
		if v != nil {
			if tempActionableInsights, cErr := v.ToORM(ctx); cErr == nil {
				to.ActionableInsights = append(to.ActionableInsights, &tempActionableInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionableInsights = append(to.ActionableInsights, nil)
		}
	}
	to.Email = m.Email
	for _, v := range m.MergeLiink {
		if v != nil {
			if tempMergeLiink, cErr := v.ToORM(ctx); cErr == nil {
				to.MergeLiink = append(to.MergeLiink, &tempMergeLiink)
			} else {
				return to, cErr
			}
		} else {
			to.MergeLiink = append(to.MergeLiink, nil)
		}
	}
	for _, v := range m.ActionablePersonalInsights {
		if v != nil {
			if tempActionablePersonalInsights, cErr := v.ToORM(ctx); cErr == nil {
				to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, &tempActionablePersonalInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, nil)
		}
	}
	to.ProfileType = FinancialUserProfileType_name[int32(m.ProfileType)]
	if posthook, ok := interface{}(m).(FinancialUserProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FinancialUserProfileORM) ToPB(ctx context.Context) (FinancialUserProfile, error) {
	to := FinancialUserProfile{}
	var err error
	if prehook, ok := interface{}(m).(FinancialUserProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.StripeCustomerId = m.StripeCustomerId
	if m.StripeSubscriptions != nil {
		tempStripeSubscriptions, err := m.StripeSubscriptions.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.StripeSubscriptions = &tempStripeSubscriptions
	}
	for _, v := range m.Link {
		if v != nil {
			if tempLink, cErr := v.ToPB(ctx); cErr == nil {
				to.Link = append(to.Link, &tempLink)
			} else {
				return to, cErr
			}
		} else {
			to.Link = append(to.Link, nil)
		}
	}
	for _, v := range m.ActionableInsights {
		if v != nil {
			if tempActionableInsights, cErr := v.ToPB(ctx); cErr == nil {
				to.ActionableInsights = append(to.ActionableInsights, &tempActionableInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionableInsights = append(to.ActionableInsights, nil)
		}
	}
	to.Email = m.Email
	for _, v := range m.MergeLiink {
		if v != nil {
			if tempMergeLiink, cErr := v.ToPB(ctx); cErr == nil {
				to.MergeLiink = append(to.MergeLiink, &tempMergeLiink)
			} else {
				return to, cErr
			}
		} else {
			to.MergeLiink = append(to.MergeLiink, nil)
		}
	}
	for _, v := range m.ActionablePersonalInsights {
		if v != nil {
			if tempActionablePersonalInsights, cErr := v.ToPB(ctx); cErr == nil {
				to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, &tempActionablePersonalInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, nil)
		}
	}
	to.ProfileType = FinancialUserProfileType(FinancialUserProfileType_value[m.ProfileType])
	if posthook, ok := interface{}(m).(FinancialUserProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FinancialUserProfile the arg will be the target, the caller the one being converted from

// FinancialUserProfileBeforeToORM called before default ToORM code
type FinancialUserProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *FinancialUserProfileORM) error
}

// FinancialUserProfileAfterToORM called after default ToORM code
type FinancialUserProfileWithAfterToORM interface {
	AfterToORM(context.Context, *FinancialUserProfileORM) error
}

// FinancialUserProfileBeforeToPB called before default ToPB code
type FinancialUserProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *FinancialUserProfile) error
}

// FinancialUserProfileAfterToPB called after default ToPB code
type FinancialUserProfileWithAfterToPB interface {
	AfterToPB(context.Context, *FinancialUserProfile) error
}

type ActionableInsightORM struct {
	DetailedAction         string
	FinancialUserProfileId *uint64
	GeneratedTime          *time.Time
	Id                     uint64
	SummarizedAction       string
	Tags                   pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (ActionableInsightORM) TableName() string {
	return "actionable_insights"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ActionableInsight) ToORM(ctx context.Context) (ActionableInsightORM, error) {
	to := ActionableInsightORM{}
	var err error
	if prehook, ok := interface{}(m).(ActionableInsightWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DetailedAction = m.DetailedAction
	to.SummarizedAction = m.SummarizedAction
	if m.GeneratedTime != nil {
		t := m.GeneratedTime.AsTime()
		to.GeneratedTime = &t
	}
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if posthook, ok := interface{}(m).(ActionableInsightWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ActionableInsightORM) ToPB(ctx context.Context) (ActionableInsight, error) {
	to := ActionableInsight{}
	var err error
	if prehook, ok := interface{}(m).(ActionableInsightWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DetailedAction = m.DetailedAction
	to.SummarizedAction = m.SummarizedAction
	if m.GeneratedTime != nil {
		to.GeneratedTime = timestamppb.New(*m.GeneratedTime)
	}
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if posthook, ok := interface{}(m).(ActionableInsightWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ActionableInsight the arg will be the target, the caller the one being converted from

// ActionableInsightBeforeToORM called before default ToORM code
type ActionableInsightWithBeforeToORM interface {
	BeforeToORM(context.Context, *ActionableInsightORM) error
}

// ActionableInsightAfterToORM called after default ToORM code
type ActionableInsightWithAfterToORM interface {
	AfterToORM(context.Context, *ActionableInsightORM) error
}

// ActionableInsightBeforeToPB called before default ToPB code
type ActionableInsightWithBeforeToPB interface {
	BeforeToPB(context.Context, *ActionableInsight) error
}

// ActionableInsightAfterToPB called after default ToPB code
type ActionableInsightWithAfterToPB interface {
	AfterToPB(context.Context, *ActionableInsight) error
}

type PersonalActionableInsightORM struct {
	Action                 string
	Description            string
	ExpectedBenefit        string
	FinancialUserProfileId *uint64
	GeneratedTime          *time.Time
	Id                     uint64
	InsightName            string
	MetricsToOptimizeFor   pq.StringArray `gorm:"type:text[]"`
	Tags                   pq.StringArray `gorm:"type:text[]"`
	Takeaway               string
}

// TableName overrides the default tablename generated by GORM
func (PersonalActionableInsightORM) TableName() string {
	return "personal_actionable_insights"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PersonalActionableInsight) ToORM(ctx context.Context) (PersonalActionableInsightORM, error) {
	to := PersonalActionableInsightORM{}
	var err error
	if prehook, ok := interface{}(m).(PersonalActionableInsightWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightName = PersonalActionableInsightName_name[int32(m.InsightName)]
	to.Description = m.Description
	to.Takeaway = m.Takeaway
	to.Action = m.Action
	to.ExpectedBenefit = m.ExpectedBenefit
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.GeneratedTime != nil {
		t := m.GeneratedTime.AsTime()
		to.GeneratedTime = &t
	}
	if m.MetricsToOptimizeFor != nil {
		to.MetricsToOptimizeFor = make(pq.StringArray, len(m.MetricsToOptimizeFor))
		copy(to.MetricsToOptimizeFor, m.MetricsToOptimizeFor)
	}
	if posthook, ok := interface{}(m).(PersonalActionableInsightWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PersonalActionableInsightORM) ToPB(ctx context.Context) (PersonalActionableInsight, error) {
	to := PersonalActionableInsight{}
	var err error
	if prehook, ok := interface{}(m).(PersonalActionableInsightWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightName = PersonalActionableInsightName(PersonalActionableInsightName_value[m.InsightName])
	to.Description = m.Description
	to.Takeaway = m.Takeaway
	to.Action = m.Action
	to.ExpectedBenefit = m.ExpectedBenefit
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.GeneratedTime != nil {
		to.GeneratedTime = timestamppb.New(*m.GeneratedTime)
	}
	if m.MetricsToOptimizeFor != nil {
		to.MetricsToOptimizeFor = make(pq.StringArray, len(m.MetricsToOptimizeFor))
		copy(to.MetricsToOptimizeFor, m.MetricsToOptimizeFor)
	}
	if posthook, ok := interface{}(m).(PersonalActionableInsightWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PersonalActionableInsight the arg will be the target, the caller the one being converted from

// PersonalActionableInsightBeforeToORM called before default ToORM code
type PersonalActionableInsightWithBeforeToORM interface {
	BeforeToORM(context.Context, *PersonalActionableInsightORM) error
}

// PersonalActionableInsightAfterToORM called after default ToORM code
type PersonalActionableInsightWithAfterToORM interface {
	AfterToORM(context.Context, *PersonalActionableInsightORM) error
}

// PersonalActionableInsightBeforeToPB called before default ToPB code
type PersonalActionableInsightWithBeforeToPB interface {
	BeforeToPB(context.Context, *PersonalActionableInsight) error
}

// PersonalActionableInsightAfterToPB called after default ToPB code
type PersonalActionableInsightWithAfterToPB interface {
	AfterToPB(context.Context, *PersonalActionableInsight) error
}

type LinkORM struct {
	BankAccounts              []*BankAccountORM   `gorm:"foreignkey:LinkId;association_foreignkey:Id"`
	CreditAccounts            []*CreditAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	CustomInstitutionName     string
	Description               string
	ErrorCode                 string
	ExpirationDate            string
	FinancialUserProfileId    *uint64
	Id                        uint64
	InstitutionName           string
	InvestmentAccounts        []*InvestmentAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	LastManualSync            string
	LastSuccessfulUpdate      string
	LinkStatus                string
	LinkType                  string
	MortgageAccounts          []*MortgageAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	NewAccountsAvailable      bool
	PlaidInstitutionId        string
	PlaidLink                 *PlaidLinkORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	PlaidNewAccountsAvailable bool
	PlaidSync                 *PlaidSyncORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	ShouldBeUpdated           bool
	StudentLoanAccounts       []*StudentLoanAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	Token                     *TokenORM                `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	UpdatedAt                 string
}

// TableName overrides the default tablename generated by GORM
func (LinkORM) TableName() string {
	return "links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Link) ToORM(ctx context.Context) (LinkORM, error) {
	to := LinkORM{}
	var err error
	if prehook, ok := interface{}(m).(LinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PlaidSync != nil {
		tempPlaidSync, err := m.PlaidSync.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidSync = &tempPlaidSync
	}
	to.LinkStatus = LinkStatus_name[int32(m.LinkStatus)]
	if m.PlaidLink != nil {
		tempPlaidLink, err := m.PlaidLink.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidLink = &tempPlaidLink
	}
	to.PlaidNewAccountsAvailable = m.PlaidNewAccountsAvailable
	to.ExpirationDate = m.ExpirationDate
	to.InstitutionName = m.InstitutionName
	to.CustomInstitutionName = m.CustomInstitutionName
	to.Description = m.Description
	to.LastManualSync = m.LastManualSync
	to.LastSuccessfulUpdate = m.LastSuccessfulUpdate
	if m.Token != nil {
		tempToken, err := m.Token.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	for _, v := range m.BankAccounts {
		if v != nil {
			if tempBankAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.BankAccounts = append(to.BankAccounts, &tempBankAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.BankAccounts = append(to.BankAccounts, nil)
		}
	}
	for _, v := range m.InvestmentAccounts {
		if v != nil {
			if tempInvestmentAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestmentAccounts = append(to.InvestmentAccounts, &tempInvestmentAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentAccounts = append(to.InvestmentAccounts, nil)
		}
	}
	for _, v := range m.CreditAccounts {
		if v != nil {
			if tempCreditAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.CreditAccounts = append(to.CreditAccounts, &tempCreditAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.CreditAccounts = append(to.CreditAccounts, nil)
		}
	}
	for _, v := range m.MortgageAccounts {
		if v != nil {
			if tempMortgageAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.MortgageAccounts = append(to.MortgageAccounts, &tempMortgageAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MortgageAccounts = append(to.MortgageAccounts, nil)
		}
	}
	for _, v := range m.StudentLoanAccounts {
		if v != nil {
			if tempStudentLoanAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.StudentLoanAccounts = append(to.StudentLoanAccounts, &tempStudentLoanAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.StudentLoanAccounts = append(to.StudentLoanAccounts, nil)
		}
	}
	to.PlaidInstitutionId = m.PlaidInstitutionId
	to.LinkType = LinkType_name[int32(m.LinkType)]
	to.ErrorCode = m.ErrorCode
	to.UpdatedAt = m.UpdatedAt
	to.NewAccountsAvailable = m.NewAccountsAvailable
	to.ShouldBeUpdated = m.ShouldBeUpdated
	if posthook, ok := interface{}(m).(LinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LinkORM) ToPB(ctx context.Context) (Link, error) {
	to := Link{}
	var err error
	if prehook, ok := interface{}(m).(LinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PlaidSync != nil {
		tempPlaidSync, err := m.PlaidSync.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidSync = &tempPlaidSync
	}
	to.LinkStatus = LinkStatus(LinkStatus_value[m.LinkStatus])
	if m.PlaidLink != nil {
		tempPlaidLink, err := m.PlaidLink.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidLink = &tempPlaidLink
	}
	to.PlaidNewAccountsAvailable = m.PlaidNewAccountsAvailable
	to.ExpirationDate = m.ExpirationDate
	to.InstitutionName = m.InstitutionName
	to.CustomInstitutionName = m.CustomInstitutionName
	to.Description = m.Description
	to.LastManualSync = m.LastManualSync
	to.LastSuccessfulUpdate = m.LastSuccessfulUpdate
	if m.Token != nil {
		tempToken, err := m.Token.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	for _, v := range m.BankAccounts {
		if v != nil {
			if tempBankAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.BankAccounts = append(to.BankAccounts, &tempBankAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.BankAccounts = append(to.BankAccounts, nil)
		}
	}
	for _, v := range m.InvestmentAccounts {
		if v != nil {
			if tempInvestmentAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestmentAccounts = append(to.InvestmentAccounts, &tempInvestmentAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentAccounts = append(to.InvestmentAccounts, nil)
		}
	}
	for _, v := range m.CreditAccounts {
		if v != nil {
			if tempCreditAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.CreditAccounts = append(to.CreditAccounts, &tempCreditAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.CreditAccounts = append(to.CreditAccounts, nil)
		}
	}
	for _, v := range m.MortgageAccounts {
		if v != nil {
			if tempMortgageAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.MortgageAccounts = append(to.MortgageAccounts, &tempMortgageAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MortgageAccounts = append(to.MortgageAccounts, nil)
		}
	}
	for _, v := range m.StudentLoanAccounts {
		if v != nil {
			if tempStudentLoanAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.StudentLoanAccounts = append(to.StudentLoanAccounts, &tempStudentLoanAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.StudentLoanAccounts = append(to.StudentLoanAccounts, nil)
		}
	}
	to.PlaidInstitutionId = m.PlaidInstitutionId
	to.LinkType = LinkType(LinkType_value[m.LinkType])
	to.ErrorCode = m.ErrorCode
	to.UpdatedAt = m.UpdatedAt
	to.NewAccountsAvailable = m.NewAccountsAvailable
	to.ShouldBeUpdated = m.ShouldBeUpdated
	if posthook, ok := interface{}(m).(LinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Link the arg will be the target, the caller the one being converted from

// LinkBeforeToORM called before default ToORM code
type LinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *LinkORM) error
}

// LinkAfterToORM called after default ToORM code
type LinkWithAfterToORM interface {
	AfterToORM(context.Context, *LinkORM) error
}

// LinkBeforeToPB called before default ToPB code
type LinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *Link) error
}

// LinkAfterToPB called after default ToPB code
type LinkWithAfterToPB interface {
	AfterToPB(context.Context, *Link) error
}

type PlaidSyncORM struct {
	Added      int64
	Id         uint64
	LinkId     *uint64
	Modified   int64
	NextCursor string
	Removed    int64
	TimeStamp  string
	Trigger    string
}

// TableName overrides the default tablename generated by GORM
func (PlaidSyncORM) TableName() string {
	return "plaid_syncs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidSync) ToORM(ctx context.Context) (PlaidSyncORM, error) {
	to := PlaidSyncORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidSyncWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TimeStamp = m.TimeStamp
	to.Trigger = m.Trigger
	to.NextCursor = m.NextCursor
	to.Added = m.Added
	to.Removed = m.Removed
	to.Modified = m.Modified
	if posthook, ok := interface{}(m).(PlaidSyncWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidSyncORM) ToPB(ctx context.Context) (PlaidSync, error) {
	to := PlaidSync{}
	var err error
	if prehook, ok := interface{}(m).(PlaidSyncWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TimeStamp = m.TimeStamp
	to.Trigger = m.Trigger
	to.NextCursor = m.NextCursor
	to.Added = m.Added
	to.Removed = m.Removed
	to.Modified = m.Modified
	if posthook, ok := interface{}(m).(PlaidSyncWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidSync the arg will be the target, the caller the one being converted from

// PlaidSyncBeforeToORM called before default ToORM code
type PlaidSyncWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidSyncORM) error
}

// PlaidSyncAfterToORM called after default ToORM code
type PlaidSyncWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidSyncORM) error
}

// PlaidSyncBeforeToPB called before default ToPB code
type PlaidSyncWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidSync) error
}

// PlaidSyncAfterToPB called after default ToPB code
type PlaidSyncWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidSync) error
}

type TokenORM struct {
	AccessToken          string
	Id                   uint64
	ItemId               string
	KeyId                string
	LastMergeCreatedAt   *time.Time
	LinkId               *uint64
	MergeEndUserOriginId string
	MergeIntegrationSlug string
	MergeLinkId          *uint64
	Version              string
}

// TableName overrides the default tablename generated by GORM
func (TokenORM) TableName() string {
	return "tokens"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Token) ToORM(ctx context.Context) (TokenORM, error) {
	to := TokenORM{}
	var err error
	if prehook, ok := interface{}(m).(TokenWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ItemId = m.ItemId
	to.KeyId = m.KeyId
	to.AccessToken = m.AccessToken
	to.Version = m.Version
	to.MergeEndUserOriginId = m.MergeEndUserOriginId
	to.MergeIntegrationSlug = m.MergeIntegrationSlug
	if m.LastMergeCreatedAt != nil {
		t := m.LastMergeCreatedAt.AsTime()
		to.LastMergeCreatedAt = &t
	}
	if posthook, ok := interface{}(m).(TokenWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TokenORM) ToPB(ctx context.Context) (Token, error) {
	to := Token{}
	var err error
	if prehook, ok := interface{}(m).(TokenWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ItemId = m.ItemId
	to.KeyId = m.KeyId
	to.AccessToken = m.AccessToken
	to.Version = m.Version
	to.MergeEndUserOriginId = m.MergeEndUserOriginId
	to.MergeIntegrationSlug = m.MergeIntegrationSlug
	if m.LastMergeCreatedAt != nil {
		to.LastMergeCreatedAt = timestamppb.New(*m.LastMergeCreatedAt)
	}
	if posthook, ok := interface{}(m).(TokenWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Token the arg will be the target, the caller the one being converted from

// TokenBeforeToORM called before default ToORM code
type TokenWithBeforeToORM interface {
	BeforeToORM(context.Context, *TokenORM) error
}

// TokenAfterToORM called after default ToORM code
type TokenWithAfterToORM interface {
	AfterToORM(context.Context, *TokenORM) error
}

// TokenBeforeToPB called before default ToPB code
type TokenWithBeforeToPB interface {
	BeforeToPB(context.Context, *Token) error
}

// TokenAfterToPB called after default ToPB code
type TokenWithAfterToPB interface {
	AfterToPB(context.Context, *Token) error
}

type PlaidLinkORM struct {
	Id              uint64
	InstitutionId   string
	InstitutionName string
	ItemId          string
	LinkId          *uint64
	Products        pq.StringArray `gorm:"type:text[]"`
	UsePlaidSync    bool
	WebhookUrl      string
}

// TableName overrides the default tablename generated by GORM
func (PlaidLinkORM) TableName() string {
	return "plaid_links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidLink) ToORM(ctx context.Context) (PlaidLinkORM, error) {
	to := PlaidLinkORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidLinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Products != nil {
		to.Products = make(pq.StringArray, len(m.Products))
		copy(to.Products, m.Products)
	}
	to.WebhookUrl = m.WebhookUrl
	to.InstitutionId = m.InstitutionId
	to.InstitutionName = m.InstitutionName
	to.UsePlaidSync = m.UsePlaidSync
	to.ItemId = m.ItemId
	if posthook, ok := interface{}(m).(PlaidLinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidLinkORM) ToPB(ctx context.Context) (PlaidLink, error) {
	to := PlaidLink{}
	var err error
	if prehook, ok := interface{}(m).(PlaidLinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Products != nil {
		to.Products = make(pq.StringArray, len(m.Products))
		copy(to.Products, m.Products)
	}
	to.WebhookUrl = m.WebhookUrl
	to.InstitutionId = m.InstitutionId
	to.InstitutionName = m.InstitutionName
	to.UsePlaidSync = m.UsePlaidSync
	to.ItemId = m.ItemId
	if posthook, ok := interface{}(m).(PlaidLinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidLink the arg will be the target, the caller the one being converted from

// PlaidLinkBeforeToORM called before default ToORM code
type PlaidLinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidLinkORM) error
}

// PlaidLinkAfterToORM called after default ToORM code
type PlaidLinkWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidLinkORM) error
}

// PlaidLinkBeforeToPB called before default ToPB code
type PlaidLinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidLink) error
}

// PlaidLinkAfterToPB called after default ToPB code
type PlaidLinkWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidLink) error
}

type StudentLoanAccountORM struct {
	DisbursementDates                  pq.StringArray `gorm:"type:text[]"`
	ExpectedPayoffDate                 string
	Guarantor                          string
	Id                                 uint64
	InterestRatePercentage             float64
	IsOverdue                          bool
	LastPaymentAmount                  float64
	LastPaymentDate                    string
	LastStatementIssueDate             string
	LinkId                             *uint64
	LoanEndDate                        string
	LoanName                           string
	LoanType                           string
	MinimumPaymentAmount               float64
	Name                               string
	NextPaymentDueDate                 string
	OriginationDate                    string
	OriginationPrincipalAmount         float64
	OutstandingInterestAmount          float64
	PaymentReferenceNumber             string
	PlaidAccountId                     string
	PslfStatusEstimatedEligibilityDate string
	PslfStatusPaymentsMade             int32
	PslfStatusPaymentsRemaining        int32
	RepaymentPlanDescription           string
	RepaymentPlanType                  string
	SequenceNumber                     string
	ServicerAddressCity                string
	ServicerAddressCountry             string
	ServicerAddressPostalCode          string
	ServicerAddressRegion              string
	ServicerAddressState               string
	ServicerAddressStreet              string
	Status                             string
	UserId                             uint64
	YtdInterestPaid                    float64
	YtdPrincipalPaid                   float64
}

// TableName overrides the default tablename generated by GORM
func (StudentLoanAccountORM) TableName() string {
	return "student_loan_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StudentLoanAccount) ToORM(ctx context.Context) (StudentLoanAccountORM, error) {
	to := StudentLoanAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(StudentLoanAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	if m.DisbursementDates != nil {
		to.DisbursementDates = make(pq.StringArray, len(m.DisbursementDates))
		copy(to.DisbursementDates, m.DisbursementDates)
	}
	to.ExpectedPayoffDate = m.ExpectedPayoffDate
	to.Guarantor = m.Guarantor
	to.InterestRatePercentage = m.InterestRatePercentage
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.LoanName = m.LoanName
	to.LoanEndDate = m.LoanEndDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.OutstandingInterestAmount = m.OutstandingInterestAmount
	to.PaymentReferenceNumber = m.PaymentReferenceNumber
	to.SequenceNumber = m.SequenceNumber
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.LoanType = m.LoanType
	to.PslfStatusEstimatedEligibilityDate = m.PslfStatusEstimatedEligibilityDate
	to.PslfStatusPaymentsMade = m.PslfStatusPaymentsMade
	to.PslfStatusPaymentsRemaining = m.PslfStatusPaymentsRemaining
	to.RepaymentPlanType = m.RepaymentPlanType
	to.RepaymentPlanDescription = m.RepaymentPlanDescription
	to.ServicerAddressCity = m.ServicerAddressCity
	to.ServicerAddressPostalCode = m.ServicerAddressPostalCode
	to.ServicerAddressState = m.ServicerAddressState
	to.ServicerAddressStreet = m.ServicerAddressStreet
	to.ServicerAddressRegion = m.ServicerAddressRegion
	to.ServicerAddressCountry = m.ServicerAddressCountry
	to.UserId = m.UserId
	to.Name = m.Name
	to.Status = BankAccountStatus_name[int32(m.Status)]
	if posthook, ok := interface{}(m).(StudentLoanAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StudentLoanAccountORM) ToPB(ctx context.Context) (StudentLoanAccount, error) {
	to := StudentLoanAccount{}
	var err error
	if prehook, ok := interface{}(m).(StudentLoanAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	if m.DisbursementDates != nil {
		to.DisbursementDates = make(pq.StringArray, len(m.DisbursementDates))
		copy(to.DisbursementDates, m.DisbursementDates)
	}
	to.ExpectedPayoffDate = m.ExpectedPayoffDate
	to.Guarantor = m.Guarantor
	to.InterestRatePercentage = m.InterestRatePercentage
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.LoanName = m.LoanName
	to.LoanEndDate = m.LoanEndDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.OutstandingInterestAmount = m.OutstandingInterestAmount
	to.PaymentReferenceNumber = m.PaymentReferenceNumber
	to.SequenceNumber = m.SequenceNumber
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.LoanType = m.LoanType
	to.PslfStatusEstimatedEligibilityDate = m.PslfStatusEstimatedEligibilityDate
	to.PslfStatusPaymentsMade = m.PslfStatusPaymentsMade
	to.PslfStatusPaymentsRemaining = m.PslfStatusPaymentsRemaining
	to.RepaymentPlanType = m.RepaymentPlanType
	to.RepaymentPlanDescription = m.RepaymentPlanDescription
	to.ServicerAddressCity = m.ServicerAddressCity
	to.ServicerAddressPostalCode = m.ServicerAddressPostalCode
	to.ServicerAddressState = m.ServicerAddressState
	to.ServicerAddressStreet = m.ServicerAddressStreet
	to.ServicerAddressRegion = m.ServicerAddressRegion
	to.ServicerAddressCountry = m.ServicerAddressCountry
	to.UserId = m.UserId
	to.Name = m.Name
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	if posthook, ok := interface{}(m).(StudentLoanAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StudentLoanAccount the arg will be the target, the caller the one being converted from

// StudentLoanAccountBeforeToORM called before default ToORM code
type StudentLoanAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *StudentLoanAccountORM) error
}

// StudentLoanAccountAfterToORM called after default ToORM code
type StudentLoanAccountWithAfterToORM interface {
	AfterToORM(context.Context, *StudentLoanAccountORM) error
}

// StudentLoanAccountBeforeToPB called before default ToPB code
type StudentLoanAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *StudentLoanAccount) error
}

// StudentLoanAccountAfterToPB called after default ToPB code
type StudentLoanAccountWithAfterToPB interface {
	AfterToPB(context.Context, *StudentLoanAccount) error
}

type CreditAccountORM struct {
	Aprs                   []*AprORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Balance                float32
	BalanceLimit           uint64
	CurrentFunds           float64
	Id                     uint64
	IsOverdue              bool
	LastPaymentAmount      float64
	LastPaymentDate        string
	LastStatementBalance   float64
	LastStatementIssueDate string
	LinkId                 *uint64
	MinimumAmountDueDate   float64
	MinimumPaymentAmount   float64
	Name                   string
	NextPaymentDate        string
	NextPaymentDueDate     string
	Number                 string
	PlaidAccountId         string
	RecurringTransactions  []*PlaidAccountRecurringTransactionORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Status                 string
	Subtype                string
	Transactions           []*PlaidAccountTransactionORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Type                   string
	UserId                 uint64
}

// TableName overrides the default tablename generated by GORM
func (CreditAccountORM) TableName() string {
	return "credit_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditAccount) ToORM(ctx context.Context) (CreditAccountORM, error) {
	to := CreditAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.MinimumAmountDueDate = m.MinimumAmountDueDate
	to.NextPaymentDate = m.NextPaymentDate
	for _, v := range m.Aprs {
		if v != nil {
			if tempAprs, cErr := v.ToORM(ctx); cErr == nil {
				to.Aprs = append(to.Aprs, &tempAprs)
			} else {
				return to, cErr
			}
		} else {
			to.Aprs = append(to.Aprs, nil)
		}
	}
	to.LastStatementBalance = m.LastStatementBalance
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.Status = BankAccountStatus_name[int32(m.Status)]
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(CreditAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditAccountORM) ToPB(ctx context.Context) (CreditAccount, error) {
	to := CreditAccount{}
	var err error
	if prehook, ok := interface{}(m).(CreditAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.MinimumAmountDueDate = m.MinimumAmountDueDate
	to.NextPaymentDate = m.NextPaymentDate
	for _, v := range m.Aprs {
		if v != nil {
			if tempAprs, cErr := v.ToPB(ctx); cErr == nil {
				to.Aprs = append(to.Aprs, &tempAprs)
			} else {
				return to, cErr
			}
		} else {
			to.Aprs = append(to.Aprs, nil)
		}
	}
	to.LastStatementBalance = m.LastStatementBalance
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(CreditAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditAccount the arg will be the target, the caller the one being converted from

// CreditAccountBeforeToORM called before default ToORM code
type CreditAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditAccountORM) error
}

// CreditAccountAfterToORM called after default ToORM code
type CreditAccountWithAfterToORM interface {
	AfterToORM(context.Context, *CreditAccountORM) error
}

// CreditAccountBeforeToPB called before default ToPB code
type CreditAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditAccount) error
}

// CreditAccountAfterToPB called after default ToPB code
type CreditAccountWithAfterToPB interface {
	AfterToPB(context.Context, *CreditAccount) error
}

type MortgageAccountORM struct {
	AccountNumber               string
	CurrentLateFee              float64
	EscrowBalance               float64
	HasPmi                      bool
	HasPrepaymentPenalty        bool
	Id                          uint64
	InterestRatePercentage      float64
	InterestRateType            string
	LastPaymentAmount           float64
	LastPaymentDate             string
	LinkId                      *uint64
	LoanTerm                    string
	LoanTypeDescription         string
	MaturityDate                string
	NextMonthlyPayment          float64
	NextPaymentDueDate          string
	OriginalPrincipalBalance    float64
	OriginalPropertyValue       float64
	OriginationDate             string
	OriginationPrincipalAmount  float64
	OutstandingPrincipalBalance float64
	PastDueAmount               float64
	PaymentAmount               float64
	PaymentDate                 string
	PlaidAccountId              string
	PropertyAddressCity         string
	PropertyAddressPostalCode   string
	PropertyAddressState        string
	PropertyAddressStreet       string
	PropertyCountry             string
	PropertyRegion              string
	Status                      string
	YtdInterestPaid             float64
	YtdPrincipalPaid            float64
}

// TableName overrides the default tablename generated by GORM
func (MortgageAccountORM) TableName() string {
	return "mortgage_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MortgageAccount) ToORM(ctx context.Context) (MortgageAccountORM, error) {
	to := MortgageAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(MortgageAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	to.AccountNumber = m.AccountNumber
	to.CurrentLateFee = m.CurrentLateFee
	to.EscrowBalance = m.EscrowBalance
	to.HasPmi = m.HasPmi
	to.HasPrepaymentPenalty = m.HasPrepaymentPenalty
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LoanTerm = m.LoanTerm
	to.LoanTypeDescription = m.LoanTypeDescription
	to.MaturityDate = m.MaturityDate
	to.NextMonthlyPayment = m.NextMonthlyPayment
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginalPrincipalBalance = m.OriginalPrincipalBalance
	to.OriginalPropertyValue = m.OriginalPropertyValue
	to.OutstandingPrincipalBalance = m.OutstandingPrincipalBalance
	to.PaymentAmount = m.PaymentAmount
	to.PaymentDate = m.PaymentDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.PastDueAmount = m.PastDueAmount
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.PropertyAddressCity = m.PropertyAddressCity
	to.PropertyAddressState = m.PropertyAddressState
	to.PropertyAddressStreet = m.PropertyAddressStreet
	to.PropertyAddressPostalCode = m.PropertyAddressPostalCode
	to.PropertyRegion = m.PropertyRegion
	to.PropertyCountry = m.PropertyCountry
	to.InterestRatePercentage = m.InterestRatePercentage
	to.InterestRateType = m.InterestRateType
	to.Status = BankAccountStatus_name[int32(m.Status)]
	if posthook, ok := interface{}(m).(MortgageAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MortgageAccountORM) ToPB(ctx context.Context) (MortgageAccount, error) {
	to := MortgageAccount{}
	var err error
	if prehook, ok := interface{}(m).(MortgageAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	to.AccountNumber = m.AccountNumber
	to.CurrentLateFee = m.CurrentLateFee
	to.EscrowBalance = m.EscrowBalance
	to.HasPmi = m.HasPmi
	to.HasPrepaymentPenalty = m.HasPrepaymentPenalty
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LoanTerm = m.LoanTerm
	to.LoanTypeDescription = m.LoanTypeDescription
	to.MaturityDate = m.MaturityDate
	to.NextMonthlyPayment = m.NextMonthlyPayment
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginalPrincipalBalance = m.OriginalPrincipalBalance
	to.OriginalPropertyValue = m.OriginalPropertyValue
	to.OutstandingPrincipalBalance = m.OutstandingPrincipalBalance
	to.PaymentAmount = m.PaymentAmount
	to.PaymentDate = m.PaymentDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.PastDueAmount = m.PastDueAmount
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.PropertyAddressCity = m.PropertyAddressCity
	to.PropertyAddressState = m.PropertyAddressState
	to.PropertyAddressStreet = m.PropertyAddressStreet
	to.PropertyAddressPostalCode = m.PropertyAddressPostalCode
	to.PropertyRegion = m.PropertyRegion
	to.PropertyCountry = m.PropertyCountry
	to.InterestRatePercentage = m.InterestRatePercentage
	to.InterestRateType = m.InterestRateType
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	if posthook, ok := interface{}(m).(MortgageAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MortgageAccount the arg will be the target, the caller the one being converted from

// MortgageAccountBeforeToORM called before default ToORM code
type MortgageAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *MortgageAccountORM) error
}

// MortgageAccountAfterToORM called after default ToORM code
type MortgageAccountWithAfterToORM interface {
	AfterToORM(context.Context, *MortgageAccountORM) error
}

// MortgageAccountBeforeToPB called before default ToPB code
type MortgageAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *MortgageAccount) error
}

// MortgageAccountAfterToPB called after default ToPB code
type MortgageAccountWithAfterToPB interface {
	AfterToPB(context.Context, *MortgageAccount) error
}

type InvestmentAccountORM struct {
	Balance        float32
	BalanceLimit   uint64
	CurrentFunds   float64
	Holdings       []*InvesmentHoldingORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Id             uint64
	LinkId         *uint64
	Name           string
	Number         string
	PlaidAccountId string
	Securities     []*InvestmentSecurityORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Status         string
	Subtype        string
	Transactions   []*PlaidAccountInvestmentTransactionORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Type           string
	UserId         uint64
}

// TableName overrides the default tablename generated by GORM
func (InvestmentAccountORM) TableName() string {
	return "investment_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentAccount) ToORM(ctx context.Context) (InvestmentAccountORM, error) {
	to := InvestmentAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	for _, v := range m.Holdings {
		if v != nil {
			if tempHoldings, cErr := v.ToORM(ctx); cErr == nil {
				to.Holdings = append(to.Holdings, &tempHoldings)
			} else {
				return to, cErr
			}
		} else {
			to.Holdings = append(to.Holdings, nil)
		}
	}
	for _, v := range m.Securities {
		if v != nil {
			if tempSecurities, cErr := v.ToORM(ctx); cErr == nil {
				to.Securities = append(to.Securities, &tempSecurities)
			} else {
				return to, cErr
			}
		} else {
			to.Securities = append(to.Securities, nil)
		}
	}
	to.Status = BankAccountStatus_name[int32(m.Status)]
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestmentAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentAccountORM) ToPB(ctx context.Context) (InvestmentAccount, error) {
	to := InvestmentAccount{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	for _, v := range m.Holdings {
		if v != nil {
			if tempHoldings, cErr := v.ToPB(ctx); cErr == nil {
				to.Holdings = append(to.Holdings, &tempHoldings)
			} else {
				return to, cErr
			}
		} else {
			to.Holdings = append(to.Holdings, nil)
		}
	}
	for _, v := range m.Securities {
		if v != nil {
			if tempSecurities, cErr := v.ToPB(ctx); cErr == nil {
				to.Securities = append(to.Securities, &tempSecurities)
			} else {
				return to, cErr
			}
		} else {
			to.Securities = append(to.Securities, nil)
		}
	}
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestmentAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentAccount the arg will be the target, the caller the one being converted from

// InvestmentAccountBeforeToORM called before default ToORM code
type InvestmentAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentAccountORM) error
}

// InvestmentAccountAfterToORM called after default ToORM code
type InvestmentAccountWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentAccountORM) error
}

// InvestmentAccountBeforeToPB called before default ToPB code
type InvestmentAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentAccount) error
}

// InvestmentAccountAfterToPB called after default ToPB code
type InvestmentAccountWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentAccount) error
}

type BankAccountORM struct {
	Balance               float32
	BalanceLimit          uint64
	Currency              string
	CurrentFunds          float64
	Id                    uint64
	LinkId                *uint64
	Name                  string
	Number                string
	PlaidAccountId        string
	Pockets               []*PocketORM                           `gorm:"foreignkey:BankAccountId;association_foreignkey:Id;preload:true"`
	RecurringTransactions []*PlaidAccountRecurringTransactionORM `gorm:"foreignkey:BankAccountId;association_foreignkey:Id;preload:true"`
	Status                string
	Subtype               string
	Transactions          []*PlaidAccountTransactionORM `gorm:"foreignkey:BankAccountId;association_foreignkey:Id;preload:true"`
	Type                  string
	UserId                uint64
}

// TableName overrides the default tablename generated by GORM
func (BankAccountORM) TableName() string {
	return "bank_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BankAccount) ToORM(ctx context.Context) (BankAccountORM, error) {
	to := BankAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BankAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = BankAccountType_name[int32(m.Type)]
	to.Balance = m.Balance
	to.Currency = m.Currency
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	for _, v := range m.Pockets {
		if v != nil {
			if tempPockets, cErr := v.ToORM(ctx); cErr == nil {
				to.Pockets = append(to.Pockets, &tempPockets)
			} else {
				return to, cErr
			}
		} else {
			to.Pockets = append(to.Pockets, nil)
		}
	}
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.Status = BankAccountStatus_name[int32(m.Status)]
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(BankAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BankAccountORM) ToPB(ctx context.Context) (BankAccount, error) {
	to := BankAccount{}
	var err error
	if prehook, ok := interface{}(m).(BankAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = BankAccountType(BankAccountType_value[m.Type])
	to.Balance = m.Balance
	to.Currency = m.Currency
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	for _, v := range m.Pockets {
		if v != nil {
			if tempPockets, cErr := v.ToPB(ctx); cErr == nil {
				to.Pockets = append(to.Pockets, &tempPockets)
			} else {
				return to, cErr
			}
		} else {
			to.Pockets = append(to.Pockets, nil)
		}
	}
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(BankAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BankAccount the arg will be the target, the caller the one being converted from

// BankAccountBeforeToORM called before default ToORM code
type BankAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BankAccountORM) error
}

// BankAccountAfterToORM called after default ToORM code
type BankAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BankAccountORM) error
}

// BankAccountBeforeToPB called before default ToPB code
type BankAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BankAccount) error
}

// BankAccountAfterToPB called after default ToPB code
type BankAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BankAccount) error
}

type PocketORM struct {
	BankAccountId *uint64
	Goals         []*SmartGoalORM `gorm:"foreignkey:PocketId;association_foreignkey:Id;preload:true"`
	Id            uint64
	Type          string
}

// TableName overrides the default tablename generated by GORM
func (PocketORM) TableName() string {
	return "pockets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Pocket) ToORM(ctx context.Context) (PocketORM, error) {
	to := PocketORM{}
	var err error
	if prehook, ok := interface{}(m).(PocketWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Goals {
		if v != nil {
			if tempGoals, cErr := v.ToORM(ctx); cErr == nil {
				to.Goals = append(to.Goals, &tempGoals)
			} else {
				return to, cErr
			}
		} else {
			to.Goals = append(to.Goals, nil)
		}
	}
	to.Type = PocketType_name[int32(m.Type)]
	if posthook, ok := interface{}(m).(PocketWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PocketORM) ToPB(ctx context.Context) (Pocket, error) {
	to := Pocket{}
	var err error
	if prehook, ok := interface{}(m).(PocketWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Goals {
		if v != nil {
			if tempGoals, cErr := v.ToPB(ctx); cErr == nil {
				to.Goals = append(to.Goals, &tempGoals)
			} else {
				return to, cErr
			}
		} else {
			to.Goals = append(to.Goals, nil)
		}
	}
	to.Type = PocketType(PocketType_value[m.Type])
	if posthook, ok := interface{}(m).(PocketWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Pocket the arg will be the target, the caller the one being converted from

// PocketBeforeToORM called before default ToORM code
type PocketWithBeforeToORM interface {
	BeforeToORM(context.Context, *PocketORM) error
}

// PocketAfterToORM called after default ToORM code
type PocketWithAfterToORM interface {
	AfterToORM(context.Context, *PocketORM) error
}

// PocketBeforeToPB called before default ToPB code
type PocketWithBeforeToPB interface {
	BeforeToPB(context.Context, *Pocket) error
}

// PocketAfterToPB called after default ToPB code
type PocketWithAfterToPB interface {
	AfterToPB(context.Context, *Pocket) error
}

type SmartGoalORM struct {
	CurrentAmount string
	Description   string
	Duration      string
	EndDate       string
	Forecasts     *ForecastORM `gorm:"foreignkey:SmartGoalId;association_foreignkey:Id;preload:true"`
	GoalType      string
	Id            uint64
	IsCompleted   bool
	Milestones    []*MilestoneORM `gorm:"foreignkey:SmartGoalId;association_foreignkey:Id;preload:true"`
	Name          string
	Notes         []*SmartNoteORM `gorm:"foreignkey:SmartGoalId;association_foreignkey:Id;preload:true"`
	PocketId      *uint64
	StartDate     string
	TargetAmount  string
	UserId        uint64
}

// TableName overrides the default tablename generated by GORM
func (SmartGoalORM) TableName() string {
	return "smart_goals"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SmartGoal) ToORM(ctx context.Context) (SmartGoalORM, error) {
	to := SmartGoalORM{}
	var err error
	if prehook, ok := interface{}(m).(SmartGoalWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Description = m.Description
	to.IsCompleted = m.IsCompleted
	to.GoalType = GoalType_name[int32(m.GoalType)]
	to.Duration = m.Duration
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	to.TargetAmount = m.TargetAmount
	to.CurrentAmount = m.CurrentAmount
	for _, v := range m.Milestones {
		if v != nil {
			if tempMilestones, cErr := v.ToORM(ctx); cErr == nil {
				to.Milestones = append(to.Milestones, &tempMilestones)
			} else {
				return to, cErr
			}
		} else {
			to.Milestones = append(to.Milestones, nil)
		}
	}
	if m.Forecasts != nil {
		tempForecasts, err := m.Forecasts.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Forecasts = &tempForecasts
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(SmartGoalWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SmartGoalORM) ToPB(ctx context.Context) (SmartGoal, error) {
	to := SmartGoal{}
	var err error
	if prehook, ok := interface{}(m).(SmartGoalWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Description = m.Description
	to.IsCompleted = m.IsCompleted
	to.GoalType = GoalType(GoalType_value[m.GoalType])
	to.Duration = m.Duration
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	to.TargetAmount = m.TargetAmount
	to.CurrentAmount = m.CurrentAmount
	for _, v := range m.Milestones {
		if v != nil {
			if tempMilestones, cErr := v.ToPB(ctx); cErr == nil {
				to.Milestones = append(to.Milestones, &tempMilestones)
			} else {
				return to, cErr
			}
		} else {
			to.Milestones = append(to.Milestones, nil)
		}
	}
	if m.Forecasts != nil {
		tempForecasts, err := m.Forecasts.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Forecasts = &tempForecasts
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(SmartGoalWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SmartGoal the arg will be the target, the caller the one being converted from

// SmartGoalBeforeToORM called before default ToORM code
type SmartGoalWithBeforeToORM interface {
	BeforeToORM(context.Context, *SmartGoalORM) error
}

// SmartGoalAfterToORM called after default ToORM code
type SmartGoalWithAfterToORM interface {
	AfterToORM(context.Context, *SmartGoalORM) error
}

// SmartGoalBeforeToPB called before default ToPB code
type SmartGoalWithBeforeToPB interface {
	BeforeToPB(context.Context, *SmartGoal) error
}

// SmartGoalAfterToPB called after default ToPB code
type SmartGoalWithAfterToPB interface {
	AfterToPB(context.Context, *SmartGoal) error
}

type SmartNoteORM struct {
	Content                             string
	CreatedAt                           *time.Time
	Id                                  uint64
	PlaidAccountInvestmentTransactionId *uint64
	PlaidAccountRecurringTransactionId  *uint64
	PlaidAccountTransactionId           *uint64
	SmartGoalId                         *uint64
	UpdatedAt                           *time.Time
	UserId                              uint64
}

// TableName overrides the default tablename generated by GORM
func (SmartNoteORM) TableName() string {
	return "smart_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SmartNote) ToORM(ctx context.Context) (SmartNoteORM, error) {
	to := SmartNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(SmartNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Content = m.Content
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(SmartNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SmartNoteORM) ToPB(ctx context.Context) (SmartNote, error) {
	to := SmartNote{}
	var err error
	if prehook, ok := interface{}(m).(SmartNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Content = m.Content
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(SmartNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SmartNote the arg will be the target, the caller the one being converted from

// SmartNoteBeforeToORM called before default ToORM code
type SmartNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *SmartNoteORM) error
}

// SmartNoteAfterToORM called after default ToORM code
type SmartNoteWithAfterToORM interface {
	AfterToORM(context.Context, *SmartNoteORM) error
}

// SmartNoteBeforeToPB called before default ToPB code
type SmartNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *SmartNote) error
}

// SmartNoteAfterToPB called after default ToPB code
type SmartNoteWithAfterToPB interface {
	AfterToPB(context.Context, *SmartNote) error
}

type ForecastORM struct {
	ForecastedAmount         string
	ForecastedCompletionDate string
	Id                       uint64
	SmartGoalId              *uint64
	VarianceAmount           string
}

// TableName overrides the default tablename generated by GORM
func (ForecastORM) TableName() string {
	return "forecasts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Forecast) ToORM(ctx context.Context) (ForecastORM, error) {
	to := ForecastORM{}
	var err error
	if prehook, ok := interface{}(m).(ForecastWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ForecastedAmount = m.ForecastedAmount
	to.ForecastedCompletionDate = m.ForecastedCompletionDate
	to.VarianceAmount = m.VarianceAmount
	if posthook, ok := interface{}(m).(ForecastWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ForecastORM) ToPB(ctx context.Context) (Forecast, error) {
	to := Forecast{}
	var err error
	if prehook, ok := interface{}(m).(ForecastWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ForecastedAmount = m.ForecastedAmount
	to.ForecastedCompletionDate = m.ForecastedCompletionDate
	to.VarianceAmount = m.VarianceAmount
	if posthook, ok := interface{}(m).(ForecastWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Forecast the arg will be the target, the caller the one being converted from

// ForecastBeforeToORM called before default ToORM code
type ForecastWithBeforeToORM interface {
	BeforeToORM(context.Context, *ForecastORM) error
}

// ForecastAfterToORM called after default ToORM code
type ForecastWithAfterToORM interface {
	AfterToORM(context.Context, *ForecastORM) error
}

// ForecastBeforeToPB called before default ToPB code
type ForecastWithBeforeToPB interface {
	BeforeToPB(context.Context, *Forecast) error
}

// ForecastAfterToPB called after default ToPB code
type ForecastWithAfterToPB interface {
	AfterToPB(context.Context, *Forecast) error
}

type MilestoneORM struct {
	Budget       *BudgetORM `gorm:"foreignkey:MilestoneId;association_foreignkey:Id"`
	Description  string
	Id           uint64
	IsCompleted  bool
	Name         string
	SmartGoalId  *uint64
	TargetAmount string
	TargetDate   string
}

// TableName overrides the default tablename generated by GORM
func (MilestoneORM) TableName() string {
	return "milestones"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Milestone) ToORM(ctx context.Context) (MilestoneORM, error) {
	to := MilestoneORM{}
	var err error
	if prehook, ok := interface{}(m).(MilestoneWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.TargetDate = m.TargetDate
	to.TargetAmount = m.TargetAmount
	to.IsCompleted = m.IsCompleted
	if m.Budget != nil {
		tempBudget, err := m.Budget.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Budget = &tempBudget
	}
	if posthook, ok := interface{}(m).(MilestoneWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MilestoneORM) ToPB(ctx context.Context) (Milestone, error) {
	to := Milestone{}
	var err error
	if prehook, ok := interface{}(m).(MilestoneWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.TargetDate = m.TargetDate
	to.TargetAmount = m.TargetAmount
	to.IsCompleted = m.IsCompleted
	if m.Budget != nil {
		tempBudget, err := m.Budget.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Budget = &tempBudget
	}
	if posthook, ok := interface{}(m).(MilestoneWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Milestone the arg will be the target, the caller the one being converted from

// MilestoneBeforeToORM called before default ToORM code
type MilestoneWithBeforeToORM interface {
	BeforeToORM(context.Context, *MilestoneORM) error
}

// MilestoneAfterToORM called after default ToORM code
type MilestoneWithAfterToORM interface {
	AfterToORM(context.Context, *MilestoneORM) error
}

// MilestoneBeforeToPB called before default ToPB code
type MilestoneWithBeforeToPB interface {
	BeforeToPB(context.Context, *Milestone) error
}

// MilestoneAfterToPB called after default ToPB code
type MilestoneWithAfterToPB interface {
	AfterToPB(context.Context, *Milestone) error
}

type BudgetORM struct {
	Category    *CategoryORM `gorm:"foreignkey:BudgetId;association_foreignkey:Id;preload:true"`
	Description string
	EndDate     string
	Id          uint64
	MilestoneId *uint64
	Name        string
	StartDate   string
}

// TableName overrides the default tablename generated by GORM
func (BudgetORM) TableName() string {
	return "budgets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Budget) ToORM(ctx context.Context) (BudgetORM, error) {
	to := BudgetORM{}
	var err error
	if prehook, ok := interface{}(m).(BudgetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	if m.Category != nil {
		tempCategory, err := m.Category.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Category = &tempCategory
	}
	if posthook, ok := interface{}(m).(BudgetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BudgetORM) ToPB(ctx context.Context) (Budget, error) {
	to := Budget{}
	var err error
	if prehook, ok := interface{}(m).(BudgetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	if m.Category != nil {
		tempCategory, err := m.Category.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Category = &tempCategory
	}
	if posthook, ok := interface{}(m).(BudgetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Budget the arg will be the target, the caller the one being converted from

// BudgetBeforeToORM called before default ToORM code
type BudgetWithBeforeToORM interface {
	BeforeToORM(context.Context, *BudgetORM) error
}

// BudgetAfterToORM called after default ToORM code
type BudgetWithAfterToORM interface {
	AfterToORM(context.Context, *BudgetORM) error
}

// BudgetBeforeToPB called before default ToPB code
type BudgetWithBeforeToPB interface {
	BeforeToPB(context.Context, *Budget) error
}

// BudgetAfterToPB called after default ToPB code
type BudgetWithAfterToPB interface {
	AfterToPB(context.Context, *Budget) error
}

type CategoryORM struct {
	BudgetId      *uint64
	Description   string
	Id            uint64
	Name          string
	Subcategories pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (CategoryORM) TableName() string {
	return "categories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Category) ToORM(ctx context.Context) (CategoryORM, error) {
	to := CategoryORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if m.Subcategories != nil {
		to.Subcategories = make(pq.StringArray, len(m.Subcategories))
		copy(to.Subcategories, m.Subcategories)
	}
	if posthook, ok := interface{}(m).(CategoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryORM) ToPB(ctx context.Context) (Category, error) {
	to := Category{}
	var err error
	if prehook, ok := interface{}(m).(CategoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if m.Subcategories != nil {
		to.Subcategories = make(pq.StringArray, len(m.Subcategories))
		copy(to.Subcategories, m.Subcategories)
	}
	if posthook, ok := interface{}(m).(CategoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Category the arg will be the target, the caller the one being converted from

// CategoryBeforeToORM called before default ToORM code
type CategoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryORM) error
}

// CategoryAfterToORM called after default ToORM code
type CategoryWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryORM) error
}

// CategoryBeforeToPB called before default ToPB code
type CategoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *Category) error
}

// CategoryAfterToPB called after default ToPB code
type CategoryWithAfterToPB interface {
	AfterToPB(context.Context, *Category) error
}

type InvesmentHoldingORM struct {
	CostBasis                float64
	Id                       uint64
	InstitutionPrice         float64
	InstitutionPriceAsOf     string
	InstitutionPriceDatetime string
	InstitutionValue         float64
	InvestmentAccountId      *uint64
	IsoCurrencyCode          string
	Name                     string
	PlaidAccountId           string
	Quantity                 float64
	SecurityId               string
	UnofficialCurrencyCode   string
}

// TableName overrides the default tablename generated by GORM
func (InvesmentHoldingORM) TableName() string {
	return "invesment_holdings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvesmentHolding) ToORM(ctx context.Context) (InvesmentHoldingORM, error) {
	to := InvesmentHoldingORM{}
	var err error
	if prehook, ok := interface{}(m).(InvesmentHoldingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.PlaidAccountId = m.PlaidAccountId
	to.CostBasis = m.CostBasis
	to.InstitutionPrice = m.InstitutionPrice
	to.InstitutionPriceAsOf = m.InstitutionPriceAsOf
	to.InstitutionPriceDatetime = m.InstitutionPriceDatetime
	to.InstitutionValue = m.InstitutionValue
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Quantity = m.Quantity
	to.SecurityId = m.SecurityId
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	if posthook, ok := interface{}(m).(InvesmentHoldingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvesmentHoldingORM) ToPB(ctx context.Context) (InvesmentHolding, error) {
	to := InvesmentHolding{}
	var err error
	if prehook, ok := interface{}(m).(InvesmentHoldingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.PlaidAccountId = m.PlaidAccountId
	to.CostBasis = m.CostBasis
	to.InstitutionPrice = m.InstitutionPrice
	to.InstitutionPriceAsOf = m.InstitutionPriceAsOf
	to.InstitutionPriceDatetime = m.InstitutionPriceDatetime
	to.InstitutionValue = m.InstitutionValue
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Quantity = m.Quantity
	to.SecurityId = m.SecurityId
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	if posthook, ok := interface{}(m).(InvesmentHoldingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvesmentHolding the arg will be the target, the caller the one being converted from

// InvesmentHoldingBeforeToORM called before default ToORM code
type InvesmentHoldingWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvesmentHoldingORM) error
}

// InvesmentHoldingAfterToORM called after default ToORM code
type InvesmentHoldingWithAfterToORM interface {
	AfterToORM(context.Context, *InvesmentHoldingORM) error
}

// InvesmentHoldingBeforeToPB called before default ToPB code
type InvesmentHoldingWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvesmentHolding) error
}

// InvesmentHoldingAfterToPB called after default ToPB code
type InvesmentHoldingWithAfterToPB interface {
	AfterToPB(context.Context, *InvesmentHolding) error
}

type InvestmentSecurityORM struct {
	ClosePrice             float64
	ClosePriceAsOf         string
	Cusip                  string
	Id                     uint64
	InstitutionId          string
	InstitutionSecurityId  string
	InvestmentAccountId    *uint64
	IsCashEquivalent       bool
	Isin                   string
	IsoCurrencyCode        string
	Name                   string
	ProxySecurityId        string
	SecurityId             string
	Sedol                  string
	TickerSymbol           string
	Type                   string
	UnofficialCurrencyCode string
	UpdateDatetime         string
}

// TableName overrides the default tablename generated by GORM
func (InvestmentSecurityORM) TableName() string {
	return "investment_securities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentSecurity) ToORM(ctx context.Context) (InvestmentSecurityORM, error) {
	to := InvestmentSecurityORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentSecurityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ClosePrice = m.ClosePrice
	to.ClosePriceAsOf = m.ClosePriceAsOf
	to.Cusip = m.Cusip
	to.InstitutionId = m.InstitutionId
	to.InstitutionSecurityId = m.InstitutionSecurityId
	to.IsCashEquivalent = m.IsCashEquivalent
	to.Isin = m.Isin
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Name = m.Name
	to.ProxySecurityId = m.ProxySecurityId
	to.SecurityId = m.SecurityId
	to.Sedol = m.Sedol
	to.TickerSymbol = m.TickerSymbol
	to.Type = m.Type
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.UpdateDatetime = m.UpdateDatetime
	if posthook, ok := interface{}(m).(InvestmentSecurityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentSecurityORM) ToPB(ctx context.Context) (InvestmentSecurity, error) {
	to := InvestmentSecurity{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentSecurityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ClosePrice = m.ClosePrice
	to.ClosePriceAsOf = m.ClosePriceAsOf
	to.Cusip = m.Cusip
	to.InstitutionId = m.InstitutionId
	to.InstitutionSecurityId = m.InstitutionSecurityId
	to.IsCashEquivalent = m.IsCashEquivalent
	to.Isin = m.Isin
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Name = m.Name
	to.ProxySecurityId = m.ProxySecurityId
	to.SecurityId = m.SecurityId
	to.Sedol = m.Sedol
	to.TickerSymbol = m.TickerSymbol
	to.Type = m.Type
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.UpdateDatetime = m.UpdateDatetime
	if posthook, ok := interface{}(m).(InvestmentSecurityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentSecurity the arg will be the target, the caller the one being converted from

// InvestmentSecurityBeforeToORM called before default ToORM code
type InvestmentSecurityWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentSecurityORM) error
}

// InvestmentSecurityAfterToORM called after default ToORM code
type InvestmentSecurityWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentSecurityORM) error
}

// InvestmentSecurityBeforeToPB called before default ToPB code
type InvestmentSecurityWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentSecurity) error
}

// InvestmentSecurityAfterToPB called after default ToPB code
type InvestmentSecurityWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentSecurity) error
}

type AprORM struct {
	BalanceSubjectToApr  float64
	CreditAccountId      *uint64
	Id                   uint64
	InterestChargeAmount float64
	Percentage           float64
	Type                 string
}

// TableName overrides the default tablename generated by GORM
func (AprORM) TableName() string {
	return "aprs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Apr) ToORM(ctx context.Context) (AprORM, error) {
	to := AprORM{}
	var err error
	if prehook, ok := interface{}(m).(AprWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Percentage = m.Percentage
	to.Type = m.Type
	to.BalanceSubjectToApr = m.BalanceSubjectToApr
	to.InterestChargeAmount = m.InterestChargeAmount
	if posthook, ok := interface{}(m).(AprWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AprORM) ToPB(ctx context.Context) (Apr, error) {
	to := Apr{}
	var err error
	if prehook, ok := interface{}(m).(AprWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Percentage = m.Percentage
	to.Type = m.Type
	to.BalanceSubjectToApr = m.BalanceSubjectToApr
	to.InterestChargeAmount = m.InterestChargeAmount
	if posthook, ok := interface{}(m).(AprWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Apr the arg will be the target, the caller the one being converted from

// AprBeforeToORM called before default ToORM code
type AprWithBeforeToORM interface {
	BeforeToORM(context.Context, *AprORM) error
}

// AprAfterToORM called after default ToORM code
type AprWithAfterToORM interface {
	AfterToORM(context.Context, *AprORM) error
}

// AprBeforeToPB called before default ToPB code
type AprWithBeforeToPB interface {
	BeforeToPB(context.Context, *Apr) error
}

// AprAfterToPB called after default ToPB code
type AprWithAfterToPB interface {
	AfterToPB(context.Context, *Apr) error
}

type MergeLinkORM struct {
	Account                 []*LinkedAccountingAccountORM `gorm:"foreignkey:MergeLinkId;association_foreignkey:Id"`
	Category                string
	EndUserEmailAddress     string
	EndUserOrganizationName string
	EndUserOriginId         string
	FinancialUserProfileId  *uint64
	Id                      uint64
	Integration             string
	IntegrationImage        string
	IntegrationName         string
	IntegrationSlug         string
	IntegrationSquareImage  string
	IsDuplicate             bool
	MergeLinkedAccountId    string
	Status                  string
	Token                   *TokenORM `gorm:"foreignkey:MergeLinkId;association_foreignkey:Id;preload:true"`
	WebhookListenerUrl      string
}

// TableName overrides the default tablename generated by GORM
func (MergeLinkORM) TableName() string {
	return "merge_links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MergeLink) ToORM(ctx context.Context) (MergeLinkORM, error) {
	to := MergeLinkORM{}
	var err error
	if prehook, ok := interface{}(m).(MergeLinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	for _, v := range m.Account {
		if v != nil {
			if tempAccount, cErr := v.ToORM(ctx); cErr == nil {
				to.Account = append(to.Account, &tempAccount)
			} else {
				return to, cErr
			}
		} else {
			to.Account = append(to.Account, nil)
		}
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if posthook, ok := interface{}(m).(MergeLinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MergeLinkORM) ToPB(ctx context.Context) (MergeLink, error) {
	to := MergeLink{}
	var err error
	if prehook, ok := interface{}(m).(MergeLinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	for _, v := range m.Account {
		if v != nil {
			if tempAccount, cErr := v.ToPB(ctx); cErr == nil {
				to.Account = append(to.Account, &tempAccount)
			} else {
				return to, cErr
			}
		} else {
			to.Account = append(to.Account, nil)
		}
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if posthook, ok := interface{}(m).(MergeLinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MergeLink the arg will be the target, the caller the one being converted from

// MergeLinkBeforeToORM called before default ToORM code
type MergeLinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *MergeLinkORM) error
}

// MergeLinkAfterToORM called after default ToORM code
type MergeLinkWithAfterToORM interface {
	AfterToORM(context.Context, *MergeLinkORM) error
}

// MergeLinkBeforeToPB called before default ToPB code
type MergeLinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *MergeLink) error
}

// MergeLinkAfterToPB called after default ToPB code
type MergeLinkWithAfterToPB interface {
	AfterToPB(context.Context, *MergeLink) error
}

type LinkedAccountingAccountORM struct {
	Attachments         []*AttachmentsORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	CompanyInfo         []*CompanyInfoORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Id                  uint64
	MergeLinkId         *uint64
	PurchaseOrders      []*PurchaseOrderORM    `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	ReferenceDetails    *ReferenceDetailsORM   `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	ReportDetails       *ReportDetailsORM      `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	TransactionsDetails *TransactionDetailsORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (LinkedAccountingAccountORM) TableName() string {
	return "linked_accounting_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LinkedAccountingAccount) ToORM(ctx context.Context) (LinkedAccountingAccountORM, error) {
	to := LinkedAccountingAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(LinkedAccountingAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Attachments {
		if v != nil {
			if tempAttachments, cErr := v.ToORM(ctx); cErr == nil {
				to.Attachments = append(to.Attachments, &tempAttachments)
			} else {
				return to, cErr
			}
		} else {
			to.Attachments = append(to.Attachments, nil)
		}
	}
	for _, v := range m.CompanyInfo {
		if v != nil {
			if tempCompanyInfo, cErr := v.ToORM(ctx); cErr == nil {
				to.CompanyInfo = append(to.CompanyInfo, &tempCompanyInfo)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyInfo = append(to.CompanyInfo, nil)
		}
	}
	for _, v := range m.PurchaseOrders {
		if v != nil {
			if tempPurchaseOrders, cErr := v.ToORM(ctx); cErr == nil {
				to.PurchaseOrders = append(to.PurchaseOrders, &tempPurchaseOrders)
			} else {
				return to, cErr
			}
		} else {
			to.PurchaseOrders = append(to.PurchaseOrders, nil)
		}
	}
	if m.ReportDetails != nil {
		tempReportDetails, err := m.ReportDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ReportDetails = &tempReportDetails
	}
	if m.ReferenceDetails != nil {
		tempReferenceDetails, err := m.ReferenceDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ReferenceDetails = &tempReferenceDetails
	}
	if m.TransactionsDetails != nil {
		tempTransactionsDetails, err := m.TransactionsDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TransactionsDetails = &tempTransactionsDetails
	}
	if posthook, ok := interface{}(m).(LinkedAccountingAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LinkedAccountingAccountORM) ToPB(ctx context.Context) (LinkedAccountingAccount, error) {
	to := LinkedAccountingAccount{}
	var err error
	if prehook, ok := interface{}(m).(LinkedAccountingAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Attachments {
		if v != nil {
			if tempAttachments, cErr := v.ToPB(ctx); cErr == nil {
				to.Attachments = append(to.Attachments, &tempAttachments)
			} else {
				return to, cErr
			}
		} else {
			to.Attachments = append(to.Attachments, nil)
		}
	}
	for _, v := range m.CompanyInfo {
		if v != nil {
			if tempCompanyInfo, cErr := v.ToPB(ctx); cErr == nil {
				to.CompanyInfo = append(to.CompanyInfo, &tempCompanyInfo)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyInfo = append(to.CompanyInfo, nil)
		}
	}
	for _, v := range m.PurchaseOrders {
		if v != nil {
			if tempPurchaseOrders, cErr := v.ToPB(ctx); cErr == nil {
				to.PurchaseOrders = append(to.PurchaseOrders, &tempPurchaseOrders)
			} else {
				return to, cErr
			}
		} else {
			to.PurchaseOrders = append(to.PurchaseOrders, nil)
		}
	}
	if m.ReportDetails != nil {
		tempReportDetails, err := m.ReportDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ReportDetails = &tempReportDetails
	}
	if m.ReferenceDetails != nil {
		tempReferenceDetails, err := m.ReferenceDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ReferenceDetails = &tempReferenceDetails
	}
	if m.TransactionsDetails != nil {
		tempTransactionsDetails, err := m.TransactionsDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TransactionsDetails = &tempTransactionsDetails
	}
	if posthook, ok := interface{}(m).(LinkedAccountingAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LinkedAccountingAccount the arg will be the target, the caller the one being converted from

// LinkedAccountingAccountBeforeToORM called before default ToORM code
type LinkedAccountingAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *LinkedAccountingAccountORM) error
}

// LinkedAccountingAccountAfterToORM called after default ToORM code
type LinkedAccountingAccountWithAfterToORM interface {
	AfterToORM(context.Context, *LinkedAccountingAccountORM) error
}

// LinkedAccountingAccountBeforeToPB called before default ToPB code
type LinkedAccountingAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *LinkedAccountingAccount) error
}

// LinkedAccountingAccountAfterToPB called after default ToPB code
type LinkedAccountingAccountWithAfterToPB interface {
	AfterToPB(context.Context, *LinkedAccountingAccount) error
}

type TransactionDetailsORM struct {
	CreditNotes               []*CreditNoteORM `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	Expenses                  []*ExpenseORM    `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	Id                        uint64
	Invoices                  []*InvoiceORM      `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	JournalEntries            []*JournalEntryORM `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
	Payments                  []*PaymentORM             `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	Transactions              []*BusinessTransactionORM `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	VendorCredits             []*VendorCreditORM        `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (TransactionDetailsORM) TableName() string {
	return "transaction_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionDetails) ToORM(ctx context.Context) (TransactionDetailsORM, error) {
	to := TransactionDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Invoices {
		if v != nil {
			if tempInvoices, cErr := v.ToORM(ctx); cErr == nil {
				to.Invoices = append(to.Invoices, &tempInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.Invoices = append(to.Invoices, nil)
		}
	}
	for _, v := range m.Payments {
		if v != nil {
			if tempPayments, cErr := v.ToORM(ctx); cErr == nil {
				to.Payments = append(to.Payments, &tempPayments)
			} else {
				return to, cErr
			}
		} else {
			to.Payments = append(to.Payments, nil)
		}
	}
	for _, v := range m.Expenses {
		if v != nil {
			if tempExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.Expenses = append(to.Expenses, &tempExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.Expenses = append(to.Expenses, nil)
		}
	}
	for _, v := range m.JournalEntries {
		if v != nil {
			if tempJournalEntries, cErr := v.ToORM(ctx); cErr == nil {
				to.JournalEntries = append(to.JournalEntries, &tempJournalEntries)
			} else {
				return to, cErr
			}
		} else {
			to.JournalEntries = append(to.JournalEntries, nil)
		}
	}
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.VendorCredits {
		if v != nil {
			if tempVendorCredits, cErr := v.ToORM(ctx); cErr == nil {
				to.VendorCredits = append(to.VendorCredits, &tempVendorCredits)
			} else {
				return to, cErr
			}
		} else {
			to.VendorCredits = append(to.VendorCredits, nil)
		}
	}
	for _, v := range m.CreditNotes {
		if v != nil {
			if tempCreditNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.CreditNotes = append(to.CreditNotes, &tempCreditNotes)
			} else {
				return to, cErr
			}
		} else {
			to.CreditNotes = append(to.CreditNotes, nil)
		}
	}
	if posthook, ok := interface{}(m).(TransactionDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionDetailsORM) ToPB(ctx context.Context) (TransactionDetails, error) {
	to := TransactionDetails{}
	var err error
	if prehook, ok := interface{}(m).(TransactionDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Invoices {
		if v != nil {
			if tempInvoices, cErr := v.ToPB(ctx); cErr == nil {
				to.Invoices = append(to.Invoices, &tempInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.Invoices = append(to.Invoices, nil)
		}
	}
	for _, v := range m.Payments {
		if v != nil {
			if tempPayments, cErr := v.ToPB(ctx); cErr == nil {
				to.Payments = append(to.Payments, &tempPayments)
			} else {
				return to, cErr
			}
		} else {
			to.Payments = append(to.Payments, nil)
		}
	}
	for _, v := range m.Expenses {
		if v != nil {
			if tempExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.Expenses = append(to.Expenses, &tempExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.Expenses = append(to.Expenses, nil)
		}
	}
	for _, v := range m.JournalEntries {
		if v != nil {
			if tempJournalEntries, cErr := v.ToPB(ctx); cErr == nil {
				to.JournalEntries = append(to.JournalEntries, &tempJournalEntries)
			} else {
				return to, cErr
			}
		} else {
			to.JournalEntries = append(to.JournalEntries, nil)
		}
	}
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.VendorCredits {
		if v != nil {
			if tempVendorCredits, cErr := v.ToPB(ctx); cErr == nil {
				to.VendorCredits = append(to.VendorCredits, &tempVendorCredits)
			} else {
				return to, cErr
			}
		} else {
			to.VendorCredits = append(to.VendorCredits, nil)
		}
	}
	for _, v := range m.CreditNotes {
		if v != nil {
			if tempCreditNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.CreditNotes = append(to.CreditNotes, &tempCreditNotes)
			} else {
				return to, cErr
			}
		} else {
			to.CreditNotes = append(to.CreditNotes, nil)
		}
	}
	if posthook, ok := interface{}(m).(TransactionDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionDetails the arg will be the target, the caller the one being converted from

// TransactionDetailsBeforeToORM called before default ToORM code
type TransactionDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionDetailsORM) error
}

// TransactionDetailsAfterToORM called after default ToORM code
type TransactionDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionDetailsORM) error
}

// TransactionDetailsBeforeToPB called before default ToPB code
type TransactionDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionDetails) error
}

// TransactionDetailsAfterToPB called after default ToPB code
type TransactionDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionDetails) error
}

type ReferenceDetailsORM struct {
	ChartOfAccounts           []*BusinessChartOfAccountsORM `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
	Contacts                  []*ContactsORM                `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
	Id                        uint64
	Items                     []*ItemORM `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
	TaxRates                  []*TaxRateORM `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (ReferenceDetailsORM) TableName() string {
	return "reference_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReferenceDetails) ToORM(ctx context.Context) (ReferenceDetailsORM, error) {
	to := ReferenceDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(ReferenceDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.ChartOfAccounts {
		if v != nil {
			if tempChartOfAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.ChartOfAccounts = append(to.ChartOfAccounts, &tempChartOfAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.ChartOfAccounts = append(to.ChartOfAccounts, nil)
		}
	}
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToORM(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	for _, v := range m.TaxRates {
		if v != nil {
			if tempTaxRates, cErr := v.ToORM(ctx); cErr == nil {
				to.TaxRates = append(to.TaxRates, &tempTaxRates)
			} else {
				return to, cErr
			}
		} else {
			to.TaxRates = append(to.TaxRates, nil)
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReferenceDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReferenceDetailsORM) ToPB(ctx context.Context) (ReferenceDetails, error) {
	to := ReferenceDetails{}
	var err error
	if prehook, ok := interface{}(m).(ReferenceDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.ChartOfAccounts {
		if v != nil {
			if tempChartOfAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.ChartOfAccounts = append(to.ChartOfAccounts, &tempChartOfAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.ChartOfAccounts = append(to.ChartOfAccounts, nil)
		}
	}
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToPB(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	for _, v := range m.TaxRates {
		if v != nil {
			if tempTaxRates, cErr := v.ToPB(ctx); cErr == nil {
				to.TaxRates = append(to.TaxRates, &tempTaxRates)
			} else {
				return to, cErr
			}
		} else {
			to.TaxRates = append(to.TaxRates, nil)
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReferenceDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReferenceDetails the arg will be the target, the caller the one being converted from

// ReferenceDetailsBeforeToORM called before default ToORM code
type ReferenceDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReferenceDetailsORM) error
}

// ReferenceDetailsAfterToORM called after default ToORM code
type ReferenceDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *ReferenceDetailsORM) error
}

// ReferenceDetailsBeforeToPB called before default ToPB code
type ReferenceDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReferenceDetails) error
}

// ReferenceDetailsAfterToPB called after default ToPB code
type ReferenceDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *ReferenceDetails) error
}

type ReportDetailsORM struct {
	BalanceSheets             []*BalanceSheetORM       `gorm:"foreignkey:ReportDetailsId;association_foreignkey:Id;preload:true"`
	CashFlowStatements        []*CashFlowStatementsORM `gorm:"foreignkey:ReportDetailsId;association_foreignkey:Id;preload:true"`
	Id                        uint64
	IncomeStatements          []*IncomeStatementORM `gorm:"foreignkey:ReportDetailsId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (ReportDetailsORM) TableName() string {
	return "report_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReportDetails) ToORM(ctx context.Context) (ReportDetailsORM, error) {
	to := ReportDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(ReportDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.BalanceSheets {
		if v != nil {
			if tempBalanceSheets, cErr := v.ToORM(ctx); cErr == nil {
				to.BalanceSheets = append(to.BalanceSheets, &tempBalanceSheets)
			} else {
				return to, cErr
			}
		} else {
			to.BalanceSheets = append(to.BalanceSheets, nil)
		}
	}
	for _, v := range m.CashFlowStatements {
		if v != nil {
			if tempCashFlowStatements, cErr := v.ToORM(ctx); cErr == nil {
				to.CashFlowStatements = append(to.CashFlowStatements, &tempCashFlowStatements)
			} else {
				return to, cErr
			}
		} else {
			to.CashFlowStatements = append(to.CashFlowStatements, nil)
		}
	}
	for _, v := range m.IncomeStatements {
		if v != nil {
			if tempIncomeStatements, cErr := v.ToORM(ctx); cErr == nil {
				to.IncomeStatements = append(to.IncomeStatements, &tempIncomeStatements)
			} else {
				return to, cErr
			}
		} else {
			to.IncomeStatements = append(to.IncomeStatements, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReportDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReportDetailsORM) ToPB(ctx context.Context) (ReportDetails, error) {
	to := ReportDetails{}
	var err error
	if prehook, ok := interface{}(m).(ReportDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.BalanceSheets {
		if v != nil {
			if tempBalanceSheets, cErr := v.ToPB(ctx); cErr == nil {
				to.BalanceSheets = append(to.BalanceSheets, &tempBalanceSheets)
			} else {
				return to, cErr
			}
		} else {
			to.BalanceSheets = append(to.BalanceSheets, nil)
		}
	}
	for _, v := range m.CashFlowStatements {
		if v != nil {
			if tempCashFlowStatements, cErr := v.ToPB(ctx); cErr == nil {
				to.CashFlowStatements = append(to.CashFlowStatements, &tempCashFlowStatements)
			} else {
				return to, cErr
			}
		} else {
			to.CashFlowStatements = append(to.CashFlowStatements, nil)
		}
	}
	for _, v := range m.IncomeStatements {
		if v != nil {
			if tempIncomeStatements, cErr := v.ToPB(ctx); cErr == nil {
				to.IncomeStatements = append(to.IncomeStatements, &tempIncomeStatements)
			} else {
				return to, cErr
			}
		} else {
			to.IncomeStatements = append(to.IncomeStatements, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReportDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReportDetails the arg will be the target, the caller the one being converted from

// ReportDetailsBeforeToORM called before default ToORM code
type ReportDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReportDetailsORM) error
}

// ReportDetailsAfterToORM called after default ToORM code
type ReportDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *ReportDetailsORM) error
}

// ReportDetailsBeforeToPB called before default ToPB code
type ReportDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReportDetails) error
}

// ReportDetailsAfterToPB called after default ToPB code
type ReportDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *ReportDetails) error
}

type BusinessChartOfAccountsORM struct {
	AccountNumber      string
	Classification     string
	Company            string
	Currency           string
	CurrentBalance     float64
	Description        string
	Id                 uint64
	MergeAccountId     string
	ModifiedAt         *time.Time
	Name               string
	ParentAccountId    string
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteWasDeleted   bool
	Status             string
	Type               string
}

// TableName overrides the default tablename generated by GORM
func (BusinessChartOfAccountsORM) TableName() string {
	return "business_chart_of_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessChartOfAccounts) ToORM(ctx context.Context) (BusinessChartOfAccountsORM, error) {
	to := BusinessChartOfAccountsORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessChartOfAccountsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Description = m.Description
	to.Classification = m.Classification
	to.Type = m.Type
	to.Status = m.Status
	to.CurrentBalance = m.CurrentBalance
	to.Currency = m.Currency
	to.AccountNumber = m.AccountNumber
	to.ParentAccountId = m.ParentAccountId
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(BusinessChartOfAccountsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessChartOfAccountsORM) ToPB(ctx context.Context) (BusinessChartOfAccounts, error) {
	to := BusinessChartOfAccounts{}
	var err error
	if prehook, ok := interface{}(m).(BusinessChartOfAccountsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Description = m.Description
	to.Classification = m.Classification
	to.Type = m.Type
	to.Status = m.Status
	to.CurrentBalance = m.CurrentBalance
	to.Currency = m.Currency
	to.AccountNumber = m.AccountNumber
	to.ParentAccountId = m.ParentAccountId
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(BusinessChartOfAccountsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessChartOfAccounts the arg will be the target, the caller the one being converted from

// BusinessChartOfAccountsBeforeToORM called before default ToORM code
type BusinessChartOfAccountsWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessChartOfAccountsORM) error
}

// BusinessChartOfAccountsAfterToORM called after default ToORM code
type BusinessChartOfAccountsWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessChartOfAccountsORM) error
}

// BusinessChartOfAccountsBeforeToPB called before default ToPB code
type BusinessChartOfAccountsWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessChartOfAccounts) error
}

// BusinessChartOfAccountsAfterToPB called after default ToPB code
type BusinessChartOfAccountsWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessChartOfAccounts) error
}

type AddressORM struct {
	City               string
	CompanyInfoId      *uint64
	Country            string
	CountrySubdivision string
	Id                 uint64
	ModifiedAt         *time.Time
	PurchaseOrderId    *uint64
	State              string
	Street_1           string
	Street_2           string
	Type               string
	ZipCode            string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type AttachmentsORM struct {
	Company                   string
	FileName                  string
	FileUrl                   string
	Id                        uint64
	LinkedAccountingAccountId *uint64
	MergeAccountId            string
	ModifiedAt                *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
}

// TableName overrides the default tablename generated by GORM
func (AttachmentsORM) TableName() string {
	return "attachments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Attachments) ToORM(ctx context.Context) (AttachmentsORM, error) {
	to := AttachmentsORM{}
	var err error
	if prehook, ok := interface{}(m).(AttachmentsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(AttachmentsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AttachmentsORM) ToPB(ctx context.Context) (Attachments, error) {
	to := Attachments{}
	var err error
	if prehook, ok := interface{}(m).(AttachmentsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(AttachmentsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Attachments the arg will be the target, the caller the one being converted from

// AttachmentsBeforeToORM called before default ToORM code
type AttachmentsWithBeforeToORM interface {
	BeforeToORM(context.Context, *AttachmentsORM) error
}

// AttachmentsAfterToORM called after default ToORM code
type AttachmentsWithAfterToORM interface {
	AfterToORM(context.Context, *AttachmentsORM) error
}

// AttachmentsBeforeToPB called before default ToPB code
type AttachmentsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Attachments) error
}

// AttachmentsAfterToPB called after default ToPB code
type AttachmentsWithAfterToPB interface {
	AfterToPB(context.Context, *Attachments) error
}

type BalanceSheetORM struct {
	Assets            []*ReportItemORM `gorm:"foreignkey:AssetsBalanceSheetId;association_foreignkey:Id;preload:true"`
	Company           string
	Currency          string
	Date              *time.Time
	Equity            []*ReportItemORM `gorm:"foreignkey:EquityBalanceSheetId;association_foreignkey:Id;preload:true"`
	Id                uint64
	Liabilities       []*ReportItemORM `gorm:"foreignkey:LiabilitiesBalanceSheetId;association_foreignkey:Id;preload:true"`
	MergeAccountId    string
	ModifiedAt        *time.Time
	Name              string
	NetAssets         int64
	RemoteGeneratedAt *time.Time
	RemoteId          string
	RemoteWasDeleted  bool
	ReportDetailsId   *uint64
}

// TableName overrides the default tablename generated by GORM
func (BalanceSheetORM) TableName() string {
	return "balance_sheets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BalanceSheet) ToORM(ctx context.Context) (BalanceSheetORM, error) {
	to := BalanceSheetORM{}
	var err error
	if prehook, ok := interface{}(m).(BalanceSheetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.Date != nil {
		t := m.Date.AsTime()
		to.Date = &t
	}
	to.NetAssets = m.NetAssets
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToORM(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Liabilities {
		if v != nil {
			if tempLiabilities, cErr := v.ToORM(ctx); cErr == nil {
				to.Liabilities = append(to.Liabilities, &tempLiabilities)
			} else {
				return to, cErr
			}
		} else {
			to.Liabilities = append(to.Liabilities, nil)
		}
	}
	for _, v := range m.Equity {
		if v != nil {
			if tempEquity, cErr := v.ToORM(ctx); cErr == nil {
				to.Equity = append(to.Equity, &tempEquity)
			} else {
				return to, cErr
			}
		} else {
			to.Equity = append(to.Equity, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		t := m.RemoteGeneratedAt.AsTime()
		to.RemoteGeneratedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(BalanceSheetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BalanceSheetORM) ToPB(ctx context.Context) (BalanceSheet, error) {
	to := BalanceSheet{}
	var err error
	if prehook, ok := interface{}(m).(BalanceSheetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.Date != nil {
		to.Date = timestamppb.New(*m.Date)
	}
	to.NetAssets = m.NetAssets
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToPB(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Liabilities {
		if v != nil {
			if tempLiabilities, cErr := v.ToPB(ctx); cErr == nil {
				to.Liabilities = append(to.Liabilities, &tempLiabilities)
			} else {
				return to, cErr
			}
		} else {
			to.Liabilities = append(to.Liabilities, nil)
		}
	}
	for _, v := range m.Equity {
		if v != nil {
			if tempEquity, cErr := v.ToPB(ctx); cErr == nil {
				to.Equity = append(to.Equity, &tempEquity)
			} else {
				return to, cErr
			}
		} else {
			to.Equity = append(to.Equity, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		to.RemoteGeneratedAt = timestamppb.New(*m.RemoteGeneratedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(BalanceSheetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BalanceSheet the arg will be the target, the caller the one being converted from

// BalanceSheetBeforeToORM called before default ToORM code
type BalanceSheetWithBeforeToORM interface {
	BeforeToORM(context.Context, *BalanceSheetORM) error
}

// BalanceSheetAfterToORM called after default ToORM code
type BalanceSheetWithAfterToORM interface {
	AfterToORM(context.Context, *BalanceSheetORM) error
}

// BalanceSheetBeforeToPB called before default ToPB code
type BalanceSheetWithBeforeToPB interface {
	BeforeToPB(context.Context, *BalanceSheet) error
}

// BalanceSheetAfterToPB called after default ToPB code
type BalanceSheetWithAfterToPB interface {
	AfterToPB(context.Context, *BalanceSheet) error
}

type ReportItemORM struct {
	AssetsBalanceSheetId                    *uint64
	Company                                 string
	CostOfSalesIncomeStatementId            *uint64
	EquityBalanceSheetId                    *uint64
	FinancingActivitiesCashFlowStatementsId *uint64
	Id                                      uint64
	IncomeIncomeStatementId                 *uint64
	InvestingActivitiesCashFlowStatementsId *uint64
	LiabilitiesBalanceSheetId               *uint64
	ModifiedAt                              *time.Time
	Name                                    string
	NonOperatingExpensesIncomeStatementId   *uint64
	OperatingActivitiesCashFlowStatementsId *uint64
	OperatingExpensesIncomeStatementId      *uint64
	RemoteId                                string
	Value                                   int64
}

// TableName overrides the default tablename generated by GORM
func (ReportItemORM) TableName() string {
	return "report_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReportItem) ToORM(ctx context.Context) (ReportItemORM, error) {
	to := ReportItemORM{}
	var err error
	if prehook, ok := interface{}(m).(ReportItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Value = m.Value
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(ReportItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReportItemORM) ToPB(ctx context.Context) (ReportItem, error) {
	to := ReportItem{}
	var err error
	if prehook, ok := interface{}(m).(ReportItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Value = m.Value
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(ReportItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReportItem the arg will be the target, the caller the one being converted from

// ReportItemBeforeToORM called before default ToORM code
type ReportItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReportItemORM) error
}

// ReportItemAfterToORM called after default ToORM code
type ReportItemWithAfterToORM interface {
	AfterToORM(context.Context, *ReportItemORM) error
}

// ReportItemBeforeToPB called before default ToPB code
type ReportItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReportItem) error
}

// ReportItemAfterToPB called after default ToPB code
type ReportItemWithAfterToPB interface {
	AfterToPB(context.Context, *ReportItem) error
}

type CashFlowStatementsORM struct {
	CashAtBeginningOfPeriod float64
	CashAtEndOfPeriod       float64
	Company                 string
	Currency                string
	EndPeriod               *time.Time
	FinancingActivities     []*ReportItemORM `gorm:"foreignkey:FinancingActivitiesCashFlowStatementsId;association_foreignkey:Id;preload:true"`
	Id                      uint64
	InvestingActivities     []*ReportItemORM `gorm:"foreignkey:InvestingActivitiesCashFlowStatementsId;association_foreignkey:Id;preload:true"`
	MergeRecordId           string
	ModifiedAt              *time.Time
	Name                    string
	OperatingActivities     []*ReportItemORM `gorm:"foreignkey:OperatingActivitiesCashFlowStatementsId;association_foreignkey:Id;preload:true"`
	RemoteGeneratedAt       *time.Time
	RemoteId                string
	RemoteWasDeleted        bool
	ReportDetailsId         *uint64
	StartPeriod             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (CashFlowStatementsORM) TableName() string {
	return "cash_flow_statements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CashFlowStatements) ToORM(ctx context.Context) (CashFlowStatementsORM, error) {
	to := CashFlowStatementsORM{}
	var err error
	if prehook, ok := interface{}(m).(CashFlowStatementsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		t := m.StartPeriod.AsTime()
		to.StartPeriod = &t
	}
	if m.EndPeriod != nil {
		t := m.EndPeriod.AsTime()
		to.EndPeriod = &t
	}
	to.CashAtBeginningOfPeriod = m.CashAtBeginningOfPeriod
	to.CashAtEndOfPeriod = m.CashAtEndOfPeriod
	for _, v := range m.OperatingActivities {
		if v != nil {
			if tempOperatingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.OperatingActivities = append(to.OperatingActivities, &tempOperatingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingActivities = append(to.OperatingActivities, nil)
		}
	}
	for _, v := range m.InvestingActivities {
		if v != nil {
			if tempInvestingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestingActivities = append(to.InvestingActivities, &tempInvestingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.InvestingActivities = append(to.InvestingActivities, nil)
		}
	}
	for _, v := range m.FinancingActivities {
		if v != nil {
			if tempFinancingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.FinancingActivities = append(to.FinancingActivities, &tempFinancingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.FinancingActivities = append(to.FinancingActivities, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		t := m.RemoteGeneratedAt.AsTime()
		to.RemoteGeneratedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CashFlowStatementsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CashFlowStatementsORM) ToPB(ctx context.Context) (CashFlowStatements, error) {
	to := CashFlowStatements{}
	var err error
	if prehook, ok := interface{}(m).(CashFlowStatementsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		to.StartPeriod = timestamppb.New(*m.StartPeriod)
	}
	if m.EndPeriod != nil {
		to.EndPeriod = timestamppb.New(*m.EndPeriod)
	}
	to.CashAtBeginningOfPeriod = m.CashAtBeginningOfPeriod
	to.CashAtEndOfPeriod = m.CashAtEndOfPeriod
	for _, v := range m.OperatingActivities {
		if v != nil {
			if tempOperatingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.OperatingActivities = append(to.OperatingActivities, &tempOperatingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingActivities = append(to.OperatingActivities, nil)
		}
	}
	for _, v := range m.InvestingActivities {
		if v != nil {
			if tempInvestingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestingActivities = append(to.InvestingActivities, &tempInvestingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.InvestingActivities = append(to.InvestingActivities, nil)
		}
	}
	for _, v := range m.FinancingActivities {
		if v != nil {
			if tempFinancingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.FinancingActivities = append(to.FinancingActivities, &tempFinancingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.FinancingActivities = append(to.FinancingActivities, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		to.RemoteGeneratedAt = timestamppb.New(*m.RemoteGeneratedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CashFlowStatementsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CashFlowStatements the arg will be the target, the caller the one being converted from

// CashFlowStatementsBeforeToORM called before default ToORM code
type CashFlowStatementsWithBeforeToORM interface {
	BeforeToORM(context.Context, *CashFlowStatementsORM) error
}

// CashFlowStatementsAfterToORM called after default ToORM code
type CashFlowStatementsWithAfterToORM interface {
	AfterToORM(context.Context, *CashFlowStatementsORM) error
}

// CashFlowStatementsBeforeToPB called before default ToPB code
type CashFlowStatementsWithBeforeToPB interface {
	BeforeToPB(context.Context, *CashFlowStatements) error
}

// CashFlowStatementsAfterToPB called after default ToPB code
type CashFlowStatementsWithAfterToPB interface {
	AfterToPB(context.Context, *CashFlowStatements) error
}

type CompanyInfoORM struct {
	Addresses                 []*AddressORM `gorm:"foreignkey:CompanyInfoId;association_foreignkey:Id"`
	Currency                  string
	FiscalYearEndDay          int32
	FiscalYearEndMonth        int32
	Id                        uint64
	LegalName                 string
	LinkedAccountingAccountId *uint64
	MergeAccountId            string
	ModifiedAt                *time.Time
	Name                      string
	PhoneNumbers              pq.StringArray `gorm:"type:text[]"`
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
	TaxNumber                 string
	Urls                      pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyInfoORM) TableName() string {
	return "company_infos"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyInfo) ToORM(ctx context.Context) (CompanyInfoORM, error) {
	to := CompanyInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.LegalName = m.LegalName
	to.TaxNumber = m.TaxNumber
	to.FiscalYearEndMonth = m.FiscalYearEndMonth
	to.FiscalYearEndDay = m.FiscalYearEndDay
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.Urls != nil {
		to.Urls = make(pq.StringArray, len(m.Urls))
		copy(to.Urls, m.Urls)
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToORM(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CompanyInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyInfoORM) ToPB(ctx context.Context) (CompanyInfo, error) {
	to := CompanyInfo{}
	var err error
	if prehook, ok := interface{}(m).(CompanyInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.LegalName = m.LegalName
	to.TaxNumber = m.TaxNumber
	to.FiscalYearEndMonth = m.FiscalYearEndMonth
	to.FiscalYearEndDay = m.FiscalYearEndDay
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.Urls != nil {
		to.Urls = make(pq.StringArray, len(m.Urls))
		copy(to.Urls, m.Urls)
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToPB(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CompanyInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyInfo the arg will be the target, the caller the one being converted from

// CompanyInfoBeforeToORM called before default ToORM code
type CompanyInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyInfoORM) error
}

// CompanyInfoAfterToORM called after default ToORM code
type CompanyInfoWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyInfoORM) error
}

// CompanyInfoBeforeToPB called before default ToPB code
type CompanyInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyInfo) error
}

// CompanyInfoAfterToPB called after default ToPB code
type CompanyInfoWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyInfo) error
}

type AccountingAttachmentORM struct {
	Company          string
	FileName         string
	FileUrl          string
	Id               uint64
	MergeRecordId    string
	ModifiedAt       string
	RemoteId         string
	RemoteWasDeleted bool
}

// TableName overrides the default tablename generated by GORM
func (AccountingAttachmentORM) TableName() string {
	return "accounting_attachments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountingAttachment) ToORM(ctx context.Context) (AccountingAttachmentORM, error) {
	to := AccountingAttachmentORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountingAttachmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.ModifiedAt = m.ModifiedAt
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(AccountingAttachmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountingAttachmentORM) ToPB(ctx context.Context) (AccountingAttachment, error) {
	to := AccountingAttachment{}
	var err error
	if prehook, ok := interface{}(m).(AccountingAttachmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.ModifiedAt = m.ModifiedAt
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(AccountingAttachmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountingAttachment the arg will be the target, the caller the one being converted from

// AccountingAttachmentBeforeToORM called before default ToORM code
type AccountingAttachmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountingAttachmentORM) error
}

// AccountingAttachmentAfterToORM called after default ToORM code
type AccountingAttachmentWithAfterToORM interface {
	AfterToORM(context.Context, *AccountingAttachmentORM) error
}

// AccountingAttachmentBeforeToPB called before default ToPB code
type AccountingAttachmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountingAttachment) error
}

// AccountingAttachmentAfterToPB called after default ToPB code
type AccountingAttachmentWithAfterToPB interface {
	AfterToPB(context.Context, *AccountingAttachment) error
}

type ContactsORM struct {
	AddressesIds       pq.StringArray `gorm:"type:text[]"`
	Company            string
	Currency           string
	EmailAddress       string
	Id                 uint64
	IsCustomer         bool
	IsSupplier         bool
	MergeAccountId     string
	ModifiedAt         *time.Time
	Name               string
	PhoneNumbers       pq.StringArray `gorm:"type:text[]"`
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteUpdatedAt    *time.Time
	RemoteWasDeleted   bool
	Status             string
	TaxNumber          string
}

// TableName overrides the default tablename generated by GORM
func (ContactsORM) TableName() string {
	return "contacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Contacts) ToORM(ctx context.Context) (ContactsORM, error) {
	to := ContactsORM{}
	var err error
	if prehook, ok := interface{}(m).(ContactsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.IsSupplier = m.IsSupplier
	to.IsCustomer = m.IsCustomer
	to.EmailAddress = m.EmailAddress
	to.TaxNumber = m.TaxNumber
	to.Status = m.Status
	to.Currency = m.Currency
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.Company = m.Company
	if m.AddressesIds != nil {
		to.AddressesIds = make(pq.StringArray, len(m.AddressesIds))
		copy(to.AddressesIds, m.AddressesIds)
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ContactsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContactsORM) ToPB(ctx context.Context) (Contacts, error) {
	to := Contacts{}
	var err error
	if prehook, ok := interface{}(m).(ContactsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.IsSupplier = m.IsSupplier
	to.IsCustomer = m.IsCustomer
	to.EmailAddress = m.EmailAddress
	to.TaxNumber = m.TaxNumber
	to.Status = m.Status
	to.Currency = m.Currency
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.Company = m.Company
	if m.AddressesIds != nil {
		to.AddressesIds = make(pq.StringArray, len(m.AddressesIds))
		copy(to.AddressesIds, m.AddressesIds)
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ContactsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Contacts the arg will be the target, the caller the one being converted from

// ContactsBeforeToORM called before default ToORM code
type ContactsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContactsORM) error
}

// ContactsAfterToORM called after default ToORM code
type ContactsWithAfterToORM interface {
	AfterToORM(context.Context, *ContactsORM) error
}

// ContactsBeforeToPB called before default ToPB code
type ContactsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Contacts) error
}

// ContactsAfterToPB called after default ToPB code
type ContactsWithAfterToPB interface {
	AfterToPB(context.Context, *Contacts) error
}

type CreditNoteORM struct {
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	LineItems            []*CreditNoteLineItemORM `gorm:"foreignkey:CreditNoteId;association_foreignkey:Id"`
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	PaymentIds           pq.StringArray `gorm:"type:text[]"`
	RemainingCredit      float64
	RemoteCreatedAt      *time.Time
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	Status               string
	TotalAmount          float64
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (CreditNoteORM) TableName() string {
	return "credit_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditNote) ToORM(ctx context.Context) (CreditNoteORM, error) {
	to := CreditNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Status = m.Status
	to.Number = m.Number
	to.Contact = m.Contact
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	to.TotalAmount = m.TotalAmount
	to.RemainingCredit = m.RemainingCredit
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CreditNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditNoteORM) ToPB(ctx context.Context) (CreditNote, error) {
	to := CreditNote{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Status = m.Status
	to.Number = m.Number
	to.Contact = m.Contact
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	to.TotalAmount = m.TotalAmount
	to.RemainingCredit = m.RemainingCredit
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CreditNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditNote the arg will be the target, the caller the one being converted from

// CreditNoteBeforeToORM called before default ToORM code
type CreditNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditNoteORM) error
}

// CreditNoteAfterToORM called after default ToORM code
type CreditNoteWithAfterToORM interface {
	AfterToORM(context.Context, *CreditNoteORM) error
}

// CreditNoteBeforeToPB called before default ToPB code
type CreditNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditNote) error
}

// CreditNoteAfterToPB called after default ToPB code
type CreditNoteWithAfterToPB interface {
	AfterToPB(context.Context, *CreditNote) error
}

type CreditNoteLineItemORM struct {
	Account            string
	Company            string
	CreditNoteId       *uint64
	Description        string
	Id                 uint64
	Item               string
	Name               string
	Quantity           string
	RemoteId           string
	TaxRate            string
	TotalLineAmount    string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          string
}

// TableName overrides the default tablename generated by GORM
func (CreditNoteLineItemORM) TableName() string {
	return "credit_note_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditNoteLineItem) ToORM(ctx context.Context) (CreditNoteLineItemORM, error) {
	to := CreditNoteLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.TaxRate = m.TaxRate
	to.TotalLineAmount = m.TotalLineAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Account = m.Account
	to.Company = m.Company
	to.RemoteId = m.RemoteId
	to.Item = m.Item
	if posthook, ok := interface{}(m).(CreditNoteLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditNoteLineItemORM) ToPB(ctx context.Context) (CreditNoteLineItem, error) {
	to := CreditNoteLineItem{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.TaxRate = m.TaxRate
	to.TotalLineAmount = m.TotalLineAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Account = m.Account
	to.Company = m.Company
	to.RemoteId = m.RemoteId
	to.Item = m.Item
	if posthook, ok := interface{}(m).(CreditNoteLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditNoteLineItem the arg will be the target, the caller the one being converted from

// CreditNoteLineItemBeforeToORM called before default ToORM code
type CreditNoteLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditNoteLineItemORM) error
}

// CreditNoteLineItemAfterToORM called after default ToORM code
type CreditNoteLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *CreditNoteLineItemORM) error
}

// CreditNoteLineItemBeforeToPB called before default ToPB code
type CreditNoteLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditNoteLineItem) error
}

// CreditNoteLineItemAfterToPB called after default ToPB code
type CreditNoteLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *CreditNoteLineItem) error
}

type ExpenseORM struct {
	Account              string
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	Lines                []*ExpenseLineORM `gorm:"foreignkey:ExpenseId;association_foreignkey:Id"`
	Memo                 string
	MergeAccountId       string
	ModifiedAt           *time.Time
	RemoteCreatedAt      *time.Time
	RemoteId             string
	RemoteWasDeleted     bool
	SubTotal             float64
	TotalAmount          float64
	TotalTaxAmount       float64
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (ExpenseORM) TableName() string {
	return "expenses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Expense) ToORM(ctx context.Context) (ExpenseORM, error) {
	to := ExpenseORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.SubTotal = m.SubTotal
	to.TotalTaxAmount = m.TotalTaxAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.Memo = m.Memo
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ExpenseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseORM) ToPB(ctx context.Context) (Expense, error) {
	to := Expense{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.SubTotal = m.SubTotal
	to.TotalTaxAmount = m.TotalTaxAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.Memo = m.Memo
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ExpenseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Expense the arg will be the target, the caller the one being converted from

// ExpenseBeforeToORM called before default ToORM code
type ExpenseWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseORM) error
}

// ExpenseAfterToORM called after default ToORM code
type ExpenseWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseORM) error
}

// ExpenseBeforeToPB called before default ToPB code
type ExpenseWithBeforeToPB interface {
	BeforeToPB(context.Context, *Expense) error
}

// ExpenseAfterToPB called after default ToPB code
type ExpenseWithAfterToPB interface {
	AfterToPB(context.Context, *Expense) error
}

type ExpenseLineORM struct {
	Account            string
	Company            string
	Contact            string
	Currency           string
	Description        string
	ExchangeRate       string
	ExpenseId          *uint64
	Id                 uint64
	Item               string
	ModifiedAt         *time.Time
	NetAmount          float64
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
}

// TableName overrides the default tablename generated by GORM
func (ExpenseLineORM) TableName() string {
	return "expense_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExpenseLine) ToORM(ctx context.Context) (ExpenseLineORM, error) {
	to := ExpenseLineORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.Item = m.Item
	to.Account = m.Account
	to.Contact = m.Contact
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	to.RemoteId = m.RemoteId
	to.Currency = m.Currency
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(ExpenseLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseLineORM) ToPB(ctx context.Context) (ExpenseLine, error) {
	to := ExpenseLine{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.Item = m.Item
	to.Account = m.Account
	to.Contact = m.Contact
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	to.RemoteId = m.RemoteId
	to.Currency = m.Currency
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(ExpenseLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExpenseLine the arg will be the target, the caller the one being converted from

// ExpenseLineBeforeToORM called before default ToORM code
type ExpenseLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseLineORM) error
}

// ExpenseLineAfterToORM called after default ToORM code
type ExpenseLineWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseLineORM) error
}

// ExpenseLineBeforeToPB called before default ToPB code
type ExpenseLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExpenseLine) error
}

// ExpenseLineAfterToPB called after default ToPB code
type ExpenseLineWithAfterToPB interface {
	AfterToPB(context.Context, *ExpenseLine) error
}

type IncomeStatementORM struct {
	Company              string
	CostOfSales          []*ReportItemORM `gorm:"foreignkey:CostOfSalesIncomeStatementId;association_foreignkey:Id"`
	Currency             string
	EndPeriod            *time.Time
	GrossProfit          int32
	Id                   uint64
	Income               []*ReportItemORM `gorm:"foreignkey:IncomeIncomeStatementId;association_foreignkey:Id"`
	ModifiedAt           *time.Time
	Name                 string
	NetIncome            int32
	NetOperatingIncome   int32
	NonOperatingExpenses []*ReportItemORM `gorm:"foreignkey:NonOperatingExpensesIncomeStatementId;association_foreignkey:Id"`
	OperatingExpenses    []*ReportItemORM `gorm:"foreignkey:OperatingExpensesIncomeStatementId;association_foreignkey:Id"`
	RemoteId             string
	RemoteWasDeleted     bool
	ReportDetailsId      *uint64
	StartPeriod          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (IncomeStatementORM) TableName() string {
	return "income_statements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IncomeStatement) ToORM(ctx context.Context) (IncomeStatementORM, error) {
	to := IncomeStatementORM{}
	var err error
	if prehook, ok := interface{}(m).(IncomeStatementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		t := m.StartPeriod.AsTime()
		to.StartPeriod = &t
	}
	if m.EndPeriod != nil {
		t := m.EndPeriod.AsTime()
		to.EndPeriod = &t
	}
	for _, v := range m.Income {
		if v != nil {
			if tempIncome, cErr := v.ToORM(ctx); cErr == nil {
				to.Income = append(to.Income, &tempIncome)
			} else {
				return to, cErr
			}
		} else {
			to.Income = append(to.Income, nil)
		}
	}
	for _, v := range m.CostOfSales {
		if v != nil {
			if tempCostOfSales, cErr := v.ToORM(ctx); cErr == nil {
				to.CostOfSales = append(to.CostOfSales, &tempCostOfSales)
			} else {
				return to, cErr
			}
		} else {
			to.CostOfSales = append(to.CostOfSales, nil)
		}
	}
	to.GrossProfit = m.GrossProfit
	for _, v := range m.OperatingExpenses {
		if v != nil {
			if tempOperatingExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.OperatingExpenses = append(to.OperatingExpenses, &tempOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingExpenses = append(to.OperatingExpenses, nil)
		}
	}
	to.NetOperatingIncome = m.NetOperatingIncome
	for _, v := range m.NonOperatingExpenses {
		if v != nil {
			if tempNonOperatingExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.NonOperatingExpenses = append(to.NonOperatingExpenses, &tempNonOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.NonOperatingExpenses = append(to.NonOperatingExpenses, nil)
		}
	}
	to.NetIncome = m.NetIncome
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(IncomeStatementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IncomeStatementORM) ToPB(ctx context.Context) (IncomeStatement, error) {
	to := IncomeStatement{}
	var err error
	if prehook, ok := interface{}(m).(IncomeStatementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		to.StartPeriod = timestamppb.New(*m.StartPeriod)
	}
	if m.EndPeriod != nil {
		to.EndPeriod = timestamppb.New(*m.EndPeriod)
	}
	for _, v := range m.Income {
		if v != nil {
			if tempIncome, cErr := v.ToPB(ctx); cErr == nil {
				to.Income = append(to.Income, &tempIncome)
			} else {
				return to, cErr
			}
		} else {
			to.Income = append(to.Income, nil)
		}
	}
	for _, v := range m.CostOfSales {
		if v != nil {
			if tempCostOfSales, cErr := v.ToPB(ctx); cErr == nil {
				to.CostOfSales = append(to.CostOfSales, &tempCostOfSales)
			} else {
				return to, cErr
			}
		} else {
			to.CostOfSales = append(to.CostOfSales, nil)
		}
	}
	to.GrossProfit = m.GrossProfit
	for _, v := range m.OperatingExpenses {
		if v != nil {
			if tempOperatingExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.OperatingExpenses = append(to.OperatingExpenses, &tempOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingExpenses = append(to.OperatingExpenses, nil)
		}
	}
	to.NetOperatingIncome = m.NetOperatingIncome
	for _, v := range m.NonOperatingExpenses {
		if v != nil {
			if tempNonOperatingExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.NonOperatingExpenses = append(to.NonOperatingExpenses, &tempNonOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.NonOperatingExpenses = append(to.NonOperatingExpenses, nil)
		}
	}
	to.NetIncome = m.NetIncome
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(IncomeStatementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IncomeStatement the arg will be the target, the caller the one being converted from

// IncomeStatementBeforeToORM called before default ToORM code
type IncomeStatementWithBeforeToORM interface {
	BeforeToORM(context.Context, *IncomeStatementORM) error
}

// IncomeStatementAfterToORM called after default ToORM code
type IncomeStatementWithAfterToORM interface {
	AfterToORM(context.Context, *IncomeStatementORM) error
}

// IncomeStatementBeforeToPB called before default ToPB code
type IncomeStatementWithBeforeToPB interface {
	BeforeToPB(context.Context, *IncomeStatement) error
}

// IncomeStatementAfterToPB called after default ToPB code
type IncomeStatementWithAfterToPB interface {
	AfterToPB(context.Context, *IncomeStatement) error
}

type InvoiceORM struct {
	AccountingPeriod     string
	Balance              float32
	Company              string
	Contact              string
	Currency             string
	DueDate              *time.Time
	ExchangeRate         string
	Id                   uint64
	IssueDate            *time.Time
	LineItems            []*InvoiceLineItemORM `gorm:"foreignkey:InvoiceId;association_foreignkey:Id"`
	Memo                 string
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	PaidOnDate           *time.Time
	Payments             pq.StringArray `gorm:"type:text[]"`
	PurchaseOrders       pq.StringArray `gorm:"type:text[]"`
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	Status               string
	SubTotal             float32
	TotalAmount          float32
	TotalDiscount        float32
	TotalTaxAmount       float32
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDetailsId *uint64
	Type                 string
}

// TableName overrides the default tablename generated by GORM
func (InvoiceORM) TableName() string {
	return "invoices"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Invoice) ToORM(ctx context.Context) (InvoiceORM, error) {
	to := InvoiceORM{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Contact = m.Contact
	to.Number = m.Number
	if m.IssueDate != nil {
		t := m.IssueDate.AsTime()
		to.IssueDate = &t
	}
	if m.DueDate != nil {
		t := m.DueDate.AsTime()
		to.DueDate = &t
	}
	if m.PaidOnDate != nil {
		t := m.PaidOnDate.AsTime()
		to.PaidOnDate = &t
	}
	to.Memo = m.Memo
	to.Company = m.Company
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.TotalDiscount = m.TotalDiscount
	to.SubTotal = m.SubTotal
	to.Status = m.Status
	to.TotalTaxAmount = m.TotalTaxAmount
	to.TotalAmount = m.TotalAmount
	to.Balance = m.Balance
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.PurchaseOrders != nil {
		to.PurchaseOrders = make(pq.StringArray, len(m.PurchaseOrders))
		copy(to.PurchaseOrders, m.PurchaseOrders)
	}
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(InvoiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvoiceORM) ToPB(ctx context.Context) (Invoice, error) {
	to := Invoice{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Contact = m.Contact
	to.Number = m.Number
	if m.IssueDate != nil {
		to.IssueDate = timestamppb.New(*m.IssueDate)
	}
	if m.DueDate != nil {
		to.DueDate = timestamppb.New(*m.DueDate)
	}
	if m.PaidOnDate != nil {
		to.PaidOnDate = timestamppb.New(*m.PaidOnDate)
	}
	to.Memo = m.Memo
	to.Company = m.Company
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.TotalDiscount = m.TotalDiscount
	to.SubTotal = m.SubTotal
	to.Status = m.Status
	to.TotalTaxAmount = m.TotalTaxAmount
	to.TotalAmount = m.TotalAmount
	to.Balance = m.Balance
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.PurchaseOrders != nil {
		to.PurchaseOrders = make(pq.StringArray, len(m.PurchaseOrders))
		copy(to.PurchaseOrders, m.PurchaseOrders)
	}
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(InvoiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Invoice the arg will be the target, the caller the one being converted from

// InvoiceBeforeToORM called before default ToORM code
type InvoiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvoiceORM) error
}

// InvoiceAfterToORM called after default ToORM code
type InvoiceWithAfterToORM interface {
	AfterToORM(context.Context, *InvoiceORM) error
}

// InvoiceBeforeToPB called before default ToPB code
type InvoiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Invoice) error
}

// InvoiceAfterToPB called after default ToPB code
type InvoiceWithAfterToPB interface {
	AfterToPB(context.Context, *Invoice) error
}

type InvoiceLineItemORM struct {
	Account            string
	Company            string
	Currency           string
	Description        string
	ExchangeRate       string
	Id                 uint64
	InvoiceId          *uint64
	Item               string
	MergeAccountId     string
	ModifiedAt         *time.Time
	Quantity           int32
	RemoteId           string
	TotalAmount        float32
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          float32
}

// TableName overrides the default tablename generated by GORM
func (InvoiceLineItemORM) TableName() string {
	return "invoice_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvoiceLineItem) ToORM(ctx context.Context) (InvoiceLineItemORM, error) {
	to := InvoiceLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.MergeAccountId = m.MergeAccountId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(InvoiceLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvoiceLineItemORM) ToPB(ctx context.Context) (InvoiceLineItem, error) {
	to := InvoiceLineItem{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.MergeAccountId = m.MergeAccountId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(InvoiceLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvoiceLineItem the arg will be the target, the caller the one being converted from

// InvoiceLineItemBeforeToORM called before default ToORM code
type InvoiceLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvoiceLineItemORM) error
}

// InvoiceLineItemAfterToORM called after default ToORM code
type InvoiceLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *InvoiceLineItemORM) error
}

// InvoiceLineItemBeforeToPB called before default ToPB code
type InvoiceLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvoiceLineItem) error
}

// InvoiceLineItemAfterToPB called after default ToPB code
type InvoiceLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *InvoiceLineItem) error
}

type ItemORM struct {
	Company            string
	Id                 uint64
	MergeAccountId     string
	ModifiedAt         *time.Time
	Name               string
	PurchaseAccount    string
	PurchasePrice      float32
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteUpdatedAt    *time.Time
	RemoteWasDeleted   bool
	SalesAccount       string
	Status             string
	UnitPrice          float32
}

// TableName overrides the default tablename generated by GORM
func (ItemORM) TableName() string {
	return "items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Item) ToORM(ctx context.Context) (ItemORM, error) {
	to := ItemORM{}
	var err error
	if prehook, ok := interface{}(m).(ItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Status = m.Status
	to.UnitPrice = m.UnitPrice
	to.PurchasePrice = m.PurchasePrice
	to.PurchaseAccount = m.PurchaseAccount
	to.SalesAccount = m.SalesAccount
	to.Company = m.Company
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ItemORM) ToPB(ctx context.Context) (Item, error) {
	to := Item{}
	var err error
	if prehook, ok := interface{}(m).(ItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Status = m.Status
	to.UnitPrice = m.UnitPrice
	to.PurchasePrice = m.PurchasePrice
	to.PurchaseAccount = m.PurchaseAccount
	to.SalesAccount = m.SalesAccount
	to.Company = m.Company
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Item the arg will be the target, the caller the one being converted from

// ItemBeforeToORM called before default ToORM code
type ItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *ItemORM) error
}

// ItemAfterToORM called after default ToORM code
type ItemWithAfterToORM interface {
	AfterToORM(context.Context, *ItemORM) error
}

// ItemBeforeToPB called before default ToPB code
type ItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *Item) error
}

// ItemAfterToPB called after default ToPB code
type ItemWithAfterToPB interface {
	AfterToPB(context.Context, *Item) error
}

type JournalEntryORM struct {
	AccountingPeriod     string
	Company              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	JournalNumber        string
	Lines                []*JournalLineORM `gorm:"foreignkey:JournalEntryId;association_foreignkey:Id"`
	Memo                 string
	MergeAccountId       string
	ModifiedAt           *time.Time
	PaymentIds           pq.StringArray `gorm:"type:text[]"`
	PostingStatus        string
	RemoteCreatedAt      *time.Time
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (JournalEntryORM) TableName() string {
	return "journal_entries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalEntry) ToORM(ctx context.Context) (JournalEntryORM, error) {
	to := JournalEntryORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.Memo = m.Memo
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	to.JournalNumber = m.JournalNumber
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.PostingStatus = m.PostingStatus
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalEntryORM) ToPB(ctx context.Context) (JournalEntry, error) {
	to := JournalEntry{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.Memo = m.Memo
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	to.JournalNumber = m.JournalNumber
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.PostingStatus = m.PostingStatus
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalEntry the arg will be the target, the caller the one being converted from

// JournalEntryBeforeToORM called before default ToORM code
type JournalEntryWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryAfterToORM called after default ToORM code
type JournalEntryWithAfterToORM interface {
	AfterToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryBeforeToPB called before default ToPB code
type JournalEntryWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalEntry) error
}

// JournalEntryAfterToPB called after default ToPB code
type JournalEntryWithAfterToPB interface {
	AfterToPB(context.Context, *JournalEntry) error
}

type JournalLineORM struct {
	Account            string
	Company            string
	Contact            string
	Description        string
	ExchangeRate       string
	Id                 uint64
	JournalEntryId     *uint64
	ModifiedAt         *time.Time
	NetAmount          float32
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
}

// TableName overrides the default tablename generated by GORM
func (JournalLineORM) TableName() string {
	return "journal_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalLine) ToORM(ctx context.Context) (JournalLineORM, error) {
	to := JournalLineORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Account = m.Account
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Contact = m.Contact
	to.Company = m.Company
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(JournalLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalLineORM) ToPB(ctx context.Context) (JournalLine, error) {
	to := JournalLine{}
	var err error
	if prehook, ok := interface{}(m).(JournalLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Account = m.Account
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Contact = m.Contact
	to.Company = m.Company
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(JournalLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalLine the arg will be the target, the caller the one being converted from

// JournalLineBeforeToORM called before default ToORM code
type JournalLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalLineORM) error
}

// JournalLineAfterToORM called after default ToORM code
type JournalLineWithAfterToORM interface {
	AfterToORM(context.Context, *JournalLineORM) error
}

// JournalLineBeforeToPB called before default ToPB code
type JournalLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalLine) error
}

// JournalLineAfterToPB called after default ToPB code
type JournalLineWithAfterToPB interface {
	AfterToPB(context.Context, *JournalLine) error
}

type PaymentORM struct {
	Account              string
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	MergeAccountId       string
	ModifiedAt           *time.Time
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	TotalAmount          float32
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (PaymentORM) TableName() string {
	return "payments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Payment) ToORM(ctx context.Context) (PaymentORM, error) {
	to := PaymentORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Contact = m.Contact
	to.Account = m.Account
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(PaymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentORM) ToPB(ctx context.Context) (Payment, error) {
	to := Payment{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Contact = m.Contact
	to.Account = m.Account
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(PaymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Payment the arg will be the target, the caller the one being converted from

// PaymentBeforeToORM called before default ToORM code
type PaymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentORM) error
}

// PaymentAfterToORM called after default ToORM code
type PaymentWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentORM) error
}

// PaymentBeforeToPB called before default ToPB code
type PaymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Payment) error
}

// PaymentAfterToPB called after default ToPB code
type PaymentWithAfterToPB interface {
	AfterToPB(context.Context, *Payment) error
}

type PurchaseOrderORM struct {
	AccountingPeriod          string
	Company                   string
	Currency                  string
	Customer                  string
	DeliveryAddress           *AddressORM `gorm:"foreignkey:PurchaseOrderId;association_foreignkey:Id"`
	DeliveryDate              *time.Time
	ExchangeRate              string
	Id                        uint64
	IssueDate                 *time.Time
	LineItems                 []*PurchaseOrderLineItemORM `gorm:"foreignkey:PurchaseOrderId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	Memo                      string
	MergeAccountId            string
	ModifiedAt                *time.Time
	PurchaseOrderNumber       string
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	Status                    string
	TotalAmount               float32
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	Vendor                    string
}

// TableName overrides the default tablename generated by GORM
func (PurchaseOrderORM) TableName() string {
	return "purchase_orders"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PurchaseOrder) ToORM(ctx context.Context) (PurchaseOrderORM, error) {
	to := PurchaseOrderORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.Status = m.Status
	if m.IssueDate != nil {
		t := m.IssueDate.AsTime()
		to.IssueDate = &t
	}
	to.PurchaseOrderNumber = m.PurchaseOrderNumber
	if m.DeliveryDate != nil {
		t := m.DeliveryDate.AsTime()
		to.DeliveryDate = &t
	}
	if m.DeliveryAddress != nil {
		tempDeliveryAddress, err := m.DeliveryAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DeliveryAddress = &tempDeliveryAddress
	}
	to.Customer = m.Customer
	to.Vendor = m.Vendor
	to.Memo = m.Memo
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(PurchaseOrderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseOrderORM) ToPB(ctx context.Context) (PurchaseOrder, error) {
	to := PurchaseOrder{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.Status = m.Status
	if m.IssueDate != nil {
		to.IssueDate = timestamppb.New(*m.IssueDate)
	}
	to.PurchaseOrderNumber = m.PurchaseOrderNumber
	if m.DeliveryDate != nil {
		to.DeliveryDate = timestamppb.New(*m.DeliveryDate)
	}
	if m.DeliveryAddress != nil {
		tempDeliveryAddress, err := m.DeliveryAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DeliveryAddress = &tempDeliveryAddress
	}
	to.Customer = m.Customer
	to.Vendor = m.Vendor
	to.Memo = m.Memo
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(PurchaseOrderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PurchaseOrder the arg will be the target, the caller the one being converted from

// PurchaseOrderBeforeToORM called before default ToORM code
type PurchaseOrderWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseOrderORM) error
}

// PurchaseOrderAfterToORM called after default ToORM code
type PurchaseOrderWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseOrderORM) error
}

// PurchaseOrderBeforeToPB called before default ToPB code
type PurchaseOrderWithBeforeToPB interface {
	BeforeToPB(context.Context, *PurchaseOrder) error
}

// PurchaseOrderAfterToPB called after default ToPB code
type PurchaseOrderWithAfterToPB interface {
	AfterToPB(context.Context, *PurchaseOrder) error
}

type PurchaseOrderLineItemORM struct {
	Account            string
	Company            string
	Currency           string
	Description        string
	ExchangeRate       string
	Id                 uint64
	Item               string
	ModifiedAt         *time.Time
	PurchaseOrderId    *uint64
	Quantity           int32
	RemoteId           string
	TaxAmount          string
	TotalLineAmount    string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          string
}

// TableName overrides the default tablename generated by GORM
func (PurchaseOrderLineItemORM) TableName() string {
	return "purchase_order_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PurchaseOrderLineItem) ToORM(ctx context.Context) (PurchaseOrderLineItemORM, error) {
	to := PurchaseOrderLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TaxAmount = m.TaxAmount
	to.TotalLineAmount = m.TotalLineAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(PurchaseOrderLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseOrderLineItemORM) ToPB(ctx context.Context) (PurchaseOrderLineItem, error) {
	to := PurchaseOrderLineItem{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TaxAmount = m.TaxAmount
	to.TotalLineAmount = m.TotalLineAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(PurchaseOrderLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PurchaseOrderLineItem the arg will be the target, the caller the one being converted from

// PurchaseOrderLineItemBeforeToORM called before default ToORM code
type PurchaseOrderLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseOrderLineItemORM) error
}

// PurchaseOrderLineItemAfterToORM called after default ToORM code
type PurchaseOrderLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseOrderLineItemORM) error
}

// PurchaseOrderLineItemBeforeToPB called before default ToPB code
type PurchaseOrderLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *PurchaseOrderLineItem) error
}

// PurchaseOrderLineItemAfterToPB called after default ToPB code
type PurchaseOrderLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *PurchaseOrderLineItem) error
}

type TaxRateORM struct {
	Company            string
	Description        string
	EffectiveTaxRate   float64
	Id                 uint64
	MergeAccountId     string
	ModifiedAt         *time.Time
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteWasDeleted   bool
	TotalTaxRate       float64
}

// TableName overrides the default tablename generated by GORM
func (TaxRateORM) TableName() string {
	return "tax_rates"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TaxRate) ToORM(ctx context.Context) (TaxRateORM, error) {
	to := TaxRateORM{}
	var err error
	if prehook, ok := interface{}(m).(TaxRateWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.TotalTaxRate = m.TotalTaxRate
	to.EffectiveTaxRate = m.EffectiveTaxRate
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(TaxRateWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TaxRateORM) ToPB(ctx context.Context) (TaxRate, error) {
	to := TaxRate{}
	var err error
	if prehook, ok := interface{}(m).(TaxRateWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.TotalTaxRate = m.TotalTaxRate
	to.EffectiveTaxRate = m.EffectiveTaxRate
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(TaxRateWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TaxRate the arg will be the target, the caller the one being converted from

// TaxRateBeforeToORM called before default ToORM code
type TaxRateWithBeforeToORM interface {
	BeforeToORM(context.Context, *TaxRateORM) error
}

// TaxRateAfterToORM called after default ToORM code
type TaxRateWithAfterToORM interface {
	AfterToORM(context.Context, *TaxRateORM) error
}

// TaxRateBeforeToPB called before default ToPB code
type TaxRateWithBeforeToPB interface {
	BeforeToPB(context.Context, *TaxRate) error
}

// TaxRateAfterToPB called after default ToPB code
type TaxRateWithAfterToPB interface {
	AfterToPB(context.Context, *TaxRate) error
}

type TrackingCategoryORM struct {
	CategoryType     string
	Company          string
	Id               uint64
	MergeAccountId   string
	ModifiedAt       *time.Time
	ParentCategory   string
	RemoteId         string
	RemoteWasDeleted bool
}

// TableName overrides the default tablename generated by GORM
func (TrackingCategoryORM) TableName() string {
	return "tracking_categories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TrackingCategory) ToORM(ctx context.Context) (TrackingCategoryORM, error) {
	to := TrackingCategoryORM{}
	var err error
	if prehook, ok := interface{}(m).(TrackingCategoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.MergeAccountId = m.MergeAccountId
	to.CategoryType = CategoryType_name[int32(m.CategoryType)]
	to.ParentCategory = m.ParentCategory
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(TrackingCategoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TrackingCategoryORM) ToPB(ctx context.Context) (TrackingCategory, error) {
	to := TrackingCategory{}
	var err error
	if prehook, ok := interface{}(m).(TrackingCategoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.MergeAccountId = m.MergeAccountId
	to.CategoryType = CategoryType(CategoryType_value[m.CategoryType])
	to.ParentCategory = m.ParentCategory
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(TrackingCategoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TrackingCategory the arg will be the target, the caller the one being converted from

// TrackingCategoryBeforeToORM called before default ToORM code
type TrackingCategoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *TrackingCategoryORM) error
}

// TrackingCategoryAfterToORM called after default ToORM code
type TrackingCategoryWithAfterToORM interface {
	AfterToORM(context.Context, *TrackingCategoryORM) error
}

// TrackingCategoryBeforeToPB called before default ToPB code
type TrackingCategoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *TrackingCategory) error
}

// TrackingCategoryAfterToPB called after default ToPB code
type TrackingCategoryWithAfterToPB interface {
	AfterToPB(context.Context, *TrackingCategory) error
}

type BusinessTransactionORM struct {
	Account              string
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	LineItems            []*TransactionLineItemORM `gorm:"foreignkey:BusinessTransactionId;association_foreignkey:Id"`
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	RemoteId             string
	RemoteWasDeleted     bool
	TotalAmount          string
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
	TransactionType      string
}

// TableName overrides the default tablename generated by GORM
func (BusinessTransactionORM) TableName() string {
	return "business_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessTransaction) ToORM(ctx context.Context) (BusinessTransactionORM, error) {
	to := BusinessTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TransactionType = m.TransactionType
	to.Number = m.Number
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(BusinessTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessTransactionORM) ToPB(ctx context.Context) (BusinessTransaction, error) {
	to := BusinessTransaction{}
	var err error
	if prehook, ok := interface{}(m).(BusinessTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TransactionType = m.TransactionType
	to.Number = m.Number
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(BusinessTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessTransaction the arg will be the target, the caller the one being converted from

// BusinessTransactionBeforeToORM called before default ToORM code
type BusinessTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessTransactionORM) error
}

// BusinessTransactionAfterToORM called after default ToORM code
type BusinessTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessTransactionORM) error
}

// BusinessTransactionBeforeToPB called before default ToPB code
type BusinessTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessTransaction) error
}

// BusinessTransactionAfterToPB called after default ToPB code
type BusinessTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessTransaction) error
}

type TransactionLineItemORM struct {
	Account               string
	BusinessTransactionId *uint64
	Company               string
	Currency              string
	ExchangeRate          string
	Id                    uint64
	Item                  string
	Memo                  string
	ModifiedAt            *time.Time
	Quantity              string
	RemoteId              string
	TaxRate               string
	TotalLineAmount       string
	TrackingCategories    pq.StringArray `gorm:"type:text[]"`
	TrackingCategory      string
	UnitPrice             string
}

// TableName overrides the default tablename generated by GORM
func (TransactionLineItemORM) TableName() string {
	return "transaction_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionLineItem) ToORM(ctx context.Context) (TransactionLineItemORM, error) {
	to := TransactionLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Memo = m.Memo
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TotalLineAmount = m.TotalLineAmount
	to.TaxRate = m.TaxRate
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(TransactionLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionLineItemORM) ToPB(ctx context.Context) (TransactionLineItem, error) {
	to := TransactionLineItem{}
	var err error
	if prehook, ok := interface{}(m).(TransactionLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Memo = m.Memo
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TotalLineAmount = m.TotalLineAmount
	to.TaxRate = m.TaxRate
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(TransactionLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionLineItem the arg will be the target, the caller the one being converted from

// TransactionLineItemBeforeToORM called before default ToORM code
type TransactionLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionLineItemORM) error
}

// TransactionLineItemAfterToORM called after default ToORM code
type TransactionLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionLineItemORM) error
}

// TransactionLineItemBeforeToPB called before default ToPB code
type TransactionLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionLineItem) error
}

// TransactionLineItemAfterToPB called after default ToPB code
type TransactionLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionLineItem) error
}

type VendorCreditORM struct {
	AccountingPeriod     string
	Company              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	Lines                []*VendorCreditLineORM `gorm:"foreignkey:VendorCreditId;association_foreignkey:Id"`
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	RemoteId             string
	RemoteWasDeleted     bool
	TotalAmount          float64
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
	Vendor               string
}

// TableName overrides the default tablename generated by GORM
func (VendorCreditORM) TableName() string {
	return "vendor_credits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VendorCredit) ToORM(ctx context.Context) (VendorCreditORM, error) {
	to := VendorCreditORM{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Number = m.Number
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Vendor = m.Vendor
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VendorCreditORM) ToPB(ctx context.Context) (VendorCredit, error) {
	to := VendorCredit{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Number = m.Number
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Vendor = m.Vendor
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VendorCredit the arg will be the target, the caller the one being converted from

// VendorCreditBeforeToORM called before default ToORM code
type VendorCreditWithBeforeToORM interface {
	BeforeToORM(context.Context, *VendorCreditORM) error
}

// VendorCreditAfterToORM called after default ToORM code
type VendorCreditWithAfterToORM interface {
	AfterToORM(context.Context, *VendorCreditORM) error
}

// VendorCreditBeforeToPB called before default ToPB code
type VendorCreditWithBeforeToPB interface {
	BeforeToPB(context.Context, *VendorCredit) error
}

// VendorCreditAfterToPB called after default ToPB code
type VendorCreditWithAfterToPB interface {
	AfterToPB(context.Context, *VendorCredit) error
}

type VendorCreditLineORM struct {
	Account            string
	Company            string
	Description        string
	ExchangeRate       string
	Id                 uint64
	ModifiedAt         *time.Time
	NetAmount          float64
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	VendorCreditId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (VendorCreditLineORM) TableName() string {
	return "vendor_credit_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VendorCreditLine) ToORM(ctx context.Context) (VendorCreditLineORM, error) {
	to := VendorCreditLineORM{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.RemoteId = m.RemoteId
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Description = m.Description
	to.Account = m.Account
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VendorCreditLineORM) ToPB(ctx context.Context) (VendorCreditLine, error) {
	to := VendorCreditLine{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.RemoteId = m.RemoteId
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Description = m.Description
	to.Account = m.Account
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VendorCreditLine the arg will be the target, the caller the one being converted from

// VendorCreditLineBeforeToORM called before default ToORM code
type VendorCreditLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *VendorCreditLineORM) error
}

// VendorCreditLineAfterToORM called after default ToORM code
type VendorCreditLineWithAfterToORM interface {
	AfterToORM(context.Context, *VendorCreditLineORM) error
}

// VendorCreditLineBeforeToPB called before default ToPB code
type VendorCreditLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *VendorCreditLine) error
}

// VendorCreditLineAfterToPB called after default ToPB code
type VendorCreditLineWithAfterToPB interface {
	AfterToPB(context.Context, *VendorCreditLine) error
}

type PlaidAccountInvestmentTransactionORM struct {
	AccountId               string
	Ammount                 string
	Amount                  float64
	CreatedAt               *time.Time
	CurrentDate             string
	Fees                    float64
	Id                      uint64
	InvestmentAccountId     *uint64
	InvestmentTransactionId string
	IsoCurrencyCode         string
	LinkId                  uint64
	Name                    string
	Notes                   []*SmartNoteORM `gorm:"foreignkey:PlaidAccountInvestmentTransactionId;association_foreignkey:Id"`
	Price                   float64
	Quantity                float64
	SecurityId              string
	Subtype                 string
	Time                    *time.Time
	Type                    string
	UnofficialCurrencyCode  string
	UserId                  uint64
}

// TableName overrides the default tablename generated by GORM
func (PlaidAccountInvestmentTransactionORM) TableName() string {
	return "plaid_account_investment_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidAccountInvestmentTransaction) ToORM(ctx context.Context) (PlaidAccountInvestmentTransactionORM, error) {
	to := PlaidAccountInvestmentTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.CurrentDate = m.CurrentDate
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidAccountInvestmentTransactionORM) ToPB(ctx context.Context) (PlaidAccountInvestmentTransaction, error) {
	to := PlaidAccountInvestmentTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.CurrentDate = m.CurrentDate
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidAccountInvestmentTransaction the arg will be the target, the caller the one being converted from

// PlaidAccountInvestmentTransactionBeforeToORM called before default ToORM code
type PlaidAccountInvestmentTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidAccountInvestmentTransactionORM) error
}

// PlaidAccountInvestmentTransactionAfterToORM called after default ToORM code
type PlaidAccountInvestmentTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidAccountInvestmentTransactionORM) error
}

// PlaidAccountInvestmentTransactionBeforeToPB called before default ToPB code
type PlaidAccountInvestmentTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidAccountInvestmentTransaction) error
}

// PlaidAccountInvestmentTransactionAfterToPB called after default ToPB code
type PlaidAccountInvestmentTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidAccountInvestmentTransaction) error
}

type PlaidAccountRecurringTransactionORM struct {
	AccountId                       string
	AverageAmount                   string
	AverageAmountIsoCurrencyCode    string
	BankAccountId                   *uint64
	CategoryId                      string
	CreditAccountId                 *uint64
	Description                     string
	FirstDate                       *time.Time
	Flow                            string
	Frequency                       string
	Id                              uint64
	IsActive                        bool
	LastAmount                      string
	LastAmountIsoCurrencyCode       string
	LastDate                        *time.Time
	LinkId                          uint64
	MerchantName                    string
	Notes                           []*SmartNoteORM `gorm:"foreignkey:PlaidAccountRecurringTransactionId;association_foreignkey:Id"`
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Status                          string
	StreamId                        string
	Time                            *time.Time
	TransactionIds                  string
	UpdatedTime                     *time.Time
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (PlaidAccountRecurringTransactionORM) TableName() string {
	return "plaid_account_recurring_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidAccountRecurringTransaction) ToORM(ctx context.Context) (PlaidAccountRecurringTransactionORM, error) {
	to := PlaidAccountRecurringTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.FirstDate != nil {
		t := m.FirstDate.AsTime()
		to.FirstDate = &t
	}
	if m.LastDate != nil {
		t := m.LastDate.AsTime()
		to.LastDate = &t
	}
	to.Frequency = m.Frequency
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = m.Status
	if m.UpdatedTime != nil {
		t := m.UpdatedTime.AsTime()
		to.UpdatedTime = &t
	}
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = m.Flow
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidAccountRecurringTransactionORM) ToPB(ctx context.Context) (PlaidAccountRecurringTransaction, error) {
	to := PlaidAccountRecurringTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.FirstDate != nil {
		to.FirstDate = timestamppb.New(*m.FirstDate)
	}
	if m.LastDate != nil {
		to.LastDate = timestamppb.New(*m.LastDate)
	}
	to.Frequency = m.Frequency
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = m.Status
	if m.UpdatedTime != nil {
		to.UpdatedTime = timestamppb.New(*m.UpdatedTime)
	}
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = m.Flow
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidAccountRecurringTransaction the arg will be the target, the caller the one being converted from

// PlaidAccountRecurringTransactionBeforeToORM called before default ToORM code
type PlaidAccountRecurringTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidAccountRecurringTransactionORM) error
}

// PlaidAccountRecurringTransactionAfterToORM called after default ToORM code
type PlaidAccountRecurringTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidAccountRecurringTransactionORM) error
}

// PlaidAccountRecurringTransactionBeforeToPB called before default ToPB code
type PlaidAccountRecurringTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidAccountRecurringTransaction) error
}

// PlaidAccountRecurringTransactionAfterToPB called after default ToPB code
type PlaidAccountRecurringTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidAccountRecurringTransaction) error
}

type PlaidAccountTransactionORM struct {
	AccountId                       string
	AccountOwner                    string
	Amount                          float64
	AuthorizedDate                  *time.Time
	AuthorizedDatetime              *time.Time
	BankAccountId                   *uint64
	Categories                      pq.StringArray `gorm:"type:text[]"`
	CategoryId                      string
	CheckNumber                     string
	CreditAccountId                 *uint64
	CurrentDate                     *time.Time
	CurrentDatetime                 *time.Time
	HideTransaction                 bool
	Id                              uint64
	IsoCurrencyCode                 string
	LinkId                          uint64
	LocationAddress                 string
	LocationCity                    string
	LocationCountry                 string
	LocationLat                     float64
	LocationLon                     float64
	LocationPostalCode              string
	LocationRegion                  string
	LocationStoreNumber             string
	MerchantName                    string
	NeedsReview                     bool
	Notes                           []*SmartNoteORM `gorm:"foreignkey:PlaidAccountTransactionId;association_foreignkey:Id"`
	PaymentChannel                  string
	PaymentMetaByOrderOf            string
	PaymentMetaPayee                string
	PaymentMetaPayer                string
	PaymentMetaPaymentMethod        string
	PaymentMetaPaymentProcessor     string
	PaymentMetaPpdId                string
	PaymentMetaReason               string
	PaymentMetaReferenceNumber      string
	Pending                         bool
	PendingTransactionId            string
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Splits                          []*TransactionSplitORM `gorm:"foreignkey:PlaidAccountTransactionId;association_foreignkey:Id"`
	Tags                            pq.StringArray         `gorm:"type:text[]"`
	Time                            *time.Time
	TransactionCode                 string
	TransactionId                   string
	TransactionName                 string
	UnofficialCurrencyCode          string
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (PlaidAccountTransactionORM) TableName() string {
	return "plaid_account_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidAccountTransaction) ToORM(ctx context.Context) (PlaidAccountTransactionORM, error) {
	to := PlaidAccountTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	if m.CurrentDate != nil {
		t := m.CurrentDate.AsTime()
		to.CurrentDate = &t
	}
	if m.CurrentDatetime != nil {
		t := m.CurrentDatetime.AsTime()
		to.CurrentDatetime = &t
	}
	if m.AuthorizedDate != nil {
		t := m.AuthorizedDate.AsTime()
		to.AuthorizedDate = &t
	}
	if m.AuthorizedDatetime != nil {
		t := m.AuthorizedDatetime.AsTime()
		to.AuthorizedDatetime = &t
	}
	to.CategoryId = m.CategoryId
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.TransactionName = m.TransactionName
	to.MerchantName = m.MerchantName
	to.CheckNumber = m.CheckNumber
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.NeedsReview = m.NeedsReview
	to.HideTransaction = m.HideTransaction
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	for _, v := range m.Splits {
		if v != nil {
			if tempSplits, cErr := v.ToORM(ctx); cErr == nil {
				to.Splits = append(to.Splits, &tempSplits)
			} else {
				return to, cErr
			}
		} else {
			to.Splits = append(to.Splits, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidAccountTransactionORM) ToPB(ctx context.Context) (PlaidAccountTransaction, error) {
	to := PlaidAccountTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	if m.CurrentDate != nil {
		to.CurrentDate = timestamppb.New(*m.CurrentDate)
	}
	if m.CurrentDatetime != nil {
		to.CurrentDatetime = timestamppb.New(*m.CurrentDatetime)
	}
	if m.AuthorizedDate != nil {
		to.AuthorizedDate = timestamppb.New(*m.AuthorizedDate)
	}
	if m.AuthorizedDatetime != nil {
		to.AuthorizedDatetime = timestamppb.New(*m.AuthorizedDatetime)
	}
	to.CategoryId = m.CategoryId
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.TransactionName = m.TransactionName
	to.MerchantName = m.MerchantName
	to.CheckNumber = m.CheckNumber
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.NeedsReview = m.NeedsReview
	to.HideTransaction = m.HideTransaction
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	for _, v := range m.Splits {
		if v != nil {
			if tempSplits, cErr := v.ToPB(ctx); cErr == nil {
				to.Splits = append(to.Splits, &tempSplits)
			} else {
				return to, cErr
			}
		} else {
			to.Splits = append(to.Splits, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidAccountTransaction the arg will be the target, the caller the one being converted from

// PlaidAccountTransactionBeforeToORM called before default ToORM code
type PlaidAccountTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidAccountTransactionORM) error
}

// PlaidAccountTransactionAfterToORM called after default ToORM code
type PlaidAccountTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidAccountTransactionORM) error
}

// PlaidAccountTransactionBeforeToPB called before default ToPB code
type PlaidAccountTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidAccountTransaction) error
}

// PlaidAccountTransactionAfterToPB called after default ToPB code
type PlaidAccountTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidAccountTransaction) error
}

type TransactionSplitORM struct {
	Amount                          float64
	AuthorizedDate                  *time.Time
	AuthorizedDatetime              *time.Time
	Categories                      pq.StringArray `gorm:"type:text[]"`
	Description                     string
	Id                              uint64
	LinkId                          uint64
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	PlaidAccountTransactionId       *uint64
	Tags                            pq.StringArray `gorm:"type:text[]"`
	TimeOfSplit                     *time.Time
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (TransactionSplitORM) TableName() string {
	return "transaction_splits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionSplit) ToORM(ctx context.Context) (TransactionSplitORM, error) {
	to := TransactionSplitORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionSplitWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Description = m.Description
	to.Amount = m.Amount
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.AuthorizedDate != nil {
		t := m.AuthorizedDate.AsTime()
		to.AuthorizedDate = &t
	}
	if m.AuthorizedDatetime != nil {
		t := m.AuthorizedDatetime.AsTime()
		to.AuthorizedDatetime = &t
	}
	if m.TimeOfSplit != nil {
		t := m.TimeOfSplit.AsTime()
		to.TimeOfSplit = &t
	}
	if posthook, ok := interface{}(m).(TransactionSplitWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionSplitORM) ToPB(ctx context.Context) (TransactionSplit, error) {
	to := TransactionSplit{}
	var err error
	if prehook, ok := interface{}(m).(TransactionSplitWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Description = m.Description
	to.Amount = m.Amount
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.AuthorizedDate != nil {
		to.AuthorizedDate = timestamppb.New(*m.AuthorizedDate)
	}
	if m.AuthorizedDatetime != nil {
		to.AuthorizedDatetime = timestamppb.New(*m.AuthorizedDatetime)
	}
	if m.TimeOfSplit != nil {
		to.TimeOfSplit = timestamppb.New(*m.TimeOfSplit)
	}
	if posthook, ok := interface{}(m).(TransactionSplitWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionSplit the arg will be the target, the caller the one being converted from

// TransactionSplitBeforeToORM called before default ToORM code
type TransactionSplitWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionSplitORM) error
}

// TransactionSplitAfterToORM called after default ToORM code
type TransactionSplitWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionSplitORM) error
}

// TransactionSplitBeforeToPB called before default ToPB code
type TransactionSplitWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionSplit) error
}

// TransactionSplitAfterToPB called after default ToPB code
type TransactionSplitWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionSplit) error
}

// DefaultCreateStripeSubscription executes a basic gorm create call
func DefaultCreateStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StripeSubscriptionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StripeSubscriptionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StripeSubscriptionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StripeSubscriptionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StripeSubscriptionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StripeSubscriptionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StripeSubscriptionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStripeSubscriptionSet(ctx context.Context, in []*StripeSubscription, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StripeSubscriptionORM{})).(StripeSubscriptionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StripeSubscriptionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StripeSubscriptionORM{})).(StripeSubscriptionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StripeSubscriptionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StripeSubscription, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StripeSubscription, *gorm.DB) error
}

// DefaultStrictUpdateStripeSubscription clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStripeSubscription")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StripeSubscriptionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StripeSubscriptionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchStripeSubscription executes a basic gorm update call with patch behavior
func DefaultPatchStripeSubscription(ctx context.Context, in *StripeSubscription, updateMask *field_mask.FieldMask, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj StripeSubscription
	var err error
	if hook, ok := interface{}(&pbObj).(StripeSubscriptionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStripeSubscription(ctx, &StripeSubscription{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StripeSubscriptionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStripeSubscription(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StripeSubscriptionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStripeSubscription(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StripeSubscriptionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StripeSubscriptionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetStripeSubscription executes a bulk gorm update call with patch behavior
func DefaultPatchSetStripeSubscription(ctx context.Context, objects []*StripeSubscription, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*StripeSubscription, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StripeSubscription, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStripeSubscription(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStripeSubscription patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStripeSubscription(ctx context.Context, patchee *StripeSubscription, patcher *StripeSubscription, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*StripeSubscription, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"StripeSubscriptionId" {
			patchee.StripeSubscriptionId = patcher.StripeSubscriptionId
			continue
		}
		if f == prefix+"StripeSubscriptionStatus" {
			patchee.StripeSubscriptionStatus = patcher.StripeSubscriptionStatus
			continue
		}
		if f == prefix+"StripeSubscriptionActiveUntil" {
			patchee.StripeSubscriptionActiveUntil = patcher.StripeSubscriptionActiveUntil
			continue
		}
		if f == prefix+"StripeWebhookLatestTimestamp" {
			patchee.StripeWebhookLatestTimestamp = patcher.StripeWebhookLatestTimestamp
			continue
		}
		if f == prefix+"IsTrialing" {
			patchee.IsTrialing = patcher.IsTrialing
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStripeSubscription executes a gorm list call
func DefaultListStripeSubscription(ctx context.Context, db *gorm.DB) ([]*StripeSubscription, error) {
	in := StripeSubscription{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StripeSubscriptionORM{}, &StripeSubscription{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StripeSubscriptionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StripeSubscription{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StripeSubscriptionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StripeSubscriptionORM) error
}

// DefaultCreateFinancialUserProfile executes a basic gorm create call
func DefaultCreateFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FinancialUserProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FinancialUserProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FinancialUserProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FinancialUserProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FinancialUserProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FinancialUserProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FinancialUserProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialUserProfileSet(ctx context.Context, in []*FinancialUserProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FinancialUserProfileORM{})).(FinancialUserProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FinancialUserProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FinancialUserProfileORM{})).(FinancialUserProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FinancialUserProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FinancialUserProfile, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FinancialUserProfile, *gorm.DB) error
}

// DefaultStrictUpdateFinancialUserProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFinancialUserProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FinancialUserProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterActionableInsights := ActionableInsightORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterActionableInsights.FinancialUserProfileId = new(uint64)
	*filterActionableInsights.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterActionableInsights).Delete(ActionableInsightORM{}).Error; err != nil {
		return nil, err
	}
	filterActionablePersonalInsights := PersonalActionableInsightORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterActionablePersonalInsights.FinancialUserProfileId = new(uint64)
	*filterActionablePersonalInsights.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterActionablePersonalInsights).Delete(PersonalActionableInsightORM{}).Error; err != nil {
		return nil, err
	}
	filterLink := LinkORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLink.FinancialUserProfileId = new(uint64)
	*filterLink.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterLink).Delete(LinkORM{}).Error; err != nil {
		return nil, err
	}
	filterMergeLiink := MergeLinkORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMergeLiink.FinancialUserProfileId = new(uint64)
	*filterMergeLiink.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterMergeLiink).Delete(MergeLinkORM{}).Error; err != nil {
		return nil, err
	}
	filterStripeSubscriptions := StripeSubscriptionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterStripeSubscriptions.FinancialUserProfileId = new(uint64)
	*filterStripeSubscriptions.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterStripeSubscriptions).Delete(StripeSubscriptionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FinancialUserProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFinancialUserProfile executes a basic gorm update call with patch behavior
func DefaultPatchFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FinancialUserProfile
	var err error
	if hook, ok := interface{}(&pbObj).(FinancialUserProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFinancialUserProfile(ctx, &FinancialUserProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FinancialUserProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFinancialUserProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FinancialUserProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFinancialUserProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FinancialUserProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FinancialUserProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFinancialUserProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetFinancialUserProfile(ctx context.Context, objects []*FinancialUserProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FinancialUserProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FinancialUserProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFinancialUserProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFinancialUserProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFinancialUserProfile(ctx context.Context, patchee *FinancialUserProfile, patcher *FinancialUserProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FinancialUserProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStripeSubscriptions bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"StripeCustomerId" {
			patchee.StripeCustomerId = patcher.StripeCustomerId
			continue
		}
		if !updatedStripeSubscriptions && strings.HasPrefix(f, prefix+"StripeSubscriptions.") {
			updatedStripeSubscriptions = true
			if patcher.StripeSubscriptions == nil {
				patchee.StripeSubscriptions = nil
				continue
			}
			if patchee.StripeSubscriptions == nil {
				patchee.StripeSubscriptions = &StripeSubscription{}
			}
			if o, err := DefaultApplyFieldMaskStripeSubscription(ctx, patchee.StripeSubscriptions, patcher.StripeSubscriptions, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"StripeSubscriptions.", db); err != nil {
				return nil, err
			} else {
				patchee.StripeSubscriptions = o
			}
			continue
		}
		if f == prefix+"StripeSubscriptions" {
			updatedStripeSubscriptions = true
			patchee.StripeSubscriptions = patcher.StripeSubscriptions
			continue
		}
		if f == prefix+"Link" {
			patchee.Link = patcher.Link
			continue
		}
		if f == prefix+"ActionableInsights" {
			patchee.ActionableInsights = patcher.ActionableInsights
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"MergeLiink" {
			patchee.MergeLiink = patcher.MergeLiink
			continue
		}
		if f == prefix+"ActionablePersonalInsights" {
			patchee.ActionablePersonalInsights = patcher.ActionablePersonalInsights
			continue
		}
		if f == prefix+"ProfileType" {
			patchee.ProfileType = patcher.ProfileType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFinancialUserProfile executes a gorm list call
func DefaultListFinancialUserProfile(ctx context.Context, db *gorm.DB) ([]*FinancialUserProfile, error) {
	in := FinancialUserProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FinancialUserProfileORM{}, &FinancialUserProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FinancialUserProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FinancialUserProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FinancialUserProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FinancialUserProfileORM) error
}

// DefaultCreateActionableInsight executes a basic gorm create call
func DefaultCreateActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ActionableInsightORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ActionableInsightORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ActionableInsightORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ActionableInsightORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ActionableInsightORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ActionableInsightORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteActionableInsightSet(ctx context.Context, in []*ActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ActionableInsightORM{})).(ActionableInsightORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ActionableInsightORM{})).(ActionableInsightORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ActionableInsightORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ActionableInsight, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ActionableInsight, *gorm.DB) error
}

// DefaultStrictUpdateActionableInsight clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateActionableInsight")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ActionableInsightORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ActionableInsightORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchActionableInsight executes a basic gorm update call with patch behavior
func DefaultPatchActionableInsight(ctx context.Context, in *ActionableInsight, updateMask *field_mask.FieldMask, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ActionableInsight
	var err error
	if hook, ok := interface{}(&pbObj).(ActionableInsightWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadActionableInsight(ctx, &ActionableInsight{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ActionableInsightWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskActionableInsight(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ActionableInsightWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateActionableInsight(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ActionableInsightWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ActionableInsightWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetActionableInsight executes a bulk gorm update call with patch behavior
func DefaultPatchSetActionableInsight(ctx context.Context, objects []*ActionableInsight, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ActionableInsight, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ActionableInsight, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchActionableInsight(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskActionableInsight patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskActionableInsight(ctx context.Context, patchee *ActionableInsight, patcher *ActionableInsight, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ActionableInsight, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedGeneratedTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"DetailedAction" {
			patchee.DetailedAction = patcher.DetailedAction
			continue
		}
		if f == prefix+"SummarizedAction" {
			patchee.SummarizedAction = patcher.SummarizedAction
			continue
		}
		if !updatedGeneratedTime && strings.HasPrefix(f, prefix+"GeneratedTime.") {
			if patcher.GeneratedTime == nil {
				patchee.GeneratedTime = nil
				continue
			}
			if patchee.GeneratedTime == nil {
				patchee.GeneratedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"GeneratedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.GeneratedTime, patchee.GeneratedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"GeneratedTime" {
			updatedGeneratedTime = true
			patchee.GeneratedTime = patcher.GeneratedTime
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListActionableInsight executes a gorm list call
func DefaultListActionableInsight(ctx context.Context, db *gorm.DB) ([]*ActionableInsight, error) {
	in := ActionableInsight{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ActionableInsightORM{}, &ActionableInsight{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ActionableInsightORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ActionableInsight{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ActionableInsightORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ActionableInsightORM) error
}

// DefaultCreatePersonalActionableInsight executes a basic gorm create call
func DefaultCreatePersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PersonalActionableInsightORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PersonalActionableInsightORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PersonalActionableInsightORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PersonalActionableInsightORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PersonalActionableInsightORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PersonalActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PersonalActionableInsightORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalActionableInsightSet(ctx context.Context, in []*PersonalActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PersonalActionableInsightORM{})).(PersonalActionableInsightORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PersonalActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PersonalActionableInsightORM{})).(PersonalActionableInsightORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PersonalActionableInsightORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PersonalActionableInsight, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PersonalActionableInsight, *gorm.DB) error
}

// DefaultStrictUpdatePersonalActionableInsight clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePersonalActionableInsight")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PersonalActionableInsightORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PersonalActionableInsightORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPersonalActionableInsight executes a basic gorm update call with patch behavior
func DefaultPatchPersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, updateMask *field_mask.FieldMask, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PersonalActionableInsight
	var err error
	if hook, ok := interface{}(&pbObj).(PersonalActionableInsightWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPersonalActionableInsight(ctx, &PersonalActionableInsight{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PersonalActionableInsightWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPersonalActionableInsight(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PersonalActionableInsightWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePersonalActionableInsight(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PersonalActionableInsightWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PersonalActionableInsightWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPersonalActionableInsight executes a bulk gorm update call with patch behavior
func DefaultPatchSetPersonalActionableInsight(ctx context.Context, objects []*PersonalActionableInsight, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PersonalActionableInsight, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PersonalActionableInsight, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPersonalActionableInsight(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPersonalActionableInsight patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPersonalActionableInsight(ctx context.Context, patchee *PersonalActionableInsight, patcher *PersonalActionableInsight, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PersonalActionableInsight, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedGeneratedTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"InsightName" {
			patchee.InsightName = patcher.InsightName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Takeaway" {
			patchee.Takeaway = patcher.Takeaway
			continue
		}
		if f == prefix+"Action" {
			patchee.Action = patcher.Action
			continue
		}
		if f == prefix+"ExpectedBenefit" {
			patchee.ExpectedBenefit = patcher.ExpectedBenefit
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedGeneratedTime && strings.HasPrefix(f, prefix+"GeneratedTime.") {
			if patcher.GeneratedTime == nil {
				patchee.GeneratedTime = nil
				continue
			}
			if patchee.GeneratedTime == nil {
				patchee.GeneratedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"GeneratedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.GeneratedTime, patchee.GeneratedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"GeneratedTime" {
			updatedGeneratedTime = true
			patchee.GeneratedTime = patcher.GeneratedTime
			continue
		}
		if f == prefix+"MetricsToOptimizeFor" {
			patchee.MetricsToOptimizeFor = patcher.MetricsToOptimizeFor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPersonalActionableInsight executes a gorm list call
func DefaultListPersonalActionableInsight(ctx context.Context, db *gorm.DB) ([]*PersonalActionableInsight, error) {
	in := PersonalActionableInsight{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PersonalActionableInsightORM{}, &PersonalActionableInsight{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PersonalActionableInsightORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PersonalActionableInsight{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PersonalActionableInsightORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PersonalActionableInsightORM) error
}

// DefaultCreateLink executes a basic gorm create call
func DefaultCreateLink(ctx context.Context, in *Link, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLink(ctx context.Context, in *Link, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLink(ctx context.Context, in *Link, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkSet(ctx context.Context, in []*Link, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LinkORM{})).(LinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LinkORM{})).(LinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Link, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Link, *gorm.DB) error
}

// DefaultStrictUpdateLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLink(ctx context.Context, in *Link, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBankAccounts := BankAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBankAccounts.LinkId = new(uint64)
	*filterBankAccounts.LinkId = ormObj.Id
	if err = db.Where(filterBankAccounts).Delete(BankAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterCreditAccounts := CreditAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCreditAccounts.LinkId = new(uint64)
	*filterCreditAccounts.LinkId = ormObj.Id
	if err = db.Where(filterCreditAccounts).Delete(CreditAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestmentAccounts := InvestmentAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvestmentAccounts.LinkId = new(uint64)
	*filterInvestmentAccounts.LinkId = ormObj.Id
	if err = db.Where(filterInvestmentAccounts).Delete(InvestmentAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterMortgageAccounts := MortgageAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMortgageAccounts.LinkId = new(uint64)
	*filterMortgageAccounts.LinkId = ormObj.Id
	if err = db.Where(filterMortgageAccounts).Delete(MortgageAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterPlaidLink := PlaidLinkORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPlaidLink.LinkId = new(uint64)
	*filterPlaidLink.LinkId = ormObj.Id
	if err = db.Where(filterPlaidLink).Delete(PlaidLinkORM{}).Error; err != nil {
		return nil, err
	}
	filterPlaidSync := PlaidSyncORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPlaidSync.LinkId = new(uint64)
	*filterPlaidSync.LinkId = ormObj.Id
	if err = db.Where(filterPlaidSync).Delete(PlaidSyncORM{}).Error; err != nil {
		return nil, err
	}
	filterStudentLoanAccounts := StudentLoanAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterStudentLoanAccounts.LinkId = new(uint64)
	*filterStudentLoanAccounts.LinkId = ormObj.Id
	if err = db.Where(filterStudentLoanAccounts).Delete(StudentLoanAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterToken := TokenORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterToken.LinkId = new(uint64)
	*filterToken.LinkId = ormObj.Id
	if err = db.Where(filterToken).Delete(TokenORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLink executes a basic gorm update call with patch behavior
func DefaultPatchLink(ctx context.Context, in *Link, updateMask *field_mask.FieldMask, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Link
	var err error
	if hook, ok := interface{}(&pbObj).(LinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLink(ctx, &Link{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetLink(ctx context.Context, objects []*Link, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Link, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Link, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLink(ctx context.Context, patchee *Link, patcher *Link, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Link, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPlaidSync bool
	var updatedPlaidLink bool
	var updatedToken bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedPlaidSync && strings.HasPrefix(f, prefix+"PlaidSync.") {
			updatedPlaidSync = true
			if patcher.PlaidSync == nil {
				patchee.PlaidSync = nil
				continue
			}
			if patchee.PlaidSync == nil {
				patchee.PlaidSync = &PlaidSync{}
			}
			if o, err := DefaultApplyFieldMaskPlaidSync(ctx, patchee.PlaidSync, patcher.PlaidSync, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PlaidSync.", db); err != nil {
				return nil, err
			} else {
				patchee.PlaidSync = o
			}
			continue
		}
		if f == prefix+"PlaidSync" {
			updatedPlaidSync = true
			patchee.PlaidSync = patcher.PlaidSync
			continue
		}
		if f == prefix+"LinkStatus" {
			patchee.LinkStatus = patcher.LinkStatus
			continue
		}
		if !updatedPlaidLink && strings.HasPrefix(f, prefix+"PlaidLink.") {
			updatedPlaidLink = true
			if patcher.PlaidLink == nil {
				patchee.PlaidLink = nil
				continue
			}
			if patchee.PlaidLink == nil {
				patchee.PlaidLink = &PlaidLink{}
			}
			if o, err := DefaultApplyFieldMaskPlaidLink(ctx, patchee.PlaidLink, patcher.PlaidLink, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PlaidLink.", db); err != nil {
				return nil, err
			} else {
				patchee.PlaidLink = o
			}
			continue
		}
		if f == prefix+"PlaidLink" {
			updatedPlaidLink = true
			patchee.PlaidLink = patcher.PlaidLink
			continue
		}
		if f == prefix+"PlaidNewAccountsAvailable" {
			patchee.PlaidNewAccountsAvailable = patcher.PlaidNewAccountsAvailable
			continue
		}
		if f == prefix+"ExpirationDate" {
			patchee.ExpirationDate = patcher.ExpirationDate
			continue
		}
		if f == prefix+"InstitutionName" {
			patchee.InstitutionName = patcher.InstitutionName
			continue
		}
		if f == prefix+"CustomInstitutionName" {
			patchee.CustomInstitutionName = patcher.CustomInstitutionName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"LastManualSync" {
			patchee.LastManualSync = patcher.LastManualSync
			continue
		}
		if f == prefix+"LastSuccessfulUpdate" {
			patchee.LastSuccessfulUpdate = patcher.LastSuccessfulUpdate
			continue
		}
		if !updatedToken && strings.HasPrefix(f, prefix+"Token.") {
			updatedToken = true
			if patcher.Token == nil {
				patchee.Token = nil
				continue
			}
			if patchee.Token == nil {
				patchee.Token = &Token{}
			}
			if o, err := DefaultApplyFieldMaskToken(ctx, patchee.Token, patcher.Token, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Token.", db); err != nil {
				return nil, err
			} else {
				patchee.Token = o
			}
			continue
		}
		if f == prefix+"Token" {
			updatedToken = true
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"BankAccounts" {
			patchee.BankAccounts = patcher.BankAccounts
			continue
		}
		if f == prefix+"InvestmentAccounts" {
			patchee.InvestmentAccounts = patcher.InvestmentAccounts
			continue
		}
		if f == prefix+"CreditAccounts" {
			patchee.CreditAccounts = patcher.CreditAccounts
			continue
		}
		if f == prefix+"MortgageAccounts" {
			patchee.MortgageAccounts = patcher.MortgageAccounts
			continue
		}
		if f == prefix+"StudentLoanAccounts" {
			patchee.StudentLoanAccounts = patcher.StudentLoanAccounts
			continue
		}
		if f == prefix+"PlaidInstitutionId" {
			patchee.PlaidInstitutionId = patcher.PlaidInstitutionId
			continue
		}
		if f == prefix+"LinkType" {
			patchee.LinkType = patcher.LinkType
			continue
		}
		if f == prefix+"ErrorCode" {
			patchee.ErrorCode = patcher.ErrorCode
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"NewAccountsAvailable" {
			patchee.NewAccountsAvailable = patcher.NewAccountsAvailable
			continue
		}
		if f == prefix+"ShouldBeUpdated" {
			patchee.ShouldBeUpdated = patcher.ShouldBeUpdated
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLink executes a gorm list call
func DefaultListLink(ctx context.Context, db *gorm.DB) ([]*Link, error) {
	in := Link{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LinkORM{}, &Link{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Link{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LinkORM) error
}

// DefaultCreatePlaidSync executes a basic gorm create call
func DefaultCreatePlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidSyncORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidSyncORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidSyncORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidSyncORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidSyncORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidSyncORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidSyncORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidSyncSet(ctx context.Context, in []*PlaidSync, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidSyncORM{})).(PlaidSyncORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidSyncORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidSyncORM{})).(PlaidSyncORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidSyncORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidSync, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidSync, *gorm.DB) error
}

// DefaultStrictUpdatePlaidSync clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidSync")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidSyncORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidSyncORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidSync executes a basic gorm update call with patch behavior
func DefaultPatchPlaidSync(ctx context.Context, in *PlaidSync, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidSync
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidSyncWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidSync(ctx, &PlaidSync{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidSyncWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidSync(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidSyncWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidSync(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidSyncWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidSyncWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidSync executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidSync(ctx context.Context, objects []*PlaidSync, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidSync, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidSync, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidSync(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidSync patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidSync(ctx context.Context, patchee *PlaidSync, patcher *PlaidSync, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidSync, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TimeStamp" {
			patchee.TimeStamp = patcher.TimeStamp
			continue
		}
		if f == prefix+"Trigger" {
			patchee.Trigger = patcher.Trigger
			continue
		}
		if f == prefix+"NextCursor" {
			patchee.NextCursor = patcher.NextCursor
			continue
		}
		if f == prefix+"Added" {
			patchee.Added = patcher.Added
			continue
		}
		if f == prefix+"Removed" {
			patchee.Removed = patcher.Removed
			continue
		}
		if f == prefix+"Modified" {
			patchee.Modified = patcher.Modified
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidSync executes a gorm list call
func DefaultListPlaidSync(ctx context.Context, db *gorm.DB) ([]*PlaidSync, error) {
	in := PlaidSync{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidSyncORM{}, &PlaidSync{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidSyncORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidSync{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidSyncORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidSyncORM) error
}

// DefaultCreateToken executes a basic gorm create call
func DefaultCreateToken(ctx context.Context, in *Token, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TokenORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadToken(ctx context.Context, in *Token, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TokenORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TokenORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TokenORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TokenORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteToken(ctx context.Context, in *Token, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TokenORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TokenORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTokenSet(ctx context.Context, in []*Token, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TokenORM{})).(TokenORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TokenORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TokenORM{})).(TokenORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TokenORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Token, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Token, *gorm.DB) error
}

// DefaultStrictUpdateToken clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateToken(ctx context.Context, in *Token, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateToken")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TokenORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TokenORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchToken executes a basic gorm update call with patch behavior
func DefaultPatchToken(ctx context.Context, in *Token, updateMask *field_mask.FieldMask, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Token
	var err error
	if hook, ok := interface{}(&pbObj).(TokenWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadToken(ctx, &Token{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TokenWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskToken(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TokenWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateToken(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TokenWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TokenWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetToken executes a bulk gorm update call with patch behavior
func DefaultPatchSetToken(ctx context.Context, objects []*Token, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Token, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Token, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchToken(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskToken patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskToken(ctx context.Context, patchee *Token, patcher *Token, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Token, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastMergeCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ItemId" {
			patchee.ItemId = patcher.ItemId
			continue
		}
		if f == prefix+"KeyId" {
			patchee.KeyId = patcher.KeyId
			continue
		}
		if f == prefix+"AccessToken" {
			patchee.AccessToken = patcher.AccessToken
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"MergeEndUserOriginId" {
			patchee.MergeEndUserOriginId = patcher.MergeEndUserOriginId
			continue
		}
		if f == prefix+"MergeIntegrationSlug" {
			patchee.MergeIntegrationSlug = patcher.MergeIntegrationSlug
			continue
		}
		if !updatedLastMergeCreatedAt && strings.HasPrefix(f, prefix+"LastMergeCreatedAt.") {
			if patcher.LastMergeCreatedAt == nil {
				patchee.LastMergeCreatedAt = nil
				continue
			}
			if patchee.LastMergeCreatedAt == nil {
				patchee.LastMergeCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastMergeCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastMergeCreatedAt, patchee.LastMergeCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastMergeCreatedAt" {
			updatedLastMergeCreatedAt = true
			patchee.LastMergeCreatedAt = patcher.LastMergeCreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListToken executes a gorm list call
func DefaultListToken(ctx context.Context, db *gorm.DB) ([]*Token, error) {
	in := Token{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TokenORM{}, &Token{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TokenORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Token{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TokenORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TokenORM) error
}

// DefaultCreatePlaidLink executes a basic gorm create call
func DefaultCreatePlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidLinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidLinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidLinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidLinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidLinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidLinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidLinkSet(ctx context.Context, in []*PlaidLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidLinkORM{})).(PlaidLinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidLinkORM{})).(PlaidLinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidLinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidLink, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidLink, *gorm.DB) error
}

// DefaultStrictUpdatePlaidLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidLinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidLinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidLink executes a basic gorm update call with patch behavior
func DefaultPatchPlaidLink(ctx context.Context, in *PlaidLink, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidLink
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidLinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidLink(ctx, &PlaidLink{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidLinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidLinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidLinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidLinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidLink(ctx context.Context, objects []*PlaidLink, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidLink, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidLink, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidLink(ctx context.Context, patchee *PlaidLink, patcher *PlaidLink, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidLink, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Products" {
			patchee.Products = patcher.Products
			continue
		}
		if f == prefix+"WebhookUrl" {
			patchee.WebhookUrl = patcher.WebhookUrl
			continue
		}
		if f == prefix+"InstitutionId" {
			patchee.InstitutionId = patcher.InstitutionId
			continue
		}
		if f == prefix+"InstitutionName" {
			patchee.InstitutionName = patcher.InstitutionName
			continue
		}
		if f == prefix+"UsePlaidSync" {
			patchee.UsePlaidSync = patcher.UsePlaidSync
			continue
		}
		if f == prefix+"ItemId" {
			patchee.ItemId = patcher.ItemId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidLink executes a gorm list call
func DefaultListPlaidLink(ctx context.Context, db *gorm.DB) ([]*PlaidLink, error) {
	in := PlaidLink{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidLinkORM{}, &PlaidLink{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidLinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidLink{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidLinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidLinkORM) error
}

// DefaultCreateStudentLoanAccount executes a basic gorm create call
func DefaultCreateStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StudentLoanAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StudentLoanAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StudentLoanAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StudentLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StudentLoanAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStudentLoanAccountSet(ctx context.Context, in []*StudentLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StudentLoanAccountORM{})).(StudentLoanAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StudentLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StudentLoanAccountORM{})).(StudentLoanAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StudentLoanAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StudentLoanAccount, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StudentLoanAccount, *gorm.DB) error
}

// DefaultStrictUpdateStudentLoanAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStudentLoanAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StudentLoanAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchStudentLoanAccount executes a basic gorm update call with patch behavior
func DefaultPatchStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj StudentLoanAccount
	var err error
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStudentLoanAccount(ctx, &StudentLoanAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStudentLoanAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStudentLoanAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StudentLoanAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StudentLoanAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetStudentLoanAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetStudentLoanAccount(ctx context.Context, objects []*StudentLoanAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*StudentLoanAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StudentLoanAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStudentLoanAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStudentLoanAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStudentLoanAccount(ctx context.Context, patchee *StudentLoanAccount, patcher *StudentLoanAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*StudentLoanAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"DisbursementDates" {
			patchee.DisbursementDates = patcher.DisbursementDates
			continue
		}
		if f == prefix+"ExpectedPayoffDate" {
			patchee.ExpectedPayoffDate = patcher.ExpectedPayoffDate
			continue
		}
		if f == prefix+"Guarantor" {
			patchee.Guarantor = patcher.Guarantor
			continue
		}
		if f == prefix+"InterestRatePercentage" {
			patchee.InterestRatePercentage = patcher.InterestRatePercentage
			continue
		}
		if f == prefix+"IsOverdue" {
			patchee.IsOverdue = patcher.IsOverdue
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LastStatementIssueDate" {
			patchee.LastStatementIssueDate = patcher.LastStatementIssueDate
			continue
		}
		if f == prefix+"LoanName" {
			patchee.LoanName = patcher.LoanName
			continue
		}
		if f == prefix+"LoanEndDate" {
			patchee.LoanEndDate = patcher.LoanEndDate
			continue
		}
		if f == prefix+"MinimumPaymentAmount" {
			patchee.MinimumPaymentAmount = patcher.MinimumPaymentAmount
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"OriginationDate" {
			patchee.OriginationDate = patcher.OriginationDate
			continue
		}
		if f == prefix+"OriginationPrincipalAmount" {
			patchee.OriginationPrincipalAmount = patcher.OriginationPrincipalAmount
			continue
		}
		if f == prefix+"OutstandingInterestAmount" {
			patchee.OutstandingInterestAmount = patcher.OutstandingInterestAmount
			continue
		}
		if f == prefix+"PaymentReferenceNumber" {
			patchee.PaymentReferenceNumber = patcher.PaymentReferenceNumber
			continue
		}
		if f == prefix+"SequenceNumber" {
			patchee.SequenceNumber = patcher.SequenceNumber
			continue
		}
		if f == prefix+"YtdInterestPaid" {
			patchee.YtdInterestPaid = patcher.YtdInterestPaid
			continue
		}
		if f == prefix+"YtdPrincipalPaid" {
			patchee.YtdPrincipalPaid = patcher.YtdPrincipalPaid
			continue
		}
		if f == prefix+"LoanType" {
			patchee.LoanType = patcher.LoanType
			continue
		}
		if f == prefix+"PslfStatusEstimatedEligibilityDate" {
			patchee.PslfStatusEstimatedEligibilityDate = patcher.PslfStatusEstimatedEligibilityDate
			continue
		}
		if f == prefix+"PslfStatusPaymentsMade" {
			patchee.PslfStatusPaymentsMade = patcher.PslfStatusPaymentsMade
			continue
		}
		if f == prefix+"PslfStatusPaymentsRemaining" {
			patchee.PslfStatusPaymentsRemaining = patcher.PslfStatusPaymentsRemaining
			continue
		}
		if f == prefix+"RepaymentPlanType" {
			patchee.RepaymentPlanType = patcher.RepaymentPlanType
			continue
		}
		if f == prefix+"RepaymentPlanDescription" {
			patchee.RepaymentPlanDescription = patcher.RepaymentPlanDescription
			continue
		}
		if f == prefix+"ServicerAddressCity" {
			patchee.ServicerAddressCity = patcher.ServicerAddressCity
			continue
		}
		if f == prefix+"ServicerAddressPostalCode" {
			patchee.ServicerAddressPostalCode = patcher.ServicerAddressPostalCode
			continue
		}
		if f == prefix+"ServicerAddressState" {
			patchee.ServicerAddressState = patcher.ServicerAddressState
			continue
		}
		if f == prefix+"ServicerAddressStreet" {
			patchee.ServicerAddressStreet = patcher.ServicerAddressStreet
			continue
		}
		if f == prefix+"ServicerAddressRegion" {
			patchee.ServicerAddressRegion = patcher.ServicerAddressRegion
			continue
		}
		if f == prefix+"ServicerAddressCountry" {
			patchee.ServicerAddressCountry = patcher.ServicerAddressCountry
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStudentLoanAccount executes a gorm list call
func DefaultListStudentLoanAccount(ctx context.Context, db *gorm.DB) ([]*StudentLoanAccount, error) {
	in := StudentLoanAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StudentLoanAccountORM{}, &StudentLoanAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StudentLoanAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StudentLoanAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StudentLoanAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StudentLoanAccountORM) error
}

// DefaultCreateCreditAccount executes a basic gorm create call
func DefaultCreateCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditAccountSet(ctx context.Context, in []*CreditAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditAccountORM{})).(CreditAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditAccountORM{})).(CreditAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditAccount, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditAccount, *gorm.DB) error
}

// DefaultStrictUpdateCreditAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAprs := AprORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAprs.CreditAccountId = new(uint64)
	*filterAprs.CreditAccountId = ormObj.Id
	if err = db.Where(filterAprs).Delete(AprORM{}).Error; err != nil {
		return nil, err
	}
	filterRecurringTransactions := PlaidAccountRecurringTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRecurringTransactions.CreditAccountId = new(uint64)
	*filterRecurringTransactions.CreditAccountId = ormObj.Id
	if err = db.Where(filterRecurringTransactions).Delete(PlaidAccountRecurringTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := PlaidAccountTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.CreditAccountId = new(uint64)
	*filterTransactions.CreditAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(PlaidAccountTransactionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditAccount executes a basic gorm update call with patch behavior
func DefaultPatchCreditAccount(ctx context.Context, in *CreditAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditAccount
	var err error
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditAccount(ctx, &CreditAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditAccount(ctx context.Context, objects []*CreditAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditAccount(ctx context.Context, patchee *CreditAccount, patcher *CreditAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"IsOverdue" {
			patchee.IsOverdue = patcher.IsOverdue
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LastStatementIssueDate" {
			patchee.LastStatementIssueDate = patcher.LastStatementIssueDate
			continue
		}
		if f == prefix+"MinimumAmountDueDate" {
			patchee.MinimumAmountDueDate = patcher.MinimumAmountDueDate
			continue
		}
		if f == prefix+"NextPaymentDate" {
			patchee.NextPaymentDate = patcher.NextPaymentDate
			continue
		}
		if f == prefix+"Aprs" {
			patchee.Aprs = patcher.Aprs
			continue
		}
		if f == prefix+"LastStatementBalance" {
			patchee.LastStatementBalance = patcher.LastStatementBalance
			continue
		}
		if f == prefix+"MinimumPaymentAmount" {
			patchee.MinimumPaymentAmount = patcher.MinimumPaymentAmount
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"RecurringTransactions" {
			patchee.RecurringTransactions = patcher.RecurringTransactions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditAccount executes a gorm list call
func DefaultListCreditAccount(ctx context.Context, db *gorm.DB) ([]*CreditAccount, error) {
	in := CreditAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditAccountORM{}, &CreditAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditAccountORM) error
}

// DefaultCreateMortgageAccount executes a basic gorm create call
func DefaultCreateMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MortgageAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MortgageAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MortgageAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MortgageAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MortgageAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MortgageAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MortgageAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMortgageAccountSet(ctx context.Context, in []*MortgageAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MortgageAccountORM{})).(MortgageAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MortgageAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MortgageAccountORM{})).(MortgageAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MortgageAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MortgageAccount, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MortgageAccount, *gorm.DB) error
}

// DefaultStrictUpdateMortgageAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMortgageAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MortgageAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MortgageAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMortgageAccount executes a basic gorm update call with patch behavior
func DefaultPatchMortgageAccount(ctx context.Context, in *MortgageAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MortgageAccount
	var err error
	if hook, ok := interface{}(&pbObj).(MortgageAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMortgageAccount(ctx, &MortgageAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MortgageAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMortgageAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MortgageAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMortgageAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MortgageAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MortgageAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMortgageAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetMortgageAccount(ctx context.Context, objects []*MortgageAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MortgageAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MortgageAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMortgageAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMortgageAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMortgageAccount(ctx context.Context, patchee *MortgageAccount, patcher *MortgageAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MortgageAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"CurrentLateFee" {
			patchee.CurrentLateFee = patcher.CurrentLateFee
			continue
		}
		if f == prefix+"EscrowBalance" {
			patchee.EscrowBalance = patcher.EscrowBalance
			continue
		}
		if f == prefix+"HasPmi" {
			patchee.HasPmi = patcher.HasPmi
			continue
		}
		if f == prefix+"HasPrepaymentPenalty" {
			patchee.HasPrepaymentPenalty = patcher.HasPrepaymentPenalty
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LoanTerm" {
			patchee.LoanTerm = patcher.LoanTerm
			continue
		}
		if f == prefix+"LoanTypeDescription" {
			patchee.LoanTypeDescription = patcher.LoanTypeDescription
			continue
		}
		if f == prefix+"MaturityDate" {
			patchee.MaturityDate = patcher.MaturityDate
			continue
		}
		if f == prefix+"NextMonthlyPayment" {
			patchee.NextMonthlyPayment = patcher.NextMonthlyPayment
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"OriginalPrincipalBalance" {
			patchee.OriginalPrincipalBalance = patcher.OriginalPrincipalBalance
			continue
		}
		if f == prefix+"OriginalPropertyValue" {
			patchee.OriginalPropertyValue = patcher.OriginalPropertyValue
			continue
		}
		if f == prefix+"OutstandingPrincipalBalance" {
			patchee.OutstandingPrincipalBalance = patcher.OutstandingPrincipalBalance
			continue
		}
		if f == prefix+"PaymentAmount" {
			patchee.PaymentAmount = patcher.PaymentAmount
			continue
		}
		if f == prefix+"PaymentDate" {
			patchee.PaymentDate = patcher.PaymentDate
			continue
		}
		if f == prefix+"OriginationDate" {
			patchee.OriginationDate = patcher.OriginationDate
			continue
		}
		if f == prefix+"OriginationPrincipalAmount" {
			patchee.OriginationPrincipalAmount = patcher.OriginationPrincipalAmount
			continue
		}
		if f == prefix+"PastDueAmount" {
			patchee.PastDueAmount = patcher.PastDueAmount
			continue
		}
		if f == prefix+"YtdInterestPaid" {
			patchee.YtdInterestPaid = patcher.YtdInterestPaid
			continue
		}
		if f == prefix+"YtdPrincipalPaid" {
			patchee.YtdPrincipalPaid = patcher.YtdPrincipalPaid
			continue
		}
		if f == prefix+"PropertyAddressCity" {
			patchee.PropertyAddressCity = patcher.PropertyAddressCity
			continue
		}
		if f == prefix+"PropertyAddressState" {
			patchee.PropertyAddressState = patcher.PropertyAddressState
			continue
		}
		if f == prefix+"PropertyAddressStreet" {
			patchee.PropertyAddressStreet = patcher.PropertyAddressStreet
			continue
		}
		if f == prefix+"PropertyAddressPostalCode" {
			patchee.PropertyAddressPostalCode = patcher.PropertyAddressPostalCode
			continue
		}
		if f == prefix+"PropertyRegion" {
			patchee.PropertyRegion = patcher.PropertyRegion
			continue
		}
		if f == prefix+"PropertyCountry" {
			patchee.PropertyCountry = patcher.PropertyCountry
			continue
		}
		if f == prefix+"InterestRatePercentage" {
			patchee.InterestRatePercentage = patcher.InterestRatePercentage
			continue
		}
		if f == prefix+"InterestRateType" {
			patchee.InterestRateType = patcher.InterestRateType
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMortgageAccount executes a gorm list call
func DefaultListMortgageAccount(ctx context.Context, db *gorm.DB) ([]*MortgageAccount, error) {
	in := MortgageAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MortgageAccountORM{}, &MortgageAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MortgageAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MortgageAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MortgageAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MortgageAccountORM) error
}

// DefaultCreateInvestmentAccount executes a basic gorm create call
func DefaultCreateInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentAccountSet(ctx context.Context, in []*InvestmentAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentAccountORM{})).(InvestmentAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentAccountORM{})).(InvestmentAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentAccount, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentAccount, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterHoldings := InvesmentHoldingORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterHoldings.InvestmentAccountId = new(uint64)
	*filterHoldings.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterHoldings).Delete(InvesmentHoldingORM{}).Error; err != nil {
		return nil, err
	}
	filterSecurities := InvestmentSecurityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSecurities.InvestmentAccountId = new(uint64)
	*filterSecurities.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterSecurities).Delete(InvestmentSecurityORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := PlaidAccountInvestmentTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.InvestmentAccountId = new(uint64)
	*filterTransactions.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(PlaidAccountInvestmentTransactionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentAccount executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentAccount(ctx context.Context, in *InvestmentAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentAccount
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentAccount(ctx, &InvestmentAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentAccount(ctx context.Context, objects []*InvestmentAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentAccount(ctx context.Context, patchee *InvestmentAccount, patcher *InvestmentAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"Holdings" {
			patchee.Holdings = patcher.Holdings
			continue
		}
		if f == prefix+"Securities" {
			patchee.Securities = patcher.Securities
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentAccount executes a gorm list call
func DefaultListInvestmentAccount(ctx context.Context, db *gorm.DB) ([]*InvestmentAccount, error) {
	in := InvestmentAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentAccountORM{}, &InvestmentAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentAccountORM) error
}

// DefaultCreateBankAccount executes a basic gorm create call
func DefaultCreateBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BankAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BankAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BankAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BankAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BankAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BankAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BankAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBankAccountSet(ctx context.Context, in []*BankAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BankAccountORM{})).(BankAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BankAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BankAccountORM{})).(BankAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BankAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BankAccount, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BankAccount, *gorm.DB) error
}

// DefaultStrictUpdateBankAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBankAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BankAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterPockets := PocketORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPockets.BankAccountId = new(uint64)
	*filterPockets.BankAccountId = ormObj.Id
	if err = db.Where(filterPockets).Delete(PocketORM{}).Error; err != nil {
		return nil, err
	}
	filterRecurringTransactions := PlaidAccountRecurringTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRecurringTransactions.BankAccountId = new(uint64)
	*filterRecurringTransactions.BankAccountId = ormObj.Id
	if err = db.Where(filterRecurringTransactions).Delete(PlaidAccountRecurringTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := PlaidAccountTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.BankAccountId = new(uint64)
	*filterTransactions.BankAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(PlaidAccountTransactionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BankAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBankAccount executes a basic gorm update call with patch behavior
func DefaultPatchBankAccount(ctx context.Context, in *BankAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BankAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BankAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBankAccount(ctx, &BankAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BankAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBankAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BankAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBankAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BankAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BankAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBankAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBankAccount(ctx context.Context, objects []*BankAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BankAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BankAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBankAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBankAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBankAccount(ctx context.Context, patchee *BankAccount, patcher *BankAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BankAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
		if f == prefix+"Pockets" {
			patchee.Pockets = patcher.Pockets
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"RecurringTransactions" {
			patchee.RecurringTransactions = patcher.RecurringTransactions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBankAccount executes a gorm list call
func DefaultListBankAccount(ctx context.Context, db *gorm.DB) ([]*BankAccount, error) {
	in := BankAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BankAccountORM{}, &BankAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BankAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BankAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BankAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BankAccountORM) error
}

// DefaultCreatePocket executes a basic gorm create call
func DefaultCreatePocket(ctx context.Context, in *Pocket, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PocketORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPocket(ctx context.Context, in *Pocket, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PocketORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PocketORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PocketORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PocketORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePocket(ctx context.Context, in *Pocket, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PocketORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PocketORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePocketSet(ctx context.Context, in []*Pocket, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PocketORM{})).(PocketORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PocketORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PocketORM{})).(PocketORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PocketORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Pocket, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Pocket, *gorm.DB) error
}

// DefaultStrictUpdatePocket clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePocket(ctx context.Context, in *Pocket, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePocket")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PocketORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterGoals := SmartGoalORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterGoals.PocketId = new(uint64)
	*filterGoals.PocketId = ormObj.Id
	if err = db.Where(filterGoals).Delete(SmartGoalORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PocketORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPocket executes a basic gorm update call with patch behavior
func DefaultPatchPocket(ctx context.Context, in *Pocket, updateMask *field_mask.FieldMask, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Pocket
	var err error
	if hook, ok := interface{}(&pbObj).(PocketWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPocket(ctx, &Pocket{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PocketWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPocket(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PocketWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePocket(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PocketWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PocketWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PocketWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PocketWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PocketWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPocket executes a bulk gorm update call with patch behavior
func DefaultPatchSetPocket(ctx context.Context, objects []*Pocket, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Pocket, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Pocket, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPocket(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPocket patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPocket(ctx context.Context, patchee *Pocket, patcher *Pocket, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Pocket, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Goals" {
			patchee.Goals = patcher.Goals
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPocket executes a gorm list call
func DefaultListPocket(ctx context.Context, db *gorm.DB) ([]*Pocket, error) {
	in := Pocket{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PocketORM{}, &Pocket{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PocketORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Pocket{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PocketORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PocketORM) error
}

// DefaultCreateSmartGoal executes a basic gorm create call
func DefaultCreateSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SmartGoalORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SmartGoalORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SmartGoalORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SmartGoalORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SmartGoalORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SmartGoalORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SmartGoalORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartGoalSet(ctx context.Context, in []*SmartGoal, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SmartGoalORM{})).(SmartGoalORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SmartGoalORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SmartGoalORM{})).(SmartGoalORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SmartGoalORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SmartGoal, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SmartGoal, *gorm.DB) error
}

// DefaultStrictUpdateSmartGoal clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSmartGoal")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SmartGoalORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterForecasts := ForecastORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterForecasts.SmartGoalId = new(uint64)
	*filterForecasts.SmartGoalId = ormObj.Id
	if err = db.Where(filterForecasts).Delete(ForecastORM{}).Error; err != nil {
		return nil, err
	}
	filterMilestones := MilestoneORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMilestones.SmartGoalId = new(uint64)
	*filterMilestones.SmartGoalId = ormObj.Id
	if err = db.Where(filterMilestones).Delete(MilestoneORM{}).Error; err != nil {
		return nil, err
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.SmartGoalId = new(uint64)
	*filterNotes.SmartGoalId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SmartGoalORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSmartGoal executes a basic gorm update call with patch behavior
func DefaultPatchSmartGoal(ctx context.Context, in *SmartGoal, updateMask *field_mask.FieldMask, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SmartGoal
	var err error
	if hook, ok := interface{}(&pbObj).(SmartGoalWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSmartGoal(ctx, &SmartGoal{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SmartGoalWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSmartGoal(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SmartGoalWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSmartGoal(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SmartGoalWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SmartGoalWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSmartGoal executes a bulk gorm update call with patch behavior
func DefaultPatchSetSmartGoal(ctx context.Context, objects []*SmartGoal, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SmartGoal, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SmartGoal, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSmartGoal(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSmartGoal patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSmartGoal(ctx context.Context, patchee *SmartGoal, patcher *SmartGoal, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SmartGoal, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedForecasts bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"IsCompleted" {
			patchee.IsCompleted = patcher.IsCompleted
			continue
		}
		if f == prefix+"GoalType" {
			patchee.GoalType = patcher.GoalType
			continue
		}
		if f == prefix+"Duration" {
			patchee.Duration = patcher.Duration
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"TargetAmount" {
			patchee.TargetAmount = patcher.TargetAmount
			continue
		}
		if f == prefix+"CurrentAmount" {
			patchee.CurrentAmount = patcher.CurrentAmount
			continue
		}
		if f == prefix+"Milestones" {
			patchee.Milestones = patcher.Milestones
			continue
		}
		if !updatedForecasts && strings.HasPrefix(f, prefix+"Forecasts.") {
			updatedForecasts = true
			if patcher.Forecasts == nil {
				patchee.Forecasts = nil
				continue
			}
			if patchee.Forecasts == nil {
				patchee.Forecasts = &Forecast{}
			}
			if o, err := DefaultApplyFieldMaskForecast(ctx, patchee.Forecasts, patcher.Forecasts, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Forecasts.", db); err != nil {
				return nil, err
			} else {
				patchee.Forecasts = o
			}
			continue
		}
		if f == prefix+"Forecasts" {
			updatedForecasts = true
			patchee.Forecasts = patcher.Forecasts
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSmartGoal executes a gorm list call
func DefaultListSmartGoal(ctx context.Context, db *gorm.DB) ([]*SmartGoal, error) {
	in := SmartGoal{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SmartGoalORM{}, &SmartGoal{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SmartGoalORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SmartGoal{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SmartGoalORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SmartGoalORM) error
}

// DefaultCreateSmartNote executes a basic gorm create call
func DefaultCreateSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SmartNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SmartNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SmartNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SmartNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SmartNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SmartNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SmartNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartNoteSet(ctx context.Context, in []*SmartNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SmartNoteORM{})).(SmartNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SmartNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SmartNoteORM{})).(SmartNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SmartNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SmartNote, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SmartNote, *gorm.DB) error
}

// DefaultStrictUpdateSmartNote clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSmartNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SmartNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SmartNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSmartNote executes a basic gorm update call with patch behavior
func DefaultPatchSmartNote(ctx context.Context, in *SmartNote, updateMask *field_mask.FieldMask, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SmartNote
	var err error
	if hook, ok := interface{}(&pbObj).(SmartNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSmartNote(ctx, &SmartNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SmartNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSmartNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SmartNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSmartNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SmartNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SmartNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSmartNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetSmartNote(ctx context.Context, objects []*SmartNote, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SmartNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SmartNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSmartNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSmartNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSmartNote(ctx context.Context, patchee *SmartNote, patcher *SmartNote, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SmartNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSmartNote executes a gorm list call
func DefaultListSmartNote(ctx context.Context, db *gorm.DB) ([]*SmartNote, error) {
	in := SmartNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SmartNoteORM{}, &SmartNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SmartNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SmartNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SmartNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SmartNoteORM) error
}

// DefaultCreateForecast executes a basic gorm create call
func DefaultCreateForecast(ctx context.Context, in *Forecast, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ForecastORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadForecast(ctx context.Context, in *Forecast, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ForecastORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ForecastORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ForecastORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ForecastORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteForecast(ctx context.Context, in *Forecast, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ForecastORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ForecastORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteForecastSet(ctx context.Context, in []*Forecast, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ForecastORM{})).(ForecastORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ForecastORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ForecastORM{})).(ForecastORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ForecastORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Forecast, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Forecast, *gorm.DB) error
}

// DefaultStrictUpdateForecast clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateForecast(ctx context.Context, in *Forecast, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateForecast")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ForecastORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ForecastORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchForecast executes a basic gorm update call with patch behavior
func DefaultPatchForecast(ctx context.Context, in *Forecast, updateMask *field_mask.FieldMask, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Forecast
	var err error
	if hook, ok := interface{}(&pbObj).(ForecastWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadForecast(ctx, &Forecast{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ForecastWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskForecast(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ForecastWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateForecast(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ForecastWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ForecastWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ForecastWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ForecastWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ForecastWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetForecast executes a bulk gorm update call with patch behavior
func DefaultPatchSetForecast(ctx context.Context, objects []*Forecast, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Forecast, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Forecast, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchForecast(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskForecast patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskForecast(ctx context.Context, patchee *Forecast, patcher *Forecast, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Forecast, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ForecastedAmount" {
			patchee.ForecastedAmount = patcher.ForecastedAmount
			continue
		}
		if f == prefix+"ForecastedCompletionDate" {
			patchee.ForecastedCompletionDate = patcher.ForecastedCompletionDate
			continue
		}
		if f == prefix+"VarianceAmount" {
			patchee.VarianceAmount = patcher.VarianceAmount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListForecast executes a gorm list call
func DefaultListForecast(ctx context.Context, db *gorm.DB) ([]*Forecast, error) {
	in := Forecast{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ForecastORM{}, &Forecast{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ForecastORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Forecast{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ForecastORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ForecastORM) error
}

// DefaultCreateMilestone executes a basic gorm create call
func DefaultCreateMilestone(ctx context.Context, in *Milestone, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MilestoneORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMilestone(ctx context.Context, in *Milestone, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MilestoneORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MilestoneORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MilestoneORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MilestoneORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMilestone(ctx context.Context, in *Milestone, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MilestoneORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MilestoneORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMilestoneSet(ctx context.Context, in []*Milestone, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MilestoneORM{})).(MilestoneORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MilestoneORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MilestoneORM{})).(MilestoneORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MilestoneORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Milestone, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Milestone, *gorm.DB) error
}

// DefaultStrictUpdateMilestone clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMilestone(ctx context.Context, in *Milestone, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMilestone")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MilestoneORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBudget := BudgetORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBudget.MilestoneId = new(uint64)
	*filterBudget.MilestoneId = ormObj.Id
	if err = db.Where(filterBudget).Delete(BudgetORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MilestoneORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMilestone executes a basic gorm update call with patch behavior
func DefaultPatchMilestone(ctx context.Context, in *Milestone, updateMask *field_mask.FieldMask, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Milestone
	var err error
	if hook, ok := interface{}(&pbObj).(MilestoneWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMilestone(ctx, &Milestone{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MilestoneWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMilestone(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MilestoneWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMilestone(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MilestoneWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MilestoneWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MilestoneWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MilestoneWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MilestoneWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMilestone executes a bulk gorm update call with patch behavior
func DefaultPatchSetMilestone(ctx context.Context, objects []*Milestone, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Milestone, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Milestone, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMilestone(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMilestone patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMilestone(ctx context.Context, patchee *Milestone, patcher *Milestone, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Milestone, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedBudget bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"TargetDate" {
			patchee.TargetDate = patcher.TargetDate
			continue
		}
		if f == prefix+"TargetAmount" {
			patchee.TargetAmount = patcher.TargetAmount
			continue
		}
		if f == prefix+"IsCompleted" {
			patchee.IsCompleted = patcher.IsCompleted
			continue
		}
		if !updatedBudget && strings.HasPrefix(f, prefix+"Budget.") {
			updatedBudget = true
			if patcher.Budget == nil {
				patchee.Budget = nil
				continue
			}
			if patchee.Budget == nil {
				patchee.Budget = &Budget{}
			}
			if o, err := DefaultApplyFieldMaskBudget(ctx, patchee.Budget, patcher.Budget, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Budget.", db); err != nil {
				return nil, err
			} else {
				patchee.Budget = o
			}
			continue
		}
		if f == prefix+"Budget" {
			updatedBudget = true
			patchee.Budget = patcher.Budget
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMilestone executes a gorm list call
func DefaultListMilestone(ctx context.Context, db *gorm.DB) ([]*Milestone, error) {
	in := Milestone{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MilestoneORM{}, &Milestone{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MilestoneORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Milestone{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MilestoneORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MilestoneORM) error
}

// DefaultCreateBudget executes a basic gorm create call
func DefaultCreateBudget(ctx context.Context, in *Budget, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BudgetORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBudget(ctx context.Context, in *Budget, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BudgetORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BudgetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BudgetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BudgetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBudget(ctx context.Context, in *Budget, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BudgetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BudgetORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBudgetSet(ctx context.Context, in []*Budget, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BudgetORM{})).(BudgetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BudgetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BudgetORM{})).(BudgetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BudgetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Budget, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Budget, *gorm.DB) error
}

// DefaultStrictUpdateBudget clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBudget(ctx context.Context, in *Budget, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBudget")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BudgetORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCategory := CategoryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCategory.BudgetId = new(uint64)
	*filterCategory.BudgetId = ormObj.Id
	if err = db.Where(filterCategory).Delete(CategoryORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BudgetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBudget executes a basic gorm update call with patch behavior
func DefaultPatchBudget(ctx context.Context, in *Budget, updateMask *field_mask.FieldMask, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Budget
	var err error
	if hook, ok := interface{}(&pbObj).(BudgetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBudget(ctx, &Budget{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BudgetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBudget(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BudgetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBudget(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BudgetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BudgetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BudgetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BudgetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BudgetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBudget executes a bulk gorm update call with patch behavior
func DefaultPatchSetBudget(ctx context.Context, objects []*Budget, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Budget, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Budget, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBudget(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBudget patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBudget(ctx context.Context, patchee *Budget, patcher *Budget, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Budget, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCategory bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if !updatedCategory && strings.HasPrefix(f, prefix+"Category.") {
			updatedCategory = true
			if patcher.Category == nil {
				patchee.Category = nil
				continue
			}
			if patchee.Category == nil {
				patchee.Category = &Category{}
			}
			if o, err := DefaultApplyFieldMaskCategory(ctx, patchee.Category, patcher.Category, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Category.", db); err != nil {
				return nil, err
			} else {
				patchee.Category = o
			}
			continue
		}
		if f == prefix+"Category" {
			updatedCategory = true
			patchee.Category = patcher.Category
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBudget executes a gorm list call
func DefaultListBudget(ctx context.Context, db *gorm.DB) ([]*Budget, error) {
	in := Budget{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BudgetORM{}, &Budget{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BudgetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Budget{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BudgetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BudgetORM) error
}

// DefaultCreateCategory executes a basic gorm create call
func DefaultCreateCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CategoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CategoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CategoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CategoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCategory(ctx context.Context, in *Category, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CategoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCategorySet(ctx context.Context, in []*Category, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CategoryORM{})).(CategoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CategoryORM{})).(CategoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CategoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Category, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Category, *gorm.DB) error
}

// DefaultStrictUpdateCategory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCategory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CategoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CategoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCategory executes a basic gorm update call with patch behavior
func DefaultPatchCategory(ctx context.Context, in *Category, updateMask *field_mask.FieldMask, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Category
	var err error
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCategory(ctx, &Category{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCategory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCategory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CategoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CategoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCategory executes a bulk gorm update call with patch behavior
func DefaultPatchSetCategory(ctx context.Context, objects []*Category, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Category, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Category, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCategory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCategory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategory(ctx context.Context, patchee *Category, patcher *Category, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Category, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Subcategories" {
			patchee.Subcategories = patcher.Subcategories
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategory executes a gorm list call
func DefaultListCategory(ctx context.Context, db *gorm.DB) ([]*Category, error) {
	in := Category{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryORM{}, &Category{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CategoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Category{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryORM) error
}

// DefaultCreateInvesmentHolding executes a basic gorm create call
func DefaultCreateInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvesmentHoldingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvesmentHoldingORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvesmentHoldingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvesmentHoldingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvesmentHoldingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvesmentHoldingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvesmentHoldingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvesmentHoldingSet(ctx context.Context, in []*InvesmentHolding, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvesmentHoldingORM{})).(InvesmentHoldingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvesmentHoldingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvesmentHoldingORM{})).(InvesmentHoldingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvesmentHoldingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvesmentHolding, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvesmentHolding, *gorm.DB) error
}

// DefaultStrictUpdateInvesmentHolding clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvesmentHolding")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvesmentHoldingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvesmentHoldingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvesmentHolding executes a basic gorm update call with patch behavior
func DefaultPatchInvesmentHolding(ctx context.Context, in *InvesmentHolding, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvesmentHolding
	var err error
	if hook, ok := interface{}(&pbObj).(InvesmentHoldingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvesmentHolding(ctx, &InvesmentHolding{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvesmentHoldingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvesmentHolding(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvesmentHoldingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvesmentHolding(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvesmentHoldingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvesmentHoldingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvesmentHolding executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvesmentHolding(ctx context.Context, objects []*InvesmentHolding, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvesmentHolding, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvesmentHolding, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvesmentHolding(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvesmentHolding patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvesmentHolding(ctx context.Context, patchee *InvesmentHolding, patcher *InvesmentHolding, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvesmentHolding, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"CostBasis" {
			patchee.CostBasis = patcher.CostBasis
			continue
		}
		if f == prefix+"InstitutionPrice" {
			patchee.InstitutionPrice = patcher.InstitutionPrice
			continue
		}
		if f == prefix+"InstitutionPriceAsOf" {
			patchee.InstitutionPriceAsOf = patcher.InstitutionPriceAsOf
			continue
		}
		if f == prefix+"InstitutionPriceDatetime" {
			patchee.InstitutionPriceDatetime = patcher.InstitutionPriceDatetime
			continue
		}
		if f == prefix+"InstitutionValue" {
			patchee.InstitutionValue = patcher.InstitutionValue
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvesmentHolding executes a gorm list call
func DefaultListInvesmentHolding(ctx context.Context, db *gorm.DB) ([]*InvesmentHolding, error) {
	in := InvesmentHolding{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvesmentHoldingORM{}, &InvesmentHolding{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvesmentHoldingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvesmentHolding{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvesmentHoldingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvesmentHoldingORM) error
}

// DefaultCreateInvestmentSecurity executes a basic gorm create call
func DefaultCreateInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentSecurityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentSecurityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentSecurityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentSecurityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentSecurityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentSecurityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentSecurityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentSecuritySet(ctx context.Context, in []*InvestmentSecurity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentSecurityORM{})).(InvestmentSecurityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentSecurityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentSecurityORM{})).(InvestmentSecurityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentSecurityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentSecurity, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentSecurity, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentSecurity clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentSecurity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentSecurityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentSecurityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentSecurity executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentSecurity
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentSecurityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentSecurity(ctx, &InvestmentSecurity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentSecurityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentSecurity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentSecurityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentSecurity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentSecurityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentSecurityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentSecurity executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentSecurity(ctx context.Context, objects []*InvestmentSecurity, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentSecurity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentSecurity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentSecurity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentSecurity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentSecurity(ctx context.Context, patchee *InvestmentSecurity, patcher *InvestmentSecurity, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentSecurity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ClosePrice" {
			patchee.ClosePrice = patcher.ClosePrice
			continue
		}
		if f == prefix+"ClosePriceAsOf" {
			patchee.ClosePriceAsOf = patcher.ClosePriceAsOf
			continue
		}
		if f == prefix+"Cusip" {
			patchee.Cusip = patcher.Cusip
			continue
		}
		if f == prefix+"InstitutionId" {
			patchee.InstitutionId = patcher.InstitutionId
			continue
		}
		if f == prefix+"InstitutionSecurityId" {
			patchee.InstitutionSecurityId = patcher.InstitutionSecurityId
			continue
		}
		if f == prefix+"IsCashEquivalent" {
			patchee.IsCashEquivalent = patcher.IsCashEquivalent
			continue
		}
		if f == prefix+"Isin" {
			patchee.Isin = patcher.Isin
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ProxySecurityId" {
			patchee.ProxySecurityId = patcher.ProxySecurityId
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"Sedol" {
			patchee.Sedol = patcher.Sedol
			continue
		}
		if f == prefix+"TickerSymbol" {
			patchee.TickerSymbol = patcher.TickerSymbol
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"UpdateDatetime" {
			patchee.UpdateDatetime = patcher.UpdateDatetime
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentSecurity executes a gorm list call
func DefaultListInvestmentSecurity(ctx context.Context, db *gorm.DB) ([]*InvestmentSecurity, error) {
	in := InvestmentSecurity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentSecurityORM{}, &InvestmentSecurity{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentSecurityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentSecurity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentSecurityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentSecurityORM) error
}

// DefaultCreateApr executes a basic gorm create call
func DefaultCreateApr(ctx context.Context, in *Apr, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AprORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadApr(ctx context.Context, in *Apr, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AprORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AprORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AprORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AprORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteApr(ctx context.Context, in *Apr, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AprORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AprORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAprSet(ctx context.Context, in []*Apr, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AprORM{})).(AprORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AprORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AprORM{})).(AprORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AprORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Apr, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Apr, *gorm.DB) error
}

// DefaultStrictUpdateApr clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApr(ctx context.Context, in *Apr, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApr")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AprORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AprORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchApr executes a basic gorm update call with patch behavior
func DefaultPatchApr(ctx context.Context, in *Apr, updateMask *field_mask.FieldMask, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Apr
	var err error
	if hook, ok := interface{}(&pbObj).(AprWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApr(ctx, &Apr{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AprWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApr(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AprWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApr(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AprWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AprWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AprWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AprWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AprWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetApr executes a bulk gorm update call with patch behavior
func DefaultPatchSetApr(ctx context.Context, objects []*Apr, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Apr, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Apr, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApr(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApr patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApr(ctx context.Context, patchee *Apr, patcher *Apr, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Apr, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Percentage" {
			patchee.Percentage = patcher.Percentage
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"BalanceSubjectToApr" {
			patchee.BalanceSubjectToApr = patcher.BalanceSubjectToApr
			continue
		}
		if f == prefix+"InterestChargeAmount" {
			patchee.InterestChargeAmount = patcher.InterestChargeAmount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApr executes a gorm list call
func DefaultListApr(ctx context.Context, db *gorm.DB) ([]*Apr, error) {
	in := Apr{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AprORM{}, &Apr{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AprORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Apr{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AprORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AprORM) error
}

// DefaultCreateMergeLink executes a basic gorm create call
func DefaultCreateMergeLink(ctx context.Context, in *MergeLink, db *gorm.DB) (*MergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MergeLinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMergeLink(ctx context.Context, in *MergeLink, db *gorm.DB) (*MergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MergeLinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MergeLinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MergeLinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MergeLinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMergeLink(ctx context.Context, in *MergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MergeLinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMergeLinkSet(ctx context.Context, in []*MergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MergeLinkORM{})).(MergeLinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MergeLinkORM{})).(MergeLinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MergeLinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MergeLink, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MergeLink, *gorm.DB) error
}

// DefaultStrictUpdateMergeLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMergeLink(ctx context.Context, in *MergeLink, db *gorm.DB) (*MergeLink, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMergeLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MergeLinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccount := LinkedAccountingAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccount.MergeLinkId = new(uint64)
	*filterAccount.MergeLinkId = ormObj.Id
	if err = db.Where(filterAccount).Delete(LinkedAccountingAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterToken := TokenORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterToken.MergeLinkId = new(uint64)
	*filterToken.MergeLinkId = ormObj.Id
	if err = db.Where(filterToken).Delete(TokenORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MergeLinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMergeLink executes a basic gorm update call with patch behavior
func DefaultPatchMergeLink(ctx context.Context, in *MergeLink, updateMask *field_mask.FieldMask, db *gorm.DB) (*MergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MergeLink
	var err error
	if hook, ok := interface{}(&pbObj).(MergeLinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMergeLink(ctx, &MergeLink{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MergeLinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMergeLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MergeLinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMergeLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MergeLinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MergeLinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MergeLink, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMergeLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetMergeLink(ctx context.Context, objects []*MergeLink, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MergeLink, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MergeLink, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMergeLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMergeLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMergeLink(ctx context.Context, patchee *MergeLink, patcher *MergeLink, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MergeLink, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedToken bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Integration" {
			patchee.Integration = patcher.Integration
			continue
		}
		if f == prefix+"IntegrationSlug" {
			patchee.IntegrationSlug = patcher.IntegrationSlug
			continue
		}
		if f == prefix+"Category" {
			patchee.Category = patcher.Category
			continue
		}
		if f == prefix+"EndUserOriginId" {
			patchee.EndUserOriginId = patcher.EndUserOriginId
			continue
		}
		if f == prefix+"EndUserOrganizationName" {
			patchee.EndUserOrganizationName = patcher.EndUserOrganizationName
			continue
		}
		if f == prefix+"EndUserEmailAddress" {
			patchee.EndUserEmailAddress = patcher.EndUserEmailAddress
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"WebhookListenerUrl" {
			patchee.WebhookListenerUrl = patcher.WebhookListenerUrl
			continue
		}
		if f == prefix+"IsDuplicate" {
			patchee.IsDuplicate = patcher.IsDuplicate
			continue
		}
		if !updatedToken && strings.HasPrefix(f, prefix+"Token.") {
			updatedToken = true
			if patcher.Token == nil {
				patchee.Token = nil
				continue
			}
			if patchee.Token == nil {
				patchee.Token = &Token{}
			}
			if o, err := DefaultApplyFieldMaskToken(ctx, patchee.Token, patcher.Token, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Token.", db); err != nil {
				return nil, err
			} else {
				patchee.Token = o
			}
			continue
		}
		if f == prefix+"Token" {
			updatedToken = true
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"IntegrationName" {
			patchee.IntegrationName = patcher.IntegrationName
			continue
		}
		if f == prefix+"IntegrationImage" {
			patchee.IntegrationImage = patcher.IntegrationImage
			continue
		}
		if f == prefix+"IntegrationSquareImage" {
			patchee.IntegrationSquareImage = patcher.IntegrationSquareImage
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"MergeLinkedAccountId" {
			patchee.MergeLinkedAccountId = patcher.MergeLinkedAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMergeLink executes a gorm list call
func DefaultListMergeLink(ctx context.Context, db *gorm.DB) ([]*MergeLink, error) {
	in := MergeLink{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MergeLinkORM{}, &MergeLink{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MergeLinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MergeLink{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MergeLinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MergeLinkORM) error
}

// DefaultCreateLinkedAccountingAccount executes a basic gorm create call
func DefaultCreateLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LinkedAccountingAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LinkedAccountingAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LinkedAccountingAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LinkedAccountingAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LinkedAccountingAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkedAccountingAccountSet(ctx context.Context, in []*LinkedAccountingAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LinkedAccountingAccountORM{})).(LinkedAccountingAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LinkedAccountingAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LinkedAccountingAccountORM{})).(LinkedAccountingAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LinkedAccountingAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LinkedAccountingAccount, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LinkedAccountingAccount, *gorm.DB) error
}

// DefaultStrictUpdateLinkedAccountingAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLinkedAccountingAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LinkedAccountingAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAttachments := AttachmentsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAttachments.LinkedAccountingAccountId = new(uint64)
	*filterAttachments.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterAttachments).Delete(AttachmentsORM{}).Error; err != nil {
		return nil, err
	}
	filterCompanyInfo := CompanyInfoORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompanyInfo.LinkedAccountingAccountId = new(uint64)
	*filterCompanyInfo.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterCompanyInfo).Delete(CompanyInfoORM{}).Error; err != nil {
		return nil, err
	}
	filterPurchaseOrders := PurchaseOrderORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPurchaseOrders.LinkedAccountingAccountId = new(uint64)
	*filterPurchaseOrders.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterPurchaseOrders).Delete(PurchaseOrderORM{}).Error; err != nil {
		return nil, err
	}
	filterReferenceDetails := ReferenceDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterReferenceDetails.LinkedAccountingAccountId = new(uint64)
	*filterReferenceDetails.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterReferenceDetails).Delete(ReferenceDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterReportDetails := ReportDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterReportDetails.LinkedAccountingAccountId = new(uint64)
	*filterReportDetails.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterReportDetails).Delete(ReportDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactionsDetails := TransactionDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactionsDetails.LinkedAccountingAccountId = new(uint64)
	*filterTransactionsDetails.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterTransactionsDetails).Delete(TransactionDetailsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLinkedAccountingAccount executes a basic gorm update call with patch behavior
func DefaultPatchLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LinkedAccountingAccount
	var err error
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLinkedAccountingAccount(ctx, &LinkedAccountingAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLinkedAccountingAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLinkedAccountingAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LinkedAccountingAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LinkedAccountingAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLinkedAccountingAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetLinkedAccountingAccount(ctx context.Context, objects []*LinkedAccountingAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LinkedAccountingAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LinkedAccountingAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLinkedAccountingAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLinkedAccountingAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLinkedAccountingAccount(ctx context.Context, patchee *LinkedAccountingAccount, patcher *LinkedAccountingAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedReportDetails bool
	var updatedReferenceDetails bool
	var updatedTransactionsDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Attachments" {
			patchee.Attachments = patcher.Attachments
			continue
		}
		if f == prefix+"CompanyInfo" {
			patchee.CompanyInfo = patcher.CompanyInfo
			continue
		}
		if f == prefix+"PurchaseOrders" {
			patchee.PurchaseOrders = patcher.PurchaseOrders
			continue
		}
		if !updatedReportDetails && strings.HasPrefix(f, prefix+"ReportDetails.") {
			updatedReportDetails = true
			if patcher.ReportDetails == nil {
				patchee.ReportDetails = nil
				continue
			}
			if patchee.ReportDetails == nil {
				patchee.ReportDetails = &ReportDetails{}
			}
			if o, err := DefaultApplyFieldMaskReportDetails(ctx, patchee.ReportDetails, patcher.ReportDetails, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ReportDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.ReportDetails = o
			}
			continue
		}
		if f == prefix+"ReportDetails" {
			updatedReportDetails = true
			patchee.ReportDetails = patcher.ReportDetails
			continue
		}
		if !updatedReferenceDetails && strings.HasPrefix(f, prefix+"ReferenceDetails.") {
			updatedReferenceDetails = true
			if patcher.ReferenceDetails == nil {
				patchee.ReferenceDetails = nil
				continue
			}
			if patchee.ReferenceDetails == nil {
				patchee.ReferenceDetails = &ReferenceDetails{}
			}
			if o, err := DefaultApplyFieldMaskReferenceDetails(ctx, patchee.ReferenceDetails, patcher.ReferenceDetails, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ReferenceDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.ReferenceDetails = o
			}
			continue
		}
		if f == prefix+"ReferenceDetails" {
			updatedReferenceDetails = true
			patchee.ReferenceDetails = patcher.ReferenceDetails
			continue
		}
		if !updatedTransactionsDetails && strings.HasPrefix(f, prefix+"TransactionsDetails.") {
			updatedTransactionsDetails = true
			if patcher.TransactionsDetails == nil {
				patchee.TransactionsDetails = nil
				continue
			}
			if patchee.TransactionsDetails == nil {
				patchee.TransactionsDetails = &TransactionDetails{}
			}
			if o, err := DefaultApplyFieldMaskTransactionDetails(ctx, patchee.TransactionsDetails, patcher.TransactionsDetails, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TransactionsDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.TransactionsDetails = o
			}
			continue
		}
		if f == prefix+"TransactionsDetails" {
			updatedTransactionsDetails = true
			patchee.TransactionsDetails = patcher.TransactionsDetails
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLinkedAccountingAccount executes a gorm list call
func DefaultListLinkedAccountingAccount(ctx context.Context, db *gorm.DB) ([]*LinkedAccountingAccount, error) {
	in := LinkedAccountingAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LinkedAccountingAccountORM{}, &LinkedAccountingAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LinkedAccountingAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LinkedAccountingAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LinkedAccountingAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LinkedAccountingAccountORM) error
}

// DefaultCreateTransactionDetails executes a basic gorm create call
func DefaultCreateTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionDetailsSet(ctx context.Context, in []*TransactionDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionDetailsORM{})).(TransactionDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionDetailsORM{})).(TransactionDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionDetails, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionDetails, *gorm.DB) error
}

// DefaultStrictUpdateTransactionDetails clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCreditNotes := CreditNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCreditNotes.TransactionDetailsId = new(uint64)
	*filterCreditNotes.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterCreditNotes).Delete(CreditNoteORM{}).Error; err != nil {
		return nil, err
	}
	filterExpenses := ExpenseORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterExpenses.TransactionDetailsId = new(uint64)
	*filterExpenses.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterExpenses).Delete(ExpenseORM{}).Error; err != nil {
		return nil, err
	}
	filterInvoices := InvoiceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvoices.TransactionDetailsId = new(uint64)
	*filterInvoices.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterInvoices).Delete(InvoiceORM{}).Error; err != nil {
		return nil, err
	}
	filterJournalEntries := JournalEntryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterJournalEntries.TransactionDetailsId = new(uint64)
	*filterJournalEntries.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterJournalEntries).Delete(JournalEntryORM{}).Error; err != nil {
		return nil, err
	}
	filterPayments := PaymentORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayments.TransactionDetailsId = new(uint64)
	*filterPayments.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterPayments).Delete(PaymentORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := BusinessTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.TransactionDetailsId = new(uint64)
	*filterTransactions.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(BusinessTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterVendorCredits := VendorCreditORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVendorCredits.TransactionDetailsId = new(uint64)
	*filterVendorCredits.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterVendorCredits).Delete(VendorCreditORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionDetails executes a basic gorm update call with patch behavior
func DefaultPatchTransactionDetails(ctx context.Context, in *TransactionDetails, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionDetails
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionDetails(ctx, &TransactionDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionDetails(ctx context.Context, objects []*TransactionDetails, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionDetails(ctx context.Context, patchee *TransactionDetails, patcher *TransactionDetails, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Invoices" {
			patchee.Invoices = patcher.Invoices
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"Expenses" {
			patchee.Expenses = patcher.Expenses
			continue
		}
		if f == prefix+"JournalEntries" {
			patchee.JournalEntries = patcher.JournalEntries
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"VendorCredits" {
			patchee.VendorCredits = patcher.VendorCredits
			continue
		}
		if f == prefix+"CreditNotes" {
			patchee.CreditNotes = patcher.CreditNotes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionDetails executes a gorm list call
func DefaultListTransactionDetails(ctx context.Context, db *gorm.DB) ([]*TransactionDetails, error) {
	in := TransactionDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionDetailsORM{}, &TransactionDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionDetailsORM) error
}

// DefaultCreateReferenceDetails executes a basic gorm create call
func DefaultCreateReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReferenceDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReferenceDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReferenceDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReferenceDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReferenceDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReferenceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReferenceDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReferenceDetailsSet(ctx context.Context, in []*ReferenceDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReferenceDetailsORM{})).(ReferenceDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReferenceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReferenceDetailsORM{})).(ReferenceDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReferenceDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReferenceDetails, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReferenceDetails, *gorm.DB) error
}

// DefaultStrictUpdateReferenceDetails clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReferenceDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReferenceDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterChartOfAccounts := BusinessChartOfAccountsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterChartOfAccounts.ReferenceDetailsId = new(uint64)
	*filterChartOfAccounts.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterChartOfAccounts).Delete(BusinessChartOfAccountsORM{}).Error; err != nil {
		return nil, err
	}
	filterContacts := ContactsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterContacts.ReferenceDetailsId = new(uint64)
	*filterContacts.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterContacts).Delete(ContactsORM{}).Error; err != nil {
		return nil, err
	}
	filterItems := ItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterItems.ReferenceDetailsId = new(uint64)
	*filterItems.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterItems).Delete(ItemORM{}).Error; err != nil {
		return nil, err
	}
	filterTaxRates := TaxRateORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTaxRates.ReferenceDetailsId = new(uint64)
	*filterTaxRates.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterTaxRates).Delete(TaxRateORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReferenceDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReferenceDetails executes a basic gorm update call with patch behavior
func DefaultPatchReferenceDetails(ctx context.Context, in *ReferenceDetails, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReferenceDetails
	var err error
	if hook, ok := interface{}(&pbObj).(ReferenceDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReferenceDetails(ctx, &ReferenceDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReferenceDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReferenceDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReferenceDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReferenceDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReferenceDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReferenceDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReferenceDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetReferenceDetails(ctx context.Context, objects []*ReferenceDetails, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReferenceDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReferenceDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReferenceDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReferenceDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReferenceDetails(ctx context.Context, patchee *ReferenceDetails, patcher *ReferenceDetails, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReferenceDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ChartOfAccounts" {
			patchee.ChartOfAccounts = patcher.ChartOfAccounts
			continue
		}
		if f == prefix+"Items" {
			patchee.Items = patcher.Items
			continue
		}
		if f == prefix+"TaxRates" {
			patchee.TaxRates = patcher.TaxRates
			continue
		}
		if f == prefix+"Contacts" {
			patchee.Contacts = patcher.Contacts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReferenceDetails executes a gorm list call
func DefaultListReferenceDetails(ctx context.Context, db *gorm.DB) ([]*ReferenceDetails, error) {
	in := ReferenceDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReferenceDetailsORM{}, &ReferenceDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReferenceDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReferenceDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReferenceDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReferenceDetailsORM) error
}

// DefaultCreateReportDetails executes a basic gorm create call
func DefaultCreateReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReportDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReportDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReportDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReportDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReportDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReportDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReportDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReportDetailsSet(ctx context.Context, in []*ReportDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReportDetailsORM{})).(ReportDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReportDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReportDetailsORM{})).(ReportDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReportDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReportDetails, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReportDetails, *gorm.DB) error
}

// DefaultStrictUpdateReportDetails clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReportDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReportDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBalanceSheets := BalanceSheetORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceSheets.ReportDetailsId = new(uint64)
	*filterBalanceSheets.ReportDetailsId = ormObj.Id
	if err = db.Where(filterBalanceSheets).Delete(BalanceSheetORM{}).Error; err != nil {
		return nil, err
	}
	filterCashFlowStatements := CashFlowStatementsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCashFlowStatements.ReportDetailsId = new(uint64)
	*filterCashFlowStatements.ReportDetailsId = ormObj.Id
	if err = db.Where(filterCashFlowStatements).Delete(CashFlowStatementsORM{}).Error; err != nil {
		return nil, err
	}
	filterIncomeStatements := IncomeStatementORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIncomeStatements.ReportDetailsId = new(uint64)
	*filterIncomeStatements.ReportDetailsId = ormObj.Id
	if err = db.Where(filterIncomeStatements).Delete(IncomeStatementORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReportDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReportDetails executes a basic gorm update call with patch behavior
func DefaultPatchReportDetails(ctx context.Context, in *ReportDetails, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReportDetails
	var err error
	if hook, ok := interface{}(&pbObj).(ReportDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReportDetails(ctx, &ReportDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReportDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReportDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReportDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReportDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReportDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReportDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReportDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetReportDetails(ctx context.Context, objects []*ReportDetails, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReportDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReportDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReportDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReportDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReportDetails(ctx context.Context, patchee *ReportDetails, patcher *ReportDetails, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReportDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"BalanceSheets" {
			patchee.BalanceSheets = patcher.BalanceSheets
			continue
		}
		if f == prefix+"CashFlowStatements" {
			patchee.CashFlowStatements = patcher.CashFlowStatements
			continue
		}
		if f == prefix+"IncomeStatements" {
			patchee.IncomeStatements = patcher.IncomeStatements
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReportDetails executes a gorm list call
func DefaultListReportDetails(ctx context.Context, db *gorm.DB) ([]*ReportDetails, error) {
	in := ReportDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReportDetailsORM{}, &ReportDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReportDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReportDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReportDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReportDetailsORM) error
}

// DefaultCreateBusinessChartOfAccounts executes a basic gorm create call
func DefaultCreateBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessChartOfAccountsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessChartOfAccountsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessChartOfAccountsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessChartOfAccountsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessChartOfAccountsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessChartOfAccountsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessChartOfAccountsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessChartOfAccountsSet(ctx context.Context, in []*BusinessChartOfAccounts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessChartOfAccountsORM{})).(BusinessChartOfAccountsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessChartOfAccountsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessChartOfAccountsORM{})).(BusinessChartOfAccountsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessChartOfAccountsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessChartOfAccounts, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessChartOfAccounts, *gorm.DB) error
}

// DefaultStrictUpdateBusinessChartOfAccounts clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessChartOfAccounts")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessChartOfAccountsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessChartOfAccountsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessChartOfAccounts executes a basic gorm update call with patch behavior
func DefaultPatchBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessChartOfAccounts
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessChartOfAccounts(ctx, &BusinessChartOfAccounts{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessChartOfAccounts(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessChartOfAccounts(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessChartOfAccountsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessChartOfAccountsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessChartOfAccounts executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessChartOfAccounts(ctx context.Context, objects []*BusinessChartOfAccounts, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessChartOfAccounts, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessChartOfAccounts, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessChartOfAccounts(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessChartOfAccounts patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessChartOfAccounts(ctx context.Context, patchee *BusinessChartOfAccounts, patcher *BusinessChartOfAccounts, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Classification" {
			patchee.Classification = patcher.Classification
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"CurrentBalance" {
			patchee.CurrentBalance = patcher.CurrentBalance
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"ParentAccountId" {
			patchee.ParentAccountId = patcher.ParentAccountId
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessChartOfAccounts executes a gorm list call
func DefaultListBusinessChartOfAccounts(ctx context.Context, db *gorm.DB) ([]*BusinessChartOfAccounts, error) {
	in := BusinessChartOfAccounts{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessChartOfAccountsORM{}, &BusinessChartOfAccounts{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessChartOfAccountsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessChartOfAccounts{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessChartOfAccountsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessChartOfAccountsORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Street_1" {
			patchee.Street_1 = patcher.Street_1
			continue
		}
		if f == prefix+"Street_2" {
			patchee.Street_2 = patcher.Street_2
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"CountrySubdivision" {
			patchee.CountrySubdivision = patcher.CountrySubdivision
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateAttachments executes a basic gorm create call
func DefaultCreateAttachments(ctx context.Context, in *Attachments, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AttachmentsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAttachments(ctx context.Context, in *Attachments, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AttachmentsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AttachmentsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AttachmentsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AttachmentsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAttachments(ctx context.Context, in *Attachments, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AttachmentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AttachmentsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAttachmentsSet(ctx context.Context, in []*Attachments, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AttachmentsORM{})).(AttachmentsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AttachmentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AttachmentsORM{})).(AttachmentsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AttachmentsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Attachments, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Attachments, *gorm.DB) error
}

// DefaultStrictUpdateAttachments clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAttachments(ctx context.Context, in *Attachments, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAttachments")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AttachmentsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AttachmentsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAttachments executes a basic gorm update call with patch behavior
func DefaultPatchAttachments(ctx context.Context, in *Attachments, updateMask *field_mask.FieldMask, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Attachments
	var err error
	if hook, ok := interface{}(&pbObj).(AttachmentsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAttachments(ctx, &Attachments{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AttachmentsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAttachments(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AttachmentsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAttachments(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AttachmentsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AttachmentsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAttachments executes a bulk gorm update call with patch behavior
func DefaultPatchSetAttachments(ctx context.Context, objects []*Attachments, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Attachments, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Attachments, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAttachments(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAttachments patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAttachments(ctx context.Context, patchee *Attachments, patcher *Attachments, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Attachments, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"FileUrl" {
			patchee.FileUrl = patcher.FileUrl
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAttachments executes a gorm list call
func DefaultListAttachments(ctx context.Context, db *gorm.DB) ([]*Attachments, error) {
	in := Attachments{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AttachmentsORM{}, &Attachments{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AttachmentsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Attachments{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AttachmentsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AttachmentsORM) error
}

// DefaultCreateBalanceSheet executes a basic gorm create call
func DefaultCreateBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BalanceSheetORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BalanceSheetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BalanceSheetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BalanceSheetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BalanceSheetORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSheetSet(ctx context.Context, in []*BalanceSheet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BalanceSheetORM{})).(BalanceSheetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BalanceSheetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BalanceSheetORM{})).(BalanceSheetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BalanceSheetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BalanceSheet, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BalanceSheet, *gorm.DB) error
}

// DefaultStrictUpdateBalanceSheet clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBalanceSheet")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BalanceSheetORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAssets := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAssets.AssetsBalanceSheetId = new(uint64)
	*filterAssets.AssetsBalanceSheetId = ormObj.Id
	if err = db.Where(filterAssets).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterEquity := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEquity.EquityBalanceSheetId = new(uint64)
	*filterEquity.EquityBalanceSheetId = ormObj.Id
	if err = db.Where(filterEquity).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterLiabilities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLiabilities.LiabilitiesBalanceSheetId = new(uint64)
	*filterLiabilities.LiabilitiesBalanceSheetId = ormObj.Id
	if err = db.Where(filterLiabilities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBalanceSheet executes a basic gorm update call with patch behavior
func DefaultPatchBalanceSheet(ctx context.Context, in *BalanceSheet, updateMask *field_mask.FieldMask, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BalanceSheet
	var err error
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBalanceSheet(ctx, &BalanceSheet{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBalanceSheet(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBalanceSheet(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BalanceSheetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BalanceSheetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBalanceSheet executes a bulk gorm update call with patch behavior
func DefaultPatchSetBalanceSheet(ctx context.Context, objects []*BalanceSheet, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BalanceSheet, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BalanceSheet, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBalanceSheet(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBalanceSheet patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBalanceSheet(ctx context.Context, patchee *BalanceSheet, patcher *BalanceSheet, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BalanceSheet, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDate bool
	var updatedRemoteGeneratedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedDate && strings.HasPrefix(f, prefix+"Date.") {
			if patcher.Date == nil {
				patchee.Date = nil
				continue
			}
			if patchee.Date == nil {
				patchee.Date = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Date."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Date, patchee.Date, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Date" {
			updatedDate = true
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"NetAssets" {
			patchee.NetAssets = patcher.NetAssets
			continue
		}
		if f == prefix+"Assets" {
			patchee.Assets = patcher.Assets
			continue
		}
		if f == prefix+"Liabilities" {
			patchee.Liabilities = patcher.Liabilities
			continue
		}
		if f == prefix+"Equity" {
			patchee.Equity = patcher.Equity
			continue
		}
		if !updatedRemoteGeneratedAt && strings.HasPrefix(f, prefix+"RemoteGeneratedAt.") {
			if patcher.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = nil
				continue
			}
			if patchee.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteGeneratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteGeneratedAt, patchee.RemoteGeneratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteGeneratedAt" {
			updatedRemoteGeneratedAt = true
			patchee.RemoteGeneratedAt = patcher.RemoteGeneratedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBalanceSheet executes a gorm list call
func DefaultListBalanceSheet(ctx context.Context, db *gorm.DB) ([]*BalanceSheet, error) {
	in := BalanceSheet{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BalanceSheetORM{}, &BalanceSheet{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BalanceSheetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BalanceSheet{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BalanceSheetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BalanceSheetORM) error
}

// DefaultCreateReportItem executes a basic gorm create call
func DefaultCreateReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReportItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReportItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReportItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReportItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReportItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReportItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReportItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReportItemSet(ctx context.Context, in []*ReportItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReportItemORM{})).(ReportItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReportItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReportItemORM{})).(ReportItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReportItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReportItem, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReportItem, *gorm.DB) error
}

// DefaultStrictUpdateReportItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReportItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReportItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReportItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReportItem executes a basic gorm update call with patch behavior
func DefaultPatchReportItem(ctx context.Context, in *ReportItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReportItem
	var err error
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReportItem(ctx, &ReportItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReportItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReportItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReportItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReportItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReportItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetReportItem(ctx context.Context, objects []*ReportItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReportItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReportItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReportItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReportItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReportItem(ctx context.Context, patchee *ReportItem, patcher *ReportItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReportItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReportItem executes a gorm list call
func DefaultListReportItem(ctx context.Context, db *gorm.DB) ([]*ReportItem, error) {
	in := ReportItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReportItemORM{}, &ReportItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReportItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReportItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReportItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReportItemORM) error
}

// DefaultCreateCashFlowStatements executes a basic gorm create call
func DefaultCreateCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CashFlowStatementsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CashFlowStatementsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CashFlowStatementsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CashFlowStatementsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CashFlowStatementsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CashFlowStatementsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CashFlowStatementsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCashFlowStatementsSet(ctx context.Context, in []*CashFlowStatements, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CashFlowStatementsORM{})).(CashFlowStatementsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CashFlowStatementsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CashFlowStatementsORM{})).(CashFlowStatementsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CashFlowStatementsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CashFlowStatements, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CashFlowStatements, *gorm.DB) error
}

// DefaultStrictUpdateCashFlowStatements clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCashFlowStatements")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CashFlowStatementsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFinancingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFinancingActivities.FinancingActivitiesCashFlowStatementsId = new(uint64)
	*filterFinancingActivities.FinancingActivitiesCashFlowStatementsId = ormObj.Id
	if err = db.Where(filterFinancingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvestingActivities.InvestingActivitiesCashFlowStatementsId = new(uint64)
	*filterInvestingActivities.InvestingActivitiesCashFlowStatementsId = ormObj.Id
	if err = db.Where(filterInvestingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterOperatingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOperatingActivities.OperatingActivitiesCashFlowStatementsId = new(uint64)
	*filterOperatingActivities.OperatingActivitiesCashFlowStatementsId = ormObj.Id
	if err = db.Where(filterOperatingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CashFlowStatementsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCashFlowStatements executes a basic gorm update call with patch behavior
func DefaultPatchCashFlowStatements(ctx context.Context, in *CashFlowStatements, updateMask *field_mask.FieldMask, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CashFlowStatements
	var err error
	if hook, ok := interface{}(&pbObj).(CashFlowStatementsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCashFlowStatements(ctx, &CashFlowStatements{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CashFlowStatementsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCashFlowStatements(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CashFlowStatementsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCashFlowStatements(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CashFlowStatementsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CashFlowStatementsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCashFlowStatements executes a bulk gorm update call with patch behavior
func DefaultPatchSetCashFlowStatements(ctx context.Context, objects []*CashFlowStatements, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CashFlowStatements, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CashFlowStatements, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCashFlowStatements(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCashFlowStatements patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCashFlowStatements(ctx context.Context, patchee *CashFlowStatements, patcher *CashFlowStatements, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CashFlowStatements, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartPeriod bool
	var updatedEndPeriod bool
	var updatedRemoteGeneratedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedStartPeriod && strings.HasPrefix(f, prefix+"StartPeriod.") {
			if patcher.StartPeriod == nil {
				patchee.StartPeriod = nil
				continue
			}
			if patchee.StartPeriod == nil {
				patchee.StartPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartPeriod, patchee.StartPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartPeriod" {
			updatedStartPeriod = true
			patchee.StartPeriod = patcher.StartPeriod
			continue
		}
		if !updatedEndPeriod && strings.HasPrefix(f, prefix+"EndPeriod.") {
			if patcher.EndPeriod == nil {
				patchee.EndPeriod = nil
				continue
			}
			if patchee.EndPeriod == nil {
				patchee.EndPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndPeriod, patchee.EndPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndPeriod" {
			updatedEndPeriod = true
			patchee.EndPeriod = patcher.EndPeriod
			continue
		}
		if f == prefix+"CashAtBeginningOfPeriod" {
			patchee.CashAtBeginningOfPeriod = patcher.CashAtBeginningOfPeriod
			continue
		}
		if f == prefix+"CashAtEndOfPeriod" {
			patchee.CashAtEndOfPeriod = patcher.CashAtEndOfPeriod
			continue
		}
		if f == prefix+"OperatingActivities" {
			patchee.OperatingActivities = patcher.OperatingActivities
			continue
		}
		if f == prefix+"InvestingActivities" {
			patchee.InvestingActivities = patcher.InvestingActivities
			continue
		}
		if f == prefix+"FinancingActivities" {
			patchee.FinancingActivities = patcher.FinancingActivities
			continue
		}
		if !updatedRemoteGeneratedAt && strings.HasPrefix(f, prefix+"RemoteGeneratedAt.") {
			if patcher.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = nil
				continue
			}
			if patchee.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteGeneratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteGeneratedAt, patchee.RemoteGeneratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteGeneratedAt" {
			updatedRemoteGeneratedAt = true
			patchee.RemoteGeneratedAt = patcher.RemoteGeneratedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCashFlowStatements executes a gorm list call
func DefaultListCashFlowStatements(ctx context.Context, db *gorm.DB) ([]*CashFlowStatements, error) {
	in := CashFlowStatements{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CashFlowStatementsORM{}, &CashFlowStatements{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CashFlowStatementsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CashFlowStatements{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CashFlowStatementsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CashFlowStatementsORM) error
}

// DefaultCreateCompanyInfo executes a basic gorm create call
func DefaultCreateCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyInfoORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyInfoSet(ctx context.Context, in []*CompanyInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyInfoORM{})).(CompanyInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyInfoORM{})).(CompanyInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyInfo, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyInfo, *gorm.DB) error
}

// DefaultStrictUpdateCompanyInfo clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddresses := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddresses.CompanyInfoId = new(uint64)
	*filterAddresses.CompanyInfoId = ormObj.Id
	if err = db.Where(filterAddresses).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyInfo executes a basic gorm update call with patch behavior
func DefaultPatchCompanyInfo(ctx context.Context, in *CompanyInfo, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyInfo
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompanyInfo(ctx, &CompanyInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyInfo(ctx context.Context, objects []*CompanyInfo, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyInfo(ctx context.Context, patchee *CompanyInfo, patcher *CompanyInfo, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"LegalName" {
			patchee.LegalName = patcher.LegalName
			continue
		}
		if f == prefix+"TaxNumber" {
			patchee.TaxNumber = patcher.TaxNumber
			continue
		}
		if f == prefix+"FiscalYearEndMonth" {
			patchee.FiscalYearEndMonth = patcher.FiscalYearEndMonth
			continue
		}
		if f == prefix+"FiscalYearEndDay" {
			patchee.FiscalYearEndDay = patcher.FiscalYearEndDay
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"Urls" {
			patchee.Urls = patcher.Urls
			continue
		}
		if f == prefix+"Addresses" {
			patchee.Addresses = patcher.Addresses
			continue
		}
		if f == prefix+"PhoneNumbers" {
			patchee.PhoneNumbers = patcher.PhoneNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyInfo executes a gorm list call
func DefaultListCompanyInfo(ctx context.Context, db *gorm.DB) ([]*CompanyInfo, error) {
	in := CompanyInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyInfoORM{}, &CompanyInfo{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyInfoORM) error
}

// DefaultCreateAccountingAttachment executes a basic gorm create call
func DefaultCreateAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountingAttachmentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountingAttachmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountingAttachmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountingAttachmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountingAttachmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingAttachmentSet(ctx context.Context, in []*AccountingAttachment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountingAttachmentORM{})).(AccountingAttachmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountingAttachmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountingAttachmentORM{})).(AccountingAttachmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountingAttachmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountingAttachment, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountingAttachment, *gorm.DB) error
}

// DefaultStrictUpdateAccountingAttachment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountingAttachment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountingAttachmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountingAttachment executes a basic gorm update call with patch behavior
func DefaultPatchAccountingAttachment(ctx context.Context, in *AccountingAttachment, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountingAttachment
	var err error
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountingAttachment(ctx, &AccountingAttachment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountingAttachment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountingAttachment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountingAttachmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountingAttachmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountingAttachment executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountingAttachment(ctx context.Context, objects []*AccountingAttachment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountingAttachment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountingAttachment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountingAttachment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountingAttachment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountingAttachment(ctx context.Context, patchee *AccountingAttachment, patcher *AccountingAttachment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountingAttachment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"FileUrl" {
			patchee.FileUrl = patcher.FileUrl
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"ModifiedAt" {
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountingAttachment executes a gorm list call
func DefaultListAccountingAttachment(ctx context.Context, db *gorm.DB) ([]*AccountingAttachment, error) {
	in := AccountingAttachment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountingAttachmentORM{}, &AccountingAttachment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountingAttachmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountingAttachment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountingAttachmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountingAttachmentORM) error
}

// DefaultCreateContacts executes a basic gorm create call
func DefaultCreateContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContactsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ContactsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContactsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContactsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContactsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteContacts(ctx context.Context, in *Contacts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContactsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ContactsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteContactsSet(ctx context.Context, in []*Contacts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContactsORM{})).(ContactsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ContactsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContactsORM{})).(ContactsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContactsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Contacts, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Contacts, *gorm.DB) error
}

// DefaultStrictUpdateContacts clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContacts")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ContactsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContactsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchContacts executes a basic gorm update call with patch behavior
func DefaultPatchContacts(ctx context.Context, in *Contacts, updateMask *field_mask.FieldMask, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Contacts
	var err error
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContacts(ctx, &Contacts{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContacts(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContacts(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContactsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContactsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetContacts executes a bulk gorm update call with patch behavior
func DefaultPatchSetContacts(ctx context.Context, objects []*Contacts, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Contacts, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Contacts, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchContacts(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskContacts patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContacts(ctx context.Context, patchee *Contacts, patcher *Contacts, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Contacts, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsSupplier" {
			patchee.IsSupplier = patcher.IsSupplier
			continue
		}
		if f == prefix+"IsCustomer" {
			patchee.IsCustomer = patcher.IsCustomer
			continue
		}
		if f == prefix+"EmailAddress" {
			patchee.EmailAddress = patcher.EmailAddress
			continue
		}
		if f == prefix+"TaxNumber" {
			patchee.TaxNumber = patcher.TaxNumber
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"AddressesIds" {
			patchee.AddressesIds = patcher.AddressesIds
			continue
		}
		if f == prefix+"PhoneNumbers" {
			patchee.PhoneNumbers = patcher.PhoneNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContacts executes a gorm list call
func DefaultListContacts(ctx context.Context, db *gorm.DB) ([]*Contacts, error) {
	in := Contacts{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ContactsORM{}, &Contacts{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContactsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Contacts{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContactsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ContactsORM) error
}

// DefaultCreateCreditNote executes a basic gorm create call
func DefaultCreateCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteSet(ctx context.Context, in []*CreditNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditNoteORM{})).(CreditNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditNoteORM{})).(CreditNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditNote, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditNote, *gorm.DB) error
}

// DefaultStrictUpdateCreditNote clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := CreditNoteLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.CreditNoteId = new(uint64)
	*filterLineItems.CreditNoteId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(CreditNoteLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditNote executes a basic gorm update call with patch behavior
func DefaultPatchCreditNote(ctx context.Context, in *CreditNote, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditNote
	var err error
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditNote(ctx, &CreditNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditNote(ctx context.Context, objects []*CreditNote, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditNote(ctx context.Context, patchee *CreditNote, patcher *CreditNote, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"RemainingCredit" {
			patchee.RemainingCredit = patcher.RemainingCredit
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"PaymentIds" {
			patchee.PaymentIds = patcher.PaymentIds
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditNote executes a gorm list call
func DefaultListCreditNote(ctx context.Context, db *gorm.DB) ([]*CreditNote, error) {
	in := CreditNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditNoteORM{}, &CreditNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditNoteORM) error
}

// DefaultCreateCreditNoteLineItem executes a basic gorm create call
func DefaultCreateCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditNoteLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditNoteLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditNoteLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditNoteLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditNoteLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteLineItemSet(ctx context.Context, in []*CreditNoteLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditNoteLineItemORM{})).(CreditNoteLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditNoteLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditNoteLineItemORM{})).(CreditNoteLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditNoteLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditNoteLineItem, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditNoteLineItem, *gorm.DB) error
}

// DefaultStrictUpdateCreditNoteLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditNoteLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditNoteLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditNoteLineItem executes a basic gorm update call with patch behavior
func DefaultPatchCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditNoteLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditNoteLineItem(ctx, &CreditNoteLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditNoteLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditNoteLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditNoteLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditNoteLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditNoteLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditNoteLineItem(ctx context.Context, objects []*CreditNoteLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditNoteLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditNoteLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditNoteLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditNoteLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditNoteLineItem(ctx context.Context, patchee *CreditNoteLineItem, patcher *CreditNoteLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditNoteLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"TaxRate" {
			patchee.TaxRate = patcher.TaxRate
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditNoteLineItem executes a gorm list call
func DefaultListCreditNoteLineItem(ctx context.Context, db *gorm.DB) ([]*CreditNoteLineItem, error) {
	in := CreditNoteLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditNoteLineItemORM{}, &CreditNoteLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditNoteLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditNoteLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditNoteLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditNoteLineItemORM) error
}

// DefaultCreateExpense executes a basic gorm create call
func DefaultCreateExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ExpenseORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExpenseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExpenseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExpense(ctx context.Context, in *Expense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExpenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExpenseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseSet(ctx context.Context, in []*Expense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExpenseORM{})).(ExpenseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExpenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExpenseORM{})).(ExpenseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExpenseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Expense, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Expense, *gorm.DB) error
}

// DefaultStrictUpdateExpense clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExpense")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExpenseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := ExpenseLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.ExpenseId = new(uint64)
	*filterLines.ExpenseId = ormObj.Id
	if err = db.Where(filterLines).Delete(ExpenseLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExpenseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExpense executes a basic gorm update call with patch behavior
func DefaultPatchExpense(ctx context.Context, in *Expense, updateMask *field_mask.FieldMask, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Expense
	var err error
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExpense(ctx, &Expense{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExpense(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExpense(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExpenseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExpenseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExpense executes a bulk gorm update call with patch behavior
func DefaultPatchSetExpense(ctx context.Context, objects []*Expense, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Expense, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Expense, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExpense(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExpense patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpense(ctx context.Context, patchee *Expense, patcher *Expense, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Expense, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"SubTotal" {
			patchee.SubTotal = patcher.SubTotal
			continue
		}
		if f == prefix+"TotalTaxAmount" {
			patchee.TotalTaxAmount = patcher.TotalTaxAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpense executes a gorm list call
func DefaultListExpense(ctx context.Context, db *gorm.DB) ([]*Expense, error) {
	in := Expense{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseORM{}, &Expense{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExpenseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Expense{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseORM) error
}

// DefaultCreateExpenseLine executes a basic gorm create call
func DefaultCreateExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ExpenseLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExpenseLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExpenseLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExpenseLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExpenseLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseLineSet(ctx context.Context, in []*ExpenseLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExpenseLineORM{})).(ExpenseLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExpenseLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExpenseLineORM{})).(ExpenseLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExpenseLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ExpenseLine, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ExpenseLine, *gorm.DB) error
}

// DefaultStrictUpdateExpenseLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExpenseLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExpenseLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExpenseLine executes a basic gorm update call with patch behavior
func DefaultPatchExpenseLine(ctx context.Context, in *ExpenseLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ExpenseLine
	var err error
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExpenseLine(ctx, &ExpenseLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExpenseLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExpenseLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExpenseLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExpenseLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExpenseLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetExpenseLine(ctx context.Context, objects []*ExpenseLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ExpenseLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ExpenseLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExpenseLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExpenseLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpenseLine(ctx context.Context, patchee *ExpenseLine, patcher *ExpenseLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExpenseLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpenseLine executes a gorm list call
func DefaultListExpenseLine(ctx context.Context, db *gorm.DB) ([]*ExpenseLine, error) {
	in := ExpenseLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseLineORM{}, &ExpenseLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExpenseLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExpenseLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseLineORM) error
}

// DefaultCreateIncomeStatement executes a basic gorm create call
func DefaultCreateIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &IncomeStatementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := IncomeStatementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(IncomeStatementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&IncomeStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type IncomeStatementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteIncomeStatementSet(ctx context.Context, in []*IncomeStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&IncomeStatementORM{})).(IncomeStatementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&IncomeStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&IncomeStatementORM{})).(IncomeStatementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type IncomeStatementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*IncomeStatement, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*IncomeStatement, *gorm.DB) error
}

// DefaultStrictUpdateIncomeStatement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateIncomeStatement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &IncomeStatementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCostOfSales := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCostOfSales.CostOfSalesIncomeStatementId = new(uint64)
	*filterCostOfSales.CostOfSalesIncomeStatementId = ormObj.Id
	if err = db.Where(filterCostOfSales).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterIncome := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIncome.IncomeIncomeStatementId = new(uint64)
	*filterIncome.IncomeIncomeStatementId = ormObj.Id
	if err = db.Where(filterIncome).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterNonOperatingExpenses := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNonOperatingExpenses.NonOperatingExpensesIncomeStatementId = new(uint64)
	*filterNonOperatingExpenses.NonOperatingExpensesIncomeStatementId = ormObj.Id
	if err = db.Where(filterNonOperatingExpenses).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterOperatingExpenses := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOperatingExpenses.OperatingExpensesIncomeStatementId = new(uint64)
	*filterOperatingExpenses.OperatingExpensesIncomeStatementId = ormObj.Id
	if err = db.Where(filterOperatingExpenses).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchIncomeStatement executes a basic gorm update call with patch behavior
func DefaultPatchIncomeStatement(ctx context.Context, in *IncomeStatement, updateMask *field_mask.FieldMask, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj IncomeStatement
	var err error
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadIncomeStatement(ctx, &IncomeStatement{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskIncomeStatement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateIncomeStatement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(IncomeStatementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type IncomeStatementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetIncomeStatement executes a bulk gorm update call with patch behavior
func DefaultPatchSetIncomeStatement(ctx context.Context, objects []*IncomeStatement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*IncomeStatement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*IncomeStatement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchIncomeStatement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskIncomeStatement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIncomeStatement(ctx context.Context, patchee *IncomeStatement, patcher *IncomeStatement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IncomeStatement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartPeriod bool
	var updatedEndPeriod bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedStartPeriod && strings.HasPrefix(f, prefix+"StartPeriod.") {
			if patcher.StartPeriod == nil {
				patchee.StartPeriod = nil
				continue
			}
			if patchee.StartPeriod == nil {
				patchee.StartPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartPeriod, patchee.StartPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartPeriod" {
			updatedStartPeriod = true
			patchee.StartPeriod = patcher.StartPeriod
			continue
		}
		if !updatedEndPeriod && strings.HasPrefix(f, prefix+"EndPeriod.") {
			if patcher.EndPeriod == nil {
				patchee.EndPeriod = nil
				continue
			}
			if patchee.EndPeriod == nil {
				patchee.EndPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndPeriod, patchee.EndPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndPeriod" {
			updatedEndPeriod = true
			patchee.EndPeriod = patcher.EndPeriod
			continue
		}
		if f == prefix+"Income" {
			patchee.Income = patcher.Income
			continue
		}
		if f == prefix+"CostOfSales" {
			patchee.CostOfSales = patcher.CostOfSales
			continue
		}
		if f == prefix+"GrossProfit" {
			patchee.GrossProfit = patcher.GrossProfit
			continue
		}
		if f == prefix+"OperatingExpenses" {
			patchee.OperatingExpenses = patcher.OperatingExpenses
			continue
		}
		if f == prefix+"NetOperatingIncome" {
			patchee.NetOperatingIncome = patcher.NetOperatingIncome
			continue
		}
		if f == prefix+"NonOperatingExpenses" {
			patchee.NonOperatingExpenses = patcher.NonOperatingExpenses
			continue
		}
		if f == prefix+"NetIncome" {
			patchee.NetIncome = patcher.NetIncome
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIncomeStatement executes a gorm list call
func DefaultListIncomeStatement(ctx context.Context, db *gorm.DB) ([]*IncomeStatement, error) {
	in := IncomeStatement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IncomeStatementORM{}, &IncomeStatement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []IncomeStatementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IncomeStatement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IncomeStatementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IncomeStatementORM) error
}

// DefaultCreateInvoice executes a basic gorm create call
func DefaultCreateInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvoiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvoiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvoiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoice(ctx context.Context, in *Invoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvoiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceSet(ctx context.Context, in []*Invoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvoiceORM{})).(InvoiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvoiceORM{})).(InvoiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvoiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Invoice, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Invoice, *gorm.DB) error
}

// DefaultStrictUpdateInvoice clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvoice")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvoiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := InvoiceLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.InvoiceId = new(uint64)
	*filterLineItems.InvoiceId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(InvoiceLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvoiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvoice executes a basic gorm update call with patch behavior
func DefaultPatchInvoice(ctx context.Context, in *Invoice, updateMask *field_mask.FieldMask, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Invoice
	var err error
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvoice(ctx, &Invoice{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvoice(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvoice(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvoiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvoiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvoice executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvoice(ctx context.Context, objects []*Invoice, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Invoice, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Invoice, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvoice(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvoice patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvoice(ctx context.Context, patchee *Invoice, patcher *Invoice, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Invoice, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedIssueDate bool
	var updatedDueDate bool
	var updatedPaidOnDate bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedIssueDate && strings.HasPrefix(f, prefix+"IssueDate.") {
			if patcher.IssueDate == nil {
				patchee.IssueDate = nil
				continue
			}
			if patchee.IssueDate == nil {
				patchee.IssueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IssueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IssueDate, patchee.IssueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IssueDate" {
			updatedIssueDate = true
			patchee.IssueDate = patcher.IssueDate
			continue
		}
		if !updatedDueDate && strings.HasPrefix(f, prefix+"DueDate.") {
			if patcher.DueDate == nil {
				patchee.DueDate = nil
				continue
			}
			if patchee.DueDate == nil {
				patchee.DueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DueDate, patchee.DueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DueDate" {
			updatedDueDate = true
			patchee.DueDate = patcher.DueDate
			continue
		}
		if !updatedPaidOnDate && strings.HasPrefix(f, prefix+"PaidOnDate.") {
			if patcher.PaidOnDate == nil {
				patchee.PaidOnDate = nil
				continue
			}
			if patchee.PaidOnDate == nil {
				patchee.PaidOnDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PaidOnDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.PaidOnDate, patchee.PaidOnDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PaidOnDate" {
			updatedPaidOnDate = true
			patchee.PaidOnDate = patcher.PaidOnDate
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"TotalDiscount" {
			patchee.TotalDiscount = patcher.TotalDiscount
			continue
		}
		if f == prefix+"SubTotal" {
			patchee.SubTotal = patcher.SubTotal
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"TotalTaxAmount" {
			patchee.TotalTaxAmount = patcher.TotalTaxAmount
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"PurchaseOrders" {
			patchee.PurchaseOrders = patcher.PurchaseOrders
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvoice executes a gorm list call
func DefaultListInvoice(ctx context.Context, db *gorm.DB) ([]*Invoice, error) {
	in := Invoice{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvoiceORM{}, &Invoice{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvoiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Invoice{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvoiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvoiceORM) error
}

// DefaultCreateInvoiceLineItem executes a basic gorm create call
func DefaultCreateInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvoiceLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvoiceLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvoiceLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvoiceLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvoiceLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceLineItemSet(ctx context.Context, in []*InvoiceLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvoiceLineItemORM{})).(InvoiceLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvoiceLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvoiceLineItemORM{})).(InvoiceLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvoiceLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvoiceLineItem, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvoiceLineItem, *gorm.DB) error
}

// DefaultStrictUpdateInvoiceLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvoiceLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvoiceLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvoiceLineItem executes a basic gorm update call with patch behavior
func DefaultPatchInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvoiceLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvoiceLineItem(ctx, &InvoiceLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvoiceLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvoiceLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvoiceLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvoiceLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvoiceLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvoiceLineItem(ctx context.Context, objects []*InvoiceLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvoiceLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvoiceLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvoiceLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvoiceLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvoiceLineItem(ctx context.Context, patchee *InvoiceLineItem, patcher *InvoiceLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvoiceLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvoiceLineItem executes a gorm list call
func DefaultListInvoiceLineItem(ctx context.Context, db *gorm.DB) ([]*InvoiceLineItem, error) {
	in := InvoiceLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvoiceLineItemORM{}, &InvoiceLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvoiceLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvoiceLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvoiceLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvoiceLineItemORM) error
}

// DefaultCreateItem executes a basic gorm create call
func DefaultCreateItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteItem(ctx context.Context, in *Item, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteItemSet(ctx context.Context, in []*Item, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ItemORM{})).(ItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ItemORM{})).(ItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Item, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Item, *gorm.DB) error
}

// DefaultStrictUpdateItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchItem executes a basic gorm update call with patch behavior
func DefaultPatchItem(ctx context.Context, in *Item, updateMask *field_mask.FieldMask, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Item
	var err error
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadItem(ctx, &Item{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetItem(ctx context.Context, objects []*Item, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Item, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Item, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskItem(ctx context.Context, patchee *Item, patcher *Item, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Item, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"PurchasePrice" {
			patchee.PurchasePrice = patcher.PurchasePrice
			continue
		}
		if f == prefix+"PurchaseAccount" {
			patchee.PurchaseAccount = patcher.PurchaseAccount
			continue
		}
		if f == prefix+"SalesAccount" {
			patchee.SalesAccount = patcher.SalesAccount
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListItem executes a gorm list call
func DefaultListItem(ctx context.Context, db *gorm.DB) ([]*Item, error) {
	in := Item{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ItemORM{}, &Item{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Item{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ItemORM) error
}

// DefaultCreateJournalEntry executes a basic gorm create call
func DefaultCreateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JournalEntryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalEntryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalEntryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalEntryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalEntrySet(ctx context.Context, in []*JournalEntry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalEntryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalEntry, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalEntry, *gorm.DB) error
}

// DefaultStrictUpdateJournalEntry clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalEntry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalEntryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := JournalLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.JournalEntryId = new(uint64)
	*filterLines.JournalEntryId = ormObj.Id
	if err = db.Where(filterLines).Delete(JournalLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalEntryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJournalEntry executes a basic gorm update call with patch behavior
func DefaultPatchJournalEntry(ctx context.Context, in *JournalEntry, updateMask *field_mask.FieldMask, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj JournalEntry
	var err error
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalEntry(ctx, &JournalEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalEntry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalEntry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalEntryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalEntryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJournalEntry executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalEntry(ctx context.Context, objects []*JournalEntry, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*JournalEntry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalEntry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalEntry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalEntry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalEntry(ctx context.Context, patchee *JournalEntry, patcher *JournalEntry, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*JournalEntry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"PaymentIds" {
			patchee.PaymentIds = patcher.PaymentIds
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"JournalNumber" {
			patchee.JournalNumber = patcher.JournalNumber
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"PostingStatus" {
			patchee.PostingStatus = patcher.PostingStatus
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalEntry executes a gorm list call
func DefaultListJournalEntry(ctx context.Context, db *gorm.DB) ([]*JournalEntry, error) {
	in := JournalEntry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JournalEntryORM{}, &JournalEntry{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalEntryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalEntry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalEntryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JournalEntryORM) error
}

// DefaultCreateJournalLine executes a basic gorm create call
func DefaultCreateJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JournalLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalLineSet(ctx context.Context, in []*JournalLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalLineORM{})).(JournalLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalLineORM{})).(JournalLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalLine, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalLine, *gorm.DB) error
}

// DefaultStrictUpdateJournalLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJournalLine executes a basic gorm update call with patch behavior
func DefaultPatchJournalLine(ctx context.Context, in *JournalLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj JournalLine
	var err error
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalLine(ctx, &JournalLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJournalLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalLine(ctx context.Context, objects []*JournalLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*JournalLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalLine(ctx context.Context, patchee *JournalLine, patcher *JournalLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*JournalLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalLine executes a gorm list call
func DefaultListJournalLine(ctx context.Context, db *gorm.DB) ([]*JournalLine, error) {
	in := JournalLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JournalLineORM{}, &JournalLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JournalLineORM) error
}

// DefaultCreatePayment executes a basic gorm create call
func DefaultCreatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PaymentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PaymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PaymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePayment(ctx context.Context, in *Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PaymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePaymentSet(ctx context.Context, in []*Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PaymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Payment, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Payment, *gorm.DB) error
}

// DefaultStrictUpdatePayment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePayment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PaymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PaymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPayment executes a basic gorm update call with patch behavior
func DefaultPatchPayment(ctx context.Context, in *Payment, updateMask *field_mask.FieldMask, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Payment
	var err error
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPayment(ctx, &Payment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPayment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePayment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PaymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PaymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPayment executes a bulk gorm update call with patch behavior
func DefaultPatchSetPayment(ctx context.Context, objects []*Payment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Payment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Payment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPayment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPayment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPayment(ctx context.Context, patchee *Payment, patcher *Payment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Payment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPayment executes a gorm list call
func DefaultListPayment(ctx context.Context, db *gorm.DB) ([]*Payment, error) {
	in := Payment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PaymentORM{}, &Payment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PaymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Payment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentORM) error
}

// DefaultCreatePurchaseOrder executes a basic gorm create call
func DefaultCreatePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PurchaseOrderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseOrderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseOrderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseOrderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseOrderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderSet(ctx context.Context, in []*PurchaseOrder, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseOrderORM{})).(PurchaseOrderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseOrderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseOrderORM{})).(PurchaseOrderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseOrderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PurchaseOrder, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PurchaseOrder, *gorm.DB) error
}

// DefaultStrictUpdatePurchaseOrder clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchaseOrder")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseOrderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDeliveryAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDeliveryAddress.PurchaseOrderId = new(uint64)
	*filterDeliveryAddress.PurchaseOrderId = ormObj.Id
	if err = db.Where(filterDeliveryAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterLineItems := PurchaseOrderLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.PurchaseOrderId = new(uint64)
	*filterLineItems.PurchaseOrderId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(PurchaseOrderLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPurchaseOrder executes a basic gorm update call with patch behavior
func DefaultPatchPurchaseOrder(ctx context.Context, in *PurchaseOrder, updateMask *field_mask.FieldMask, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PurchaseOrder
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchaseOrder(ctx, &PurchaseOrder{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchaseOrder(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchaseOrder(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseOrderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseOrderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPurchaseOrder executes a bulk gorm update call with patch behavior
func DefaultPatchSetPurchaseOrder(ctx context.Context, objects []*PurchaseOrder, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PurchaseOrder, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PurchaseOrder, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPurchaseOrder(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPurchaseOrder patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchaseOrder(ctx context.Context, patchee *PurchaseOrder, patcher *PurchaseOrder, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PurchaseOrder, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedIssueDate bool
	var updatedDeliveryDate bool
	var updatedDeliveryAddress bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedIssueDate && strings.HasPrefix(f, prefix+"IssueDate.") {
			if patcher.IssueDate == nil {
				patchee.IssueDate = nil
				continue
			}
			if patchee.IssueDate == nil {
				patchee.IssueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IssueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IssueDate, patchee.IssueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IssueDate" {
			updatedIssueDate = true
			patchee.IssueDate = patcher.IssueDate
			continue
		}
		if f == prefix+"PurchaseOrderNumber" {
			patchee.PurchaseOrderNumber = patcher.PurchaseOrderNumber
			continue
		}
		if !updatedDeliveryDate && strings.HasPrefix(f, prefix+"DeliveryDate.") {
			if patcher.DeliveryDate == nil {
				patchee.DeliveryDate = nil
				continue
			}
			if patchee.DeliveryDate == nil {
				patchee.DeliveryDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeliveryDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeliveryDate, patchee.DeliveryDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeliveryDate" {
			updatedDeliveryDate = true
			patchee.DeliveryDate = patcher.DeliveryDate
			continue
		}
		if !updatedDeliveryAddress && strings.HasPrefix(f, prefix+"DeliveryAddress.") {
			updatedDeliveryAddress = true
			if patcher.DeliveryAddress == nil {
				patchee.DeliveryAddress = nil
				continue
			}
			if patchee.DeliveryAddress == nil {
				patchee.DeliveryAddress = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.DeliveryAddress, patcher.DeliveryAddress, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DeliveryAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.DeliveryAddress = o
			}
			continue
		}
		if f == prefix+"DeliveryAddress" {
			updatedDeliveryAddress = true
			patchee.DeliveryAddress = patcher.DeliveryAddress
			continue
		}
		if f == prefix+"Customer" {
			patchee.Customer = patcher.Customer
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchaseOrder executes a gorm list call
func DefaultListPurchaseOrder(ctx context.Context, db *gorm.DB) ([]*PurchaseOrder, error) {
	in := PurchaseOrder{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PurchaseOrderORM{}, &PurchaseOrder{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseOrderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PurchaseOrder{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseOrderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PurchaseOrderORM) error
}

// DefaultCreatePurchaseOrderLineItem executes a basic gorm create call
func DefaultCreatePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PurchaseOrderLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseOrderLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseOrderLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseOrderLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseOrderLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderLineItemSet(ctx context.Context, in []*PurchaseOrderLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseOrderLineItemORM{})).(PurchaseOrderLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseOrderLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseOrderLineItemORM{})).(PurchaseOrderLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseOrderLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PurchaseOrderLineItem, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PurchaseOrderLineItem, *gorm.DB) error
}

// DefaultStrictUpdatePurchaseOrderLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchaseOrderLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseOrderLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPurchaseOrderLineItem executes a basic gorm update call with patch behavior
func DefaultPatchPurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PurchaseOrderLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchaseOrderLineItem(ctx, &PurchaseOrderLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchaseOrderLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchaseOrderLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseOrderLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseOrderLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPurchaseOrderLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetPurchaseOrderLineItem(ctx context.Context, objects []*PurchaseOrderLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PurchaseOrderLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PurchaseOrderLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPurchaseOrderLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPurchaseOrderLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchaseOrderLineItem(ctx context.Context, patchee *PurchaseOrderLineItem, patcher *PurchaseOrderLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"TaxAmount" {
			patchee.TaxAmount = patcher.TaxAmount
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchaseOrderLineItem executes a gorm list call
func DefaultListPurchaseOrderLineItem(ctx context.Context, db *gorm.DB) ([]*PurchaseOrderLineItem, error) {
	in := PurchaseOrderLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PurchaseOrderLineItemORM{}, &PurchaseOrderLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseOrderLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PurchaseOrderLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseOrderLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PurchaseOrderLineItemORM) error
}

// DefaultCreateTaxRate executes a basic gorm create call
func DefaultCreateTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TaxRateORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TaxRateORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TaxRateORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TaxRateORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TaxRateORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TaxRateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TaxRateORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxRateSet(ctx context.Context, in []*TaxRate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TaxRateORM{})).(TaxRateORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TaxRateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TaxRateORM{})).(TaxRateORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TaxRateORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TaxRate, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TaxRate, *gorm.DB) error
}

// DefaultStrictUpdateTaxRate clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTaxRate")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TaxRateORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TaxRateORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTaxRate executes a basic gorm update call with patch behavior
func DefaultPatchTaxRate(ctx context.Context, in *TaxRate, updateMask *field_mask.FieldMask, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TaxRate
	var err error
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTaxRate(ctx, &TaxRate{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTaxRate(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTaxRate(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TaxRateWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TaxRateWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTaxRate executes a bulk gorm update call with patch behavior
func DefaultPatchSetTaxRate(ctx context.Context, objects []*TaxRate, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TaxRate, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TaxRate, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTaxRate(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTaxRate patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTaxRate(ctx context.Context, patchee *TaxRate, patcher *TaxRate, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TaxRate, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"TotalTaxRate" {
			patchee.TotalTaxRate = patcher.TotalTaxRate
			continue
		}
		if f == prefix+"EffectiveTaxRate" {
			patchee.EffectiveTaxRate = patcher.EffectiveTaxRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTaxRate executes a gorm list call
func DefaultListTaxRate(ctx context.Context, db *gorm.DB) ([]*TaxRate, error) {
	in := TaxRate{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TaxRateORM{}, &TaxRate{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TaxRateORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TaxRate{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TaxRateORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TaxRateORM) error
}

// DefaultCreateTrackingCategory executes a basic gorm create call
func DefaultCreateTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TrackingCategoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TrackingCategoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TrackingCategoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TrackingCategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TrackingCategoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTrackingCategorySet(ctx context.Context, in []*TrackingCategory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TrackingCategoryORM{})).(TrackingCategoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TrackingCategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TrackingCategoryORM{})).(TrackingCategoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TrackingCategoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TrackingCategory, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TrackingCategory, *gorm.DB) error
}

// DefaultStrictUpdateTrackingCategory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTrackingCategory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TrackingCategoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTrackingCategory executes a basic gorm update call with patch behavior
func DefaultPatchTrackingCategory(ctx context.Context, in *TrackingCategory, updateMask *field_mask.FieldMask, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TrackingCategory
	var err error
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTrackingCategory(ctx, &TrackingCategory{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTrackingCategory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTrackingCategory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TrackingCategoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TrackingCategoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTrackingCategory executes a bulk gorm update call with patch behavior
func DefaultPatchSetTrackingCategory(ctx context.Context, objects []*TrackingCategory, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TrackingCategory, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TrackingCategory, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTrackingCategory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTrackingCategory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTrackingCategory(ctx context.Context, patchee *TrackingCategory, patcher *TrackingCategory, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TrackingCategory, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"CategoryType" {
			patchee.CategoryType = patcher.CategoryType
			continue
		}
		if f == prefix+"ParentCategory" {
			patchee.ParentCategory = patcher.ParentCategory
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTrackingCategory executes a gorm list call
func DefaultListTrackingCategory(ctx context.Context, db *gorm.DB) ([]*TrackingCategory, error) {
	in := TrackingCategory{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TrackingCategoryORM{}, &TrackingCategory{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TrackingCategoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TrackingCategory{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TrackingCategoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TrackingCategoryORM) error
}

// DefaultCreateBusinessTransaction executes a basic gorm create call
func DefaultCreateBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessTransactionSet(ctx context.Context, in []*BusinessTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessTransactionORM{})).(BusinessTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessTransactionORM{})).(BusinessTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessTransaction, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessTransaction, *gorm.DB) error
}

// DefaultStrictUpdateBusinessTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := TransactionLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.BusinessTransactionId = new(uint64)
	*filterLineItems.BusinessTransactionId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(TransactionLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessTransaction executes a basic gorm update call with patch behavior
func DefaultPatchBusinessTransaction(ctx context.Context, in *BusinessTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessTransaction(ctx, &BusinessTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessTransaction(ctx context.Context, objects []*BusinessTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessTransaction(ctx context.Context, patchee *BusinessTransaction, patcher *BusinessTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TransactionType" {
			patchee.TransactionType = patcher.TransactionType
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessTransaction executes a gorm list call
func DefaultListBusinessTransaction(ctx context.Context, db *gorm.DB) ([]*BusinessTransaction, error) {
	in := BusinessTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessTransactionORM{}, &BusinessTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessTransactionORM) error
}

// DefaultCreateTransactionLineItem executes a basic gorm create call
func DefaultCreateTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionLineItemSet(ctx context.Context, in []*TransactionLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionLineItemORM{})).(TransactionLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionLineItemORM{})).(TransactionLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionLineItem, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionLineItem, *gorm.DB) error
}

// DefaultStrictUpdateTransactionLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionLineItem executes a basic gorm update call with patch behavior
func DefaultPatchTransactionLineItem(ctx context.Context, in *TransactionLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionLineItem(ctx, &TransactionLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionLineItem(ctx context.Context, objects []*TransactionLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionLineItem(ctx context.Context, patchee *TransactionLineItem, patcher *TransactionLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"TaxRate" {
			patchee.TaxRate = patcher.TaxRate
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionLineItem executes a gorm list call
func DefaultListTransactionLineItem(ctx context.Context, db *gorm.DB) ([]*TransactionLineItem, error) {
	in := TransactionLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionLineItemORM{}, &TransactionLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionLineItemORM) error
}

// DefaultCreateVendorCredit executes a basic gorm create call
func DefaultCreateVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VendorCreditORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VendorCreditORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VendorCreditORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VendorCreditORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VendorCreditORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditSet(ctx context.Context, in []*VendorCredit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VendorCreditORM{})).(VendorCreditORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VendorCreditORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VendorCreditORM{})).(VendorCreditORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VendorCreditORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VendorCredit, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VendorCredit, *gorm.DB) error
}

// DefaultStrictUpdateVendorCredit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVendorCredit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VendorCreditORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := VendorCreditLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.VendorCreditId = new(uint64)
	*filterLines.VendorCreditId = ormObj.Id
	if err = db.Where(filterLines).Delete(VendorCreditLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VendorCreditORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVendorCredit executes a basic gorm update call with patch behavior
func DefaultPatchVendorCredit(ctx context.Context, in *VendorCredit, updateMask *field_mask.FieldMask, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VendorCredit
	var err error
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVendorCredit(ctx, &VendorCredit{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVendorCredit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVendorCredit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VendorCreditWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VendorCreditWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVendorCredit executes a bulk gorm update call with patch behavior
func DefaultPatchSetVendorCredit(ctx context.Context, objects []*VendorCredit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VendorCredit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VendorCredit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVendorCredit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVendorCredit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVendorCredit(ctx context.Context, patchee *VendorCredit, patcher *VendorCredit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VendorCredit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVendorCredit executes a gorm list call
func DefaultListVendorCredit(ctx context.Context, db *gorm.DB) ([]*VendorCredit, error) {
	in := VendorCredit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VendorCreditORM{}, &VendorCredit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VendorCreditORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VendorCredit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VendorCreditORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VendorCreditORM) error
}

// DefaultCreateVendorCreditLine executes a basic gorm create call
func DefaultCreateVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VendorCreditLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VendorCreditLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VendorCreditLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VendorCreditLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VendorCreditLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditLineSet(ctx context.Context, in []*VendorCreditLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VendorCreditLineORM{})).(VendorCreditLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VendorCreditLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VendorCreditLineORM{})).(VendorCreditLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VendorCreditLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VendorCreditLine, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VendorCreditLine, *gorm.DB) error
}

// DefaultStrictUpdateVendorCreditLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVendorCreditLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VendorCreditLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVendorCreditLine executes a basic gorm update call with patch behavior
func DefaultPatchVendorCreditLine(ctx context.Context, in *VendorCreditLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VendorCreditLine
	var err error
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVendorCreditLine(ctx, &VendorCreditLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVendorCreditLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVendorCreditLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VendorCreditLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VendorCreditLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVendorCreditLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetVendorCreditLine(ctx context.Context, objects []*VendorCreditLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VendorCreditLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VendorCreditLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVendorCreditLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVendorCreditLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVendorCreditLine(ctx context.Context, patchee *VendorCreditLine, patcher *VendorCreditLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VendorCreditLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVendorCreditLine executes a gorm list call
func DefaultListVendorCreditLine(ctx context.Context, db *gorm.DB) ([]*VendorCreditLine, error) {
	in := VendorCreditLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VendorCreditLineORM{}, &VendorCreditLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VendorCreditLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VendorCreditLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VendorCreditLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VendorCreditLineORM) error
}

// DefaultCreatePlaidAccountInvestmentTransaction executes a basic gorm create call
func DefaultCreatePlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountInvestmentTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidAccountInvestmentTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidAccountInvestmentTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidAccountInvestmentTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountInvestmentTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidAccountInvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidAccountInvestmentTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountInvestmentTransactionSet(ctx context.Context, in []*PlaidAccountInvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidAccountInvestmentTransactionORM{})).(PlaidAccountInvestmentTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidAccountInvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidAccountInvestmentTransactionORM{})).(PlaidAccountInvestmentTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidAccountInvestmentTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidAccountInvestmentTransaction, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidAccountInvestmentTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePlaidAccountInvestmentTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidAccountInvestmentTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidAccountInvestmentTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.PlaidAccountInvestmentTransactionId = new(uint64)
	*filterNotes.PlaidAccountInvestmentTransactionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidAccountInvestmentTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidAccountInvestmentTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidAccountInvestmentTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidAccountInvestmentTransaction(ctx, &PlaidAccountInvestmentTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidAccountInvestmentTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidAccountInvestmentTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidAccountInvestmentTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidAccountInvestmentTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidAccountInvestmentTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidAccountInvestmentTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidAccountInvestmentTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidAccountInvestmentTransaction(ctx context.Context, objects []*PlaidAccountInvestmentTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidAccountInvestmentTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidAccountInvestmentTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidAccountInvestmentTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidAccountInvestmentTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidAccountInvestmentTransaction(ctx context.Context, patchee *PlaidAccountInvestmentTransaction, patcher *PlaidAccountInvestmentTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Ammount" {
			patchee.Ammount = patcher.Ammount
			continue
		}
		if f == prefix+"InvestmentTransactionId" {
			patchee.InvestmentTransactionId = patcher.InvestmentTransactionId
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"CurrentDate" {
			patchee.CurrentDate = patcher.CurrentDate
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Fees" {
			patchee.Fees = patcher.Fees
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidAccountInvestmentTransaction executes a gorm list call
func DefaultListPlaidAccountInvestmentTransaction(ctx context.Context, db *gorm.DB) ([]*PlaidAccountInvestmentTransaction, error) {
	in := PlaidAccountInvestmentTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidAccountInvestmentTransactionORM{}, &PlaidAccountInvestmentTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidAccountInvestmentTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidAccountInvestmentTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidAccountInvestmentTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidAccountInvestmentTransactionORM) error
}

// DefaultCreatePlaidAccountRecurringTransaction executes a basic gorm create call
func DefaultCreatePlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountRecurringTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidAccountRecurringTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidAccountRecurringTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidAccountRecurringTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountRecurringTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidAccountRecurringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidAccountRecurringTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountRecurringTransactionSet(ctx context.Context, in []*PlaidAccountRecurringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidAccountRecurringTransactionORM{})).(PlaidAccountRecurringTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidAccountRecurringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidAccountRecurringTransactionORM{})).(PlaidAccountRecurringTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidAccountRecurringTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidAccountRecurringTransaction, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidAccountRecurringTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePlaidAccountRecurringTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidAccountRecurringTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidAccountRecurringTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.PlaidAccountRecurringTransactionId = new(uint64)
	*filterNotes.PlaidAccountRecurringTransactionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidAccountRecurringTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidAccountRecurringTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidAccountRecurringTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidAccountRecurringTransaction(ctx, &PlaidAccountRecurringTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidAccountRecurringTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidAccountRecurringTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidAccountRecurringTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidAccountRecurringTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidAccountRecurringTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidAccountRecurringTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidAccountRecurringTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidAccountRecurringTransaction(ctx context.Context, objects []*PlaidAccountRecurringTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidAccountRecurringTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidAccountRecurringTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidAccountRecurringTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidAccountRecurringTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidAccountRecurringTransaction(ctx context.Context, patchee *PlaidAccountRecurringTransaction, patcher *PlaidAccountRecurringTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedFirstDate bool
	var updatedLastDate bool
	var updatedUpdatedTime bool
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"StreamId" {
			patchee.StreamId = patcher.StreamId
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if !updatedFirstDate && strings.HasPrefix(f, prefix+"FirstDate.") {
			if patcher.FirstDate == nil {
				patchee.FirstDate = nil
				continue
			}
			if patchee.FirstDate == nil {
				patchee.FirstDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FirstDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.FirstDate, patchee.FirstDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FirstDate" {
			updatedFirstDate = true
			patchee.FirstDate = patcher.FirstDate
			continue
		}
		if !updatedLastDate && strings.HasPrefix(f, prefix+"LastDate.") {
			if patcher.LastDate == nil {
				patchee.LastDate = nil
				continue
			}
			if patchee.LastDate == nil {
				patchee.LastDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastDate, patchee.LastDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastDate" {
			updatedLastDate = true
			patchee.LastDate = patcher.LastDate
			continue
		}
		if f == prefix+"Frequency" {
			patchee.Frequency = patcher.Frequency
			continue
		}
		if f == prefix+"TransactionIds" {
			patchee.TransactionIds = patcher.TransactionIds
			continue
		}
		if f == prefix+"AverageAmount" {
			patchee.AverageAmount = patcher.AverageAmount
			continue
		}
		if f == prefix+"AverageAmountIsoCurrencyCode" {
			patchee.AverageAmountIsoCurrencyCode = patcher.AverageAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"LastAmount" {
			patchee.LastAmount = patcher.LastAmount
			continue
		}
		if f == prefix+"LastAmountIsoCurrencyCode" {
			patchee.LastAmountIsoCurrencyCode = patcher.LastAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedUpdatedTime && strings.HasPrefix(f, prefix+"UpdatedTime.") {
			if patcher.UpdatedTime == nil {
				patchee.UpdatedTime = nil
				continue
			}
			if patchee.UpdatedTime == nil {
				patchee.UpdatedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedTime, patchee.UpdatedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedTime" {
			updatedUpdatedTime = true
			patchee.UpdatedTime = patcher.UpdatedTime
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Flow" {
			patchee.Flow = patcher.Flow
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidAccountRecurringTransaction executes a gorm list call
func DefaultListPlaidAccountRecurringTransaction(ctx context.Context, db *gorm.DB) ([]*PlaidAccountRecurringTransaction, error) {
	in := PlaidAccountRecurringTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidAccountRecurringTransactionORM{}, &PlaidAccountRecurringTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidAccountRecurringTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidAccountRecurringTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidAccountRecurringTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidAccountRecurringTransactionORM) error
}

// DefaultCreatePlaidAccountTransaction executes a basic gorm create call
func DefaultCreatePlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidAccountTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidAccountTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidAccountTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidAccountTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidAccountTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountTransactionSet(ctx context.Context, in []*PlaidAccountTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidAccountTransactionORM{})).(PlaidAccountTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidAccountTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidAccountTransactionORM{})).(PlaidAccountTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidAccountTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidAccountTransaction, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidAccountTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePlaidAccountTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidAccountTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidAccountTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.PlaidAccountTransactionId = new(uint64)
	*filterNotes.PlaidAccountTransactionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	filterSplits := TransactionSplitORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSplits.PlaidAccountTransactionId = new(uint64)
	*filterSplits.PlaidAccountTransactionId = ormObj.Id
	if err = db.Where(filterSplits).Delete(TransactionSplitORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidAccountTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidAccountTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidAccountTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidAccountTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidAccountTransaction(ctx, &PlaidAccountTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidAccountTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidAccountTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidAccountTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidAccountTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidAccountTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidAccountTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidAccountTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidAccountTransaction(ctx context.Context, objects []*PlaidAccountTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidAccountTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidAccountTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidAccountTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidAccountTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidAccountTransaction(ctx context.Context, patchee *PlaidAccountTransaction, patcher *PlaidAccountTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCurrentDate bool
	var updatedCurrentDatetime bool
	var updatedAuthorizedDate bool
	var updatedAuthorizedDatetime bool
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"TransactionId" {
			patchee.TransactionId = patcher.TransactionId
			continue
		}
		if f == prefix+"TransactionCode" {
			patchee.TransactionCode = patcher.TransactionCode
			continue
		}
		if !updatedCurrentDate && strings.HasPrefix(f, prefix+"CurrentDate.") {
			if patcher.CurrentDate == nil {
				patchee.CurrentDate = nil
				continue
			}
			if patchee.CurrentDate == nil {
				patchee.CurrentDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CurrentDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CurrentDate, patchee.CurrentDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CurrentDate" {
			updatedCurrentDate = true
			patchee.CurrentDate = patcher.CurrentDate
			continue
		}
		if !updatedCurrentDatetime && strings.HasPrefix(f, prefix+"CurrentDatetime.") {
			if patcher.CurrentDatetime == nil {
				patchee.CurrentDatetime = nil
				continue
			}
			if patchee.CurrentDatetime == nil {
				patchee.CurrentDatetime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CurrentDatetime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CurrentDatetime, patchee.CurrentDatetime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CurrentDatetime" {
			updatedCurrentDatetime = true
			patchee.CurrentDatetime = patcher.CurrentDatetime
			continue
		}
		if !updatedAuthorizedDate && strings.HasPrefix(f, prefix+"AuthorizedDate.") {
			if patcher.AuthorizedDate == nil {
				patchee.AuthorizedDate = nil
				continue
			}
			if patchee.AuthorizedDate == nil {
				patchee.AuthorizedDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDate, patchee.AuthorizedDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDate" {
			updatedAuthorizedDate = true
			patchee.AuthorizedDate = patcher.AuthorizedDate
			continue
		}
		if !updatedAuthorizedDatetime && strings.HasPrefix(f, prefix+"AuthorizedDatetime.") {
			if patcher.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = nil
				continue
			}
			if patchee.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDatetime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDatetime, patchee.AuthorizedDatetime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDatetime" {
			updatedAuthorizedDatetime = true
			patchee.AuthorizedDatetime = patcher.AuthorizedDatetime
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"Categories" {
			patchee.Categories = patcher.Categories
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"TransactionName" {
			patchee.TransactionName = patcher.TransactionName
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"CheckNumber" {
			patchee.CheckNumber = patcher.CheckNumber
			continue
		}
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"Pending" {
			patchee.Pending = patcher.Pending
			continue
		}
		if f == prefix+"PendingTransactionId" {
			patchee.PendingTransactionId = patcher.PendingTransactionId
			continue
		}
		if f == prefix+"AccountOwner" {
			patchee.AccountOwner = patcher.AccountOwner
			continue
		}
		if f == prefix+"PaymentMetaByOrderOf" {
			patchee.PaymentMetaByOrderOf = patcher.PaymentMetaByOrderOf
			continue
		}
		if f == prefix+"PaymentMetaPayee" {
			patchee.PaymentMetaPayee = patcher.PaymentMetaPayee
			continue
		}
		if f == prefix+"PaymentMetaPayer" {
			patchee.PaymentMetaPayer = patcher.PaymentMetaPayer
			continue
		}
		if f == prefix+"PaymentMetaPaymentMethod" {
			patchee.PaymentMetaPaymentMethod = patcher.PaymentMetaPaymentMethod
			continue
		}
		if f == prefix+"PaymentMetaPaymentProcessor" {
			patchee.PaymentMetaPaymentProcessor = patcher.PaymentMetaPaymentProcessor
			continue
		}
		if f == prefix+"PaymentMetaPpdId" {
			patchee.PaymentMetaPpdId = patcher.PaymentMetaPpdId
			continue
		}
		if f == prefix+"PaymentMetaReason" {
			patchee.PaymentMetaReason = patcher.PaymentMetaReason
			continue
		}
		if f == prefix+"PaymentMetaReferenceNumber" {
			patchee.PaymentMetaReferenceNumber = patcher.PaymentMetaReferenceNumber
			continue
		}
		if f == prefix+"LocationAddress" {
			patchee.LocationAddress = patcher.LocationAddress
			continue
		}
		if f == prefix+"LocationCity" {
			patchee.LocationCity = patcher.LocationCity
			continue
		}
		if f == prefix+"LocationRegion" {
			patchee.LocationRegion = patcher.LocationRegion
			continue
		}
		if f == prefix+"LocationPostalCode" {
			patchee.LocationPostalCode = patcher.LocationPostalCode
			continue
		}
		if f == prefix+"LocationCountry" {
			patchee.LocationCountry = patcher.LocationCountry
			continue
		}
		if f == prefix+"LocationLat" {
			patchee.LocationLat = patcher.LocationLat
			continue
		}
		if f == prefix+"LocationLon" {
			patchee.LocationLon = patcher.LocationLon
			continue
		}
		if f == prefix+"LocationStoreNumber" {
			patchee.LocationStoreNumber = patcher.LocationStoreNumber
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"NeedsReview" {
			patchee.NeedsReview = patcher.NeedsReview
			continue
		}
		if f == prefix+"HideTransaction" {
			patchee.HideTransaction = patcher.HideTransaction
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"Splits" {
			patchee.Splits = patcher.Splits
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidAccountTransaction executes a gorm list call
func DefaultListPlaidAccountTransaction(ctx context.Context, db *gorm.DB) ([]*PlaidAccountTransaction, error) {
	in := PlaidAccountTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidAccountTransactionORM{}, &PlaidAccountTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidAccountTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidAccountTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidAccountTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidAccountTransactionORM) error
}

// DefaultCreateTransactionSplit executes a basic gorm create call
func DefaultCreateTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionSplitORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionSplitORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionSplitORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionSplitORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionSplitORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionSplitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionSplitORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSplitSet(ctx context.Context, in []*TransactionSplit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionSplitORM{})).(TransactionSplitORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionSplitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionSplitORM{})).(TransactionSplitORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionSplitORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionSplit, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionSplit, *gorm.DB) error
}

// DefaultStrictUpdateTransactionSplit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionSplit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionSplitORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionSplitORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionSplit executes a basic gorm update call with patch behavior
func DefaultPatchTransactionSplit(ctx context.Context, in *TransactionSplit, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionSplit
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionSplitWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionSplit(ctx, &TransactionSplit{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionSplitWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionSplit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionSplitWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionSplit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionSplitWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionSplitWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionSplit executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionSplit(ctx context.Context, objects []*TransactionSplit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionSplit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionSplit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionSplit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionSplit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionSplit(ctx context.Context, patchee *TransactionSplit, patcher *TransactionSplit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionSplit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAuthorizedDate bool
	var updatedAuthorizedDatetime bool
	var updatedTimeOfSplit bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Categories" {
			patchee.Categories = patcher.Categories
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedAuthorizedDate && strings.HasPrefix(f, prefix+"AuthorizedDate.") {
			if patcher.AuthorizedDate == nil {
				patchee.AuthorizedDate = nil
				continue
			}
			if patchee.AuthorizedDate == nil {
				patchee.AuthorizedDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDate, patchee.AuthorizedDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDate" {
			updatedAuthorizedDate = true
			patchee.AuthorizedDate = patcher.AuthorizedDate
			continue
		}
		if !updatedAuthorizedDatetime && strings.HasPrefix(f, prefix+"AuthorizedDatetime.") {
			if patcher.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = nil
				continue
			}
			if patchee.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDatetime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDatetime, patchee.AuthorizedDatetime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDatetime" {
			updatedAuthorizedDatetime = true
			patchee.AuthorizedDatetime = patcher.AuthorizedDatetime
			continue
		}
		if !updatedTimeOfSplit && strings.HasPrefix(f, prefix+"TimeOfSplit.") {
			if patcher.TimeOfSplit == nil {
				patchee.TimeOfSplit = nil
				continue
			}
			if patchee.TimeOfSplit == nil {
				patchee.TimeOfSplit = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TimeOfSplit."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TimeOfSplit, patchee.TimeOfSplit, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TimeOfSplit" {
			updatedTimeOfSplit = true
			patchee.TimeOfSplit = patcher.TimeOfSplit
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionSplit executes a gorm list call
func DefaultListTransactionSplit(ctx context.Context, db *gorm.DB) ([]*TransactionSplit, error) {
	in := TransactionSplit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionSplitORM{}, &TransactionSplit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionSplitORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionSplit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionSplitORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionSplitORM) error
}
