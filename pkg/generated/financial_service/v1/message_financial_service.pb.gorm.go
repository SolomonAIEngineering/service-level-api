package financial_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	anypb "google.golang.org/protobuf/types/known/anypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type StripeSubscriptionORM struct {
	FinancialUserProfileId        *uint64
	Id                            uint64
	IsTrialing                    bool
	StripeSubscriptionActiveUntil string
	StripeSubscriptionId          string
	StripeSubscriptionStatus      string
	StripeWebhookLatestTimestamp  string
}

// TableName overrides the default tablename generated by GORM
func (StripeSubscriptionORM) TableName() string {
	return "stripe_subscriptions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StripeSubscription) ToORM(ctx context.Context) (StripeSubscriptionORM, error) {
	to := StripeSubscriptionORM{}
	var err error
	if prehook, ok := interface{}(m).(StripeSubscriptionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.StripeSubscriptionId = m.StripeSubscriptionId
	to.StripeSubscriptionStatus = StripeSubscriptionStatus_name[int32(m.StripeSubscriptionStatus)]
	to.StripeSubscriptionActiveUntil = m.StripeSubscriptionActiveUntil
	to.StripeWebhookLatestTimestamp = m.StripeWebhookLatestTimestamp
	to.IsTrialing = m.IsTrialing
	if posthook, ok := interface{}(m).(StripeSubscriptionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StripeSubscriptionORM) ToPB(ctx context.Context) (StripeSubscription, error) {
	to := StripeSubscription{}
	var err error
	if prehook, ok := interface{}(m).(StripeSubscriptionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.StripeSubscriptionId = m.StripeSubscriptionId
	to.StripeSubscriptionStatus = StripeSubscriptionStatus(StripeSubscriptionStatus_value[m.StripeSubscriptionStatus])
	to.StripeSubscriptionActiveUntil = m.StripeSubscriptionActiveUntil
	to.StripeWebhookLatestTimestamp = m.StripeWebhookLatestTimestamp
	to.IsTrialing = m.IsTrialing
	if posthook, ok := interface{}(m).(StripeSubscriptionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StripeSubscription the arg will be the target, the caller the one being converted from

// StripeSubscriptionBeforeToORM called before default ToORM code
type StripeSubscriptionWithBeforeToORM interface {
	BeforeToORM(context.Context, *StripeSubscriptionORM) error
}

// StripeSubscriptionAfterToORM called after default ToORM code
type StripeSubscriptionWithAfterToORM interface {
	AfterToORM(context.Context, *StripeSubscriptionORM) error
}

// StripeSubscriptionBeforeToPB called before default ToPB code
type StripeSubscriptionWithBeforeToPB interface {
	BeforeToPB(context.Context, *StripeSubscription) error
}

// StripeSubscriptionAfterToPB called after default ToPB code
type StripeSubscriptionWithAfterToPB interface {
	AfterToPB(context.Context, *StripeSubscription) error
}

type FinancialUserProfileORM struct {
	ActionableInsights         []*ActionableInsightORM         `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id;preload:true"`
	ActionablePersonalInsights []*PersonalActionableInsightORM `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id;preload:true"`
	Email                      string
	Id                         uint64
	Link                       []*LinkORM `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id;preload:true"`
	ProfileType                string
	StripeCustomerId           string
	StripeSubscriptions        *StripeSubscriptionORM `gorm:"foreignkey:FinancialUserProfileId;association_foreignkey:Id"`
	UserId                     uint64
}

// TableName overrides the default tablename generated by GORM
func (FinancialUserProfileORM) TableName() string {
	return "financial_user_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FinancialUserProfile) ToORM(ctx context.Context) (FinancialUserProfileORM, error) {
	to := FinancialUserProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(FinancialUserProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.StripeCustomerId = m.StripeCustomerId
	if m.StripeSubscriptions != nil {
		tempStripeSubscriptions, err := m.StripeSubscriptions.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.StripeSubscriptions = &tempStripeSubscriptions
	}
	for _, v := range m.Link {
		if v != nil {
			if tempLink, cErr := v.ToORM(ctx); cErr == nil {
				to.Link = append(to.Link, &tempLink)
			} else {
				return to, cErr
			}
		} else {
			to.Link = append(to.Link, nil)
		}
	}
	for _, v := range m.ActionableInsights {
		if v != nil {
			if tempActionableInsights, cErr := v.ToORM(ctx); cErr == nil {
				to.ActionableInsights = append(to.ActionableInsights, &tempActionableInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionableInsights = append(to.ActionableInsights, nil)
		}
	}
	to.Email = m.Email
	for _, v := range m.ActionablePersonalInsights {
		if v != nil {
			if tempActionablePersonalInsights, cErr := v.ToORM(ctx); cErr == nil {
				to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, &tempActionablePersonalInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, nil)
		}
	}
	to.ProfileType = FinancialUserProfileType_name[int32(m.ProfileType)]
	if posthook, ok := interface{}(m).(FinancialUserProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FinancialUserProfileORM) ToPB(ctx context.Context) (FinancialUserProfile, error) {
	to := FinancialUserProfile{}
	var err error
	if prehook, ok := interface{}(m).(FinancialUserProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.StripeCustomerId = m.StripeCustomerId
	if m.StripeSubscriptions != nil {
		tempStripeSubscriptions, err := m.StripeSubscriptions.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.StripeSubscriptions = &tempStripeSubscriptions
	}
	for _, v := range m.Link {
		if v != nil {
			if tempLink, cErr := v.ToPB(ctx); cErr == nil {
				to.Link = append(to.Link, &tempLink)
			} else {
				return to, cErr
			}
		} else {
			to.Link = append(to.Link, nil)
		}
	}
	for _, v := range m.ActionableInsights {
		if v != nil {
			if tempActionableInsights, cErr := v.ToPB(ctx); cErr == nil {
				to.ActionableInsights = append(to.ActionableInsights, &tempActionableInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionableInsights = append(to.ActionableInsights, nil)
		}
	}
	to.Email = m.Email
	for _, v := range m.ActionablePersonalInsights {
		if v != nil {
			if tempActionablePersonalInsights, cErr := v.ToPB(ctx); cErr == nil {
				to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, &tempActionablePersonalInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, nil)
		}
	}
	to.ProfileType = FinancialUserProfileType(FinancialUserProfileType_value[m.ProfileType])
	if posthook, ok := interface{}(m).(FinancialUserProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FinancialUserProfile the arg will be the target, the caller the one being converted from

// FinancialUserProfileBeforeToORM called before default ToORM code
type FinancialUserProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *FinancialUserProfileORM) error
}

// FinancialUserProfileAfterToORM called after default ToORM code
type FinancialUserProfileWithAfterToORM interface {
	AfterToORM(context.Context, *FinancialUserProfileORM) error
}

// FinancialUserProfileBeforeToPB called before default ToPB code
type FinancialUserProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *FinancialUserProfile) error
}

// FinancialUserProfileAfterToPB called after default ToPB code
type FinancialUserProfileWithAfterToPB interface {
	AfterToPB(context.Context, *FinancialUserProfile) error
}

type ActionableInsightORM struct {
	DetailedAction         string
	FinancialUserProfileId *uint64
	GeneratedTime          *time.Time
	Id                     uint64
	SummarizedAction       string
	Tags                   pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (ActionableInsightORM) TableName() string {
	return "actionable_insights"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ActionableInsight) ToORM(ctx context.Context) (ActionableInsightORM, error) {
	to := ActionableInsightORM{}
	var err error
	if prehook, ok := interface{}(m).(ActionableInsightWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DetailedAction = m.DetailedAction
	to.SummarizedAction = m.SummarizedAction
	if m.GeneratedTime != nil {
		t := m.GeneratedTime.AsTime()
		to.GeneratedTime = &t
	}
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if posthook, ok := interface{}(m).(ActionableInsightWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ActionableInsightORM) ToPB(ctx context.Context) (ActionableInsight, error) {
	to := ActionableInsight{}
	var err error
	if prehook, ok := interface{}(m).(ActionableInsightWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.DetailedAction = m.DetailedAction
	to.SummarizedAction = m.SummarizedAction
	if m.GeneratedTime != nil {
		to.GeneratedTime = timestamppb.New(*m.GeneratedTime)
	}
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if posthook, ok := interface{}(m).(ActionableInsightWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ActionableInsight the arg will be the target, the caller the one being converted from

// ActionableInsightBeforeToORM called before default ToORM code
type ActionableInsightWithBeforeToORM interface {
	BeforeToORM(context.Context, *ActionableInsightORM) error
}

// ActionableInsightAfterToORM called after default ToORM code
type ActionableInsightWithAfterToORM interface {
	AfterToORM(context.Context, *ActionableInsightORM) error
}

// ActionableInsightBeforeToPB called before default ToPB code
type ActionableInsightWithBeforeToPB interface {
	BeforeToPB(context.Context, *ActionableInsight) error
}

// ActionableInsightAfterToPB called after default ToPB code
type ActionableInsightWithAfterToPB interface {
	AfterToPB(context.Context, *ActionableInsight) error
}

type PersonalActionableInsightORM struct {
	Action                 string
	Description            string
	ExpectedBenefit        string
	FinancialUserProfileId *uint64
	GeneratedTime          *time.Time
	Id                     uint64
	InsightName            string
	MetricsToOptimizeFor   pq.StringArray `gorm:"type:text[]"`
	Tags                   pq.StringArray `gorm:"type:text[]"`
	Takeaway               string
}

// TableName overrides the default tablename generated by GORM
func (PersonalActionableInsightORM) TableName() string {
	return "personal_actionable_insights"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PersonalActionableInsight) ToORM(ctx context.Context) (PersonalActionableInsightORM, error) {
	to := PersonalActionableInsightORM{}
	var err error
	if prehook, ok := interface{}(m).(PersonalActionableInsightWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightName = PersonalActionableInsightName_name[int32(m.InsightName)]
	to.Description = m.Description
	to.Takeaway = m.Takeaway
	to.Action = m.Action
	to.ExpectedBenefit = m.ExpectedBenefit
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.GeneratedTime != nil {
		t := m.GeneratedTime.AsTime()
		to.GeneratedTime = &t
	}
	if m.MetricsToOptimizeFor != nil {
		to.MetricsToOptimizeFor = make(pq.StringArray, len(m.MetricsToOptimizeFor))
		copy(to.MetricsToOptimizeFor, m.MetricsToOptimizeFor)
	}
	if posthook, ok := interface{}(m).(PersonalActionableInsightWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PersonalActionableInsightORM) ToPB(ctx context.Context) (PersonalActionableInsight, error) {
	to := PersonalActionableInsight{}
	var err error
	if prehook, ok := interface{}(m).(PersonalActionableInsightWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightName = PersonalActionableInsightName(PersonalActionableInsightName_value[m.InsightName])
	to.Description = m.Description
	to.Takeaway = m.Takeaway
	to.Action = m.Action
	to.ExpectedBenefit = m.ExpectedBenefit
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.GeneratedTime != nil {
		to.GeneratedTime = timestamppb.New(*m.GeneratedTime)
	}
	if m.MetricsToOptimizeFor != nil {
		to.MetricsToOptimizeFor = make(pq.StringArray, len(m.MetricsToOptimizeFor))
		copy(to.MetricsToOptimizeFor, m.MetricsToOptimizeFor)
	}
	if posthook, ok := interface{}(m).(PersonalActionableInsightWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PersonalActionableInsight the arg will be the target, the caller the one being converted from

// PersonalActionableInsightBeforeToORM called before default ToORM code
type PersonalActionableInsightWithBeforeToORM interface {
	BeforeToORM(context.Context, *PersonalActionableInsightORM) error
}

// PersonalActionableInsightAfterToORM called after default ToORM code
type PersonalActionableInsightWithAfterToORM interface {
	AfterToORM(context.Context, *PersonalActionableInsightORM) error
}

// PersonalActionableInsightBeforeToPB called before default ToPB code
type PersonalActionableInsightWithBeforeToPB interface {
	BeforeToPB(context.Context, *PersonalActionableInsight) error
}

// PersonalActionableInsightAfterToPB called after default ToPB code
type PersonalActionableInsightWithAfterToPB interface {
	AfterToPB(context.Context, *PersonalActionableInsight) error
}

type LinkORM struct {
	BankAccounts              []*BankAccountORM   `gorm:"foreignkey:LinkId;association_foreignkey:Id"`
	CreditAccounts            []*CreditAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	CustomInstitutionName     string
	Description               string
	ErrorCode                 string
	ExpirationDate            string
	FinancialUserProfileId    *uint64
	Id                        uint64
	InstitutionName           string
	InvestmentAccounts        []*InvestmentAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	LastManualSync            string
	LastSuccessfulUpdate      string
	LinkStatus                string
	LinkType                  string
	MortgageAccounts          []*MortgageAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	NewAccountsAvailable      bool
	PlaidInstitutionId        string
	PlaidLink                 *PlaidLinkORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	PlaidNewAccountsAvailable bool
	PlaidSync                 *PlaidSyncORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	ShouldBeUpdated           bool
	StudentLoanAccounts       []*StudentLoanAccountORM `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	Token                     *TokenORM                `gorm:"foreignkey:LinkId;association_foreignkey:Id;preload:true"`
	UpdatedAt                 string
}

// TableName overrides the default tablename generated by GORM
func (LinkORM) TableName() string {
	return "links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Link) ToORM(ctx context.Context) (LinkORM, error) {
	to := LinkORM{}
	var err error
	if prehook, ok := interface{}(m).(LinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PlaidSync != nil {
		tempPlaidSync, err := m.PlaidSync.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidSync = &tempPlaidSync
	}
	to.LinkStatus = LinkStatus_name[int32(m.LinkStatus)]
	if m.PlaidLink != nil {
		tempPlaidLink, err := m.PlaidLink.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidLink = &tempPlaidLink
	}
	to.PlaidNewAccountsAvailable = m.PlaidNewAccountsAvailable
	to.ExpirationDate = m.ExpirationDate
	to.InstitutionName = m.InstitutionName
	to.CustomInstitutionName = m.CustomInstitutionName
	to.Description = m.Description
	to.LastManualSync = m.LastManualSync
	to.LastSuccessfulUpdate = m.LastSuccessfulUpdate
	if m.Token != nil {
		tempToken, err := m.Token.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	for _, v := range m.BankAccounts {
		if v != nil {
			if tempBankAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.BankAccounts = append(to.BankAccounts, &tempBankAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.BankAccounts = append(to.BankAccounts, nil)
		}
	}
	for _, v := range m.InvestmentAccounts {
		if v != nil {
			if tempInvestmentAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestmentAccounts = append(to.InvestmentAccounts, &tempInvestmentAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentAccounts = append(to.InvestmentAccounts, nil)
		}
	}
	for _, v := range m.CreditAccounts {
		if v != nil {
			if tempCreditAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.CreditAccounts = append(to.CreditAccounts, &tempCreditAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.CreditAccounts = append(to.CreditAccounts, nil)
		}
	}
	for _, v := range m.MortgageAccounts {
		if v != nil {
			if tempMortgageAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.MortgageAccounts = append(to.MortgageAccounts, &tempMortgageAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MortgageAccounts = append(to.MortgageAccounts, nil)
		}
	}
	for _, v := range m.StudentLoanAccounts {
		if v != nil {
			if tempStudentLoanAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.StudentLoanAccounts = append(to.StudentLoanAccounts, &tempStudentLoanAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.StudentLoanAccounts = append(to.StudentLoanAccounts, nil)
		}
	}
	to.PlaidInstitutionId = m.PlaidInstitutionId
	to.LinkType = LinkType_name[int32(m.LinkType)]
	to.ErrorCode = m.ErrorCode
	to.UpdatedAt = m.UpdatedAt
	to.NewAccountsAvailable = m.NewAccountsAvailable
	to.ShouldBeUpdated = m.ShouldBeUpdated
	if posthook, ok := interface{}(m).(LinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LinkORM) ToPB(ctx context.Context) (Link, error) {
	to := Link{}
	var err error
	if prehook, ok := interface{}(m).(LinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PlaidSync != nil {
		tempPlaidSync, err := m.PlaidSync.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidSync = &tempPlaidSync
	}
	to.LinkStatus = LinkStatus(LinkStatus_value[m.LinkStatus])
	if m.PlaidLink != nil {
		tempPlaidLink, err := m.PlaidLink.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PlaidLink = &tempPlaidLink
	}
	to.PlaidNewAccountsAvailable = m.PlaidNewAccountsAvailable
	to.ExpirationDate = m.ExpirationDate
	to.InstitutionName = m.InstitutionName
	to.CustomInstitutionName = m.CustomInstitutionName
	to.Description = m.Description
	to.LastManualSync = m.LastManualSync
	to.LastSuccessfulUpdate = m.LastSuccessfulUpdate
	if m.Token != nil {
		tempToken, err := m.Token.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	for _, v := range m.BankAccounts {
		if v != nil {
			if tempBankAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.BankAccounts = append(to.BankAccounts, &tempBankAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.BankAccounts = append(to.BankAccounts, nil)
		}
	}
	for _, v := range m.InvestmentAccounts {
		if v != nil {
			if tempInvestmentAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestmentAccounts = append(to.InvestmentAccounts, &tempInvestmentAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentAccounts = append(to.InvestmentAccounts, nil)
		}
	}
	for _, v := range m.CreditAccounts {
		if v != nil {
			if tempCreditAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.CreditAccounts = append(to.CreditAccounts, &tempCreditAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.CreditAccounts = append(to.CreditAccounts, nil)
		}
	}
	for _, v := range m.MortgageAccounts {
		if v != nil {
			if tempMortgageAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.MortgageAccounts = append(to.MortgageAccounts, &tempMortgageAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.MortgageAccounts = append(to.MortgageAccounts, nil)
		}
	}
	for _, v := range m.StudentLoanAccounts {
		if v != nil {
			if tempStudentLoanAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.StudentLoanAccounts = append(to.StudentLoanAccounts, &tempStudentLoanAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.StudentLoanAccounts = append(to.StudentLoanAccounts, nil)
		}
	}
	to.PlaidInstitutionId = m.PlaidInstitutionId
	to.LinkType = LinkType(LinkType_value[m.LinkType])
	to.ErrorCode = m.ErrorCode
	to.UpdatedAt = m.UpdatedAt
	to.NewAccountsAvailable = m.NewAccountsAvailable
	to.ShouldBeUpdated = m.ShouldBeUpdated
	if posthook, ok := interface{}(m).(LinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Link the arg will be the target, the caller the one being converted from

// LinkBeforeToORM called before default ToORM code
type LinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *LinkORM) error
}

// LinkAfterToORM called after default ToORM code
type LinkWithAfterToORM interface {
	AfterToORM(context.Context, *LinkORM) error
}

// LinkBeforeToPB called before default ToPB code
type LinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *Link) error
}

// LinkAfterToPB called after default ToPB code
type LinkWithAfterToPB interface {
	AfterToPB(context.Context, *Link) error
}

type PlaidSyncORM struct {
	Added      int64
	Id         uint64
	LinkId     *uint64
	Modified   int64
	NextCursor string
	Removed    int64
	TimeStamp  string
	Trigger    string
}

// TableName overrides the default tablename generated by GORM
func (PlaidSyncORM) TableName() string {
	return "plaid_syncs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidSync) ToORM(ctx context.Context) (PlaidSyncORM, error) {
	to := PlaidSyncORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidSyncWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TimeStamp = m.TimeStamp
	to.Trigger = m.Trigger
	to.NextCursor = m.NextCursor
	to.Added = m.Added
	to.Removed = m.Removed
	to.Modified = m.Modified
	if posthook, ok := interface{}(m).(PlaidSyncWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidSyncORM) ToPB(ctx context.Context) (PlaidSync, error) {
	to := PlaidSync{}
	var err error
	if prehook, ok := interface{}(m).(PlaidSyncWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TimeStamp = m.TimeStamp
	to.Trigger = m.Trigger
	to.NextCursor = m.NextCursor
	to.Added = m.Added
	to.Removed = m.Removed
	to.Modified = m.Modified
	if posthook, ok := interface{}(m).(PlaidSyncWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidSync the arg will be the target, the caller the one being converted from

// PlaidSyncBeforeToORM called before default ToORM code
type PlaidSyncWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidSyncORM) error
}

// PlaidSyncAfterToORM called after default ToORM code
type PlaidSyncWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidSyncORM) error
}

// PlaidSyncBeforeToPB called before default ToPB code
type PlaidSyncWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidSync) error
}

// PlaidSyncAfterToPB called after default ToPB code
type PlaidSyncWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidSync) error
}

type TokenORM struct {
	AccessToken          string
	Id                   uint64
	ItemId               string
	KeyId                string
	LastMergeCreatedAt   *time.Time
	LinkId               *uint64
	MergeEndUserOriginId string
	MergeIntegrationSlug string
	Version              string
}

// TableName overrides the default tablename generated by GORM
func (TokenORM) TableName() string {
	return "tokens"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Token) ToORM(ctx context.Context) (TokenORM, error) {
	to := TokenORM{}
	var err error
	if prehook, ok := interface{}(m).(TokenWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ItemId = m.ItemId
	to.KeyId = m.KeyId
	to.AccessToken = m.AccessToken
	to.Version = m.Version
	to.MergeEndUserOriginId = m.MergeEndUserOriginId
	to.MergeIntegrationSlug = m.MergeIntegrationSlug
	if m.LastMergeCreatedAt != nil {
		t := m.LastMergeCreatedAt.AsTime()
		to.LastMergeCreatedAt = &t
	}
	if posthook, ok := interface{}(m).(TokenWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TokenORM) ToPB(ctx context.Context) (Token, error) {
	to := Token{}
	var err error
	if prehook, ok := interface{}(m).(TokenWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ItemId = m.ItemId
	to.KeyId = m.KeyId
	to.AccessToken = m.AccessToken
	to.Version = m.Version
	to.MergeEndUserOriginId = m.MergeEndUserOriginId
	to.MergeIntegrationSlug = m.MergeIntegrationSlug
	if m.LastMergeCreatedAt != nil {
		to.LastMergeCreatedAt = timestamppb.New(*m.LastMergeCreatedAt)
	}
	if posthook, ok := interface{}(m).(TokenWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Token the arg will be the target, the caller the one being converted from

// TokenBeforeToORM called before default ToORM code
type TokenWithBeforeToORM interface {
	BeforeToORM(context.Context, *TokenORM) error
}

// TokenAfterToORM called after default ToORM code
type TokenWithAfterToORM interface {
	AfterToORM(context.Context, *TokenORM) error
}

// TokenBeforeToPB called before default ToPB code
type TokenWithBeforeToPB interface {
	BeforeToPB(context.Context, *Token) error
}

// TokenAfterToPB called after default ToPB code
type TokenWithAfterToPB interface {
	AfterToPB(context.Context, *Token) error
}

type PlaidLinkORM struct {
	Id              uint64
	InstitutionId   string
	InstitutionName string
	ItemId          string
	LinkId          *uint64
	Products        pq.StringArray `gorm:"type:text[]"`
	UsePlaidSync    bool
	WebhookUrl      string
}

// TableName overrides the default tablename generated by GORM
func (PlaidLinkORM) TableName() string {
	return "plaid_links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidLink) ToORM(ctx context.Context) (PlaidLinkORM, error) {
	to := PlaidLinkORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidLinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Products != nil {
		to.Products = make(pq.StringArray, len(m.Products))
		copy(to.Products, m.Products)
	}
	to.WebhookUrl = m.WebhookUrl
	to.InstitutionId = m.InstitutionId
	to.InstitutionName = m.InstitutionName
	to.UsePlaidSync = m.UsePlaidSync
	to.ItemId = m.ItemId
	if posthook, ok := interface{}(m).(PlaidLinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidLinkORM) ToPB(ctx context.Context) (PlaidLink, error) {
	to := PlaidLink{}
	var err error
	if prehook, ok := interface{}(m).(PlaidLinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Products != nil {
		to.Products = make(pq.StringArray, len(m.Products))
		copy(to.Products, m.Products)
	}
	to.WebhookUrl = m.WebhookUrl
	to.InstitutionId = m.InstitutionId
	to.InstitutionName = m.InstitutionName
	to.UsePlaidSync = m.UsePlaidSync
	to.ItemId = m.ItemId
	if posthook, ok := interface{}(m).(PlaidLinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidLink the arg will be the target, the caller the one being converted from

// PlaidLinkBeforeToORM called before default ToORM code
type PlaidLinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidLinkORM) error
}

// PlaidLinkAfterToORM called after default ToORM code
type PlaidLinkWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidLinkORM) error
}

// PlaidLinkBeforeToPB called before default ToPB code
type PlaidLinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidLink) error
}

// PlaidLinkAfterToPB called after default ToPB code
type PlaidLinkWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidLink) error
}

type StudentLoanAccountORM struct {
	DisbursementDates                  pq.StringArray `gorm:"type:text[]"`
	ExpectedPayoffDate                 string
	Guarantor                          string
	Id                                 uint64
	InterestRatePercentage             float64
	IsOverdue                          bool
	LastPaymentAmount                  float64
	LastPaymentDate                    string
	LastStatementIssueDate             string
	LinkId                             *uint64
	LoanEndDate                        string
	LoanName                           string
	LoanType                           string
	MinimumPaymentAmount               float64
	Name                               string
	NextPaymentDueDate                 string
	OriginationDate                    string
	OriginationPrincipalAmount         float64
	OutstandingInterestAmount          float64
	PaymentReferenceNumber             string
	PlaidAccountId                     string
	PslfStatusEstimatedEligibilityDate string
	PslfStatusPaymentsMade             int32
	PslfStatusPaymentsRemaining        int32
	RepaymentPlanDescription           string
	RepaymentPlanType                  string
	SequenceNumber                     string
	ServicerAddressCity                string
	ServicerAddressCountry             string
	ServicerAddressPostalCode          string
	ServicerAddressRegion              string
	ServicerAddressState               string
	ServicerAddressStreet              string
	Status                             string
	UserId                             uint64
	YtdInterestPaid                    float64
	YtdPrincipalPaid                   float64
}

// TableName overrides the default tablename generated by GORM
func (StudentLoanAccountORM) TableName() string {
	return "student_loan_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StudentLoanAccount) ToORM(ctx context.Context) (StudentLoanAccountORM, error) {
	to := StudentLoanAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(StudentLoanAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	if m.DisbursementDates != nil {
		to.DisbursementDates = make(pq.StringArray, len(m.DisbursementDates))
		copy(to.DisbursementDates, m.DisbursementDates)
	}
	to.ExpectedPayoffDate = m.ExpectedPayoffDate
	to.Guarantor = m.Guarantor
	to.InterestRatePercentage = m.InterestRatePercentage
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.LoanName = m.LoanName
	to.LoanEndDate = m.LoanEndDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.OutstandingInterestAmount = m.OutstandingInterestAmount
	to.PaymentReferenceNumber = m.PaymentReferenceNumber
	to.SequenceNumber = m.SequenceNumber
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.LoanType = m.LoanType
	to.PslfStatusEstimatedEligibilityDate = m.PslfStatusEstimatedEligibilityDate
	to.PslfStatusPaymentsMade = m.PslfStatusPaymentsMade
	to.PslfStatusPaymentsRemaining = m.PslfStatusPaymentsRemaining
	to.RepaymentPlanType = m.RepaymentPlanType
	to.RepaymentPlanDescription = m.RepaymentPlanDescription
	to.ServicerAddressCity = m.ServicerAddressCity
	to.ServicerAddressPostalCode = m.ServicerAddressPostalCode
	to.ServicerAddressState = m.ServicerAddressState
	to.ServicerAddressStreet = m.ServicerAddressStreet
	to.ServicerAddressRegion = m.ServicerAddressRegion
	to.ServicerAddressCountry = m.ServicerAddressCountry
	to.UserId = m.UserId
	to.Name = m.Name
	to.Status = BankAccountStatus_name[int32(m.Status)]
	if posthook, ok := interface{}(m).(StudentLoanAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StudentLoanAccountORM) ToPB(ctx context.Context) (StudentLoanAccount, error) {
	to := StudentLoanAccount{}
	var err error
	if prehook, ok := interface{}(m).(StudentLoanAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	if m.DisbursementDates != nil {
		to.DisbursementDates = make(pq.StringArray, len(m.DisbursementDates))
		copy(to.DisbursementDates, m.DisbursementDates)
	}
	to.ExpectedPayoffDate = m.ExpectedPayoffDate
	to.Guarantor = m.Guarantor
	to.InterestRatePercentage = m.InterestRatePercentage
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.LoanName = m.LoanName
	to.LoanEndDate = m.LoanEndDate
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.OutstandingInterestAmount = m.OutstandingInterestAmount
	to.PaymentReferenceNumber = m.PaymentReferenceNumber
	to.SequenceNumber = m.SequenceNumber
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.LoanType = m.LoanType
	to.PslfStatusEstimatedEligibilityDate = m.PslfStatusEstimatedEligibilityDate
	to.PslfStatusPaymentsMade = m.PslfStatusPaymentsMade
	to.PslfStatusPaymentsRemaining = m.PslfStatusPaymentsRemaining
	to.RepaymentPlanType = m.RepaymentPlanType
	to.RepaymentPlanDescription = m.RepaymentPlanDescription
	to.ServicerAddressCity = m.ServicerAddressCity
	to.ServicerAddressPostalCode = m.ServicerAddressPostalCode
	to.ServicerAddressState = m.ServicerAddressState
	to.ServicerAddressStreet = m.ServicerAddressStreet
	to.ServicerAddressRegion = m.ServicerAddressRegion
	to.ServicerAddressCountry = m.ServicerAddressCountry
	to.UserId = m.UserId
	to.Name = m.Name
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	if posthook, ok := interface{}(m).(StudentLoanAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StudentLoanAccount the arg will be the target, the caller the one being converted from

// StudentLoanAccountBeforeToORM called before default ToORM code
type StudentLoanAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *StudentLoanAccountORM) error
}

// StudentLoanAccountAfterToORM called after default ToORM code
type StudentLoanAccountWithAfterToORM interface {
	AfterToORM(context.Context, *StudentLoanAccountORM) error
}

// StudentLoanAccountBeforeToPB called before default ToPB code
type StudentLoanAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *StudentLoanAccount) error
}

// StudentLoanAccountAfterToPB called after default ToPB code
type StudentLoanAccountWithAfterToPB interface {
	AfterToPB(context.Context, *StudentLoanAccount) error
}

type CreditAccountORM struct {
	Aprs                   []*AprORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Balance                float32
	BalanceLimit           uint64
	CurrentFunds           float64
	Id                     uint64
	IsOverdue              bool
	LastPaymentAmount      float64
	LastPaymentDate        string
	LastStatementBalance   float64
	LastStatementIssueDate string
	LinkId                 *uint64
	MinimumAmountDueDate   float64
	MinimumPaymentAmount   float64
	Name                   string
	NextPaymentDate        string
	NextPaymentDueDate     string
	Number                 string
	PlaidAccountId         string
	Pockets                []*PocketORM                           `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	RecurringTransactions  []*PlaidAccountRecurringTransactionORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Status                 string
	Subtype                string
	Transactions           []*PlaidAccountTransactionORM `gorm:"foreignkey:CreditAccountId;association_foreignkey:Id;preload:true"`
	Type                   string
	UserId                 uint64
}

// TableName overrides the default tablename generated by GORM
func (CreditAccountORM) TableName() string {
	return "credit_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditAccount) ToORM(ctx context.Context) (CreditAccountORM, error) {
	to := CreditAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.MinimumAmountDueDate = m.MinimumAmountDueDate
	to.NextPaymentDate = m.NextPaymentDate
	for _, v := range m.Aprs {
		if v != nil {
			if tempAprs, cErr := v.ToORM(ctx); cErr == nil {
				to.Aprs = append(to.Aprs, &tempAprs)
			} else {
				return to, cErr
			}
		} else {
			to.Aprs = append(to.Aprs, nil)
		}
	}
	to.LastStatementBalance = m.LastStatementBalance
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.Status = BankAccountStatus_name[int32(m.Status)]
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	for _, v := range m.Pockets {
		if v != nil {
			if tempPockets, cErr := v.ToORM(ctx); cErr == nil {
				to.Pockets = append(to.Pockets, &tempPockets)
			} else {
				return to, cErr
			}
		} else {
			to.Pockets = append(to.Pockets, nil)
		}
	}
	if posthook, ok := interface{}(m).(CreditAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditAccountORM) ToPB(ctx context.Context) (CreditAccount, error) {
	to := CreditAccount{}
	var err error
	if prehook, ok := interface{}(m).(CreditAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.IsOverdue = m.IsOverdue
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LastStatementIssueDate = m.LastStatementIssueDate
	to.MinimumAmountDueDate = m.MinimumAmountDueDate
	to.NextPaymentDate = m.NextPaymentDate
	for _, v := range m.Aprs {
		if v != nil {
			if tempAprs, cErr := v.ToPB(ctx); cErr == nil {
				to.Aprs = append(to.Aprs, &tempAprs)
			} else {
				return to, cErr
			}
		} else {
			to.Aprs = append(to.Aprs, nil)
		}
	}
	to.LastStatementBalance = m.LastStatementBalance
	to.MinimumPaymentAmount = m.MinimumPaymentAmount
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	for _, v := range m.Pockets {
		if v != nil {
			if tempPockets, cErr := v.ToPB(ctx); cErr == nil {
				to.Pockets = append(to.Pockets, &tempPockets)
			} else {
				return to, cErr
			}
		} else {
			to.Pockets = append(to.Pockets, nil)
		}
	}
	if posthook, ok := interface{}(m).(CreditAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditAccount the arg will be the target, the caller the one being converted from

// CreditAccountBeforeToORM called before default ToORM code
type CreditAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditAccountORM) error
}

// CreditAccountAfterToORM called after default ToORM code
type CreditAccountWithAfterToORM interface {
	AfterToORM(context.Context, *CreditAccountORM) error
}

// CreditAccountBeforeToPB called before default ToPB code
type CreditAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditAccount) error
}

// CreditAccountAfterToPB called after default ToPB code
type CreditAccountWithAfterToPB interface {
	AfterToPB(context.Context, *CreditAccount) error
}

type MortgageAccountORM struct {
	AccountNumber               string
	CurrentLateFee              float64
	EscrowBalance               float64
	HasPmi                      bool
	HasPrepaymentPenalty        bool
	Id                          uint64
	InterestRatePercentage      float64
	InterestRateType            string
	LastPaymentAmount           float64
	LastPaymentDate             string
	LinkId                      *uint64
	LoanTerm                    string
	LoanTypeDescription         string
	MaturityDate                string
	NextMonthlyPayment          float64
	NextPaymentDueDate          string
	OriginalPrincipalBalance    float64
	OriginalPropertyValue       float64
	OriginationDate             string
	OriginationPrincipalAmount  float64
	OutstandingPrincipalBalance float64
	PastDueAmount               float64
	PaymentAmount               float64
	PaymentDate                 string
	PlaidAccountId              string
	PropertyAddressCity         string
	PropertyAddressPostalCode   string
	PropertyAddressState        string
	PropertyAddressStreet       string
	PropertyCountry             string
	PropertyRegion              string
	Status                      string
	YtdInterestPaid             float64
	YtdPrincipalPaid            float64
}

// TableName overrides the default tablename generated by GORM
func (MortgageAccountORM) TableName() string {
	return "mortgage_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MortgageAccount) ToORM(ctx context.Context) (MortgageAccountORM, error) {
	to := MortgageAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(MortgageAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	to.AccountNumber = m.AccountNumber
	to.CurrentLateFee = m.CurrentLateFee
	to.EscrowBalance = m.EscrowBalance
	to.HasPmi = m.HasPmi
	to.HasPrepaymentPenalty = m.HasPrepaymentPenalty
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LoanTerm = m.LoanTerm
	to.LoanTypeDescription = m.LoanTypeDescription
	to.MaturityDate = m.MaturityDate
	to.NextMonthlyPayment = m.NextMonthlyPayment
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginalPrincipalBalance = m.OriginalPrincipalBalance
	to.OriginalPropertyValue = m.OriginalPropertyValue
	to.OutstandingPrincipalBalance = m.OutstandingPrincipalBalance
	to.PaymentAmount = m.PaymentAmount
	to.PaymentDate = m.PaymentDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.PastDueAmount = m.PastDueAmount
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.PropertyAddressCity = m.PropertyAddressCity
	to.PropertyAddressState = m.PropertyAddressState
	to.PropertyAddressStreet = m.PropertyAddressStreet
	to.PropertyAddressPostalCode = m.PropertyAddressPostalCode
	to.PropertyRegion = m.PropertyRegion
	to.PropertyCountry = m.PropertyCountry
	to.InterestRatePercentage = m.InterestRatePercentage
	to.InterestRateType = m.InterestRateType
	to.Status = BankAccountStatus_name[int32(m.Status)]
	if posthook, ok := interface{}(m).(MortgageAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MortgageAccountORM) ToPB(ctx context.Context) (MortgageAccount, error) {
	to := MortgageAccount{}
	var err error
	if prehook, ok := interface{}(m).(MortgageAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PlaidAccountId = m.PlaidAccountId
	to.AccountNumber = m.AccountNumber
	to.CurrentLateFee = m.CurrentLateFee
	to.EscrowBalance = m.EscrowBalance
	to.HasPmi = m.HasPmi
	to.HasPrepaymentPenalty = m.HasPrepaymentPenalty
	to.LastPaymentAmount = m.LastPaymentAmount
	to.LastPaymentDate = m.LastPaymentDate
	to.LoanTerm = m.LoanTerm
	to.LoanTypeDescription = m.LoanTypeDescription
	to.MaturityDate = m.MaturityDate
	to.NextMonthlyPayment = m.NextMonthlyPayment
	to.NextPaymentDueDate = m.NextPaymentDueDate
	to.OriginalPrincipalBalance = m.OriginalPrincipalBalance
	to.OriginalPropertyValue = m.OriginalPropertyValue
	to.OutstandingPrincipalBalance = m.OutstandingPrincipalBalance
	to.PaymentAmount = m.PaymentAmount
	to.PaymentDate = m.PaymentDate
	to.OriginationDate = m.OriginationDate
	to.OriginationPrincipalAmount = m.OriginationPrincipalAmount
	to.PastDueAmount = m.PastDueAmount
	to.YtdInterestPaid = m.YtdInterestPaid
	to.YtdPrincipalPaid = m.YtdPrincipalPaid
	to.PropertyAddressCity = m.PropertyAddressCity
	to.PropertyAddressState = m.PropertyAddressState
	to.PropertyAddressStreet = m.PropertyAddressStreet
	to.PropertyAddressPostalCode = m.PropertyAddressPostalCode
	to.PropertyRegion = m.PropertyRegion
	to.PropertyCountry = m.PropertyCountry
	to.InterestRatePercentage = m.InterestRatePercentage
	to.InterestRateType = m.InterestRateType
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	if posthook, ok := interface{}(m).(MortgageAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MortgageAccount the arg will be the target, the caller the one being converted from

// MortgageAccountBeforeToORM called before default ToORM code
type MortgageAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *MortgageAccountORM) error
}

// MortgageAccountAfterToORM called after default ToORM code
type MortgageAccountWithAfterToORM interface {
	AfterToORM(context.Context, *MortgageAccountORM) error
}

// MortgageAccountBeforeToPB called before default ToPB code
type MortgageAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *MortgageAccount) error
}

// MortgageAccountAfterToPB called after default ToPB code
type MortgageAccountWithAfterToPB interface {
	AfterToPB(context.Context, *MortgageAccount) error
}

type InvestmentAccountORM struct {
	Balance        float32
	BalanceLimit   uint64
	CurrentFunds   float64
	Holdings       []*InvesmentHoldingORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Id             uint64
	LinkId         *uint64
	Name           string
	Number         string
	PlaidAccountId string
	Securities     []*InvestmentSecurityORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Status         string
	Subtype        string
	Transactions   []*PlaidAccountInvestmentTransactionORM `gorm:"foreignkey:InvestmentAccountId;association_foreignkey:Id;preload:true"`
	Type           string
	UserId         uint64
}

// TableName overrides the default tablename generated by GORM
func (InvestmentAccountORM) TableName() string {
	return "investment_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentAccount) ToORM(ctx context.Context) (InvestmentAccountORM, error) {
	to := InvestmentAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	for _, v := range m.Holdings {
		if v != nil {
			if tempHoldings, cErr := v.ToORM(ctx); cErr == nil {
				to.Holdings = append(to.Holdings, &tempHoldings)
			} else {
				return to, cErr
			}
		} else {
			to.Holdings = append(to.Holdings, nil)
		}
	}
	for _, v := range m.Securities {
		if v != nil {
			if tempSecurities, cErr := v.ToORM(ctx); cErr == nil {
				to.Securities = append(to.Securities, &tempSecurities)
			} else {
				return to, cErr
			}
		} else {
			to.Securities = append(to.Securities, nil)
		}
	}
	to.Status = BankAccountStatus_name[int32(m.Status)]
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestmentAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentAccountORM) ToPB(ctx context.Context) (InvestmentAccount, error) {
	to := InvestmentAccount{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = m.Type
	to.Balance = m.Balance
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	for _, v := range m.Holdings {
		if v != nil {
			if tempHoldings, cErr := v.ToPB(ctx); cErr == nil {
				to.Holdings = append(to.Holdings, &tempHoldings)
			} else {
				return to, cErr
			}
		} else {
			to.Holdings = append(to.Holdings, nil)
		}
	}
	for _, v := range m.Securities {
		if v != nil {
			if tempSecurities, cErr := v.ToPB(ctx); cErr == nil {
				to.Securities = append(to.Securities, &tempSecurities)
			} else {
				return to, cErr
			}
		} else {
			to.Securities = append(to.Securities, nil)
		}
	}
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestmentAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentAccount the arg will be the target, the caller the one being converted from

// InvestmentAccountBeforeToORM called before default ToORM code
type InvestmentAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentAccountORM) error
}

// InvestmentAccountAfterToORM called after default ToORM code
type InvestmentAccountWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentAccountORM) error
}

// InvestmentAccountBeforeToPB called before default ToPB code
type InvestmentAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentAccount) error
}

// InvestmentAccountAfterToPB called after default ToPB code
type InvestmentAccountWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentAccount) error
}

type BankAccountORM struct {
	Balance               float32
	BalanceLimit          uint64
	Currency              string
	CurrentFunds          float64
	Id                    uint64
	LinkId                *uint64
	Name                  string
	Number                string
	PlaidAccountId        string
	Pockets               []*PocketORM                           `gorm:"foreignkey:BankAccountId;association_foreignkey:Id;preload:true"`
	RecurringTransactions []*PlaidAccountRecurringTransactionORM `gorm:"foreignkey:BankAccountId;association_foreignkey:Id;preload:true"`
	Status                string
	Subtype               string
	Transactions          []*PlaidAccountTransactionORM `gorm:"foreignkey:BankAccountId;association_foreignkey:Id;preload:true"`
	Type                  string
	UserId                uint64
}

// TableName overrides the default tablename generated by GORM
func (BankAccountORM) TableName() string {
	return "bank_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BankAccount) ToORM(ctx context.Context) (BankAccountORM, error) {
	to := BankAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BankAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = BankAccountType_name[int32(m.Type)]
	to.Balance = m.Balance
	to.Currency = m.Currency
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	for _, v := range m.Pockets {
		if v != nil {
			if tempPockets, cErr := v.ToORM(ctx); cErr == nil {
				to.Pockets = append(to.Pockets, &tempPockets)
			} else {
				return to, cErr
			}
		} else {
			to.Pockets = append(to.Pockets, nil)
		}
	}
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.Status = BankAccountStatus_name[int32(m.Status)]
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(BankAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BankAccountORM) ToPB(ctx context.Context) (BankAccount, error) {
	to := BankAccount{}
	var err error
	if prehook, ok := interface{}(m).(BankAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Number = m.Number
	to.Type = BankAccountType(BankAccountType_value[m.Type])
	to.Balance = m.Balance
	to.Currency = m.Currency
	to.CurrentFunds = m.CurrentFunds
	to.BalanceLimit = m.BalanceLimit
	for _, v := range m.Pockets {
		if v != nil {
			if tempPockets, cErr := v.ToPB(ctx); cErr == nil {
				to.Pockets = append(to.Pockets, &tempPockets)
			} else {
				return to, cErr
			}
		} else {
			to.Pockets = append(to.Pockets, nil)
		}
	}
	to.PlaidAccountId = m.PlaidAccountId
	to.Subtype = m.Subtype
	to.Status = BankAccountStatus(BankAccountStatus_value[m.Status])
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.RecurringTransactions {
		if v != nil {
			if tempRecurringTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.RecurringTransactions = append(to.RecurringTransactions, &tempRecurringTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.RecurringTransactions = append(to.RecurringTransactions, nil)
		}
	}
	if posthook, ok := interface{}(m).(BankAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BankAccount the arg will be the target, the caller the one being converted from

// BankAccountBeforeToORM called before default ToORM code
type BankAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BankAccountORM) error
}

// BankAccountAfterToORM called after default ToORM code
type BankAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BankAccountORM) error
}

// BankAccountBeforeToPB called before default ToPB code
type BankAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BankAccount) error
}

// BankAccountAfterToPB called after default ToPB code
type BankAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BankAccount) error
}

type PocketORM struct {
	BankAccountId   *uint64
	CreditAccountId *uint64
	Goals           []*SmartGoalORM `gorm:"foreignkey:PocketId;association_foreignkey:Id;preload:true"`
	Id              uint64
	Tags            pq.StringArray `gorm:"type:text[]"`
	Type            string
}

// TableName overrides the default tablename generated by GORM
func (PocketORM) TableName() string {
	return "pockets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Pocket) ToORM(ctx context.Context) (PocketORM, error) {
	to := PocketORM{}
	var err error
	if prehook, ok := interface{}(m).(PocketWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Goals {
		if v != nil {
			if tempGoals, cErr := v.ToORM(ctx); cErr == nil {
				to.Goals = append(to.Goals, &tempGoals)
			} else {
				return to, cErr
			}
		} else {
			to.Goals = append(to.Goals, nil)
		}
	}
	to.Type = PocketType_name[int32(m.Type)]
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if posthook, ok := interface{}(m).(PocketWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PocketORM) ToPB(ctx context.Context) (Pocket, error) {
	to := Pocket{}
	var err error
	if prehook, ok := interface{}(m).(PocketWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Goals {
		if v != nil {
			if tempGoals, cErr := v.ToPB(ctx); cErr == nil {
				to.Goals = append(to.Goals, &tempGoals)
			} else {
				return to, cErr
			}
		} else {
			to.Goals = append(to.Goals, nil)
		}
	}
	to.Type = PocketType(PocketType_value[m.Type])
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if posthook, ok := interface{}(m).(PocketWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Pocket the arg will be the target, the caller the one being converted from

// PocketBeforeToORM called before default ToORM code
type PocketWithBeforeToORM interface {
	BeforeToORM(context.Context, *PocketORM) error
}

// PocketAfterToORM called after default ToORM code
type PocketWithAfterToORM interface {
	AfterToORM(context.Context, *PocketORM) error
}

// PocketBeforeToPB called before default ToPB code
type PocketWithBeforeToPB interface {
	BeforeToPB(context.Context, *Pocket) error
}

// PocketAfterToPB called after default ToPB code
type PocketWithAfterToPB interface {
	AfterToPB(context.Context, *Pocket) error
}

type SmartGoalORM struct {
	CurrentAmount string
	Description   string
	Duration      string
	EndDate       string
	Forecasts     *ForecastORM `gorm:"foreignkey:SmartGoalId;association_foreignkey:Id;preload:true"`
	GoalType      string
	Id            uint64
	IsCompleted   bool
	Milestones    []*MilestoneORM `gorm:"foreignkey:SmartGoalId;association_foreignkey:Id;preload:true"`
	Name          string
	Notes         []*SmartNoteORM `gorm:"foreignkey:SmartGoalId;association_foreignkey:Id;preload:true"`
	PocketId      *uint64
	StartDate     string
	TargetAmount  string
	UserId        uint64
}

// TableName overrides the default tablename generated by GORM
func (SmartGoalORM) TableName() string {
	return "smart_goals"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SmartGoal) ToORM(ctx context.Context) (SmartGoalORM, error) {
	to := SmartGoalORM{}
	var err error
	if prehook, ok := interface{}(m).(SmartGoalWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Description = m.Description
	to.IsCompleted = m.IsCompleted
	to.GoalType = GoalType_name[int32(m.GoalType)]
	to.Duration = m.Duration
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	to.TargetAmount = m.TargetAmount
	to.CurrentAmount = m.CurrentAmount
	for _, v := range m.Milestones {
		if v != nil {
			if tempMilestones, cErr := v.ToORM(ctx); cErr == nil {
				to.Milestones = append(to.Milestones, &tempMilestones)
			} else {
				return to, cErr
			}
		} else {
			to.Milestones = append(to.Milestones, nil)
		}
	}
	if m.Forecasts != nil {
		tempForecasts, err := m.Forecasts.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Forecasts = &tempForecasts
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(SmartGoalWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SmartGoalORM) ToPB(ctx context.Context) (SmartGoal, error) {
	to := SmartGoal{}
	var err error
	if prehook, ok := interface{}(m).(SmartGoalWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Name = m.Name
	to.Description = m.Description
	to.IsCompleted = m.IsCompleted
	to.GoalType = GoalType(GoalType_value[m.GoalType])
	to.Duration = m.Duration
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	to.TargetAmount = m.TargetAmount
	to.CurrentAmount = m.CurrentAmount
	for _, v := range m.Milestones {
		if v != nil {
			if tempMilestones, cErr := v.ToPB(ctx); cErr == nil {
				to.Milestones = append(to.Milestones, &tempMilestones)
			} else {
				return to, cErr
			}
		} else {
			to.Milestones = append(to.Milestones, nil)
		}
	}
	if m.Forecasts != nil {
		tempForecasts, err := m.Forecasts.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Forecasts = &tempForecasts
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(SmartGoalWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SmartGoal the arg will be the target, the caller the one being converted from

// SmartGoalBeforeToORM called before default ToORM code
type SmartGoalWithBeforeToORM interface {
	BeforeToORM(context.Context, *SmartGoalORM) error
}

// SmartGoalAfterToORM called after default ToORM code
type SmartGoalWithAfterToORM interface {
	AfterToORM(context.Context, *SmartGoalORM) error
}

// SmartGoalBeforeToPB called before default ToPB code
type SmartGoalWithBeforeToPB interface {
	BeforeToPB(context.Context, *SmartGoal) error
}

// SmartGoalAfterToPB called after default ToPB code
type SmartGoalWithAfterToPB interface {
	AfterToPB(context.Context, *SmartGoal) error
}

type SmartNoteORM struct {
	Content                             string
	CreatedAt                           *time.Time
	Id                                  uint64
	PlaidAccountInvestmentTransactionId *uint64
	PlaidAccountRecurringTransactionId  *uint64
	PlaidAccountTransactionId           *uint64
	SmartGoalId                         *uint64
	UpdatedAt                           *time.Time
	UserId                              uint64
}

// TableName overrides the default tablename generated by GORM
func (SmartNoteORM) TableName() string {
	return "smart_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SmartNote) ToORM(ctx context.Context) (SmartNoteORM, error) {
	to := SmartNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(SmartNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Content = m.Content
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if posthook, ok := interface{}(m).(SmartNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SmartNoteORM) ToPB(ctx context.Context) (SmartNote, error) {
	to := SmartNote{}
	var err error
	if prehook, ok := interface{}(m).(SmartNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.Content = m.Content
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if posthook, ok := interface{}(m).(SmartNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SmartNote the arg will be the target, the caller the one being converted from

// SmartNoteBeforeToORM called before default ToORM code
type SmartNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *SmartNoteORM) error
}

// SmartNoteAfterToORM called after default ToORM code
type SmartNoteWithAfterToORM interface {
	AfterToORM(context.Context, *SmartNoteORM) error
}

// SmartNoteBeforeToPB called before default ToPB code
type SmartNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *SmartNote) error
}

// SmartNoteAfterToPB called after default ToPB code
type SmartNoteWithAfterToPB interface {
	AfterToPB(context.Context, *SmartNote) error
}

type ForecastORM struct {
	ForecastedAmount         string
	ForecastedCompletionDate string
	Id                       uint64
	SmartGoalId              *uint64
	VarianceAmount           string
}

// TableName overrides the default tablename generated by GORM
func (ForecastORM) TableName() string {
	return "forecasts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Forecast) ToORM(ctx context.Context) (ForecastORM, error) {
	to := ForecastORM{}
	var err error
	if prehook, ok := interface{}(m).(ForecastWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ForecastedAmount = m.ForecastedAmount
	to.ForecastedCompletionDate = m.ForecastedCompletionDate
	to.VarianceAmount = m.VarianceAmount
	if posthook, ok := interface{}(m).(ForecastWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ForecastORM) ToPB(ctx context.Context) (Forecast, error) {
	to := Forecast{}
	var err error
	if prehook, ok := interface{}(m).(ForecastWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ForecastedAmount = m.ForecastedAmount
	to.ForecastedCompletionDate = m.ForecastedCompletionDate
	to.VarianceAmount = m.VarianceAmount
	if posthook, ok := interface{}(m).(ForecastWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Forecast the arg will be the target, the caller the one being converted from

// ForecastBeforeToORM called before default ToORM code
type ForecastWithBeforeToORM interface {
	BeforeToORM(context.Context, *ForecastORM) error
}

// ForecastAfterToORM called after default ToORM code
type ForecastWithAfterToORM interface {
	AfterToORM(context.Context, *ForecastORM) error
}

// ForecastBeforeToPB called before default ToPB code
type ForecastWithBeforeToPB interface {
	BeforeToPB(context.Context, *Forecast) error
}

// ForecastAfterToPB called after default ToPB code
type ForecastWithAfterToPB interface {
	AfterToPB(context.Context, *Forecast) error
}

type MilestoneORM struct {
	Budget       *BudgetORM `gorm:"foreignkey:MilestoneId;association_foreignkey:Id"`
	Description  string
	Id           uint64
	IsCompleted  bool
	Name         string
	SmartGoalId  *uint64
	TargetAmount string
	TargetDate   string
}

// TableName overrides the default tablename generated by GORM
func (MilestoneORM) TableName() string {
	return "milestones"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Milestone) ToORM(ctx context.Context) (MilestoneORM, error) {
	to := MilestoneORM{}
	var err error
	if prehook, ok := interface{}(m).(MilestoneWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.TargetDate = m.TargetDate
	to.TargetAmount = m.TargetAmount
	to.IsCompleted = m.IsCompleted
	if m.Budget != nil {
		tempBudget, err := m.Budget.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Budget = &tempBudget
	}
	if posthook, ok := interface{}(m).(MilestoneWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MilestoneORM) ToPB(ctx context.Context) (Milestone, error) {
	to := Milestone{}
	var err error
	if prehook, ok := interface{}(m).(MilestoneWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.TargetDate = m.TargetDate
	to.TargetAmount = m.TargetAmount
	to.IsCompleted = m.IsCompleted
	if m.Budget != nil {
		tempBudget, err := m.Budget.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Budget = &tempBudget
	}
	if posthook, ok := interface{}(m).(MilestoneWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Milestone the arg will be the target, the caller the one being converted from

// MilestoneBeforeToORM called before default ToORM code
type MilestoneWithBeforeToORM interface {
	BeforeToORM(context.Context, *MilestoneORM) error
}

// MilestoneAfterToORM called after default ToORM code
type MilestoneWithAfterToORM interface {
	AfterToORM(context.Context, *MilestoneORM) error
}

// MilestoneBeforeToPB called before default ToPB code
type MilestoneWithBeforeToPB interface {
	BeforeToPB(context.Context, *Milestone) error
}

// MilestoneAfterToPB called after default ToPB code
type MilestoneWithAfterToPB interface {
	AfterToPB(context.Context, *Milestone) error
}

type BudgetORM struct {
	Category    *CategoryORM `gorm:"foreignkey:BudgetId;association_foreignkey:Id;preload:true"`
	Description string
	EndDate     string
	Id          uint64
	MilestoneId *uint64
	Name        string
	StartDate   string
}

// TableName overrides the default tablename generated by GORM
func (BudgetORM) TableName() string {
	return "budgets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Budget) ToORM(ctx context.Context) (BudgetORM, error) {
	to := BudgetORM{}
	var err error
	if prehook, ok := interface{}(m).(BudgetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	if m.Category != nil {
		tempCategory, err := m.Category.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Category = &tempCategory
	}
	if posthook, ok := interface{}(m).(BudgetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BudgetORM) ToPB(ctx context.Context) (Budget, error) {
	to := Budget{}
	var err error
	if prehook, ok := interface{}(m).(BudgetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	if m.Category != nil {
		tempCategory, err := m.Category.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Category = &tempCategory
	}
	if posthook, ok := interface{}(m).(BudgetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Budget the arg will be the target, the caller the one being converted from

// BudgetBeforeToORM called before default ToORM code
type BudgetWithBeforeToORM interface {
	BeforeToORM(context.Context, *BudgetORM) error
}

// BudgetAfterToORM called after default ToORM code
type BudgetWithAfterToORM interface {
	AfterToORM(context.Context, *BudgetORM) error
}

// BudgetBeforeToPB called before default ToPB code
type BudgetWithBeforeToPB interface {
	BeforeToPB(context.Context, *Budget) error
}

// BudgetAfterToPB called after default ToPB code
type BudgetWithAfterToPB interface {
	AfterToPB(context.Context, *Budget) error
}

type CategoryORM struct {
	BudgetId      *uint64
	Description   string
	Id            uint64
	Name          string
	Subcategories pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (CategoryORM) TableName() string {
	return "categories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Category) ToORM(ctx context.Context) (CategoryORM, error) {
	to := CategoryORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if m.Subcategories != nil {
		to.Subcategories = make(pq.StringArray, len(m.Subcategories))
		copy(to.Subcategories, m.Subcategories)
	}
	if posthook, ok := interface{}(m).(CategoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryORM) ToPB(ctx context.Context) (Category, error) {
	to := Category{}
	var err error
	if prehook, ok := interface{}(m).(CategoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if m.Subcategories != nil {
		to.Subcategories = make(pq.StringArray, len(m.Subcategories))
		copy(to.Subcategories, m.Subcategories)
	}
	if posthook, ok := interface{}(m).(CategoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Category the arg will be the target, the caller the one being converted from

// CategoryBeforeToORM called before default ToORM code
type CategoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryORM) error
}

// CategoryAfterToORM called after default ToORM code
type CategoryWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryORM) error
}

// CategoryBeforeToPB called before default ToPB code
type CategoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *Category) error
}

// CategoryAfterToPB called after default ToPB code
type CategoryWithAfterToPB interface {
	AfterToPB(context.Context, *Category) error
}

type InvesmentHoldingORM struct {
	CostBasis                float64
	Id                       uint64
	InstitutionPrice         float64
	InstitutionPriceAsOf     string
	InstitutionPriceDatetime string
	InstitutionValue         float64
	InvestmentAccountId      *uint64
	IsoCurrencyCode          string
	Name                     string
	PlaidAccountId           string
	Quantity                 float64
	SecurityId               string
	UnofficialCurrencyCode   string
}

// TableName overrides the default tablename generated by GORM
func (InvesmentHoldingORM) TableName() string {
	return "invesment_holdings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvesmentHolding) ToORM(ctx context.Context) (InvesmentHoldingORM, error) {
	to := InvesmentHoldingORM{}
	var err error
	if prehook, ok := interface{}(m).(InvesmentHoldingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.PlaidAccountId = m.PlaidAccountId
	to.CostBasis = m.CostBasis
	to.InstitutionPrice = m.InstitutionPrice
	to.InstitutionPriceAsOf = m.InstitutionPriceAsOf
	to.InstitutionPriceDatetime = m.InstitutionPriceDatetime
	to.InstitutionValue = m.InstitutionValue
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Quantity = m.Quantity
	to.SecurityId = m.SecurityId
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	if posthook, ok := interface{}(m).(InvesmentHoldingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvesmentHoldingORM) ToPB(ctx context.Context) (InvesmentHolding, error) {
	to := InvesmentHolding{}
	var err error
	if prehook, ok := interface{}(m).(InvesmentHoldingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.PlaidAccountId = m.PlaidAccountId
	to.CostBasis = m.CostBasis
	to.InstitutionPrice = m.InstitutionPrice
	to.InstitutionPriceAsOf = m.InstitutionPriceAsOf
	to.InstitutionPriceDatetime = m.InstitutionPriceDatetime
	to.InstitutionValue = m.InstitutionValue
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Quantity = m.Quantity
	to.SecurityId = m.SecurityId
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	if posthook, ok := interface{}(m).(InvesmentHoldingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvesmentHolding the arg will be the target, the caller the one being converted from

// InvesmentHoldingBeforeToORM called before default ToORM code
type InvesmentHoldingWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvesmentHoldingORM) error
}

// InvesmentHoldingAfterToORM called after default ToORM code
type InvesmentHoldingWithAfterToORM interface {
	AfterToORM(context.Context, *InvesmentHoldingORM) error
}

// InvesmentHoldingBeforeToPB called before default ToPB code
type InvesmentHoldingWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvesmentHolding) error
}

// InvesmentHoldingAfterToPB called after default ToPB code
type InvesmentHoldingWithAfterToPB interface {
	AfterToPB(context.Context, *InvesmentHolding) error
}

type InvestmentSecurityORM struct {
	ClosePrice             float64
	ClosePriceAsOf         string
	Cusip                  string
	Id                     uint64
	InstitutionId          string
	InstitutionSecurityId  string
	InvestmentAccountId    *uint64
	IsCashEquivalent       bool
	Isin                   string
	IsoCurrencyCode        string
	Name                   string
	ProxySecurityId        string
	SecurityId             string
	Sedol                  string
	TickerSymbol           string
	Type                   string
	UnofficialCurrencyCode string
	UpdateDatetime         string
}

// TableName overrides the default tablename generated by GORM
func (InvestmentSecurityORM) TableName() string {
	return "investment_securities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestmentSecurity) ToORM(ctx context.Context) (InvestmentSecurityORM, error) {
	to := InvestmentSecurityORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentSecurityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ClosePrice = m.ClosePrice
	to.ClosePriceAsOf = m.ClosePriceAsOf
	to.Cusip = m.Cusip
	to.InstitutionId = m.InstitutionId
	to.InstitutionSecurityId = m.InstitutionSecurityId
	to.IsCashEquivalent = m.IsCashEquivalent
	to.Isin = m.Isin
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Name = m.Name
	to.ProxySecurityId = m.ProxySecurityId
	to.SecurityId = m.SecurityId
	to.Sedol = m.Sedol
	to.TickerSymbol = m.TickerSymbol
	to.Type = m.Type
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.UpdateDatetime = m.UpdateDatetime
	if posthook, ok := interface{}(m).(InvestmentSecurityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentSecurityORM) ToPB(ctx context.Context) (InvestmentSecurity, error) {
	to := InvestmentSecurity{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentSecurityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ClosePrice = m.ClosePrice
	to.ClosePriceAsOf = m.ClosePriceAsOf
	to.Cusip = m.Cusip
	to.InstitutionId = m.InstitutionId
	to.InstitutionSecurityId = m.InstitutionSecurityId
	to.IsCashEquivalent = m.IsCashEquivalent
	to.Isin = m.Isin
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.Name = m.Name
	to.ProxySecurityId = m.ProxySecurityId
	to.SecurityId = m.SecurityId
	to.Sedol = m.Sedol
	to.TickerSymbol = m.TickerSymbol
	to.Type = m.Type
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.UpdateDatetime = m.UpdateDatetime
	if posthook, ok := interface{}(m).(InvestmentSecurityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestmentSecurity the arg will be the target, the caller the one being converted from

// InvestmentSecurityBeforeToORM called before default ToORM code
type InvestmentSecurityWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentSecurityORM) error
}

// InvestmentSecurityAfterToORM called after default ToORM code
type InvestmentSecurityWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentSecurityORM) error
}

// InvestmentSecurityBeforeToPB called before default ToPB code
type InvestmentSecurityWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestmentSecurity) error
}

// InvestmentSecurityAfterToPB called after default ToPB code
type InvestmentSecurityWithAfterToPB interface {
	AfterToPB(context.Context, *InvestmentSecurity) error
}

type AprORM struct {
	BalanceSubjectToApr  float64
	CreditAccountId      *uint64
	Id                   uint64
	InterestChargeAmount float64
	Percentage           float64
	Type                 string
}

// TableName overrides the default tablename generated by GORM
func (AprORM) TableName() string {
	return "aprs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Apr) ToORM(ctx context.Context) (AprORM, error) {
	to := AprORM{}
	var err error
	if prehook, ok := interface{}(m).(AprWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Percentage = m.Percentage
	to.Type = m.Type
	to.BalanceSubjectToApr = m.BalanceSubjectToApr
	to.InterestChargeAmount = m.InterestChargeAmount
	if posthook, ok := interface{}(m).(AprWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AprORM) ToPB(ctx context.Context) (Apr, error) {
	to := Apr{}
	var err error
	if prehook, ok := interface{}(m).(AprWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Percentage = m.Percentage
	to.Type = m.Type
	to.BalanceSubjectToApr = m.BalanceSubjectToApr
	to.InterestChargeAmount = m.InterestChargeAmount
	if posthook, ok := interface{}(m).(AprWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Apr the arg will be the target, the caller the one being converted from

// AprBeforeToORM called before default ToORM code
type AprWithBeforeToORM interface {
	BeforeToORM(context.Context, *AprORM) error
}

// AprAfterToORM called after default ToORM code
type AprWithAfterToORM interface {
	AfterToORM(context.Context, *AprORM) error
}

// AprBeforeToPB called before default ToPB code
type AprWithBeforeToPB interface {
	BeforeToPB(context.Context, *Apr) error
}

// AprAfterToPB called after default ToPB code
type AprWithAfterToPB interface {
	AfterToPB(context.Context, *Apr) error
}

type AddressORM struct {
	City               string
	Country            string
	CountrySubdivision string
	Id                 uint64
	ModifiedAt         *time.Time
	State              string
	Street_1           string
	Street_2           string
	Type               string
	ZipCode            string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type PlaidAccountInvestmentTransactionORM struct {
	AccountId               string
	Ammount                 string
	Amount                  float64
	CreatedAt               *time.Time
	CurrentDate             string
	Fees                    float64
	Id                      uint64
	InvestmentAccountId     *uint64
	InvestmentTransactionId string
	IsoCurrencyCode         string
	LinkId                  uint64
	Name                    string
	Notes                   []*SmartNoteORM `gorm:"foreignkey:PlaidAccountInvestmentTransactionId;association_foreignkey:Id"`
	Price                   float64
	Quantity                float64
	SecurityId              string
	Subtype                 string
	Time                    *time.Time
	Type                    string
	UnofficialCurrencyCode  string
	UserId                  uint64
}

// TableName overrides the default tablename generated by GORM
func (PlaidAccountInvestmentTransactionORM) TableName() string {
	return "plaid_account_investment_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidAccountInvestmentTransaction) ToORM(ctx context.Context) (PlaidAccountInvestmentTransactionORM, error) {
	to := PlaidAccountInvestmentTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.CurrentDate = m.CurrentDate
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidAccountInvestmentTransactionORM) ToPB(ctx context.Context) (PlaidAccountInvestmentTransaction, error) {
	to := PlaidAccountInvestmentTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Ammount = m.Ammount
	to.InvestmentTransactionId = m.InvestmentTransactionId
	to.SecurityId = m.SecurityId
	to.CurrentDate = m.CurrentDate
	to.Name = m.Name
	to.Quantity = m.Quantity
	to.Amount = m.Amount
	to.Price = m.Price
	to.Fees = m.Fees
	to.Type = m.Type
	to.Subtype = m.Subtype
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.UserId = m.UserId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountInvestmentTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidAccountInvestmentTransaction the arg will be the target, the caller the one being converted from

// PlaidAccountInvestmentTransactionBeforeToORM called before default ToORM code
type PlaidAccountInvestmentTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidAccountInvestmentTransactionORM) error
}

// PlaidAccountInvestmentTransactionAfterToORM called after default ToORM code
type PlaidAccountInvestmentTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidAccountInvestmentTransactionORM) error
}

// PlaidAccountInvestmentTransactionBeforeToPB called before default ToPB code
type PlaidAccountInvestmentTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidAccountInvestmentTransaction) error
}

// PlaidAccountInvestmentTransactionAfterToPB called after default ToPB code
type PlaidAccountInvestmentTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidAccountInvestmentTransaction) error
}

type PlaidAccountRecurringTransactionORM struct {
	AccountId                       string
	AverageAmount                   string
	AverageAmountIsoCurrencyCode    string
	BankAccountId                   *uint64
	CategoryId                      string
	CreditAccountId                 *uint64
	Description                     string
	FirstDate                       *time.Time
	Flow                            string
	Frequency                       string
	Id                              uint64
	IsActive                        bool
	LastAmount                      string
	LastAmountIsoCurrencyCode       string
	LastDate                        *time.Time
	LinkId                          uint64
	MerchantName                    string
	Notes                           []*SmartNoteORM `gorm:"foreignkey:PlaidAccountRecurringTransactionId;association_foreignkey:Id"`
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Status                          string
	StreamId                        string
	Time                            *time.Time
	TransactionIds                  string
	UpdatedTime                     *time.Time
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (PlaidAccountRecurringTransactionORM) TableName() string {
	return "plaid_account_recurring_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidAccountRecurringTransaction) ToORM(ctx context.Context) (PlaidAccountRecurringTransactionORM, error) {
	to := PlaidAccountRecurringTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.FirstDate != nil {
		t := m.FirstDate.AsTime()
		to.FirstDate = &t
	}
	if m.LastDate != nil {
		t := m.LastDate.AsTime()
		to.LastDate = &t
	}
	to.Frequency = m.Frequency
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = m.Status
	if m.UpdatedTime != nil {
		t := m.UpdatedTime.AsTime()
		to.UpdatedTime = &t
	}
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = m.Flow
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidAccountRecurringTransactionORM) ToPB(ctx context.Context) (PlaidAccountRecurringTransaction, error) {
	to := PlaidAccountRecurringTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.StreamId = m.StreamId
	to.CategoryId = m.CategoryId
	to.Description = m.Description
	to.MerchantName = m.MerchantName
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.FirstDate != nil {
		to.FirstDate = timestamppb.New(*m.FirstDate)
	}
	if m.LastDate != nil {
		to.LastDate = timestamppb.New(*m.LastDate)
	}
	to.Frequency = m.Frequency
	to.TransactionIds = m.TransactionIds
	to.AverageAmount = m.AverageAmount
	to.AverageAmountIsoCurrencyCode = m.AverageAmountIsoCurrencyCode
	to.LastAmount = m.LastAmount
	to.LastAmountIsoCurrencyCode = m.LastAmountIsoCurrencyCode
	to.IsActive = m.IsActive
	to.Status = m.Status
	if m.UpdatedTime != nil {
		to.UpdatedTime = timestamppb.New(*m.UpdatedTime)
	}
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Id = m.Id
	to.Flow = m.Flow
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountRecurringTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidAccountRecurringTransaction the arg will be the target, the caller the one being converted from

// PlaidAccountRecurringTransactionBeforeToORM called before default ToORM code
type PlaidAccountRecurringTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidAccountRecurringTransactionORM) error
}

// PlaidAccountRecurringTransactionAfterToORM called after default ToORM code
type PlaidAccountRecurringTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidAccountRecurringTransactionORM) error
}

// PlaidAccountRecurringTransactionBeforeToPB called before default ToPB code
type PlaidAccountRecurringTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidAccountRecurringTransaction) error
}

// PlaidAccountRecurringTransactionAfterToPB called after default ToPB code
type PlaidAccountRecurringTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidAccountRecurringTransaction) error
}

type PlaidAccountTransactionORM struct {
	AccountId                       string
	AccountOwner                    string
	Amount                          float64
	AuthorizedDate                  *time.Time
	AuthorizedDatetime              *time.Time
	BankAccountId                   *uint64
	Categories                      pq.StringArray `gorm:"type:text[]"`
	CategoryId                      string
	CheckNumber                     string
	CreditAccountId                 *uint64
	CurrentDate                     *time.Time
	CurrentDatetime                 *time.Time
	HideTransaction                 bool
	Id                              uint64
	IsoCurrencyCode                 string
	LinkId                          uint64
	LocationAddress                 string
	LocationCity                    string
	LocationCountry                 string
	LocationLat                     float64
	LocationLon                     float64
	LocationPostalCode              string
	LocationRegion                  string
	LocationStoreNumber             string
	MerchantName                    string
	NeedsReview                     bool
	Notes                           []*SmartNoteORM `gorm:"foreignkey:PlaidAccountTransactionId;association_foreignkey:Id"`
	PaymentChannel                  string
	PaymentMetaByOrderOf            string
	PaymentMetaPayee                string
	PaymentMetaPayer                string
	PaymentMetaPaymentMethod        string
	PaymentMetaPaymentProcessor     string
	PaymentMetaPpdId                string
	PaymentMetaReason               string
	PaymentMetaReferenceNumber      string
	Pending                         bool
	PendingTransactionId            string
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	Splits                          []*TransactionSplitORM `gorm:"foreignkey:PlaidAccountTransactionId;association_foreignkey:Id"`
	Tags                            pq.StringArray         `gorm:"type:text[]"`
	Time                            *time.Time
	TransactionCode                 string
	TransactionId                   string
	TransactionName                 string
	UnofficialCurrencyCode          string
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (PlaidAccountTransactionORM) TableName() string {
	return "plaid_account_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PlaidAccountTransaction) ToORM(ctx context.Context) (PlaidAccountTransactionORM, error) {
	to := PlaidAccountTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	if m.CurrentDate != nil {
		t := m.CurrentDate.AsTime()
		to.CurrentDate = &t
	}
	if m.CurrentDatetime != nil {
		t := m.CurrentDatetime.AsTime()
		to.CurrentDatetime = &t
	}
	if m.AuthorizedDate != nil {
		t := m.AuthorizedDate.AsTime()
		to.AuthorizedDate = &t
	}
	if m.AuthorizedDatetime != nil {
		t := m.AuthorizedDatetime.AsTime()
		to.AuthorizedDatetime = &t
	}
	to.CategoryId = m.CategoryId
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.TransactionName = m.TransactionName
	to.MerchantName = m.MerchantName
	to.CheckNumber = m.CheckNumber
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	if m.Time != nil {
		t := m.Time.AsTime()
		to.Time = &t
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.NeedsReview = m.NeedsReview
	to.HideTransaction = m.HideTransaction
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	for _, v := range m.Splits {
		if v != nil {
			if tempSplits, cErr := v.ToORM(ctx); cErr == nil {
				to.Splits = append(to.Splits, &tempSplits)
			} else {
				return to, cErr
			}
		} else {
			to.Splits = append(to.Splits, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PlaidAccountTransactionORM) ToPB(ctx context.Context) (PlaidAccountTransaction, error) {
	to := PlaidAccountTransaction{}
	var err error
	if prehook, ok := interface{}(m).(PlaidAccountTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AccountId = m.AccountId
	to.Amount = m.Amount
	to.IsoCurrencyCode = m.IsoCurrencyCode
	to.UnofficialCurrencyCode = m.UnofficialCurrencyCode
	to.TransactionId = m.TransactionId
	to.TransactionCode = m.TransactionCode
	if m.CurrentDate != nil {
		to.CurrentDate = timestamppb.New(*m.CurrentDate)
	}
	if m.CurrentDatetime != nil {
		to.CurrentDatetime = timestamppb.New(*m.CurrentDatetime)
	}
	if m.AuthorizedDate != nil {
		to.AuthorizedDate = timestamppb.New(*m.AuthorizedDate)
	}
	if m.AuthorizedDatetime != nil {
		to.AuthorizedDatetime = timestamppb.New(*m.AuthorizedDatetime)
	}
	to.CategoryId = m.CategoryId
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	to.TransactionName = m.TransactionName
	to.MerchantName = m.MerchantName
	to.CheckNumber = m.CheckNumber
	to.PaymentChannel = m.PaymentChannel
	to.Pending = m.Pending
	to.PendingTransactionId = m.PendingTransactionId
	to.AccountOwner = m.AccountOwner
	to.PaymentMetaByOrderOf = m.PaymentMetaByOrderOf
	to.PaymentMetaPayee = m.PaymentMetaPayee
	to.PaymentMetaPayer = m.PaymentMetaPayer
	to.PaymentMetaPaymentMethod = m.PaymentMetaPaymentMethod
	to.PaymentMetaPaymentProcessor = m.PaymentMetaPaymentProcessor
	to.PaymentMetaPpdId = m.PaymentMetaPpdId
	to.PaymentMetaReason = m.PaymentMetaReason
	to.PaymentMetaReferenceNumber = m.PaymentMetaReferenceNumber
	to.LocationAddress = m.LocationAddress
	to.LocationCity = m.LocationCity
	to.LocationRegion = m.LocationRegion
	to.LocationPostalCode = m.LocationPostalCode
	to.LocationCountry = m.LocationCountry
	to.LocationLat = m.LocationLat
	to.LocationLon = m.LocationLon
	to.LocationStoreNumber = m.LocationStoreNumber
	if m.Time != nil {
		to.Time = timestamppb.New(*m.Time)
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.NeedsReview = m.NeedsReview
	to.HideTransaction = m.HideTransaction
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Notes {
		if v != nil {
			if tempNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.Notes = append(to.Notes, &tempNotes)
			} else {
				return to, cErr
			}
		} else {
			to.Notes = append(to.Notes, nil)
		}
	}
	for _, v := range m.Splits {
		if v != nil {
			if tempSplits, cErr := v.ToPB(ctx); cErr == nil {
				to.Splits = append(to.Splits, &tempSplits)
			} else {
				return to, cErr
			}
		} else {
			to.Splits = append(to.Splits, nil)
		}
	}
	if posthook, ok := interface{}(m).(PlaidAccountTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PlaidAccountTransaction the arg will be the target, the caller the one being converted from

// PlaidAccountTransactionBeforeToORM called before default ToORM code
type PlaidAccountTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PlaidAccountTransactionORM) error
}

// PlaidAccountTransactionAfterToORM called after default ToORM code
type PlaidAccountTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *PlaidAccountTransactionORM) error
}

// PlaidAccountTransactionBeforeToPB called before default ToPB code
type PlaidAccountTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *PlaidAccountTransaction) error
}

// PlaidAccountTransactionAfterToPB called after default ToPB code
type PlaidAccountTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *PlaidAccountTransaction) error
}

type TransactionSplitORM struct {
	Amount                          float64
	AuthorizedDate                  *time.Time
	AuthorizedDatetime              *time.Time
	Categories                      pq.StringArray `gorm:"type:text[]"`
	Description                     string
	Id                              uint64
	LinkId                          uint64
	PersonalFinanceCategoryDetailed string
	PersonalFinanceCategoryPrimary  string
	PlaidAccountTransactionId       *uint64
	Tags                            pq.StringArray `gorm:"type:text[]"`
	TimeOfSplit                     *time.Time
	UserId                          uint64
}

// TableName overrides the default tablename generated by GORM
func (TransactionSplitORM) TableName() string {
	return "transaction_splits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionSplit) ToORM(ctx context.Context) (TransactionSplitORM, error) {
	to := TransactionSplitORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionSplitWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Description = m.Description
	to.Amount = m.Amount
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.AuthorizedDate != nil {
		t := m.AuthorizedDate.AsTime()
		to.AuthorizedDate = &t
	}
	if m.AuthorizedDatetime != nil {
		t := m.AuthorizedDatetime.AsTime()
		to.AuthorizedDatetime = &t
	}
	if m.TimeOfSplit != nil {
		t := m.TimeOfSplit.AsTime()
		to.TimeOfSplit = &t
	}
	if posthook, ok := interface{}(m).(TransactionSplitWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionSplitORM) ToPB(ctx context.Context) (TransactionSplit, error) {
	to := TransactionSplit{}
	var err error
	if prehook, ok := interface{}(m).(TransactionSplitWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.LinkId = m.LinkId
	to.Description = m.Description
	to.Amount = m.Amount
	if m.Categories != nil {
		to.Categories = make(pq.StringArray, len(m.Categories))
		copy(to.Categories, m.Categories)
	}
	to.PersonalFinanceCategoryPrimary = m.PersonalFinanceCategoryPrimary
	to.PersonalFinanceCategoryDetailed = m.PersonalFinanceCategoryDetailed
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.AuthorizedDate != nil {
		to.AuthorizedDate = timestamppb.New(*m.AuthorizedDate)
	}
	if m.AuthorizedDatetime != nil {
		to.AuthorizedDatetime = timestamppb.New(*m.AuthorizedDatetime)
	}
	if m.TimeOfSplit != nil {
		to.TimeOfSplit = timestamppb.New(*m.TimeOfSplit)
	}
	if posthook, ok := interface{}(m).(TransactionSplitWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionSplit the arg will be the target, the caller the one being converted from

// TransactionSplitBeforeToORM called before default ToORM code
type TransactionSplitWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionSplitORM) error
}

// TransactionSplitAfterToORM called after default ToORM code
type TransactionSplitWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionSplitORM) error
}

// TransactionSplitBeforeToPB called before default ToPB code
type TransactionSplitWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionSplit) error
}

// TransactionSplitAfterToPB called after default ToPB code
type TransactionSplitWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionSplit) error
}

// DefaultCreateStripeSubscription executes a basic gorm create call
func DefaultCreateStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StripeSubscriptionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StripeSubscriptionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StripeSubscriptionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StripeSubscriptionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StripeSubscriptionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StripeSubscriptionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StripeSubscriptionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStripeSubscriptionSet(ctx context.Context, in []*StripeSubscription, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StripeSubscriptionORM{})).(StripeSubscriptionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StripeSubscriptionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StripeSubscriptionORM{})).(StripeSubscriptionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StripeSubscriptionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StripeSubscription, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StripeSubscription, *gorm.DB) error
}

// DefaultStrictUpdateStripeSubscription clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStripeSubscription(ctx context.Context, in *StripeSubscription, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStripeSubscription")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StripeSubscriptionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StripeSubscriptionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchStripeSubscription executes a basic gorm update call with patch behavior
func DefaultPatchStripeSubscription(ctx context.Context, in *StripeSubscription, updateMask *field_mask.FieldMask, db *gorm.DB) (*StripeSubscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj StripeSubscription
	var err error
	if hook, ok := interface{}(&pbObj).(StripeSubscriptionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStripeSubscription(ctx, &StripeSubscription{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StripeSubscriptionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStripeSubscription(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StripeSubscriptionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStripeSubscription(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StripeSubscriptionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StripeSubscriptionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StripeSubscription, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetStripeSubscription executes a bulk gorm update call with patch behavior
func DefaultPatchSetStripeSubscription(ctx context.Context, objects []*StripeSubscription, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*StripeSubscription, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StripeSubscription, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStripeSubscription(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStripeSubscription patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStripeSubscription(ctx context.Context, patchee *StripeSubscription, patcher *StripeSubscription, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*StripeSubscription, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"StripeSubscriptionId" {
			patchee.StripeSubscriptionId = patcher.StripeSubscriptionId
			continue
		}
		if f == prefix+"StripeSubscriptionStatus" {
			patchee.StripeSubscriptionStatus = patcher.StripeSubscriptionStatus
			continue
		}
		if f == prefix+"StripeSubscriptionActiveUntil" {
			patchee.StripeSubscriptionActiveUntil = patcher.StripeSubscriptionActiveUntil
			continue
		}
		if f == prefix+"StripeWebhookLatestTimestamp" {
			patchee.StripeWebhookLatestTimestamp = patcher.StripeWebhookLatestTimestamp
			continue
		}
		if f == prefix+"IsTrialing" {
			patchee.IsTrialing = patcher.IsTrialing
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStripeSubscription executes a gorm list call
func DefaultListStripeSubscription(ctx context.Context, db *gorm.DB) ([]*StripeSubscription, error) {
	in := StripeSubscription{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StripeSubscriptionORM{}, &StripeSubscription{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StripeSubscriptionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StripeSubscriptionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StripeSubscription{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StripeSubscriptionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StripeSubscriptionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StripeSubscriptionORM) error
}

// DefaultCreateFinancialUserProfile executes a basic gorm create call
func DefaultCreateFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FinancialUserProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FinancialUserProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FinancialUserProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FinancialUserProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FinancialUserProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FinancialUserProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FinancialUserProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialUserProfileSet(ctx context.Context, in []*FinancialUserProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FinancialUserProfileORM{})).(FinancialUserProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FinancialUserProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FinancialUserProfileORM{})).(FinancialUserProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FinancialUserProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FinancialUserProfile, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FinancialUserProfile, *gorm.DB) error
}

// DefaultStrictUpdateFinancialUserProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFinancialUserProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FinancialUserProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterActionableInsights := ActionableInsightORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterActionableInsights.FinancialUserProfileId = new(uint64)
	*filterActionableInsights.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterActionableInsights).Delete(ActionableInsightORM{}).Error; err != nil {
		return nil, err
	}
	filterActionablePersonalInsights := PersonalActionableInsightORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterActionablePersonalInsights.FinancialUserProfileId = new(uint64)
	*filterActionablePersonalInsights.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterActionablePersonalInsights).Delete(PersonalActionableInsightORM{}).Error; err != nil {
		return nil, err
	}
	filterLink := LinkORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLink.FinancialUserProfileId = new(uint64)
	*filterLink.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterLink).Delete(LinkORM{}).Error; err != nil {
		return nil, err
	}
	filterStripeSubscriptions := StripeSubscriptionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterStripeSubscriptions.FinancialUserProfileId = new(uint64)
	*filterStripeSubscriptions.FinancialUserProfileId = ormObj.Id
	if err = db.Where(filterStripeSubscriptions).Delete(StripeSubscriptionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FinancialUserProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFinancialUserProfile executes a basic gorm update call with patch behavior
func DefaultPatchFinancialUserProfile(ctx context.Context, in *FinancialUserProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*FinancialUserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FinancialUserProfile
	var err error
	if hook, ok := interface{}(&pbObj).(FinancialUserProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFinancialUserProfile(ctx, &FinancialUserProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FinancialUserProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFinancialUserProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FinancialUserProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFinancialUserProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FinancialUserProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FinancialUserProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FinancialUserProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFinancialUserProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetFinancialUserProfile(ctx context.Context, objects []*FinancialUserProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FinancialUserProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FinancialUserProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFinancialUserProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFinancialUserProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFinancialUserProfile(ctx context.Context, patchee *FinancialUserProfile, patcher *FinancialUserProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FinancialUserProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStripeSubscriptions bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"StripeCustomerId" {
			patchee.StripeCustomerId = patcher.StripeCustomerId
			continue
		}
		if !updatedStripeSubscriptions && strings.HasPrefix(f, prefix+"StripeSubscriptions.") {
			updatedStripeSubscriptions = true
			if patcher.StripeSubscriptions == nil {
				patchee.StripeSubscriptions = nil
				continue
			}
			if patchee.StripeSubscriptions == nil {
				patchee.StripeSubscriptions = &StripeSubscription{}
			}
			if o, err := DefaultApplyFieldMaskStripeSubscription(ctx, patchee.StripeSubscriptions, patcher.StripeSubscriptions, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"StripeSubscriptions.", db); err != nil {
				return nil, err
			} else {
				patchee.StripeSubscriptions = o
			}
			continue
		}
		if f == prefix+"StripeSubscriptions" {
			updatedStripeSubscriptions = true
			patchee.StripeSubscriptions = patcher.StripeSubscriptions
			continue
		}
		if f == prefix+"Link" {
			patchee.Link = patcher.Link
			continue
		}
		if f == prefix+"ActionableInsights" {
			patchee.ActionableInsights = patcher.ActionableInsights
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"ActionablePersonalInsights" {
			patchee.ActionablePersonalInsights = patcher.ActionablePersonalInsights
			continue
		}
		if f == prefix+"ProfileType" {
			patchee.ProfileType = patcher.ProfileType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFinancialUserProfile executes a gorm list call
func DefaultListFinancialUserProfile(ctx context.Context, db *gorm.DB) ([]*FinancialUserProfile, error) {
	in := FinancialUserProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FinancialUserProfileORM{}, &FinancialUserProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FinancialUserProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialUserProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FinancialUserProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FinancialUserProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialUserProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FinancialUserProfileORM) error
}

// DefaultCreateActionableInsight executes a basic gorm create call
func DefaultCreateActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ActionableInsightORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ActionableInsightORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ActionableInsightORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ActionableInsightORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ActionableInsightORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ActionableInsightORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteActionableInsightSet(ctx context.Context, in []*ActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ActionableInsightORM{})).(ActionableInsightORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ActionableInsightORM{})).(ActionableInsightORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ActionableInsightORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ActionableInsight, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ActionableInsight, *gorm.DB) error
}

// DefaultStrictUpdateActionableInsight clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateActionableInsight(ctx context.Context, in *ActionableInsight, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateActionableInsight")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ActionableInsightORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ActionableInsightORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchActionableInsight executes a basic gorm update call with patch behavior
func DefaultPatchActionableInsight(ctx context.Context, in *ActionableInsight, updateMask *field_mask.FieldMask, db *gorm.DB) (*ActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ActionableInsight
	var err error
	if hook, ok := interface{}(&pbObj).(ActionableInsightWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadActionableInsight(ctx, &ActionableInsight{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ActionableInsightWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskActionableInsight(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ActionableInsightWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateActionableInsight(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ActionableInsightWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ActionableInsightWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ActionableInsight, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetActionableInsight executes a bulk gorm update call with patch behavior
func DefaultPatchSetActionableInsight(ctx context.Context, objects []*ActionableInsight, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ActionableInsight, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ActionableInsight, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchActionableInsight(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskActionableInsight patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskActionableInsight(ctx context.Context, patchee *ActionableInsight, patcher *ActionableInsight, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ActionableInsight, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedGeneratedTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"DetailedAction" {
			patchee.DetailedAction = patcher.DetailedAction
			continue
		}
		if f == prefix+"SummarizedAction" {
			patchee.SummarizedAction = patcher.SummarizedAction
			continue
		}
		if !updatedGeneratedTime && strings.HasPrefix(f, prefix+"GeneratedTime.") {
			if patcher.GeneratedTime == nil {
				patchee.GeneratedTime = nil
				continue
			}
			if patchee.GeneratedTime == nil {
				patchee.GeneratedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"GeneratedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.GeneratedTime, patchee.GeneratedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"GeneratedTime" {
			updatedGeneratedTime = true
			patchee.GeneratedTime = patcher.GeneratedTime
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListActionableInsight executes a gorm list call
func DefaultListActionableInsight(ctx context.Context, db *gorm.DB) ([]*ActionableInsight, error) {
	in := ActionableInsight{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ActionableInsightORM{}, &ActionableInsight{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ActionableInsightORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActionableInsightORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ActionableInsight{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ActionableInsightORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActionableInsightORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ActionableInsightORM) error
}

// DefaultCreatePersonalActionableInsight executes a basic gorm create call
func DefaultCreatePersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PersonalActionableInsightORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PersonalActionableInsightORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PersonalActionableInsightORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PersonalActionableInsightORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PersonalActionableInsightORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PersonalActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PersonalActionableInsightORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePersonalActionableInsightSet(ctx context.Context, in []*PersonalActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PersonalActionableInsightORM{})).(PersonalActionableInsightORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PersonalActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PersonalActionableInsightORM{})).(PersonalActionableInsightORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PersonalActionableInsightORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PersonalActionableInsight, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PersonalActionableInsight, *gorm.DB) error
}

// DefaultStrictUpdatePersonalActionableInsight clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePersonalActionableInsight")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PersonalActionableInsightORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PersonalActionableInsightORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPersonalActionableInsight executes a basic gorm update call with patch behavior
func DefaultPatchPersonalActionableInsight(ctx context.Context, in *PersonalActionableInsight, updateMask *field_mask.FieldMask, db *gorm.DB) (*PersonalActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PersonalActionableInsight
	var err error
	if hook, ok := interface{}(&pbObj).(PersonalActionableInsightWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPersonalActionableInsight(ctx, &PersonalActionableInsight{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PersonalActionableInsightWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPersonalActionableInsight(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PersonalActionableInsightWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePersonalActionableInsight(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PersonalActionableInsightWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PersonalActionableInsightWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PersonalActionableInsight, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPersonalActionableInsight executes a bulk gorm update call with patch behavior
func DefaultPatchSetPersonalActionableInsight(ctx context.Context, objects []*PersonalActionableInsight, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PersonalActionableInsight, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PersonalActionableInsight, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPersonalActionableInsight(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPersonalActionableInsight patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPersonalActionableInsight(ctx context.Context, patchee *PersonalActionableInsight, patcher *PersonalActionableInsight, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PersonalActionableInsight, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedGeneratedTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"InsightName" {
			patchee.InsightName = patcher.InsightName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Takeaway" {
			patchee.Takeaway = patcher.Takeaway
			continue
		}
		if f == prefix+"Action" {
			patchee.Action = patcher.Action
			continue
		}
		if f == prefix+"ExpectedBenefit" {
			patchee.ExpectedBenefit = patcher.ExpectedBenefit
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedGeneratedTime && strings.HasPrefix(f, prefix+"GeneratedTime.") {
			if patcher.GeneratedTime == nil {
				patchee.GeneratedTime = nil
				continue
			}
			if patchee.GeneratedTime == nil {
				patchee.GeneratedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"GeneratedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.GeneratedTime, patchee.GeneratedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"GeneratedTime" {
			updatedGeneratedTime = true
			patchee.GeneratedTime = patcher.GeneratedTime
			continue
		}
		if f == prefix+"MetricsToOptimizeFor" {
			patchee.MetricsToOptimizeFor = patcher.MetricsToOptimizeFor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPersonalActionableInsight executes a gorm list call
func DefaultListPersonalActionableInsight(ctx context.Context, db *gorm.DB) ([]*PersonalActionableInsight, error) {
	in := PersonalActionableInsight{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PersonalActionableInsightORM{}, &PersonalActionableInsight{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PersonalActionableInsightORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PersonalActionableInsightORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PersonalActionableInsight{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PersonalActionableInsightORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PersonalActionableInsightORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PersonalActionableInsightORM) error
}

// DefaultCreateLink executes a basic gorm create call
func DefaultCreateLink(ctx context.Context, in *Link, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLink(ctx context.Context, in *Link, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLink(ctx context.Context, in *Link, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkSet(ctx context.Context, in []*Link, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LinkORM{})).(LinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LinkORM{})).(LinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Link, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Link, *gorm.DB) error
}

// DefaultStrictUpdateLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLink(ctx context.Context, in *Link, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBankAccounts := BankAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBankAccounts.LinkId = new(uint64)
	*filterBankAccounts.LinkId = ormObj.Id
	if err = db.Where(filterBankAccounts).Delete(BankAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterCreditAccounts := CreditAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCreditAccounts.LinkId = new(uint64)
	*filterCreditAccounts.LinkId = ormObj.Id
	if err = db.Where(filterCreditAccounts).Delete(CreditAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestmentAccounts := InvestmentAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvestmentAccounts.LinkId = new(uint64)
	*filterInvestmentAccounts.LinkId = ormObj.Id
	if err = db.Where(filterInvestmentAccounts).Delete(InvestmentAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterMortgageAccounts := MortgageAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMortgageAccounts.LinkId = new(uint64)
	*filterMortgageAccounts.LinkId = ormObj.Id
	if err = db.Where(filterMortgageAccounts).Delete(MortgageAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterPlaidLink := PlaidLinkORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPlaidLink.LinkId = new(uint64)
	*filterPlaidLink.LinkId = ormObj.Id
	if err = db.Where(filterPlaidLink).Delete(PlaidLinkORM{}).Error; err != nil {
		return nil, err
	}
	filterPlaidSync := PlaidSyncORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPlaidSync.LinkId = new(uint64)
	*filterPlaidSync.LinkId = ormObj.Id
	if err = db.Where(filterPlaidSync).Delete(PlaidSyncORM{}).Error; err != nil {
		return nil, err
	}
	filterStudentLoanAccounts := StudentLoanAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterStudentLoanAccounts.LinkId = new(uint64)
	*filterStudentLoanAccounts.LinkId = ormObj.Id
	if err = db.Where(filterStudentLoanAccounts).Delete(StudentLoanAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterToken := TokenORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterToken.LinkId = new(uint64)
	*filterToken.LinkId = ormObj.Id
	if err = db.Where(filterToken).Delete(TokenORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLink executes a basic gorm update call with patch behavior
func DefaultPatchLink(ctx context.Context, in *Link, updateMask *field_mask.FieldMask, db *gorm.DB) (*Link, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Link
	var err error
	if hook, ok := interface{}(&pbObj).(LinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLink(ctx, &Link{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Link, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetLink(ctx context.Context, objects []*Link, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Link, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Link, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLink(ctx context.Context, patchee *Link, patcher *Link, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Link, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPlaidSync bool
	var updatedPlaidLink bool
	var updatedToken bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedPlaidSync && strings.HasPrefix(f, prefix+"PlaidSync.") {
			updatedPlaidSync = true
			if patcher.PlaidSync == nil {
				patchee.PlaidSync = nil
				continue
			}
			if patchee.PlaidSync == nil {
				patchee.PlaidSync = &PlaidSync{}
			}
			if o, err := DefaultApplyFieldMaskPlaidSync(ctx, patchee.PlaidSync, patcher.PlaidSync, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PlaidSync.", db); err != nil {
				return nil, err
			} else {
				patchee.PlaidSync = o
			}
			continue
		}
		if f == prefix+"PlaidSync" {
			updatedPlaidSync = true
			patchee.PlaidSync = patcher.PlaidSync
			continue
		}
		if f == prefix+"LinkStatus" {
			patchee.LinkStatus = patcher.LinkStatus
			continue
		}
		if !updatedPlaidLink && strings.HasPrefix(f, prefix+"PlaidLink.") {
			updatedPlaidLink = true
			if patcher.PlaidLink == nil {
				patchee.PlaidLink = nil
				continue
			}
			if patchee.PlaidLink == nil {
				patchee.PlaidLink = &PlaidLink{}
			}
			if o, err := DefaultApplyFieldMaskPlaidLink(ctx, patchee.PlaidLink, patcher.PlaidLink, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PlaidLink.", db); err != nil {
				return nil, err
			} else {
				patchee.PlaidLink = o
			}
			continue
		}
		if f == prefix+"PlaidLink" {
			updatedPlaidLink = true
			patchee.PlaidLink = patcher.PlaidLink
			continue
		}
		if f == prefix+"PlaidNewAccountsAvailable" {
			patchee.PlaidNewAccountsAvailable = patcher.PlaidNewAccountsAvailable
			continue
		}
		if f == prefix+"ExpirationDate" {
			patchee.ExpirationDate = patcher.ExpirationDate
			continue
		}
		if f == prefix+"InstitutionName" {
			patchee.InstitutionName = patcher.InstitutionName
			continue
		}
		if f == prefix+"CustomInstitutionName" {
			patchee.CustomInstitutionName = patcher.CustomInstitutionName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"LastManualSync" {
			patchee.LastManualSync = patcher.LastManualSync
			continue
		}
		if f == prefix+"LastSuccessfulUpdate" {
			patchee.LastSuccessfulUpdate = patcher.LastSuccessfulUpdate
			continue
		}
		if !updatedToken && strings.HasPrefix(f, prefix+"Token.") {
			updatedToken = true
			if patcher.Token == nil {
				patchee.Token = nil
				continue
			}
			if patchee.Token == nil {
				patchee.Token = &Token{}
			}
			if o, err := DefaultApplyFieldMaskToken(ctx, patchee.Token, patcher.Token, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Token.", db); err != nil {
				return nil, err
			} else {
				patchee.Token = o
			}
			continue
		}
		if f == prefix+"Token" {
			updatedToken = true
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"BankAccounts" {
			patchee.BankAccounts = patcher.BankAccounts
			continue
		}
		if f == prefix+"InvestmentAccounts" {
			patchee.InvestmentAccounts = patcher.InvestmentAccounts
			continue
		}
		if f == prefix+"CreditAccounts" {
			patchee.CreditAccounts = patcher.CreditAccounts
			continue
		}
		if f == prefix+"MortgageAccounts" {
			patchee.MortgageAccounts = patcher.MortgageAccounts
			continue
		}
		if f == prefix+"StudentLoanAccounts" {
			patchee.StudentLoanAccounts = patcher.StudentLoanAccounts
			continue
		}
		if f == prefix+"PlaidInstitutionId" {
			patchee.PlaidInstitutionId = patcher.PlaidInstitutionId
			continue
		}
		if f == prefix+"LinkType" {
			patchee.LinkType = patcher.LinkType
			continue
		}
		if f == prefix+"ErrorCode" {
			patchee.ErrorCode = patcher.ErrorCode
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"NewAccountsAvailable" {
			patchee.NewAccountsAvailable = patcher.NewAccountsAvailable
			continue
		}
		if f == prefix+"ShouldBeUpdated" {
			patchee.ShouldBeUpdated = patcher.ShouldBeUpdated
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLink executes a gorm list call
func DefaultListLink(ctx context.Context, db *gorm.DB) ([]*Link, error) {
	in := Link{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LinkORM{}, &Link{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Link{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LinkORM) error
}

// DefaultCreatePlaidSync executes a basic gorm create call
func DefaultCreatePlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidSyncORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidSyncORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidSyncORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidSyncORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidSyncORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidSyncORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidSyncORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidSyncSet(ctx context.Context, in []*PlaidSync, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidSyncORM{})).(PlaidSyncORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidSyncORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidSyncORM{})).(PlaidSyncORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidSyncORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidSync, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidSync, *gorm.DB) error
}

// DefaultStrictUpdatePlaidSync clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidSync(ctx context.Context, in *PlaidSync, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidSync")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidSyncORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidSyncORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidSync executes a basic gorm update call with patch behavior
func DefaultPatchPlaidSync(ctx context.Context, in *PlaidSync, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidSync, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidSync
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidSyncWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidSync(ctx, &PlaidSync{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidSyncWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidSync(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidSyncWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidSync(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidSyncWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidSyncWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidSync, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidSync executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidSync(ctx context.Context, objects []*PlaidSync, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidSync, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidSync, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidSync(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidSync patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidSync(ctx context.Context, patchee *PlaidSync, patcher *PlaidSync, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidSync, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TimeStamp" {
			patchee.TimeStamp = patcher.TimeStamp
			continue
		}
		if f == prefix+"Trigger" {
			patchee.Trigger = patcher.Trigger
			continue
		}
		if f == prefix+"NextCursor" {
			patchee.NextCursor = patcher.NextCursor
			continue
		}
		if f == prefix+"Added" {
			patchee.Added = patcher.Added
			continue
		}
		if f == prefix+"Removed" {
			patchee.Removed = patcher.Removed
			continue
		}
		if f == prefix+"Modified" {
			patchee.Modified = patcher.Modified
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidSync executes a gorm list call
func DefaultListPlaidSync(ctx context.Context, db *gorm.DB) ([]*PlaidSync, error) {
	in := PlaidSync{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidSyncORM{}, &PlaidSync{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidSyncORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidSyncORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidSync{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidSyncORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidSyncORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidSyncORM) error
}

// DefaultCreateToken executes a basic gorm create call
func DefaultCreateToken(ctx context.Context, in *Token, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TokenORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadToken(ctx context.Context, in *Token, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TokenORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TokenORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TokenORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TokenORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteToken(ctx context.Context, in *Token, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TokenORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TokenORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTokenSet(ctx context.Context, in []*Token, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TokenORM{})).(TokenORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TokenORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TokenORM{})).(TokenORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TokenORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Token, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Token, *gorm.DB) error
}

// DefaultStrictUpdateToken clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateToken(ctx context.Context, in *Token, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateToken")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TokenORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TokenORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchToken executes a basic gorm update call with patch behavior
func DefaultPatchToken(ctx context.Context, in *Token, updateMask *field_mask.FieldMask, db *gorm.DB) (*Token, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Token
	var err error
	if hook, ok := interface{}(&pbObj).(TokenWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadToken(ctx, &Token{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TokenWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskToken(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TokenWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateToken(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TokenWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TokenWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TokenWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Token, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetToken executes a bulk gorm update call with patch behavior
func DefaultPatchSetToken(ctx context.Context, objects []*Token, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Token, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Token, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchToken(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskToken patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskToken(ctx context.Context, patchee *Token, patcher *Token, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Token, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedLastMergeCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ItemId" {
			patchee.ItemId = patcher.ItemId
			continue
		}
		if f == prefix+"KeyId" {
			patchee.KeyId = patcher.KeyId
			continue
		}
		if f == prefix+"AccessToken" {
			patchee.AccessToken = patcher.AccessToken
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"MergeEndUserOriginId" {
			patchee.MergeEndUserOriginId = patcher.MergeEndUserOriginId
			continue
		}
		if f == prefix+"MergeIntegrationSlug" {
			patchee.MergeIntegrationSlug = patcher.MergeIntegrationSlug
			continue
		}
		if !updatedLastMergeCreatedAt && strings.HasPrefix(f, prefix+"LastMergeCreatedAt.") {
			if patcher.LastMergeCreatedAt == nil {
				patchee.LastMergeCreatedAt = nil
				continue
			}
			if patchee.LastMergeCreatedAt == nil {
				patchee.LastMergeCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastMergeCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastMergeCreatedAt, patchee.LastMergeCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastMergeCreatedAt" {
			updatedLastMergeCreatedAt = true
			patchee.LastMergeCreatedAt = patcher.LastMergeCreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListToken executes a gorm list call
func DefaultListToken(ctx context.Context, db *gorm.DB) ([]*Token, error) {
	in := Token{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TokenORM{}, &Token{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TokenORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TokenORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Token{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TokenORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TokenORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TokenORM) error
}

// DefaultCreatePlaidLink executes a basic gorm create call
func DefaultCreatePlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidLinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidLinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidLinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidLinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidLinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidLinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidLinkSet(ctx context.Context, in []*PlaidLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidLinkORM{})).(PlaidLinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidLinkORM{})).(PlaidLinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidLinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidLink, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidLink, *gorm.DB) error
}

// DefaultStrictUpdatePlaidLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidLink(ctx context.Context, in *PlaidLink, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidLinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidLinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidLink executes a basic gorm update call with patch behavior
func DefaultPatchPlaidLink(ctx context.Context, in *PlaidLink, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidLink
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidLinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidLink(ctx, &PlaidLink{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidLinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidLinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidLinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidLinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidLink, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidLink(ctx context.Context, objects []*PlaidLink, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidLink, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidLink, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidLink(ctx context.Context, patchee *PlaidLink, patcher *PlaidLink, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidLink, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Products" {
			patchee.Products = patcher.Products
			continue
		}
		if f == prefix+"WebhookUrl" {
			patchee.WebhookUrl = patcher.WebhookUrl
			continue
		}
		if f == prefix+"InstitutionId" {
			patchee.InstitutionId = patcher.InstitutionId
			continue
		}
		if f == prefix+"InstitutionName" {
			patchee.InstitutionName = patcher.InstitutionName
			continue
		}
		if f == prefix+"UsePlaidSync" {
			patchee.UsePlaidSync = patcher.UsePlaidSync
			continue
		}
		if f == prefix+"ItemId" {
			patchee.ItemId = patcher.ItemId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidLink executes a gorm list call
func DefaultListPlaidLink(ctx context.Context, db *gorm.DB) ([]*PlaidLink, error) {
	in := PlaidLink{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidLinkORM{}, &PlaidLink{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidLinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidLinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidLink{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidLinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidLinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidLinkORM) error
}

// DefaultCreateStudentLoanAccount executes a basic gorm create call
func DefaultCreateStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &StudentLoanAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StudentLoanAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StudentLoanAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StudentLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StudentLoanAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteStudentLoanAccountSet(ctx context.Context, in []*StudentLoanAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StudentLoanAccountORM{})).(StudentLoanAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StudentLoanAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StudentLoanAccountORM{})).(StudentLoanAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StudentLoanAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StudentLoanAccount, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StudentLoanAccount, *gorm.DB) error
}

// DefaultStrictUpdateStudentLoanAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStudentLoanAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StudentLoanAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StudentLoanAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchStudentLoanAccount executes a basic gorm update call with patch behavior
func DefaultPatchStudentLoanAccount(ctx context.Context, in *StudentLoanAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*StudentLoanAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj StudentLoanAccount
	var err error
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStudentLoanAccount(ctx, &StudentLoanAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStudentLoanAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StudentLoanAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStudentLoanAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StudentLoanAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StudentLoanAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StudentLoanAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetStudentLoanAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetStudentLoanAccount(ctx context.Context, objects []*StudentLoanAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*StudentLoanAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StudentLoanAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStudentLoanAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStudentLoanAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStudentLoanAccount(ctx context.Context, patchee *StudentLoanAccount, patcher *StudentLoanAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*StudentLoanAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"DisbursementDates" {
			patchee.DisbursementDates = patcher.DisbursementDates
			continue
		}
		if f == prefix+"ExpectedPayoffDate" {
			patchee.ExpectedPayoffDate = patcher.ExpectedPayoffDate
			continue
		}
		if f == prefix+"Guarantor" {
			patchee.Guarantor = patcher.Guarantor
			continue
		}
		if f == prefix+"InterestRatePercentage" {
			patchee.InterestRatePercentage = patcher.InterestRatePercentage
			continue
		}
		if f == prefix+"IsOverdue" {
			patchee.IsOverdue = patcher.IsOverdue
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LastStatementIssueDate" {
			patchee.LastStatementIssueDate = patcher.LastStatementIssueDate
			continue
		}
		if f == prefix+"LoanName" {
			patchee.LoanName = patcher.LoanName
			continue
		}
		if f == prefix+"LoanEndDate" {
			patchee.LoanEndDate = patcher.LoanEndDate
			continue
		}
		if f == prefix+"MinimumPaymentAmount" {
			patchee.MinimumPaymentAmount = patcher.MinimumPaymentAmount
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"OriginationDate" {
			patchee.OriginationDate = patcher.OriginationDate
			continue
		}
		if f == prefix+"OriginationPrincipalAmount" {
			patchee.OriginationPrincipalAmount = patcher.OriginationPrincipalAmount
			continue
		}
		if f == prefix+"OutstandingInterestAmount" {
			patchee.OutstandingInterestAmount = patcher.OutstandingInterestAmount
			continue
		}
		if f == prefix+"PaymentReferenceNumber" {
			patchee.PaymentReferenceNumber = patcher.PaymentReferenceNumber
			continue
		}
		if f == prefix+"SequenceNumber" {
			patchee.SequenceNumber = patcher.SequenceNumber
			continue
		}
		if f == prefix+"YtdInterestPaid" {
			patchee.YtdInterestPaid = patcher.YtdInterestPaid
			continue
		}
		if f == prefix+"YtdPrincipalPaid" {
			patchee.YtdPrincipalPaid = patcher.YtdPrincipalPaid
			continue
		}
		if f == prefix+"LoanType" {
			patchee.LoanType = patcher.LoanType
			continue
		}
		if f == prefix+"PslfStatusEstimatedEligibilityDate" {
			patchee.PslfStatusEstimatedEligibilityDate = patcher.PslfStatusEstimatedEligibilityDate
			continue
		}
		if f == prefix+"PslfStatusPaymentsMade" {
			patchee.PslfStatusPaymentsMade = patcher.PslfStatusPaymentsMade
			continue
		}
		if f == prefix+"PslfStatusPaymentsRemaining" {
			patchee.PslfStatusPaymentsRemaining = patcher.PslfStatusPaymentsRemaining
			continue
		}
		if f == prefix+"RepaymentPlanType" {
			patchee.RepaymentPlanType = patcher.RepaymentPlanType
			continue
		}
		if f == prefix+"RepaymentPlanDescription" {
			patchee.RepaymentPlanDescription = patcher.RepaymentPlanDescription
			continue
		}
		if f == prefix+"ServicerAddressCity" {
			patchee.ServicerAddressCity = patcher.ServicerAddressCity
			continue
		}
		if f == prefix+"ServicerAddressPostalCode" {
			patchee.ServicerAddressPostalCode = patcher.ServicerAddressPostalCode
			continue
		}
		if f == prefix+"ServicerAddressState" {
			patchee.ServicerAddressState = patcher.ServicerAddressState
			continue
		}
		if f == prefix+"ServicerAddressStreet" {
			patchee.ServicerAddressStreet = patcher.ServicerAddressStreet
			continue
		}
		if f == prefix+"ServicerAddressRegion" {
			patchee.ServicerAddressRegion = patcher.ServicerAddressRegion
			continue
		}
		if f == prefix+"ServicerAddressCountry" {
			patchee.ServicerAddressCountry = patcher.ServicerAddressCountry
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStudentLoanAccount executes a gorm list call
func DefaultListStudentLoanAccount(ctx context.Context, db *gorm.DB) ([]*StudentLoanAccount, error) {
	in := StudentLoanAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &StudentLoanAccountORM{}, &StudentLoanAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StudentLoanAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StudentLoanAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StudentLoanAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StudentLoanAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type StudentLoanAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]StudentLoanAccountORM) error
}

// DefaultCreateCreditAccount executes a basic gorm create call
func DefaultCreateCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditAccountSet(ctx context.Context, in []*CreditAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditAccountORM{})).(CreditAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditAccountORM{})).(CreditAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditAccount, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditAccount, *gorm.DB) error
}

// DefaultStrictUpdateCreditAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditAccount(ctx context.Context, in *CreditAccount, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAprs := AprORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAprs.CreditAccountId = new(uint64)
	*filterAprs.CreditAccountId = ormObj.Id
	if err = db.Where(filterAprs).Delete(AprORM{}).Error; err != nil {
		return nil, err
	}
	filterPockets := PocketORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPockets.CreditAccountId = new(uint64)
	*filterPockets.CreditAccountId = ormObj.Id
	if err = db.Where(filterPockets).Delete(PocketORM{}).Error; err != nil {
		return nil, err
	}
	filterRecurringTransactions := PlaidAccountRecurringTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRecurringTransactions.CreditAccountId = new(uint64)
	*filterRecurringTransactions.CreditAccountId = ormObj.Id
	if err = db.Where(filterRecurringTransactions).Delete(PlaidAccountRecurringTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := PlaidAccountTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.CreditAccountId = new(uint64)
	*filterTransactions.CreditAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(PlaidAccountTransactionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditAccount executes a basic gorm update call with patch behavior
func DefaultPatchCreditAccount(ctx context.Context, in *CreditAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditAccount
	var err error
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditAccount(ctx, &CreditAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditAccount(ctx context.Context, objects []*CreditAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditAccount(ctx context.Context, patchee *CreditAccount, patcher *CreditAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"IsOverdue" {
			patchee.IsOverdue = patcher.IsOverdue
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LastStatementIssueDate" {
			patchee.LastStatementIssueDate = patcher.LastStatementIssueDate
			continue
		}
		if f == prefix+"MinimumAmountDueDate" {
			patchee.MinimumAmountDueDate = patcher.MinimumAmountDueDate
			continue
		}
		if f == prefix+"NextPaymentDate" {
			patchee.NextPaymentDate = patcher.NextPaymentDate
			continue
		}
		if f == prefix+"Aprs" {
			patchee.Aprs = patcher.Aprs
			continue
		}
		if f == prefix+"LastStatementBalance" {
			patchee.LastStatementBalance = patcher.LastStatementBalance
			continue
		}
		if f == prefix+"MinimumPaymentAmount" {
			patchee.MinimumPaymentAmount = patcher.MinimumPaymentAmount
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"RecurringTransactions" {
			patchee.RecurringTransactions = patcher.RecurringTransactions
			continue
		}
		if f == prefix+"Pockets" {
			patchee.Pockets = patcher.Pockets
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditAccount executes a gorm list call
func DefaultListCreditAccount(ctx context.Context, db *gorm.DB) ([]*CreditAccount, error) {
	in := CreditAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditAccountORM{}, &CreditAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditAccountORM) error
}

// DefaultCreateMortgageAccount executes a basic gorm create call
func DefaultCreateMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MortgageAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MortgageAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MortgageAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MortgageAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MortgageAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MortgageAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MortgageAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMortgageAccountSet(ctx context.Context, in []*MortgageAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MortgageAccountORM{})).(MortgageAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MortgageAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MortgageAccountORM{})).(MortgageAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MortgageAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MortgageAccount, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MortgageAccount, *gorm.DB) error
}

// DefaultStrictUpdateMortgageAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMortgageAccount(ctx context.Context, in *MortgageAccount, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMortgageAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MortgageAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MortgageAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMortgageAccount executes a basic gorm update call with patch behavior
func DefaultPatchMortgageAccount(ctx context.Context, in *MortgageAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*MortgageAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MortgageAccount
	var err error
	if hook, ok := interface{}(&pbObj).(MortgageAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMortgageAccount(ctx, &MortgageAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MortgageAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMortgageAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MortgageAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMortgageAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MortgageAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MortgageAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MortgageAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMortgageAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetMortgageAccount(ctx context.Context, objects []*MortgageAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MortgageAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MortgageAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMortgageAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMortgageAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMortgageAccount(ctx context.Context, patchee *MortgageAccount, patcher *MortgageAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MortgageAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"CurrentLateFee" {
			patchee.CurrentLateFee = patcher.CurrentLateFee
			continue
		}
		if f == prefix+"EscrowBalance" {
			patchee.EscrowBalance = patcher.EscrowBalance
			continue
		}
		if f == prefix+"HasPmi" {
			patchee.HasPmi = patcher.HasPmi
			continue
		}
		if f == prefix+"HasPrepaymentPenalty" {
			patchee.HasPrepaymentPenalty = patcher.HasPrepaymentPenalty
			continue
		}
		if f == prefix+"LastPaymentAmount" {
			patchee.LastPaymentAmount = patcher.LastPaymentAmount
			continue
		}
		if f == prefix+"LastPaymentDate" {
			patchee.LastPaymentDate = patcher.LastPaymentDate
			continue
		}
		if f == prefix+"LoanTerm" {
			patchee.LoanTerm = patcher.LoanTerm
			continue
		}
		if f == prefix+"LoanTypeDescription" {
			patchee.LoanTypeDescription = patcher.LoanTypeDescription
			continue
		}
		if f == prefix+"MaturityDate" {
			patchee.MaturityDate = patcher.MaturityDate
			continue
		}
		if f == prefix+"NextMonthlyPayment" {
			patchee.NextMonthlyPayment = patcher.NextMonthlyPayment
			continue
		}
		if f == prefix+"NextPaymentDueDate" {
			patchee.NextPaymentDueDate = patcher.NextPaymentDueDate
			continue
		}
		if f == prefix+"OriginalPrincipalBalance" {
			patchee.OriginalPrincipalBalance = patcher.OriginalPrincipalBalance
			continue
		}
		if f == prefix+"OriginalPropertyValue" {
			patchee.OriginalPropertyValue = patcher.OriginalPropertyValue
			continue
		}
		if f == prefix+"OutstandingPrincipalBalance" {
			patchee.OutstandingPrincipalBalance = patcher.OutstandingPrincipalBalance
			continue
		}
		if f == prefix+"PaymentAmount" {
			patchee.PaymentAmount = patcher.PaymentAmount
			continue
		}
		if f == prefix+"PaymentDate" {
			patchee.PaymentDate = patcher.PaymentDate
			continue
		}
		if f == prefix+"OriginationDate" {
			patchee.OriginationDate = patcher.OriginationDate
			continue
		}
		if f == prefix+"OriginationPrincipalAmount" {
			patchee.OriginationPrincipalAmount = patcher.OriginationPrincipalAmount
			continue
		}
		if f == prefix+"PastDueAmount" {
			patchee.PastDueAmount = patcher.PastDueAmount
			continue
		}
		if f == prefix+"YtdInterestPaid" {
			patchee.YtdInterestPaid = patcher.YtdInterestPaid
			continue
		}
		if f == prefix+"YtdPrincipalPaid" {
			patchee.YtdPrincipalPaid = patcher.YtdPrincipalPaid
			continue
		}
		if f == prefix+"PropertyAddressCity" {
			patchee.PropertyAddressCity = patcher.PropertyAddressCity
			continue
		}
		if f == prefix+"PropertyAddressState" {
			patchee.PropertyAddressState = patcher.PropertyAddressState
			continue
		}
		if f == prefix+"PropertyAddressStreet" {
			patchee.PropertyAddressStreet = patcher.PropertyAddressStreet
			continue
		}
		if f == prefix+"PropertyAddressPostalCode" {
			patchee.PropertyAddressPostalCode = patcher.PropertyAddressPostalCode
			continue
		}
		if f == prefix+"PropertyRegion" {
			patchee.PropertyRegion = patcher.PropertyRegion
			continue
		}
		if f == prefix+"PropertyCountry" {
			patchee.PropertyCountry = patcher.PropertyCountry
			continue
		}
		if f == prefix+"InterestRatePercentage" {
			patchee.InterestRatePercentage = patcher.InterestRatePercentage
			continue
		}
		if f == prefix+"InterestRateType" {
			patchee.InterestRateType = patcher.InterestRateType
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMortgageAccount executes a gorm list call
func DefaultListMortgageAccount(ctx context.Context, db *gorm.DB) ([]*MortgageAccount, error) {
	in := MortgageAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MortgageAccountORM{}, &MortgageAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MortgageAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MortgageAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MortgageAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MortgageAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MortgageAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MortgageAccountORM) error
}

// DefaultCreateInvestmentAccount executes a basic gorm create call
func DefaultCreateInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentAccountSet(ctx context.Context, in []*InvestmentAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentAccountORM{})).(InvestmentAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentAccountORM{})).(InvestmentAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentAccount, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentAccount, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentAccount(ctx context.Context, in *InvestmentAccount, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterHoldings := InvesmentHoldingORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterHoldings.InvestmentAccountId = new(uint64)
	*filterHoldings.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterHoldings).Delete(InvesmentHoldingORM{}).Error; err != nil {
		return nil, err
	}
	filterSecurities := InvestmentSecurityORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSecurities.InvestmentAccountId = new(uint64)
	*filterSecurities.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterSecurities).Delete(InvestmentSecurityORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := PlaidAccountInvestmentTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.InvestmentAccountId = new(uint64)
	*filterTransactions.InvestmentAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(PlaidAccountInvestmentTransactionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentAccount executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentAccount(ctx context.Context, in *InvestmentAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentAccount
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentAccount(ctx, &InvestmentAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentAccount(ctx context.Context, objects []*InvestmentAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentAccount(ctx context.Context, patchee *InvestmentAccount, patcher *InvestmentAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"Holdings" {
			patchee.Holdings = patcher.Holdings
			continue
		}
		if f == prefix+"Securities" {
			patchee.Securities = patcher.Securities
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentAccount executes a gorm list call
func DefaultListInvestmentAccount(ctx context.Context, db *gorm.DB) ([]*InvestmentAccount, error) {
	in := InvestmentAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentAccountORM{}, &InvestmentAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentAccountORM) error
}

// DefaultCreateBankAccount executes a basic gorm create call
func DefaultCreateBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BankAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BankAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BankAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BankAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BankAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BankAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BankAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBankAccountSet(ctx context.Context, in []*BankAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BankAccountORM{})).(BankAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BankAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BankAccountORM{})).(BankAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BankAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BankAccount, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BankAccount, *gorm.DB) error
}

// DefaultStrictUpdateBankAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBankAccount(ctx context.Context, in *BankAccount, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBankAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BankAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterPockets := PocketORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPockets.BankAccountId = new(uint64)
	*filterPockets.BankAccountId = ormObj.Id
	if err = db.Where(filterPockets).Delete(PocketORM{}).Error; err != nil {
		return nil, err
	}
	filterRecurringTransactions := PlaidAccountRecurringTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRecurringTransactions.BankAccountId = new(uint64)
	*filterRecurringTransactions.BankAccountId = ormObj.Id
	if err = db.Where(filterRecurringTransactions).Delete(PlaidAccountRecurringTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := PlaidAccountTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.BankAccountId = new(uint64)
	*filterTransactions.BankAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(PlaidAccountTransactionORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BankAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBankAccount executes a basic gorm update call with patch behavior
func DefaultPatchBankAccount(ctx context.Context, in *BankAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*BankAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BankAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BankAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBankAccount(ctx, &BankAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BankAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBankAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BankAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBankAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BankAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BankAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BankAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBankAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBankAccount(ctx context.Context, objects []*BankAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BankAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BankAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBankAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBankAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBankAccount(ctx context.Context, patchee *BankAccount, patcher *BankAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BankAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"CurrentFunds" {
			patchee.CurrentFunds = patcher.CurrentFunds
			continue
		}
		if f == prefix+"BalanceLimit" {
			patchee.BalanceLimit = patcher.BalanceLimit
			continue
		}
		if f == prefix+"Pockets" {
			patchee.Pockets = patcher.Pockets
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"RecurringTransactions" {
			patchee.RecurringTransactions = patcher.RecurringTransactions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBankAccount executes a gorm list call
func DefaultListBankAccount(ctx context.Context, db *gorm.DB) ([]*BankAccount, error) {
	in := BankAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BankAccountORM{}, &BankAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BankAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BankAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BankAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BankAccountORM) error
}

// DefaultCreatePocket executes a basic gorm create call
func DefaultCreatePocket(ctx context.Context, in *Pocket, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PocketORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPocket(ctx context.Context, in *Pocket, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PocketORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PocketORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PocketORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PocketORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePocket(ctx context.Context, in *Pocket, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PocketORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PocketORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePocketSet(ctx context.Context, in []*Pocket, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PocketORM{})).(PocketORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PocketORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PocketORM{})).(PocketORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PocketORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Pocket, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Pocket, *gorm.DB) error
}

// DefaultStrictUpdatePocket clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePocket(ctx context.Context, in *Pocket, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePocket")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PocketORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterGoals := SmartGoalORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterGoals.PocketId = new(uint64)
	*filterGoals.PocketId = ormObj.Id
	if err = db.Where(filterGoals).Delete(SmartGoalORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PocketORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPocket executes a basic gorm update call with patch behavior
func DefaultPatchPocket(ctx context.Context, in *Pocket, updateMask *field_mask.FieldMask, db *gorm.DB) (*Pocket, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Pocket
	var err error
	if hook, ok := interface{}(&pbObj).(PocketWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPocket(ctx, &Pocket{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PocketWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPocket(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PocketWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePocket(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PocketWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PocketWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PocketWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PocketWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PocketWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Pocket, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPocket executes a bulk gorm update call with patch behavior
func DefaultPatchSetPocket(ctx context.Context, objects []*Pocket, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Pocket, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Pocket, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPocket(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPocket patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPocket(ctx context.Context, patchee *Pocket, patcher *Pocket, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Pocket, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Goals" {
			patchee.Goals = patcher.Goals
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPocket executes a gorm list call
func DefaultListPocket(ctx context.Context, db *gorm.DB) ([]*Pocket, error) {
	in := Pocket{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PocketORM{}, &Pocket{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PocketORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PocketORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Pocket{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PocketORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PocketORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PocketORM) error
}

// DefaultCreateSmartGoal executes a basic gorm create call
func DefaultCreateSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SmartGoalORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SmartGoalORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SmartGoalORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SmartGoalORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SmartGoalORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SmartGoalORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SmartGoalORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartGoalSet(ctx context.Context, in []*SmartGoal, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SmartGoalORM{})).(SmartGoalORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SmartGoalORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SmartGoalORM{})).(SmartGoalORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SmartGoalORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SmartGoal, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SmartGoal, *gorm.DB) error
}

// DefaultStrictUpdateSmartGoal clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSmartGoal(ctx context.Context, in *SmartGoal, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSmartGoal")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SmartGoalORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterForecasts := ForecastORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterForecasts.SmartGoalId = new(uint64)
	*filterForecasts.SmartGoalId = ormObj.Id
	if err = db.Where(filterForecasts).Delete(ForecastORM{}).Error; err != nil {
		return nil, err
	}
	filterMilestones := MilestoneORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterMilestones.SmartGoalId = new(uint64)
	*filterMilestones.SmartGoalId = ormObj.Id
	if err = db.Where(filterMilestones).Delete(MilestoneORM{}).Error; err != nil {
		return nil, err
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.SmartGoalId = new(uint64)
	*filterNotes.SmartGoalId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SmartGoalORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSmartGoal executes a basic gorm update call with patch behavior
func DefaultPatchSmartGoal(ctx context.Context, in *SmartGoal, updateMask *field_mask.FieldMask, db *gorm.DB) (*SmartGoal, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SmartGoal
	var err error
	if hook, ok := interface{}(&pbObj).(SmartGoalWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSmartGoal(ctx, &SmartGoal{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SmartGoalWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSmartGoal(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SmartGoalWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSmartGoal(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SmartGoalWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SmartGoalWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SmartGoal, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSmartGoal executes a bulk gorm update call with patch behavior
func DefaultPatchSetSmartGoal(ctx context.Context, objects []*SmartGoal, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SmartGoal, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SmartGoal, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSmartGoal(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSmartGoal patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSmartGoal(ctx context.Context, patchee *SmartGoal, patcher *SmartGoal, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SmartGoal, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedForecasts bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"IsCompleted" {
			patchee.IsCompleted = patcher.IsCompleted
			continue
		}
		if f == prefix+"GoalType" {
			patchee.GoalType = patcher.GoalType
			continue
		}
		if f == prefix+"Duration" {
			patchee.Duration = patcher.Duration
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"TargetAmount" {
			patchee.TargetAmount = patcher.TargetAmount
			continue
		}
		if f == prefix+"CurrentAmount" {
			patchee.CurrentAmount = patcher.CurrentAmount
			continue
		}
		if f == prefix+"Milestones" {
			patchee.Milestones = patcher.Milestones
			continue
		}
		if !updatedForecasts && strings.HasPrefix(f, prefix+"Forecasts.") {
			updatedForecasts = true
			if patcher.Forecasts == nil {
				patchee.Forecasts = nil
				continue
			}
			if patchee.Forecasts == nil {
				patchee.Forecasts = &Forecast{}
			}
			if o, err := DefaultApplyFieldMaskForecast(ctx, patchee.Forecasts, patcher.Forecasts, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Forecasts.", db); err != nil {
				return nil, err
			} else {
				patchee.Forecasts = o
			}
			continue
		}
		if f == prefix+"Forecasts" {
			updatedForecasts = true
			patchee.Forecasts = patcher.Forecasts
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSmartGoal executes a gorm list call
func DefaultListSmartGoal(ctx context.Context, db *gorm.DB) ([]*SmartGoal, error) {
	in := SmartGoal{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SmartGoalORM{}, &SmartGoal{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SmartGoalORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartGoalORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SmartGoal{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SmartGoalORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartGoalORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SmartGoalORM) error
}

// DefaultCreateSmartNote executes a basic gorm create call
func DefaultCreateSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SmartNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SmartNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SmartNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SmartNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SmartNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SmartNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SmartNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSmartNoteSet(ctx context.Context, in []*SmartNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SmartNoteORM{})).(SmartNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SmartNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SmartNoteORM{})).(SmartNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SmartNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*SmartNote, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*SmartNote, *gorm.DB) error
}

// DefaultStrictUpdateSmartNote clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSmartNote(ctx context.Context, in *SmartNote, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSmartNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SmartNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SmartNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSmartNote executes a basic gorm update call with patch behavior
func DefaultPatchSmartNote(ctx context.Context, in *SmartNote, updateMask *field_mask.FieldMask, db *gorm.DB) (*SmartNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj SmartNote
	var err error
	if hook, ok := interface{}(&pbObj).(SmartNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSmartNote(ctx, &SmartNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SmartNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSmartNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SmartNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSmartNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SmartNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SmartNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *SmartNote, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSmartNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetSmartNote(ctx context.Context, objects []*SmartNote, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*SmartNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*SmartNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSmartNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSmartNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSmartNote(ctx context.Context, patchee *SmartNote, patcher *SmartNote, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SmartNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"Content" {
			patchee.Content = patcher.Content
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSmartNote executes a gorm list call
func DefaultListSmartNote(ctx context.Context, db *gorm.DB) ([]*SmartNote, error) {
	in := SmartNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SmartNoteORM{}, &SmartNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SmartNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SmartNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SmartNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SmartNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SmartNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SmartNoteORM) error
}

// DefaultCreateForecast executes a basic gorm create call
func DefaultCreateForecast(ctx context.Context, in *Forecast, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ForecastORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadForecast(ctx context.Context, in *Forecast, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ForecastORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ForecastORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ForecastORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ForecastORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteForecast(ctx context.Context, in *Forecast, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ForecastORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ForecastORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteForecastSet(ctx context.Context, in []*Forecast, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ForecastORM{})).(ForecastORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ForecastORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ForecastORM{})).(ForecastORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ForecastORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Forecast, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Forecast, *gorm.DB) error
}

// DefaultStrictUpdateForecast clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateForecast(ctx context.Context, in *Forecast, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateForecast")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ForecastORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ForecastORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchForecast executes a basic gorm update call with patch behavior
func DefaultPatchForecast(ctx context.Context, in *Forecast, updateMask *field_mask.FieldMask, db *gorm.DB) (*Forecast, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Forecast
	var err error
	if hook, ok := interface{}(&pbObj).(ForecastWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadForecast(ctx, &Forecast{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ForecastWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskForecast(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ForecastWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateForecast(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ForecastWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ForecastWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ForecastWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ForecastWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ForecastWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Forecast, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetForecast executes a bulk gorm update call with patch behavior
func DefaultPatchSetForecast(ctx context.Context, objects []*Forecast, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Forecast, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Forecast, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchForecast(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskForecast patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskForecast(ctx context.Context, patchee *Forecast, patcher *Forecast, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Forecast, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ForecastedAmount" {
			patchee.ForecastedAmount = patcher.ForecastedAmount
			continue
		}
		if f == prefix+"ForecastedCompletionDate" {
			patchee.ForecastedCompletionDate = patcher.ForecastedCompletionDate
			continue
		}
		if f == prefix+"VarianceAmount" {
			patchee.VarianceAmount = patcher.VarianceAmount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListForecast executes a gorm list call
func DefaultListForecast(ctx context.Context, db *gorm.DB) ([]*Forecast, error) {
	in := Forecast{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ForecastORM{}, &Forecast{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ForecastORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ForecastORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Forecast{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ForecastORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ForecastORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ForecastORM) error
}

// DefaultCreateMilestone executes a basic gorm create call
func DefaultCreateMilestone(ctx context.Context, in *Milestone, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MilestoneORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMilestone(ctx context.Context, in *Milestone, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MilestoneORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MilestoneORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MilestoneORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MilestoneORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMilestone(ctx context.Context, in *Milestone, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MilestoneORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MilestoneORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMilestoneSet(ctx context.Context, in []*Milestone, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MilestoneORM{})).(MilestoneORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MilestoneORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MilestoneORM{})).(MilestoneORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MilestoneORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Milestone, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Milestone, *gorm.DB) error
}

// DefaultStrictUpdateMilestone clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMilestone(ctx context.Context, in *Milestone, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMilestone")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MilestoneORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBudget := BudgetORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBudget.MilestoneId = new(uint64)
	*filterBudget.MilestoneId = ormObj.Id
	if err = db.Where(filterBudget).Delete(BudgetORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MilestoneORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMilestone executes a basic gorm update call with patch behavior
func DefaultPatchMilestone(ctx context.Context, in *Milestone, updateMask *field_mask.FieldMask, db *gorm.DB) (*Milestone, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Milestone
	var err error
	if hook, ok := interface{}(&pbObj).(MilestoneWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMilestone(ctx, &Milestone{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MilestoneWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMilestone(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MilestoneWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMilestone(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MilestoneWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MilestoneWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MilestoneWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MilestoneWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MilestoneWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Milestone, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMilestone executes a bulk gorm update call with patch behavior
func DefaultPatchSetMilestone(ctx context.Context, objects []*Milestone, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Milestone, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Milestone, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMilestone(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMilestone patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMilestone(ctx context.Context, patchee *Milestone, patcher *Milestone, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Milestone, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedBudget bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"TargetDate" {
			patchee.TargetDate = patcher.TargetDate
			continue
		}
		if f == prefix+"TargetAmount" {
			patchee.TargetAmount = patcher.TargetAmount
			continue
		}
		if f == prefix+"IsCompleted" {
			patchee.IsCompleted = patcher.IsCompleted
			continue
		}
		if !updatedBudget && strings.HasPrefix(f, prefix+"Budget.") {
			updatedBudget = true
			if patcher.Budget == nil {
				patchee.Budget = nil
				continue
			}
			if patchee.Budget == nil {
				patchee.Budget = &Budget{}
			}
			if o, err := DefaultApplyFieldMaskBudget(ctx, patchee.Budget, patcher.Budget, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Budget.", db); err != nil {
				return nil, err
			} else {
				patchee.Budget = o
			}
			continue
		}
		if f == prefix+"Budget" {
			updatedBudget = true
			patchee.Budget = patcher.Budget
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMilestone executes a gorm list call
func DefaultListMilestone(ctx context.Context, db *gorm.DB) ([]*Milestone, error) {
	in := Milestone{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MilestoneORM{}, &Milestone{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MilestoneORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MilestoneORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Milestone{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MilestoneORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MilestoneORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MilestoneORM) error
}

// DefaultCreateBudget executes a basic gorm create call
func DefaultCreateBudget(ctx context.Context, in *Budget, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BudgetORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBudget(ctx context.Context, in *Budget, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BudgetORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BudgetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BudgetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BudgetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBudget(ctx context.Context, in *Budget, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BudgetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BudgetORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBudgetSet(ctx context.Context, in []*Budget, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BudgetORM{})).(BudgetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BudgetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BudgetORM{})).(BudgetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BudgetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Budget, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Budget, *gorm.DB) error
}

// DefaultStrictUpdateBudget clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBudget(ctx context.Context, in *Budget, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBudget")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BudgetORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCategory := CategoryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCategory.BudgetId = new(uint64)
	*filterCategory.BudgetId = ormObj.Id
	if err = db.Where(filterCategory).Delete(CategoryORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BudgetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBudget executes a basic gorm update call with patch behavior
func DefaultPatchBudget(ctx context.Context, in *Budget, updateMask *field_mask.FieldMask, db *gorm.DB) (*Budget, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Budget
	var err error
	if hook, ok := interface{}(&pbObj).(BudgetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBudget(ctx, &Budget{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BudgetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBudget(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BudgetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBudget(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BudgetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BudgetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BudgetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BudgetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BudgetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Budget, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBudget executes a bulk gorm update call with patch behavior
func DefaultPatchSetBudget(ctx context.Context, objects []*Budget, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Budget, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Budget, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBudget(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBudget patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBudget(ctx context.Context, patchee *Budget, patcher *Budget, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Budget, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCategory bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if !updatedCategory && strings.HasPrefix(f, prefix+"Category.") {
			updatedCategory = true
			if patcher.Category == nil {
				patchee.Category = nil
				continue
			}
			if patchee.Category == nil {
				patchee.Category = &Category{}
			}
			if o, err := DefaultApplyFieldMaskCategory(ctx, patchee.Category, patcher.Category, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Category.", db); err != nil {
				return nil, err
			} else {
				patchee.Category = o
			}
			continue
		}
		if f == prefix+"Category" {
			updatedCategory = true
			patchee.Category = patcher.Category
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBudget executes a gorm list call
func DefaultListBudget(ctx context.Context, db *gorm.DB) ([]*Budget, error) {
	in := Budget{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BudgetORM{}, &Budget{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BudgetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BudgetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Budget{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BudgetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BudgetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BudgetORM) error
}

// DefaultCreateCategory executes a basic gorm create call
func DefaultCreateCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CategoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CategoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CategoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CategoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCategory(ctx context.Context, in *Category, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CategoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCategorySet(ctx context.Context, in []*Category, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CategoryORM{})).(CategoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CategoryORM{})).(CategoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CategoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Category, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Category, *gorm.DB) error
}

// DefaultStrictUpdateCategory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCategory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CategoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CategoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCategory executes a basic gorm update call with patch behavior
func DefaultPatchCategory(ctx context.Context, in *Category, updateMask *field_mask.FieldMask, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Category
	var err error
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCategory(ctx, &Category{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCategory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCategory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CategoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CategoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCategory executes a bulk gorm update call with patch behavior
func DefaultPatchSetCategory(ctx context.Context, objects []*Category, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Category, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Category, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCategory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCategory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategory(ctx context.Context, patchee *Category, patcher *Category, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Category, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Subcategories" {
			patchee.Subcategories = patcher.Subcategories
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategory executes a gorm list call
func DefaultListCategory(ctx context.Context, db *gorm.DB) ([]*Category, error) {
	in := Category{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryORM{}, &Category{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CategoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Category{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryORM) error
}

// DefaultCreateInvesmentHolding executes a basic gorm create call
func DefaultCreateInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvesmentHoldingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvesmentHoldingORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvesmentHoldingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvesmentHoldingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvesmentHoldingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvesmentHoldingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvesmentHoldingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvesmentHoldingSet(ctx context.Context, in []*InvesmentHolding, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvesmentHoldingORM{})).(InvesmentHoldingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvesmentHoldingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvesmentHoldingORM{})).(InvesmentHoldingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvesmentHoldingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvesmentHolding, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvesmentHolding, *gorm.DB) error
}

// DefaultStrictUpdateInvesmentHolding clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvesmentHolding(ctx context.Context, in *InvesmentHolding, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvesmentHolding")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvesmentHoldingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvesmentHoldingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvesmentHolding executes a basic gorm update call with patch behavior
func DefaultPatchInvesmentHolding(ctx context.Context, in *InvesmentHolding, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvesmentHolding, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvesmentHolding
	var err error
	if hook, ok := interface{}(&pbObj).(InvesmentHoldingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvesmentHolding(ctx, &InvesmentHolding{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvesmentHoldingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvesmentHolding(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvesmentHoldingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvesmentHolding(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvesmentHoldingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvesmentHoldingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvesmentHolding, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvesmentHolding executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvesmentHolding(ctx context.Context, objects []*InvesmentHolding, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvesmentHolding, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvesmentHolding, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvesmentHolding(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvesmentHolding patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvesmentHolding(ctx context.Context, patchee *InvesmentHolding, patcher *InvesmentHolding, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvesmentHolding, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"PlaidAccountId" {
			patchee.PlaidAccountId = patcher.PlaidAccountId
			continue
		}
		if f == prefix+"CostBasis" {
			patchee.CostBasis = patcher.CostBasis
			continue
		}
		if f == prefix+"InstitutionPrice" {
			patchee.InstitutionPrice = patcher.InstitutionPrice
			continue
		}
		if f == prefix+"InstitutionPriceAsOf" {
			patchee.InstitutionPriceAsOf = patcher.InstitutionPriceAsOf
			continue
		}
		if f == prefix+"InstitutionPriceDatetime" {
			patchee.InstitutionPriceDatetime = patcher.InstitutionPriceDatetime
			continue
		}
		if f == prefix+"InstitutionValue" {
			patchee.InstitutionValue = patcher.InstitutionValue
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvesmentHolding executes a gorm list call
func DefaultListInvesmentHolding(ctx context.Context, db *gorm.DB) ([]*InvesmentHolding, error) {
	in := InvesmentHolding{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvesmentHoldingORM{}, &InvesmentHolding{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvesmentHoldingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvesmentHoldingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvesmentHolding{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvesmentHoldingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvesmentHoldingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvesmentHoldingORM) error
}

// DefaultCreateInvestmentSecurity executes a basic gorm create call
func DefaultCreateInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentSecurityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvestmentSecurityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestmentSecurityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestmentSecurityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentSecurityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestmentSecurityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestmentSecurityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvestmentSecuritySet(ctx context.Context, in []*InvestmentSecurity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestmentSecurityORM{})).(InvestmentSecurityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestmentSecurityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestmentSecurityORM{})).(InvestmentSecurityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestmentSecurityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestmentSecurity, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestmentSecurity, *gorm.DB) error
}

// DefaultStrictUpdateInvestmentSecurity clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestmentSecurity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestmentSecurityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestmentSecurityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvestmentSecurity executes a basic gorm update call with patch behavior
func DefaultPatchInvestmentSecurity(ctx context.Context, in *InvestmentSecurity, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvestmentSecurity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvestmentSecurity
	var err error
	if hook, ok := interface{}(&pbObj).(InvestmentSecurityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestmentSecurity(ctx, &InvestmentSecurity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestmentSecurityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestmentSecurity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestmentSecurityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestmentSecurity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestmentSecurityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestmentSecurityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestmentSecurity, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvestmentSecurity executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestmentSecurity(ctx context.Context, objects []*InvestmentSecurity, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvestmentSecurity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestmentSecurity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestmentSecurity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestmentSecurity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestmentSecurity(ctx context.Context, patchee *InvestmentSecurity, patcher *InvestmentSecurity, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvestmentSecurity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ClosePrice" {
			patchee.ClosePrice = patcher.ClosePrice
			continue
		}
		if f == prefix+"ClosePriceAsOf" {
			patchee.ClosePriceAsOf = patcher.ClosePriceAsOf
			continue
		}
		if f == prefix+"Cusip" {
			patchee.Cusip = patcher.Cusip
			continue
		}
		if f == prefix+"InstitutionId" {
			patchee.InstitutionId = patcher.InstitutionId
			continue
		}
		if f == prefix+"InstitutionSecurityId" {
			patchee.InstitutionSecurityId = patcher.InstitutionSecurityId
			continue
		}
		if f == prefix+"IsCashEquivalent" {
			patchee.IsCashEquivalent = patcher.IsCashEquivalent
			continue
		}
		if f == prefix+"Isin" {
			patchee.Isin = patcher.Isin
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"ProxySecurityId" {
			patchee.ProxySecurityId = patcher.ProxySecurityId
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"Sedol" {
			patchee.Sedol = patcher.Sedol
			continue
		}
		if f == prefix+"TickerSymbol" {
			patchee.TickerSymbol = patcher.TickerSymbol
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"UpdateDatetime" {
			patchee.UpdateDatetime = patcher.UpdateDatetime
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestmentSecurity executes a gorm list call
func DefaultListInvestmentSecurity(ctx context.Context, db *gorm.DB) ([]*InvestmentSecurity, error) {
	in := InvestmentSecurity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvestmentSecurityORM{}, &InvestmentSecurity{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestmentSecurityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentSecurityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestmentSecurity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentSecurityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvestmentSecurityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvestmentSecurityORM) error
}

// DefaultCreateApr executes a basic gorm create call
func DefaultCreateApr(ctx context.Context, in *Apr, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AprORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadApr(ctx context.Context, in *Apr, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AprORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AprORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AprORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AprORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteApr(ctx context.Context, in *Apr, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AprORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AprORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAprSet(ctx context.Context, in []*Apr, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AprORM{})).(AprORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AprORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AprORM{})).(AprORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AprORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Apr, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Apr, *gorm.DB) error
}

// DefaultStrictUpdateApr clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateApr(ctx context.Context, in *Apr, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateApr")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AprORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AprORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchApr executes a basic gorm update call with patch behavior
func DefaultPatchApr(ctx context.Context, in *Apr, updateMask *field_mask.FieldMask, db *gorm.DB) (*Apr, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Apr
	var err error
	if hook, ok := interface{}(&pbObj).(AprWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadApr(ctx, &Apr{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AprWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskApr(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AprWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateApr(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AprWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AprWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AprWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AprWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AprWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Apr, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetApr executes a bulk gorm update call with patch behavior
func DefaultPatchSetApr(ctx context.Context, objects []*Apr, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Apr, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Apr, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchApr(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskApr patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskApr(ctx context.Context, patchee *Apr, patcher *Apr, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Apr, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Percentage" {
			patchee.Percentage = patcher.Percentage
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"BalanceSubjectToApr" {
			patchee.BalanceSubjectToApr = patcher.BalanceSubjectToApr
			continue
		}
		if f == prefix+"InterestChargeAmount" {
			patchee.InterestChargeAmount = patcher.InterestChargeAmount
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListApr executes a gorm list call
func DefaultListApr(ctx context.Context, db *gorm.DB) ([]*Apr, error) {
	in := Apr{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AprORM{}, &Apr{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AprORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AprORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Apr{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AprORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AprORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AprORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Street_1" {
			patchee.Street_1 = patcher.Street_1
			continue
		}
		if f == prefix+"Street_2" {
			patchee.Street_2 = patcher.Street_2
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"CountrySubdivision" {
			patchee.CountrySubdivision = patcher.CountrySubdivision
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreatePlaidAccountInvestmentTransaction executes a basic gorm create call
func DefaultCreatePlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountInvestmentTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidAccountInvestmentTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidAccountInvestmentTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidAccountInvestmentTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountInvestmentTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidAccountInvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidAccountInvestmentTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountInvestmentTransactionSet(ctx context.Context, in []*PlaidAccountInvestmentTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidAccountInvestmentTransactionORM{})).(PlaidAccountInvestmentTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidAccountInvestmentTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidAccountInvestmentTransactionORM{})).(PlaidAccountInvestmentTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidAccountInvestmentTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidAccountInvestmentTransaction, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidAccountInvestmentTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePlaidAccountInvestmentTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidAccountInvestmentTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidAccountInvestmentTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.PlaidAccountInvestmentTransactionId = new(uint64)
	*filterNotes.PlaidAccountInvestmentTransactionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidAccountInvestmentTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPlaidAccountInvestmentTransaction(ctx context.Context, in *PlaidAccountInvestmentTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidAccountInvestmentTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidAccountInvestmentTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidAccountInvestmentTransaction(ctx, &PlaidAccountInvestmentTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidAccountInvestmentTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidAccountInvestmentTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidAccountInvestmentTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidAccountInvestmentTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidAccountInvestmentTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidAccountInvestmentTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidAccountInvestmentTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidAccountInvestmentTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidAccountInvestmentTransaction(ctx context.Context, objects []*PlaidAccountInvestmentTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidAccountInvestmentTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidAccountInvestmentTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidAccountInvestmentTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidAccountInvestmentTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidAccountInvestmentTransaction(ctx context.Context, patchee *PlaidAccountInvestmentTransaction, patcher *PlaidAccountInvestmentTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidAccountInvestmentTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Ammount" {
			patchee.Ammount = patcher.Ammount
			continue
		}
		if f == prefix+"InvestmentTransactionId" {
			patchee.InvestmentTransactionId = patcher.InvestmentTransactionId
			continue
		}
		if f == prefix+"SecurityId" {
			patchee.SecurityId = patcher.SecurityId
			continue
		}
		if f == prefix+"CurrentDate" {
			patchee.CurrentDate = patcher.CurrentDate
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Fees" {
			patchee.Fees = patcher.Fees
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Subtype" {
			patchee.Subtype = patcher.Subtype
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidAccountInvestmentTransaction executes a gorm list call
func DefaultListPlaidAccountInvestmentTransaction(ctx context.Context, db *gorm.DB) ([]*PlaidAccountInvestmentTransaction, error) {
	in := PlaidAccountInvestmentTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidAccountInvestmentTransactionORM{}, &PlaidAccountInvestmentTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidAccountInvestmentTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountInvestmentTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidAccountInvestmentTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidAccountInvestmentTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountInvestmentTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidAccountInvestmentTransactionORM) error
}

// DefaultCreatePlaidAccountRecurringTransaction executes a basic gorm create call
func DefaultCreatePlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountRecurringTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidAccountRecurringTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidAccountRecurringTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidAccountRecurringTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountRecurringTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidAccountRecurringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidAccountRecurringTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountRecurringTransactionSet(ctx context.Context, in []*PlaidAccountRecurringTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidAccountRecurringTransactionORM{})).(PlaidAccountRecurringTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidAccountRecurringTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidAccountRecurringTransactionORM{})).(PlaidAccountRecurringTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidAccountRecurringTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidAccountRecurringTransaction, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidAccountRecurringTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePlaidAccountRecurringTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidAccountRecurringTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidAccountRecurringTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.PlaidAccountRecurringTransactionId = new(uint64)
	*filterNotes.PlaidAccountRecurringTransactionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidAccountRecurringTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPlaidAccountRecurringTransaction(ctx context.Context, in *PlaidAccountRecurringTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidAccountRecurringTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidAccountRecurringTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidAccountRecurringTransaction(ctx, &PlaidAccountRecurringTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidAccountRecurringTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidAccountRecurringTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidAccountRecurringTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidAccountRecurringTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidAccountRecurringTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidAccountRecurringTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidAccountRecurringTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidAccountRecurringTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidAccountRecurringTransaction(ctx context.Context, objects []*PlaidAccountRecurringTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidAccountRecurringTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidAccountRecurringTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidAccountRecurringTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidAccountRecurringTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidAccountRecurringTransaction(ctx context.Context, patchee *PlaidAccountRecurringTransaction, patcher *PlaidAccountRecurringTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidAccountRecurringTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedFirstDate bool
	var updatedLastDate bool
	var updatedUpdatedTime bool
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"StreamId" {
			patchee.StreamId = patcher.StreamId
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if !updatedFirstDate && strings.HasPrefix(f, prefix+"FirstDate.") {
			if patcher.FirstDate == nil {
				patchee.FirstDate = nil
				continue
			}
			if patchee.FirstDate == nil {
				patchee.FirstDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FirstDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.FirstDate, patchee.FirstDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FirstDate" {
			updatedFirstDate = true
			patchee.FirstDate = patcher.FirstDate
			continue
		}
		if !updatedLastDate && strings.HasPrefix(f, prefix+"LastDate.") {
			if patcher.LastDate == nil {
				patchee.LastDate = nil
				continue
			}
			if patchee.LastDate == nil {
				patchee.LastDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastDate, patchee.LastDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastDate" {
			updatedLastDate = true
			patchee.LastDate = patcher.LastDate
			continue
		}
		if f == prefix+"Frequency" {
			patchee.Frequency = patcher.Frequency
			continue
		}
		if f == prefix+"TransactionIds" {
			patchee.TransactionIds = patcher.TransactionIds
			continue
		}
		if f == prefix+"AverageAmount" {
			patchee.AverageAmount = patcher.AverageAmount
			continue
		}
		if f == prefix+"AverageAmountIsoCurrencyCode" {
			patchee.AverageAmountIsoCurrencyCode = patcher.AverageAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"LastAmount" {
			patchee.LastAmount = patcher.LastAmount
			continue
		}
		if f == prefix+"LastAmountIsoCurrencyCode" {
			patchee.LastAmountIsoCurrencyCode = patcher.LastAmountIsoCurrencyCode
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedUpdatedTime && strings.HasPrefix(f, prefix+"UpdatedTime.") {
			if patcher.UpdatedTime == nil {
				patchee.UpdatedTime = nil
				continue
			}
			if patchee.UpdatedTime == nil {
				patchee.UpdatedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedTime, patchee.UpdatedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedTime" {
			updatedUpdatedTime = true
			patchee.UpdatedTime = patcher.UpdatedTime
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Flow" {
			patchee.Flow = patcher.Flow
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidAccountRecurringTransaction executes a gorm list call
func DefaultListPlaidAccountRecurringTransaction(ctx context.Context, db *gorm.DB) ([]*PlaidAccountRecurringTransaction, error) {
	in := PlaidAccountRecurringTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidAccountRecurringTransactionORM{}, &PlaidAccountRecurringTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidAccountRecurringTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountRecurringTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidAccountRecurringTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidAccountRecurringTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountRecurringTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidAccountRecurringTransactionORM) error
}

// DefaultCreatePlaidAccountTransaction executes a basic gorm create call
func DefaultCreatePlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PlaidAccountTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PlaidAccountTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PlaidAccountTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PlaidAccountTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PlaidAccountTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PlaidAccountTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePlaidAccountTransactionSet(ctx context.Context, in []*PlaidAccountTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PlaidAccountTransactionORM{})).(PlaidAccountTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PlaidAccountTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PlaidAccountTransactionORM{})).(PlaidAccountTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PlaidAccountTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PlaidAccountTransaction, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PlaidAccountTransaction, *gorm.DB) error
}

// DefaultStrictUpdatePlaidAccountTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePlaidAccountTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PlaidAccountTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotes := SmartNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotes.PlaidAccountTransactionId = new(uint64)
	*filterNotes.PlaidAccountTransactionId = ormObj.Id
	if err = db.Where(filterNotes).Delete(SmartNoteORM{}).Error; err != nil {
		return nil, err
	}
	filterSplits := TransactionSplitORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSplits.PlaidAccountTransactionId = new(uint64)
	*filterSplits.PlaidAccountTransactionId = ormObj.Id
	if err = db.Where(filterSplits).Delete(TransactionSplitORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PlaidAccountTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPlaidAccountTransaction executes a basic gorm update call with patch behavior
func DefaultPatchPlaidAccountTransaction(ctx context.Context, in *PlaidAccountTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PlaidAccountTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(PlaidAccountTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPlaidAccountTransaction(ctx, &PlaidAccountTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PlaidAccountTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPlaidAccountTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PlaidAccountTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePlaidAccountTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PlaidAccountTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PlaidAccountTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PlaidAccountTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPlaidAccountTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetPlaidAccountTransaction(ctx context.Context, objects []*PlaidAccountTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PlaidAccountTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PlaidAccountTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPlaidAccountTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPlaidAccountTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPlaidAccountTransaction(ctx context.Context, patchee *PlaidAccountTransaction, patcher *PlaidAccountTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PlaidAccountTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCurrentDate bool
	var updatedCurrentDatetime bool
	var updatedAuthorizedDate bool
	var updatedAuthorizedDatetime bool
	var updatedTime bool
	var updatedAdditionalProperties bool
	for i, f := range updateMask.Paths {
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"IsoCurrencyCode" {
			patchee.IsoCurrencyCode = patcher.IsoCurrencyCode
			continue
		}
		if f == prefix+"UnofficialCurrencyCode" {
			patchee.UnofficialCurrencyCode = patcher.UnofficialCurrencyCode
			continue
		}
		if f == prefix+"TransactionId" {
			patchee.TransactionId = patcher.TransactionId
			continue
		}
		if f == prefix+"TransactionCode" {
			patchee.TransactionCode = patcher.TransactionCode
			continue
		}
		if !updatedCurrentDate && strings.HasPrefix(f, prefix+"CurrentDate.") {
			if patcher.CurrentDate == nil {
				patchee.CurrentDate = nil
				continue
			}
			if patchee.CurrentDate == nil {
				patchee.CurrentDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CurrentDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CurrentDate, patchee.CurrentDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CurrentDate" {
			updatedCurrentDate = true
			patchee.CurrentDate = patcher.CurrentDate
			continue
		}
		if !updatedCurrentDatetime && strings.HasPrefix(f, prefix+"CurrentDatetime.") {
			if patcher.CurrentDatetime == nil {
				patchee.CurrentDatetime = nil
				continue
			}
			if patchee.CurrentDatetime == nil {
				patchee.CurrentDatetime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CurrentDatetime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CurrentDatetime, patchee.CurrentDatetime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CurrentDatetime" {
			updatedCurrentDatetime = true
			patchee.CurrentDatetime = patcher.CurrentDatetime
			continue
		}
		if !updatedAuthorizedDate && strings.HasPrefix(f, prefix+"AuthorizedDate.") {
			if patcher.AuthorizedDate == nil {
				patchee.AuthorizedDate = nil
				continue
			}
			if patchee.AuthorizedDate == nil {
				patchee.AuthorizedDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDate, patchee.AuthorizedDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDate" {
			updatedAuthorizedDate = true
			patchee.AuthorizedDate = patcher.AuthorizedDate
			continue
		}
		if !updatedAuthorizedDatetime && strings.HasPrefix(f, prefix+"AuthorizedDatetime.") {
			if patcher.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = nil
				continue
			}
			if patchee.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDatetime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDatetime, patchee.AuthorizedDatetime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDatetime" {
			updatedAuthorizedDatetime = true
			patchee.AuthorizedDatetime = patcher.AuthorizedDatetime
			continue
		}
		if f == prefix+"CategoryId" {
			patchee.CategoryId = patcher.CategoryId
			continue
		}
		if f == prefix+"Categories" {
			patchee.Categories = patcher.Categories
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"TransactionName" {
			patchee.TransactionName = patcher.TransactionName
			continue
		}
		if f == prefix+"MerchantName" {
			patchee.MerchantName = patcher.MerchantName
			continue
		}
		if f == prefix+"CheckNumber" {
			patchee.CheckNumber = patcher.CheckNumber
			continue
		}
		if f == prefix+"PaymentChannel" {
			patchee.PaymentChannel = patcher.PaymentChannel
			continue
		}
		if f == prefix+"Pending" {
			patchee.Pending = patcher.Pending
			continue
		}
		if f == prefix+"PendingTransactionId" {
			patchee.PendingTransactionId = patcher.PendingTransactionId
			continue
		}
		if f == prefix+"AccountOwner" {
			patchee.AccountOwner = patcher.AccountOwner
			continue
		}
		if f == prefix+"PaymentMetaByOrderOf" {
			patchee.PaymentMetaByOrderOf = patcher.PaymentMetaByOrderOf
			continue
		}
		if f == prefix+"PaymentMetaPayee" {
			patchee.PaymentMetaPayee = patcher.PaymentMetaPayee
			continue
		}
		if f == prefix+"PaymentMetaPayer" {
			patchee.PaymentMetaPayer = patcher.PaymentMetaPayer
			continue
		}
		if f == prefix+"PaymentMetaPaymentMethod" {
			patchee.PaymentMetaPaymentMethod = patcher.PaymentMetaPaymentMethod
			continue
		}
		if f == prefix+"PaymentMetaPaymentProcessor" {
			patchee.PaymentMetaPaymentProcessor = patcher.PaymentMetaPaymentProcessor
			continue
		}
		if f == prefix+"PaymentMetaPpdId" {
			patchee.PaymentMetaPpdId = patcher.PaymentMetaPpdId
			continue
		}
		if f == prefix+"PaymentMetaReason" {
			patchee.PaymentMetaReason = patcher.PaymentMetaReason
			continue
		}
		if f == prefix+"PaymentMetaReferenceNumber" {
			patchee.PaymentMetaReferenceNumber = patcher.PaymentMetaReferenceNumber
			continue
		}
		if f == prefix+"LocationAddress" {
			patchee.LocationAddress = patcher.LocationAddress
			continue
		}
		if f == prefix+"LocationCity" {
			patchee.LocationCity = patcher.LocationCity
			continue
		}
		if f == prefix+"LocationRegion" {
			patchee.LocationRegion = patcher.LocationRegion
			continue
		}
		if f == prefix+"LocationPostalCode" {
			patchee.LocationPostalCode = patcher.LocationPostalCode
			continue
		}
		if f == prefix+"LocationCountry" {
			patchee.LocationCountry = patcher.LocationCountry
			continue
		}
		if f == prefix+"LocationLat" {
			patchee.LocationLat = patcher.LocationLat
			continue
		}
		if f == prefix+"LocationLon" {
			patchee.LocationLon = patcher.LocationLon
			continue
		}
		if f == prefix+"LocationStoreNumber" {
			patchee.LocationStoreNumber = patcher.LocationStoreNumber
			continue
		}
		if !updatedTime && strings.HasPrefix(f, prefix+"Time.") {
			if patcher.Time == nil {
				patchee.Time = nil
				continue
			}
			if patchee.Time == nil {
				patchee.Time = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Time."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Time, patchee.Time, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Time" {
			updatedTime = true
			patchee.Time = patcher.Time
			continue
		}
		if !updatedAdditionalProperties && strings.HasPrefix(f, prefix+"AdditionalProperties.") {
			if patcher.AdditionalProperties == nil {
				patchee.AdditionalProperties = nil
				continue
			}
			if patchee.AdditionalProperties == nil {
				patchee.AdditionalProperties = &anypb.Any{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AdditionalProperties."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AdditionalProperties, patchee.AdditionalProperties, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AdditionalProperties" {
			updatedAdditionalProperties = true
			patchee.AdditionalProperties = patcher.AdditionalProperties
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"NeedsReview" {
			patchee.NeedsReview = patcher.NeedsReview
			continue
		}
		if f == prefix+"HideTransaction" {
			patchee.HideTransaction = patcher.HideTransaction
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Notes" {
			patchee.Notes = patcher.Notes
			continue
		}
		if f == prefix+"Splits" {
			patchee.Splits = patcher.Splits
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPlaidAccountTransaction executes a gorm list call
func DefaultListPlaidAccountTransaction(ctx context.Context, db *gorm.DB) ([]*PlaidAccountTransaction, error) {
	in := PlaidAccountTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PlaidAccountTransactionORM{}, &PlaidAccountTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PlaidAccountTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PlaidAccountTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PlaidAccountTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PlaidAccountTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PlaidAccountTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PlaidAccountTransactionORM) error
}

// DefaultCreateTransactionSplit executes a basic gorm create call
func DefaultCreateTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionSplitORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionSplitORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionSplitORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionSplitORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionSplitORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionSplitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionSplitORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionSplitSet(ctx context.Context, in []*TransactionSplit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionSplitORM{})).(TransactionSplitORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionSplitORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionSplitORM{})).(TransactionSplitORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionSplitORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionSplit, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionSplit, *gorm.DB) error
}

// DefaultStrictUpdateTransactionSplit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionSplit(ctx context.Context, in *TransactionSplit, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionSplit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionSplitORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionSplitORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionSplit executes a basic gorm update call with patch behavior
func DefaultPatchTransactionSplit(ctx context.Context, in *TransactionSplit, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionSplit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionSplit
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionSplitWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionSplit(ctx, &TransactionSplit{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionSplitWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionSplit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionSplitWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionSplit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionSplitWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionSplitWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionSplit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionSplit executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionSplit(ctx context.Context, objects []*TransactionSplit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionSplit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionSplit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionSplit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionSplit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionSplit(ctx context.Context, patchee *TransactionSplit, patcher *TransactionSplit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionSplit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAuthorizedDate bool
	var updatedAuthorizedDatetime bool
	var updatedTimeOfSplit bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"LinkId" {
			patchee.LinkId = patcher.LinkId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Categories" {
			patchee.Categories = patcher.Categories
			continue
		}
		if f == prefix+"PersonalFinanceCategoryPrimary" {
			patchee.PersonalFinanceCategoryPrimary = patcher.PersonalFinanceCategoryPrimary
			continue
		}
		if f == prefix+"PersonalFinanceCategoryDetailed" {
			patchee.PersonalFinanceCategoryDetailed = patcher.PersonalFinanceCategoryDetailed
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedAuthorizedDate && strings.HasPrefix(f, prefix+"AuthorizedDate.") {
			if patcher.AuthorizedDate == nil {
				patchee.AuthorizedDate = nil
				continue
			}
			if patchee.AuthorizedDate == nil {
				patchee.AuthorizedDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDate, patchee.AuthorizedDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDate" {
			updatedAuthorizedDate = true
			patchee.AuthorizedDate = patcher.AuthorizedDate
			continue
		}
		if !updatedAuthorizedDatetime && strings.HasPrefix(f, prefix+"AuthorizedDatetime.") {
			if patcher.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = nil
				continue
			}
			if patchee.AuthorizedDatetime == nil {
				patchee.AuthorizedDatetime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AuthorizedDatetime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AuthorizedDatetime, patchee.AuthorizedDatetime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AuthorizedDatetime" {
			updatedAuthorizedDatetime = true
			patchee.AuthorizedDatetime = patcher.AuthorizedDatetime
			continue
		}
		if !updatedTimeOfSplit && strings.HasPrefix(f, prefix+"TimeOfSplit.") {
			if patcher.TimeOfSplit == nil {
				patchee.TimeOfSplit = nil
				continue
			}
			if patchee.TimeOfSplit == nil {
				patchee.TimeOfSplit = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TimeOfSplit."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TimeOfSplit, patchee.TimeOfSplit, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TimeOfSplit" {
			updatedTimeOfSplit = true
			patchee.TimeOfSplit = patcher.TimeOfSplit
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionSplit executes a gorm list call
func DefaultListTransactionSplit(ctx context.Context, db *gorm.DB) ([]*TransactionSplit, error) {
	in := TransactionSplit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionSplitORM{}, &TransactionSplit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionSplitORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionSplitORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionSplit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionSplitORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionSplitORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionSplitORM) error
}
