// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: accounting_service/v1/database_schema.proto

package accounting_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on BusinessAccountingProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessAccountingProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessAccountingProfile with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessAccountingProfileMultiError, or nil if none found.
func (m *BusinessAccountingProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessAccountingProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.GetUserId() <= 0 {
		err := BusinessAccountingProfileValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CompanyName

	// no validation rules for Email

	for idx, item := range m.GetMergeLiink() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BusinessAccountingProfileValidationError{
						field:  fmt.Sprintf("MergeLiink[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BusinessAccountingProfileValidationError{
						field:  fmt.Sprintf("MergeLiink[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BusinessAccountingProfileValidationError{
					field:  fmt.Sprintf("MergeLiink[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetActionablePersonalInsights() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BusinessAccountingProfileValidationError{
						field:  fmt.Sprintf("ActionablePersonalInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BusinessAccountingProfileValidationError{
						field:  fmt.Sprintf("ActionablePersonalInsights[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BusinessAccountingProfileValidationError{
					field:  fmt.Sprintf("ActionablePersonalInsights[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BusinessAccountingProfileMultiError(errors)
	}

	return nil
}

// BusinessAccountingProfileMultiError is an error wrapping multiple validation
// errors returned by BusinessAccountingProfile.ValidateAll() if the
// designated constraints aren't met.
type BusinessAccountingProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessAccountingProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessAccountingProfileMultiError) AllErrors() []error { return m }

// BusinessAccountingProfileValidationError is the validation error returned by
// BusinessAccountingProfile.Validate if the designated constraints aren't met.
type BusinessAccountingProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessAccountingProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessAccountingProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessAccountingProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessAccountingProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessAccountingProfileValidationError) ErrorName() string {
	return "BusinessAccountingProfileValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessAccountingProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessAccountingProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessAccountingProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessAccountingProfileValidationError{}

// Validate checks the field values on BusinessActionableInsight with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessActionableInsight) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessActionableInsight with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessActionableInsightMultiError, or nil if none found.
func (m *BusinessActionableInsight) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessActionableInsight) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InsightName

	// no validation rules for Description

	// no validation rules for Takeaway

	// no validation rules for Action

	// no validation rules for ExpectedBenefit

	if all {
		switch v := interface{}(m.GetGeneratedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessActionableInsightValidationError{
					field:  "GeneratedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeneratedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessActionableInsightValidationError{
				field:  "GeneratedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BusinessActionableInsightMultiError(errors)
	}

	return nil
}

// BusinessActionableInsightMultiError is an error wrapping multiple validation
// errors returned by BusinessActionableInsight.ValidateAll() if the
// designated constraints aren't met.
type BusinessActionableInsightMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessActionableInsightMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessActionableInsightMultiError) AllErrors() []error { return m }

// BusinessActionableInsightValidationError is the validation error returned by
// BusinessActionableInsight.Validate if the designated constraints aren't met.
type BusinessActionableInsightValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessActionableInsightValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessActionableInsightValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessActionableInsightValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessActionableInsightValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessActionableInsightValidationError) ErrorName() string {
	return "BusinessActionableInsightValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessActionableInsightValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessActionableInsight.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessActionableInsightValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessActionableInsightValidationError{}

// Validate checks the field values on MergeLinkedAccountToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MergeLinkedAccountToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeLinkedAccountToken with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MergeLinkedAccountTokenMultiError, or nil if none found.
func (m *MergeLinkedAccountToken) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeLinkedAccountToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ItemId

	// no validation rules for KeyId

	// no validation rules for AccessToken

	// no validation rules for Version

	// no validation rules for MergeEndUserOriginId

	// no validation rules for MergeIntegrationSlug

	if all {
		switch v := interface{}(m.GetLastMergeCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeLinkedAccountTokenValidationError{
					field:  "LastMergeCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeLinkedAccountTokenValidationError{
					field:  "LastMergeCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastMergeCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeLinkedAccountTokenValidationError{
				field:  "LastMergeCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MergeLinkedAccountTokenMultiError(errors)
	}

	return nil
}

// MergeLinkedAccountTokenMultiError is an error wrapping multiple validation
// errors returned by MergeLinkedAccountToken.ValidateAll() if the designated
// constraints aren't met.
type MergeLinkedAccountTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeLinkedAccountTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeLinkedAccountTokenMultiError) AllErrors() []error { return m }

// MergeLinkedAccountTokenValidationError is the validation error returned by
// MergeLinkedAccountToken.Validate if the designated constraints aren't met.
type MergeLinkedAccountTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeLinkedAccountTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeLinkedAccountTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeLinkedAccountTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeLinkedAccountTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeLinkedAccountTokenValidationError) ErrorName() string {
	return "MergeLinkedAccountTokenValidationError"
}

// Error satisfies the builtin error interface
func (e MergeLinkedAccountTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeLinkedAccountToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeLinkedAccountTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeLinkedAccountTokenValidationError{}

// Validate checks the field values on Category with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Category) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Category with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CategoryMultiError, or nil
// if none found.
func (m *Category) ValidateAll() error {
	return m.validate(true)
}

func (m *Category) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(m.GetName()) < 3 {
		err := CategoryValidationError{
			field:  "Name",
			reason: "value length must be at least 3 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetDescription()) < 10 {
		err := CategoryValidationError{
			field:  "Description",
			reason: "value length must be at least 10 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CategoryMultiError(errors)
	}

	return nil
}

// CategoryMultiError is an error wrapping multiple validation errors returned
// by Category.ValidateAll() if the designated constraints aren't met.
type CategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoryMultiError) AllErrors() []error { return m }

// CategoryValidationError is the validation error returned by
// Category.Validate if the designated constraints aren't met.
type CategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoryValidationError) ErrorName() string { return "CategoryValidationError" }

// Error satisfies the builtin error interface
func (e CategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoryValidationError{}

// Validate checks the field values on MergeLink with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MergeLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeLink with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MergeLinkMultiError, or nil
// if none found.
func (m *MergeLink) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Integration

	// no validation rules for IntegrationSlug

	// no validation rules for Category

	// no validation rules for EndUserOriginId

	// no validation rules for EndUserOrganizationName

	// no validation rules for EndUserEmailAddress

	// no validation rules for Status

	// no validation rules for WebhookListenerUrl

	// no validation rules for IsDuplicate

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeLinkValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IntegrationName

	// no validation rules for IntegrationImage

	// no validation rules for IntegrationSquareImage

	for idx, item := range m.GetAccount() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeLinkValidationError{
						field:  fmt.Sprintf("Account[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeLinkValidationError{
						field:  fmt.Sprintf("Account[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeLinkValidationError{
					field:  fmt.Sprintf("Account[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MergeLinkedAccountId

	if all {
		switch v := interface{}(m.GetLastModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeLinkValidationError{
					field:  "LastModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeLinkValidationError{
					field:  "LastModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeLinkValidationError{
				field:  "LastModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MergeLinkMultiError(errors)
	}

	return nil
}

// MergeLinkMultiError is an error wrapping multiple validation errors returned
// by MergeLink.ValidateAll() if the designated constraints aren't met.
type MergeLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeLinkMultiError) AllErrors() []error { return m }

// MergeLinkValidationError is the validation error returned by
// MergeLink.Validate if the designated constraints aren't met.
type MergeLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeLinkValidationError) ErrorName() string { return "MergeLinkValidationError" }

// Error satisfies the builtin error interface
func (e MergeLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeLinkValidationError{}

// Validate checks the field values on LinkedAccountingAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LinkedAccountingAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkedAccountingAccount with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinkedAccountingAccountMultiError, or nil if none found.
func (m *LinkedAccountingAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkedAccountingAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCompanyInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CompanyInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CompanyInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("CompanyInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPurchaseOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReportDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReportDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReportDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkedAccountingAccountValidationError{
				field:  "ReportDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReferenceDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReferenceDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "ReferenceDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReferenceDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkedAccountingAccountValidationError{
				field:  "ReferenceDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransactionsDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "TransactionsDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LinkedAccountingAccountValidationError{
					field:  "TransactionsDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionsDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LinkedAccountingAccountValidationError{
				field:  "TransactionsDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LinkedAccountingAccountMultiError(errors)
	}

	return nil
}

// LinkedAccountingAccountMultiError is an error wrapping multiple validation
// errors returned by LinkedAccountingAccount.ValidateAll() if the designated
// constraints aren't met.
type LinkedAccountingAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkedAccountingAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkedAccountingAccountMultiError) AllErrors() []error { return m }

// LinkedAccountingAccountValidationError is the validation error returned by
// LinkedAccountingAccount.Validate if the designated constraints aren't met.
type LinkedAccountingAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkedAccountingAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkedAccountingAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkedAccountingAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkedAccountingAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkedAccountingAccountValidationError) ErrorName() string {
	return "LinkedAccountingAccountValidationError"
}

// Error satisfies the builtin error interface
func (e LinkedAccountingAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkedAccountingAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkedAccountingAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkedAccountingAccountValidationError{}

// Validate checks the field values on TransactionDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionDetailsMultiError, or nil if none found.
func (m *TransactionDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetInvoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Invoices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPayments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Payments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Payments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Payments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Expenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetJournalEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("JournalEntries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("JournalEntries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("JournalEntries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVendorCredits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("VendorCredits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("VendorCredits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("VendorCredits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCreditNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("CreditNotes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("CreditNotes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("CreditNotes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionDetailsMultiError(errors)
	}

	return nil
}

// TransactionDetailsMultiError is an error wrapping multiple validation errors
// returned by TransactionDetails.ValidateAll() if the designated constraints
// aren't met.
type TransactionDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionDetailsMultiError) AllErrors() []error { return m }

// TransactionDetailsValidationError is the validation error returned by
// TransactionDetails.Validate if the designated constraints aren't met.
type TransactionDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionDetailsValidationError) ErrorName() string {
	return "TransactionDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionDetailsValidationError{}

// Validate checks the field values on ReferenceDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReferenceDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferenceDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferenceDetailsMultiError, or nil if none found.
func (m *ReferenceDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferenceDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetChartOfAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTaxRates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("TaxRates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("TaxRates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("TaxRates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetContacts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Contacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReferenceDetailsValidationError{
						field:  fmt.Sprintf("Contacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReferenceDetailsValidationError{
					field:  fmt.Sprintf("Contacts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReferenceDetailsMultiError(errors)
	}

	return nil
}

// ReferenceDetailsMultiError is an error wrapping multiple validation errors
// returned by ReferenceDetails.ValidateAll() if the designated constraints
// aren't met.
type ReferenceDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferenceDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferenceDetailsMultiError) AllErrors() []error { return m }

// ReferenceDetailsValidationError is the validation error returned by
// ReferenceDetails.Validate if the designated constraints aren't met.
type ReferenceDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferenceDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferenceDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferenceDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferenceDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferenceDetailsValidationError) ErrorName() string { return "ReferenceDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ReferenceDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferenceDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferenceDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferenceDetailsValidationError{}

// Validate checks the field values on ReportDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportDetailsMultiError, or
// nil if none found.
func (m *ReportDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetBalanceSheets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("BalanceSheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("BalanceSheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportDetailsValidationError{
					field:  fmt.Sprintf("BalanceSheets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCashFlowStatements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportDetailsValidationError{
					field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIncomeStatements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("IncomeStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportDetailsValidationError{
						field:  fmt.Sprintf("IncomeStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportDetailsValidationError{
					field:  fmt.Sprintf("IncomeStatements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReportDetailsMultiError(errors)
	}

	return nil
}

// ReportDetailsMultiError is an error wrapping multiple validation errors
// returned by ReportDetails.ValidateAll() if the designated constraints
// aren't met.
type ReportDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportDetailsMultiError) AllErrors() []error { return m }

// ReportDetailsValidationError is the validation error returned by
// ReportDetails.Validate if the designated constraints aren't met.
type ReportDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportDetailsValidationError) ErrorName() string { return "ReportDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ReportDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportDetailsValidationError{}

// Validate checks the field values on BusinessChartOfAccounts with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessChartOfAccounts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessChartOfAccounts with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessChartOfAccountsMultiError, or nil if none found.
func (m *BusinessChartOfAccounts) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessChartOfAccounts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Classification

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for CurrentBalance

	// no validation rules for Currency

	// no validation rules for AccountNumber

	// no validation rules for ParentAccountId

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessChartOfAccountsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessChartOfAccountsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessChartOfAccountsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if len(errors) > 0 {
		return BusinessChartOfAccountsMultiError(errors)
	}

	return nil
}

// BusinessChartOfAccountsMultiError is an error wrapping multiple validation
// errors returned by BusinessChartOfAccounts.ValidateAll() if the designated
// constraints aren't met.
type BusinessChartOfAccountsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessChartOfAccountsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessChartOfAccountsMultiError) AllErrors() []error { return m }

// BusinessChartOfAccountsValidationError is the validation error returned by
// BusinessChartOfAccounts.Validate if the designated constraints aren't met.
type BusinessChartOfAccountsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessChartOfAccountsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessChartOfAccountsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessChartOfAccountsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessChartOfAccountsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessChartOfAccountsValidationError) ErrorName() string {
	return "BusinessChartOfAccountsValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessChartOfAccountsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessChartOfAccounts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessChartOfAccountsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessChartOfAccountsValidationError{}

// Validate checks the field values on CompanyAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyAddressMultiError,
// or nil if none found.
func (m *CompanyAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Street_1

	// no validation rules for Street_2

	// no validation rules for City

	// no validation rules for State

	// no validation rules for CountrySubdivision

	// no validation rules for Country

	// no validation rules for ZipCode

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyAddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyAddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyAddressValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompanyAddressMultiError(errors)
	}

	return nil
}

// CompanyAddressMultiError is an error wrapping multiple validation errors
// returned by CompanyAddress.ValidateAll() if the designated constraints
// aren't met.
type CompanyAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyAddressMultiError) AllErrors() []error { return m }

// CompanyAddressValidationError is the validation error returned by
// CompanyAddress.Validate if the designated constraints aren't met.
type CompanyAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyAddressValidationError) ErrorName() string { return "CompanyAddressValidationError" }

// Error satisfies the builtin error interface
func (e CompanyAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyAddressValidationError{}

// Validate checks the field values on Attachments with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Attachments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Attachments with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AttachmentsMultiError, or
// nil if none found.
func (m *Attachments) ValidateAll() error {
	return m.validate(true)
}

func (m *Attachments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	// no validation rules for FileName

	// no validation rules for FileUrl

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AttachmentsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AttachmentsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AttachmentsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AttachmentsMultiError(errors)
	}

	return nil
}

// AttachmentsMultiError is an error wrapping multiple validation errors
// returned by Attachments.ValidateAll() if the designated constraints aren't met.
type AttachmentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttachmentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttachmentsMultiError) AllErrors() []error { return m }

// AttachmentsValidationError is the validation error returned by
// Attachments.Validate if the designated constraints aren't met.
type AttachmentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttachmentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttachmentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttachmentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttachmentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttachmentsValidationError) ErrorName() string { return "AttachmentsValidationError" }

// Error satisfies the builtin error interface
func (e AttachmentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttachments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttachmentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttachmentsValidationError{}

// Validate checks the field values on BalanceSheet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceSheet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceSheet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceSheetMultiError, or
// nil if none found.
func (m *BalanceSheet) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceSheet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetAssets

	for idx, item := range m.GetAssets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Assets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLiabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Liabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Liabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Liabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEquity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Equity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Equity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Equity[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteGeneratedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteGeneratedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "RemoteGeneratedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return BalanceSheetMultiError(errors)
	}

	return nil
}

// BalanceSheetMultiError is an error wrapping multiple validation errors
// returned by BalanceSheet.ValidateAll() if the designated constraints aren't met.
type BalanceSheetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceSheetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceSheetMultiError) AllErrors() []error { return m }

// BalanceSheetValidationError is the validation error returned by
// BalanceSheet.Validate if the designated constraints aren't met.
type BalanceSheetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceSheetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceSheetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceSheetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceSheetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceSheetValidationError) ErrorName() string { return "BalanceSheetValidationError" }

// Error satisfies the builtin error interface
func (e BalanceSheetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceSheet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceSheetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceSheetValidationError{}

// Validate checks the field values on ReportItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportItemMultiError, or
// nil if none found.
func (m *ReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Value

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportItemMultiError(errors)
	}

	return nil
}

// ReportItemMultiError is an error wrapping multiple validation errors
// returned by ReportItem.ValidateAll() if the designated constraints aren't met.
type ReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportItemMultiError) AllErrors() []error { return m }

// ReportItemValidationError is the validation error returned by
// ReportItem.Validate if the designated constraints aren't met.
type ReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportItemValidationError) ErrorName() string { return "ReportItemValidationError" }

// Error satisfies the builtin error interface
func (e ReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportItemValidationError{}

// Validate checks the field values on CashFlowStatements with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CashFlowStatements) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CashFlowStatements with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CashFlowStatementsMultiError, or nil if none found.
func (m *CashFlowStatements) ValidateAll() error {
	return m.validate(true)
}

func (m *CashFlowStatements) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetStartPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "StartPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "EndPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CashAtBeginningOfPeriod

	// no validation rules for CashAtEndOfPeriod

	for idx, item := range m.GetOperatingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("OperatingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("OperatingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementsValidationError{
					field:  fmt.Sprintf("OperatingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvestingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("InvestingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("InvestingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementsValidationError{
					field:  fmt.Sprintf("InvestingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFinancingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("FinancingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementsValidationError{
						field:  fmt.Sprintf("FinancingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementsValidationError{
					field:  fmt.Sprintf("FinancingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteGeneratedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteGeneratedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "RemoteGeneratedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return CashFlowStatementsMultiError(errors)
	}

	return nil
}

// CashFlowStatementsMultiError is an error wrapping multiple validation errors
// returned by CashFlowStatements.ValidateAll() if the designated constraints
// aren't met.
type CashFlowStatementsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CashFlowStatementsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CashFlowStatementsMultiError) AllErrors() []error { return m }

// CashFlowStatementsValidationError is the validation error returned by
// CashFlowStatements.Validate if the designated constraints aren't met.
type CashFlowStatementsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CashFlowStatementsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CashFlowStatementsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CashFlowStatementsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CashFlowStatementsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CashFlowStatementsValidationError) ErrorName() string {
	return "CashFlowStatementsValidationError"
}

// Error satisfies the builtin error interface
func (e CashFlowStatementsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCashFlowStatements.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CashFlowStatementsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CashFlowStatementsValidationError{}

// Validate checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyInfoMultiError, or
// nil if none found.
func (m *CompanyInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for LegalName

	// no validation rules for TaxNumber

	// no validation rules for FiscalYearEndMonth

	// no validation rules for FiscalYearEndDay

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyInfoValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompanyInfoValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyInfoValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return CompanyInfoMultiError(errors)
	}

	return nil
}

// CompanyInfoMultiError is an error wrapping multiple validation errors
// returned by CompanyInfo.ValidateAll() if the designated constraints aren't met.
type CompanyInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyInfoMultiError) AllErrors() []error { return m }

// CompanyInfoValidationError is the validation error returned by
// CompanyInfo.Validate if the designated constraints aren't met.
type CompanyInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyInfoValidationError) ErrorName() string { return "CompanyInfoValidationError" }

// Error satisfies the builtin error interface
func (e CompanyInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyInfoValidationError{}

// Validate checks the field values on AccountingAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountingAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountingAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccountingAttachmentMultiError, or nil if none found.
func (m *AccountingAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountingAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for FileName

	// no validation rules for FileUrl

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	// no validation rules for ModifiedAt

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return AccountingAttachmentMultiError(errors)
	}

	return nil
}

// AccountingAttachmentMultiError is an error wrapping multiple validation
// errors returned by AccountingAttachment.ValidateAll() if the designated
// constraints aren't met.
type AccountingAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountingAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountingAttachmentMultiError) AllErrors() []error { return m }

// AccountingAttachmentValidationError is the validation error returned by
// AccountingAttachment.Validate if the designated constraints aren't met.
type AccountingAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountingAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountingAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountingAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountingAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountingAttachmentValidationError) ErrorName() string {
	return "AccountingAttachmentValidationError"
}

// Error satisfies the builtin error interface
func (e AccountingAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountingAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountingAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountingAttachmentValidationError{}

// Validate checks the field values on Contacts with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Contacts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Contacts with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContactsMultiError, or nil
// if none found.
func (m *Contacts) ValidateAll() error {
	return m.validate(true)
}

func (m *Contacts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for IsSupplier

	// no validation rules for IsCustomer

	// no validation rules for EmailAddress

	// no validation rules for TaxNumber

	// no validation rules for Status

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContactsValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContactsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return ContactsMultiError(errors)
	}

	return nil
}

// ContactsMultiError is an error wrapping multiple validation errors returned
// by Contacts.ValidateAll() if the designated constraints aren't met.
type ContactsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContactsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContactsMultiError) AllErrors() []error { return m }

// ContactsValidationError is the validation error returned by
// Contacts.Validate if the designated constraints aren't met.
type ContactsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContactsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContactsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContactsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContactsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContactsValidationError) ErrorName() string { return "ContactsValidationError" }

// Error satisfies the builtin error interface
func (e ContactsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContacts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContactsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContactsValidationError{}

// Validate checks the field values on CreditNote with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditNote) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditNote with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditNoteMultiError, or
// nil if none found.
func (m *CreditNote) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditNote) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Number

	// no validation rules for Contact

	// no validation rules for Company

	// no validation rules for ExchangeRate

	// no validation rules for TotalAmount

	// no validation rules for RemainingCredit

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreditNoteValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreditNoteValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreditNoteValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return CreditNoteMultiError(errors)
	}

	return nil
}

// CreditNoteMultiError is an error wrapping multiple validation errors
// returned by CreditNote.ValidateAll() if the designated constraints aren't met.
type CreditNoteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditNoteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditNoteMultiError) AllErrors() []error { return m }

// CreditNoteValidationError is the validation error returned by
// CreditNote.Validate if the designated constraints aren't met.
type CreditNoteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditNoteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditNoteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditNoteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditNoteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditNoteValidationError) ErrorName() string { return "CreditNoteValidationError" }

// Error satisfies the builtin error interface
func (e CreditNoteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditNote.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditNoteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditNoteValidationError{}

// Validate checks the field values on CreditNoteLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreditNoteLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditNoteLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreditNoteLineItemMultiError, or nil if none found.
func (m *CreditNoteLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditNoteLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Quantity

	// no validation rules for UnitPrice

	// no validation rules for TaxRate

	// no validation rules for TotalLineAmount

	// no validation rules for TrackingCategory

	// no validation rules for Account

	// no validation rules for Company

	// no validation rules for RemoteId

	// no validation rules for Item

	if len(errors) > 0 {
		return CreditNoteLineItemMultiError(errors)
	}

	return nil
}

// CreditNoteLineItemMultiError is an error wrapping multiple validation errors
// returned by CreditNoteLineItem.ValidateAll() if the designated constraints
// aren't met.
type CreditNoteLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditNoteLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditNoteLineItemMultiError) AllErrors() []error { return m }

// CreditNoteLineItemValidationError is the validation error returned by
// CreditNoteLineItem.Validate if the designated constraints aren't met.
type CreditNoteLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditNoteLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditNoteLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditNoteLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditNoteLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditNoteLineItemValidationError) ErrorName() string {
	return "CreditNoteLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e CreditNoteLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditNoteLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditNoteLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditNoteLineItemValidationError{}

// Validate checks the field values on Expense with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expense) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expense with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExpenseMultiError, or nil if none found.
func (m *Expense) ValidateAll() error {
	return m.validate(true)
}

func (m *Expense) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for TotalAmount

	// no validation rules for SubTotal

	// no validation rules for TotalTaxAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	// no validation rules for Memo

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpenseValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpenseValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpenseValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return ExpenseMultiError(errors)
	}

	return nil
}

// ExpenseMultiError is an error wrapping multiple validation errors returned
// by Expense.ValidateAll() if the designated constraints aren't met.
type ExpenseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseMultiError) AllErrors() []error { return m }

// ExpenseValidationError is the validation error returned by Expense.Validate
// if the designated constraints aren't met.
type ExpenseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseValidationError) ErrorName() string { return "ExpenseValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpense.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseValidationError{}

// Validate checks the field values on ExpenseLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpenseLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpenseLineMultiError, or
// nil if none found.
func (m *ExpenseLine) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Company

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for Description

	// no validation rules for ExchangeRate

	// no validation rules for RemoteId

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpenseLineMultiError(errors)
	}

	return nil
}

// ExpenseLineMultiError is an error wrapping multiple validation errors
// returned by ExpenseLine.ValidateAll() if the designated constraints aren't met.
type ExpenseLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseLineMultiError) AllErrors() []error { return m }

// ExpenseLineValidationError is the validation error returned by
// ExpenseLine.Validate if the designated constraints aren't met.
type ExpenseLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseLineValidationError) ErrorName() string { return "ExpenseLineValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseLineValidationError{}

// Validate checks the field values on IncomeStatement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IncomeStatement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncomeStatement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IncomeStatementMultiError, or nil if none found.
func (m *IncomeStatement) ValidateAll() error {
	return m.validate(true)
}

func (m *IncomeStatement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetStartPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "StartPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "EndPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetIncome() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("Income[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCostOfSales() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("CostOfSales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("CostOfSales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("CostOfSales[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for GrossProfit

	for idx, item := range m.GetOperatingExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NetOperatingIncome

	for idx, item := range m.GetNonOperatingExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NetIncome

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IncomeStatementMultiError(errors)
	}

	return nil
}

// IncomeStatementMultiError is an error wrapping multiple validation errors
// returned by IncomeStatement.ValidateAll() if the designated constraints
// aren't met.
type IncomeStatementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncomeStatementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncomeStatementMultiError) AllErrors() []error { return m }

// IncomeStatementValidationError is the validation error returned by
// IncomeStatement.Validate if the designated constraints aren't met.
type IncomeStatementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncomeStatementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncomeStatementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncomeStatementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncomeStatementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncomeStatementValidationError) ErrorName() string { return "IncomeStatementValidationError" }

// Error satisfies the builtin error interface
func (e IncomeStatementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncomeStatement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncomeStatementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncomeStatementValidationError{}

// Validate checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InvoiceMultiError, or nil if none found.
func (m *Invoice) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Contact

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "DueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaidOnDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidOnDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidOnDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaidOnDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "PaidOnDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Memo

	// no validation rules for Company

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for TotalDiscount

	// no validation rules for SubTotal

	// no validation rules for Status

	// no validation rules for TotalTaxAmount

	// no validation rules for TotalAmount

	// no validation rules for Balance

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvoiceValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvoiceValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvoiceValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return InvoiceMultiError(errors)
	}

	return nil
}

// InvoiceMultiError is an error wrapping multiple validation errors returned
// by Invoice.ValidateAll() if the designated constraints aren't met.
type InvoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceMultiError) AllErrors() []error { return m }

// InvoiceValidationError is the validation error returned by Invoice.Validate
// if the designated constraints aren't met.
type InvoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceValidationError) ErrorName() string { return "InvoiceValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceValidationError{}

// Validate checks the field values on InvoiceLineItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemMultiError, or nil if none found.
func (m *InvoiceLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for UnitPrice

	// no validation rules for Quantity

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for Company

	// no validation rules for MergeAccountId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineItemMultiError(errors)
	}

	return nil
}

// InvoiceLineItemMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItem.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemMultiError) AllErrors() []error { return m }

// InvoiceLineItemValidationError is the validation error returned by
// InvoiceLineItem.Validate if the designated constraints aren't met.
type InvoiceLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemValidationError) ErrorName() string { return "InvoiceLineItemValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemValidationError{}

// Validate checks the field values on Item with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Item) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Item with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ItemMultiError, or nil if none found.
func (m *Item) ValidateAll() error {
	return m.validate(true)
}

func (m *Item) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for UnitPrice

	// no validation rules for PurchasePrice

	// no validation rules for PurchaseAccount

	// no validation rules for SalesAccount

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return ItemMultiError(errors)
	}

	return nil
}

// ItemMultiError is an error wrapping multiple validation errors returned by
// Item.ValidateAll() if the designated constraints aren't met.
type ItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemMultiError) AllErrors() []error { return m }

// ItemValidationError is the validation error returned by Item.Validate if the
// designated constraints aren't met.
type ItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemValidationError) ErrorName() string { return "ItemValidationError" }

// Error satisfies the builtin error interface
func (e ItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemValidationError{}

// Validate checks the field values on JournalEntry with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JournalEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JournalEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JournalEntryMultiError, or
// nil if none found.
func (m *JournalEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *JournalEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Memo

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JournalEntryValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JournalEntryValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JournalEntryValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for JournalNumber

	// no validation rules for RemoteWasDeleted

	// no validation rules for PostingStatus

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return JournalEntryMultiError(errors)
	}

	return nil
}

// JournalEntryMultiError is an error wrapping multiple validation errors
// returned by JournalEntry.ValidateAll() if the designated constraints aren't met.
type JournalEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JournalEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JournalEntryMultiError) AllErrors() []error { return m }

// JournalEntryValidationError is the validation error returned by
// JournalEntry.Validate if the designated constraints aren't met.
type JournalEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JournalEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JournalEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JournalEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JournalEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JournalEntryValidationError) ErrorName() string { return "JournalEntryValidationError" }

// Error satisfies the builtin error interface
func (e JournalEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJournalEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JournalEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JournalEntryValidationError{}

// Validate checks the field values on JournalLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JournalLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JournalLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JournalLineMultiError, or
// nil if none found.
func (m *JournalLine) ValidateAll() error {
	return m.validate(true)
}

func (m *JournalLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Account

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Contact

	// no validation rules for Company

	// no validation rules for Description

	// no validation rules for ExchangeRate

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JournalLineMultiError(errors)
	}

	return nil
}

// JournalLineMultiError is an error wrapping multiple validation errors
// returned by JournalLine.ValidateAll() if the designated constraints aren't met.
type JournalLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JournalLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JournalLineMultiError) AllErrors() []error { return m }

// JournalLineValidationError is the validation error returned by
// JournalLine.Validate if the designated constraints aren't met.
type JournalLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JournalLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JournalLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JournalLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JournalLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JournalLineValidationError) ErrorName() string { return "JournalLineValidationError" }

// Error satisfies the builtin error interface
func (e JournalLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJournalLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JournalLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JournalLineValidationError{}

// Validate checks the field values on Payment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PaymentMultiError, or nil if none found.
func (m *Payment) ValidateAll() error {
	return m.validate(true)
}

func (m *Payment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Contact

	// no validation rules for Account

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	// no validation rules for TotalAmount

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return PaymentMultiError(errors)
	}

	return nil
}

// PaymentMultiError is an error wrapping multiple validation errors returned
// by Payment.ValidateAll() if the designated constraints aren't met.
type PaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentMultiError) AllErrors() []error { return m }

// PaymentValidationError is the validation error returned by Payment.Validate
// if the designated constraints aren't met.
type PaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentValidationError) ErrorName() string { return "PaymentValidationError" }

// Error satisfies the builtin error interface
func (e PaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentValidationError{}

// Validate checks the field values on PurchaseOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PurchaseOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PurchaseOrder with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PurchaseOrderMultiError, or
// nil if none found.
func (m *PurchaseOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *PurchaseOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeAccountId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PurchaseOrderNumber

	if all {
		switch v := interface{}(m.GetDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "DeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeliveryAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "DeliveryAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Customer

	// no validation rules for Vendor

	// no validation rules for Memo

	// no validation rules for Company

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PurchaseOrderValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PurchaseOrderValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PurchaseOrderValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PurchaseOrderMultiError(errors)
	}

	return nil
}

// PurchaseOrderMultiError is an error wrapping multiple validation errors
// returned by PurchaseOrder.ValidateAll() if the designated constraints
// aren't met.
type PurchaseOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PurchaseOrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PurchaseOrderMultiError) AllErrors() []error { return m }

// PurchaseOrderValidationError is the validation error returned by
// PurchaseOrder.Validate if the designated constraints aren't met.
type PurchaseOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PurchaseOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PurchaseOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PurchaseOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PurchaseOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PurchaseOrderValidationError) ErrorName() string { return "PurchaseOrderValidationError" }

// Error satisfies the builtin error interface
func (e PurchaseOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPurchaseOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PurchaseOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PurchaseOrderValidationError{}

// Validate checks the field values on PurchaseOrderLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PurchaseOrderLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PurchaseOrderLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PurchaseOrderLineItemMultiError, or nil if none found.
func (m *PurchaseOrderLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PurchaseOrderLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for Quantity

	// no validation rules for UnitPrice

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for TaxAmount

	// no validation rules for TotalLineAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PurchaseOrderLineItemMultiError(errors)
	}

	return nil
}

// PurchaseOrderLineItemMultiError is an error wrapping multiple validation
// errors returned by PurchaseOrderLineItem.ValidateAll() if the designated
// constraints aren't met.
type PurchaseOrderLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PurchaseOrderLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PurchaseOrderLineItemMultiError) AllErrors() []error { return m }

// PurchaseOrderLineItemValidationError is the validation error returned by
// PurchaseOrderLineItem.Validate if the designated constraints aren't met.
type PurchaseOrderLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PurchaseOrderLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PurchaseOrderLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PurchaseOrderLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PurchaseOrderLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PurchaseOrderLineItemValidationError) ErrorName() string {
	return "PurchaseOrderLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e PurchaseOrderLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPurchaseOrderLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PurchaseOrderLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PurchaseOrderLineItemValidationError{}

// Validate checks the field values on TaxRate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxRate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaxRateMultiError, or nil if none found.
func (m *TaxRate) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for TotalTaxRate

	// no validation rules for EffectiveTaxRate

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxRateValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return TaxRateMultiError(errors)
	}

	return nil
}

// TaxRateMultiError is an error wrapping multiple validation errors returned
// by TaxRate.ValidateAll() if the designated constraints aren't met.
type TaxRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxRateMultiError) AllErrors() []error { return m }

// TaxRateValidationError is the validation error returned by TaxRate.Validate
// if the designated constraints aren't met.
type TaxRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxRateValidationError) ErrorName() string { return "TaxRateValidationError" }

// Error satisfies the builtin error interface
func (e TaxRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxRateValidationError{}

// Validate checks the field values on TrackingCategory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TrackingCategory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackingCategory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackingCategoryMultiError, or nil if none found.
func (m *TrackingCategory) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackingCategory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for MergeAccountId

	// no validation rules for CategoryType

	// no validation rules for ParentCategory

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackingCategoryValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackingCategoryMultiError(errors)
	}

	return nil
}

// TrackingCategoryMultiError is an error wrapping multiple validation errors
// returned by TrackingCategory.ValidateAll() if the designated constraints
// aren't met.
type TrackingCategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackingCategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackingCategoryMultiError) AllErrors() []error { return m }

// TrackingCategoryValidationError is the validation error returned by
// TrackingCategory.Validate if the designated constraints aren't met.
type TrackingCategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackingCategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackingCategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackingCategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackingCategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackingCategoryValidationError) ErrorName() string { return "TrackingCategoryValidationError" }

// Error satisfies the builtin error interface
func (e TrackingCategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackingCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackingCategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackingCategoryValidationError{}

// Validate checks the field values on BusinessTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessTransactionMultiError, or nil if none found.
func (m *BusinessTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TransactionType

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BusinessTransactionValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BusinessTransactionValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BusinessTransactionValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BusinessTransactionMultiError(errors)
	}

	return nil
}

// BusinessTransactionMultiError is an error wrapping multiple validation
// errors returned by BusinessTransaction.ValidateAll() if the designated
// constraints aren't met.
type BusinessTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessTransactionMultiError) AllErrors() []error { return m }

// BusinessTransactionValidationError is the validation error returned by
// BusinessTransaction.Validate if the designated constraints aren't met.
type BusinessTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessTransactionValidationError) ErrorName() string {
	return "BusinessTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessTransactionValidationError{}

// Validate checks the field values on TransactionLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionLineItemMultiError, or nil if none found.
func (m *TransactionLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Memo

	// no validation rules for UnitPrice

	// no validation rules for Quantity

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for TotalLineAmount

	// no validation rules for TaxRate

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionLineItemMultiError(errors)
	}

	return nil
}

// TransactionLineItemMultiError is an error wrapping multiple validation
// errors returned by TransactionLineItem.ValidateAll() if the designated
// constraints aren't met.
type TransactionLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionLineItemMultiError) AllErrors() []error { return m }

// TransactionLineItemValidationError is the validation error returned by
// TransactionLineItem.Validate if the designated constraints aren't met.
type TransactionLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionLineItemValidationError) ErrorName() string {
	return "TransactionLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionLineItemValidationError{}

// Validate checks the field values on VendorCredit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorCredit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorCredit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorCreditMultiError, or
// nil if none found.
func (m *VendorCredit) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorCredit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MergeAccountId

	// no validation rules for RemoteId

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Vendor

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VendorCreditValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VendorCreditValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VendorCreditValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorCreditMultiError(errors)
	}

	return nil
}

// VendorCreditMultiError is an error wrapping multiple validation errors
// returned by VendorCredit.ValidateAll() if the designated constraints aren't met.
type VendorCreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorCreditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorCreditMultiError) AllErrors() []error { return m }

// VendorCreditValidationError is the validation error returned by
// VendorCredit.Validate if the designated constraints aren't met.
type VendorCreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorCreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorCreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorCreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorCreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorCreditValidationError) ErrorName() string { return "VendorCreditValidationError" }

// Error satisfies the builtin error interface
func (e VendorCreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorCredit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorCreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorCreditValidationError{}

// Validate checks the field values on VendorCreditLine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VendorCreditLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorCreditLine with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VendorCreditLineMultiError, or nil if none found.
func (m *VendorCreditLine) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorCreditLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RemoteId

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Description

	// no validation rules for Account

	// no validation rules for Company

	// no validation rules for ExchangeRate

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorCreditLineMultiError(errors)
	}

	return nil
}

// VendorCreditLineMultiError is an error wrapping multiple validation errors
// returned by VendorCreditLine.ValidateAll() if the designated constraints
// aren't met.
type VendorCreditLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorCreditLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorCreditLineMultiError) AllErrors() []error { return m }

// VendorCreditLineValidationError is the validation error returned by
// VendorCreditLine.Validate if the designated constraints aren't met.
type VendorCreditLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorCreditLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorCreditLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorCreditLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorCreditLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorCreditLineValidationError) ErrorName() string { return "VendorCreditLineValidationError" }

// Error satisfies the builtin error interface
func (e VendorCreditLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorCreditLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorCreditLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorCreditLineValidationError{}
