// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        (unknown)
// source: accounting_service/v1/enums.proto

package accounting_servicev1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The time period this pay rate encompasses. Possible values include:
// HOUR, DAY, WEEK, EVERY_TWO_WEEKS, SEMIMONTHLY, MONTH, QUARTER,
// EVERY_SIX_MONTHS, YEAR. In cases where there is no clear mapping,
// the original value passed through will be returned.
type PayPeriod int32

const (
	PayPeriod_PAY_PERIOD_UNSPECIFIED      PayPeriod = 0
	PayPeriod_PAY_PERIOD_HOUR             PayPeriod = 1
	PayPeriod_PAY_PERIOD_DAY              PayPeriod = 2
	PayPeriod_PAY_PERIOD_WEEK             PayPeriod = 3
	PayPeriod_PAY_PERIOD_EVERY_TWO_WEEKS  PayPeriod = 4
	PayPeriod_PAY_PERIOD_SEMIMONTHLY      PayPeriod = 5
	PayPeriod_PAY_PERIOD_MONTH            PayPeriod = 6
	PayPeriod_PAY_PERIOD_QUARTER          PayPeriod = 7
	PayPeriod_PAY_PERIOD_EVERY_SIX_MONTHS PayPeriod = 8
	PayPeriod_PAY_PERIOD_YEAR             PayPeriod = 9
)

// Enum value maps for PayPeriod.
var (
	PayPeriod_name = map[int32]string{
		0: "PAY_PERIOD_UNSPECIFIED",
		1: "PAY_PERIOD_HOUR",
		2: "PAY_PERIOD_DAY",
		3: "PAY_PERIOD_WEEK",
		4: "PAY_PERIOD_EVERY_TWO_WEEKS",
		5: "PAY_PERIOD_SEMIMONTHLY",
		6: "PAY_PERIOD_MONTH",
		7: "PAY_PERIOD_QUARTER",
		8: "PAY_PERIOD_EVERY_SIX_MONTHS",
		9: "PAY_PERIOD_YEAR",
	}
	PayPeriod_value = map[string]int32{
		"PAY_PERIOD_UNSPECIFIED":      0,
		"PAY_PERIOD_HOUR":             1,
		"PAY_PERIOD_DAY":              2,
		"PAY_PERIOD_WEEK":             3,
		"PAY_PERIOD_EVERY_TWO_WEEKS":  4,
		"PAY_PERIOD_SEMIMONTHLY":      5,
		"PAY_PERIOD_MONTH":            6,
		"PAY_PERIOD_QUARTER":          7,
		"PAY_PERIOD_EVERY_SIX_MONTHS": 8,
		"PAY_PERIOD_YEAR":             9,
	}
)

func (x PayPeriod) Enum() *PayPeriod {
	p := new(PayPeriod)
	*p = x
	return p
}

func (x PayPeriod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayPeriod) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[0].Descriptor()
}

func (PayPeriod) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[0]
}

func (x PayPeriod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayPeriod.Descriptor instead.
func (PayPeriod) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{0}
}

// The position's pay frequency. Possible values include: WEEKLY, BIWEEKLY, MONTHLY,
// QUARTERLY, SEMIANNUALLY, ANNUALLY, THIRTEEN-MONTHLY, PRO_RATA, SEMIMONTHLY.
// In cases where there is no clear mapping, the original value passed through will be returned.
type PayFrequency int32

const (
	PayFrequency_PAY_FREQUENCY_UNSPECIFIED      PayFrequency = 0
	PayFrequency_PAY_FREQUENCY_WEEKLY           PayFrequency = 1
	PayFrequency_PAY_FREQUENCY_BIWEEKLY         PayFrequency = 2
	PayFrequency_PAY_FREQUENCY_MONTHLY          PayFrequency = 3
	PayFrequency_PAY_FREQUENCY_QUARTERLY        PayFrequency = 4
	PayFrequency_PAY_FREQUENCY_SEMIANNUALLY     PayFrequency = 5
	PayFrequency_PAY_FREQUENCY_ANNUALLY         PayFrequency = 6
	PayFrequency_PAY_FREQUENCY_THIRTEEN_MONTHLY PayFrequency = 7
	PayFrequency_PAY_FREQUENCY_PRO_RATA         PayFrequency = 8
	PayFrequency_PAY_FREQUENCY_SEMIMONTHLY      PayFrequency = 9
)

// Enum value maps for PayFrequency.
var (
	PayFrequency_name = map[int32]string{
		0: "PAY_FREQUENCY_UNSPECIFIED",
		1: "PAY_FREQUENCY_WEEKLY",
		2: "PAY_FREQUENCY_BIWEEKLY",
		3: "PAY_FREQUENCY_MONTHLY",
		4: "PAY_FREQUENCY_QUARTERLY",
		5: "PAY_FREQUENCY_SEMIANNUALLY",
		6: "PAY_FREQUENCY_ANNUALLY",
		7: "PAY_FREQUENCY_THIRTEEN_MONTHLY",
		8: "PAY_FREQUENCY_PRO_RATA",
		9: "PAY_FREQUENCY_SEMIMONTHLY",
	}
	PayFrequency_value = map[string]int32{
		"PAY_FREQUENCY_UNSPECIFIED":      0,
		"PAY_FREQUENCY_WEEKLY":           1,
		"PAY_FREQUENCY_BIWEEKLY":         2,
		"PAY_FREQUENCY_MONTHLY":          3,
		"PAY_FREQUENCY_QUARTERLY":        4,
		"PAY_FREQUENCY_SEMIANNUALLY":     5,
		"PAY_FREQUENCY_ANNUALLY":         6,
		"PAY_FREQUENCY_THIRTEEN_MONTHLY": 7,
		"PAY_FREQUENCY_PRO_RATA":         8,
		"PAY_FREQUENCY_SEMIMONTHLY":      9,
	}
)

func (x PayFrequency) Enum() *PayFrequency {
	p := new(PayFrequency)
	*p = x
	return p
}

func (x PayFrequency) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayFrequency) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[1].Descriptor()
}

func (PayFrequency) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[1]
}

func (x PayFrequency) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayFrequency.Descriptor instead.
func (PayFrequency) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{1}
}

// The position's FLSA status. Possible values include: EXEMPT, SALARIED_NONEXEMPT,
// NONEXEMPT, OWNER. In cases where there is no clear mapping,
// the original value passed through will be returned.
type FlsaStatus int32

const (
	FlsaStatus_FLSA_STATUS_UNSPECIFIED         FlsaStatus = 0
	FlsaStatus_FLSA_STATUS_EXEMPT              FlsaStatus = 1
	FlsaStatus_FLSA_STATUS_NON_EXEMPT          FlsaStatus = 2
	FlsaStatus_FLSA_STATUS_SALARIED_NON_EXEMPT FlsaStatus = 3
	FlsaStatus_FLSA_STATUS_OWNER               FlsaStatus = 4
)

// Enum value maps for FlsaStatus.
var (
	FlsaStatus_name = map[int32]string{
		0: "FLSA_STATUS_UNSPECIFIED",
		1: "FLSA_STATUS_EXEMPT",
		2: "FLSA_STATUS_NON_EXEMPT",
		3: "FLSA_STATUS_SALARIED_NON_EXEMPT",
		4: "FLSA_STATUS_OWNER",
	}
	FlsaStatus_value = map[string]int32{
		"FLSA_STATUS_UNSPECIFIED":         0,
		"FLSA_STATUS_EXEMPT":              1,
		"FLSA_STATUS_NON_EXEMPT":          2,
		"FLSA_STATUS_SALARIED_NON_EXEMPT": 3,
		"FLSA_STATUS_OWNER":               4,
	}
)

func (x FlsaStatus) Enum() *FlsaStatus {
	p := new(FlsaStatus)
	*p = x
	return p
}

func (x FlsaStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FlsaStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[2].Descriptor()
}

func (FlsaStatus) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[2]
}

func (x FlsaStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FlsaStatus.Descriptor instead.
func (FlsaStatus) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{2}
}

// The position's type of employment. Possible values include: FULL_TIME, PART_TIME, INTERN, CONTRACTOR, FREELANCE.
// In cases where there is no clear mapping, the original value passed through will be returned.
type EmploymentType int32

const (
	EmploymentType_EMPLOYMENT_TYPE_UNSPECIFIED EmploymentType = 0
	EmploymentType_EMPLOYMENT_TYPE_FULL_TIME   EmploymentType = 1
	EmploymentType_EMPLOYMENT_TYPE_PART_TIME   EmploymentType = 2
	EmploymentType_EMPLOYMENT_TYPE_INTERN      EmploymentType = 3
	EmploymentType_EMPLOYMENT_TYPE_CONTRACTOR  EmploymentType = 4
	EmploymentType_EMPLOYMENT_TYPE_FREELANCE   EmploymentType = 5
)

// Enum value maps for EmploymentType.
var (
	EmploymentType_name = map[int32]string{
		0: "EMPLOYMENT_TYPE_UNSPECIFIED",
		1: "EMPLOYMENT_TYPE_FULL_TIME",
		2: "EMPLOYMENT_TYPE_PART_TIME",
		3: "EMPLOYMENT_TYPE_INTERN",
		4: "EMPLOYMENT_TYPE_CONTRACTOR",
		5: "EMPLOYMENT_TYPE_FREELANCE",
	}
	EmploymentType_value = map[string]int32{
		"EMPLOYMENT_TYPE_UNSPECIFIED": 0,
		"EMPLOYMENT_TYPE_FULL_TIME":   1,
		"EMPLOYMENT_TYPE_PART_TIME":   2,
		"EMPLOYMENT_TYPE_INTERN":      3,
		"EMPLOYMENT_TYPE_CONTRACTOR":  4,
		"EMPLOYMENT_TYPE_FREELANCE":   5,
	}
)

func (x EmploymentType) Enum() *EmploymentType {
	p := new(EmploymentType)
	*p = x
	return p
}

func (x EmploymentType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EmploymentType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[3].Descriptor()
}

func (EmploymentType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[3]
}

func (x EmploymentType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EmploymentType.Descriptor instead.
func (EmploymentType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{3}
}

// The group type Possible values include: TEAM, DEPARTMENT, COST_CENTER, BUSINESS_UNIT, GROUP.
// In cases where there is no clear mapping, the original value passed through will be returned.
type PayGroupType int32

const (
	PayGroupType_PAY_GROUP_TYPE_UNSPECIFIED   PayGroupType = 0
	PayGroupType_PAY_GROUP_TYPE_TEAM          PayGroupType = 1
	PayGroupType_PAY_GROUP_TYPE_DEPARTMENT    PayGroupType = 2
	PayGroupType_PAY_GROUP_TYPE_COST_CENTER   PayGroupType = 3
	PayGroupType_PAY_GROUP_TYPE_BUSINESS_UNIT PayGroupType = 4
	PayGroupType_PAY_GROUP_TYPE_GROUP         PayGroupType = 5
)

// Enum value maps for PayGroupType.
var (
	PayGroupType_name = map[int32]string{
		0: "PAY_GROUP_TYPE_UNSPECIFIED",
		1: "PAY_GROUP_TYPE_TEAM",
		2: "PAY_GROUP_TYPE_DEPARTMENT",
		3: "PAY_GROUP_TYPE_COST_CENTER",
		4: "PAY_GROUP_TYPE_BUSINESS_UNIT",
		5: "PAY_GROUP_TYPE_GROUP",
	}
	PayGroupType_value = map[string]int32{
		"PAY_GROUP_TYPE_UNSPECIFIED":   0,
		"PAY_GROUP_TYPE_TEAM":          1,
		"PAY_GROUP_TYPE_DEPARTMENT":    2,
		"PAY_GROUP_TYPE_COST_CENTER":   3,
		"PAY_GROUP_TYPE_BUSINESS_UNIT": 4,
		"PAY_GROUP_TYPE_GROUP":         5,
	}
)

func (x PayGroupType) Enum() *PayGroupType {
	p := new(PayGroupType)
	*p = x
	return p
}

func (x PayGroupType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayGroupType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[4].Descriptor()
}

func (PayGroupType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[4]
}

func (x PayGroupType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayGroupType.Descriptor instead.
func (PayGroupType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{4}
}

// The employee's gender. Possible values include: MALE, FEMALE, NON-BINARY, OTHER,
// PREFER_NOT_TO_DISCLOSE. In cases where there is no clear mapping,
// the original value passed through will be returned.
type Gender int32

const (
	Gender_GENDER_UNSPECIFIED            Gender = 0
	Gender_GENDER_MALE                   Gender = 1
	Gender_GENDER_FEMALE                 Gender = 2
	Gender_GENDER_NON_BINARY             Gender = 3
	Gender_GENDER_OTHER                  Gender = 4
	Gender_GENDER_PREFER_NOT_TO_DISCLOSE Gender = 5
)

// Enum value maps for Gender.
var (
	Gender_name = map[int32]string{
		0: "GENDER_UNSPECIFIED",
		1: "GENDER_MALE",
		2: "GENDER_FEMALE",
		3: "GENDER_NON_BINARY",
		4: "GENDER_OTHER",
		5: "GENDER_PREFER_NOT_TO_DISCLOSE",
	}
	Gender_value = map[string]int32{
		"GENDER_UNSPECIFIED":            0,
		"GENDER_MALE":                   1,
		"GENDER_FEMALE":                 2,
		"GENDER_NON_BINARY":             3,
		"GENDER_OTHER":                  4,
		"GENDER_PREFER_NOT_TO_DISCLOSE": 5,
	}
)

func (x Gender) Enum() *Gender {
	p := new(Gender)
	*p = x
	return p
}

func (x Gender) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Gender) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[5].Descriptor()
}

func (Gender) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[5]
}

func (x Gender) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Gender.Descriptor instead.
func (Gender) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{5}
}

// The employee's ethnicity. Possible values include: AMERICAN_INDIAN_OR_ALASKA_NATIVE, ASIAN_OR_INDIAN_SUBCONTINENT,
// BLACK_OR_AFRICAN_AMERICAN, HISPANIC_OR_LATINO, NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER,
// TWO_OR_MORE_RACES, WHITE, PREFER_NOT_TO_DISCLOSE. In cases where there is no clear mapping, the original value passed through will be returned.
type Ethnicity int32

const (
	Ethnicity_ETHNICITY_UNSPECIFIED                               Ethnicity = 0
	Ethnicity_ETHNICITY_AMERICAN_INDIAN_OR_ALASKA_NATIVE          Ethnicity = 1
	Ethnicity_ETHNICITY_ASIAN_OR_INDIAN_SUBCONTINENT              Ethnicity = 2
	Ethnicity_ETHNICITY_BLACK_OR_AFRICAN_AMERICAN                 Ethnicity = 3
	Ethnicity_ETHNICITY_HISPANIC_OR_LATINO                        Ethnicity = 4
	Ethnicity_ETHNICITY_NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER Ethnicity = 5
	Ethnicity_ETHNICITY_TWO_OR_MORE_RACES                         Ethnicity = 6
	Ethnicity_ETHNICITY_WHITE                                     Ethnicity = 7
	Ethnicity_ETHNICITY_PREFER_NOT_TO_DISCLOSE                    Ethnicity = 8
)

// Enum value maps for Ethnicity.
var (
	Ethnicity_name = map[int32]string{
		0: "ETHNICITY_UNSPECIFIED",
		1: "ETHNICITY_AMERICAN_INDIAN_OR_ALASKA_NATIVE",
		2: "ETHNICITY_ASIAN_OR_INDIAN_SUBCONTINENT",
		3: "ETHNICITY_BLACK_OR_AFRICAN_AMERICAN",
		4: "ETHNICITY_HISPANIC_OR_LATINO",
		5: "ETHNICITY_NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER",
		6: "ETHNICITY_TWO_OR_MORE_RACES",
		7: "ETHNICITY_WHITE",
		8: "ETHNICITY_PREFER_NOT_TO_DISCLOSE",
	}
	Ethnicity_value = map[string]int32{
		"ETHNICITY_UNSPECIFIED":                               0,
		"ETHNICITY_AMERICAN_INDIAN_OR_ALASKA_NATIVE":          1,
		"ETHNICITY_ASIAN_OR_INDIAN_SUBCONTINENT":              2,
		"ETHNICITY_BLACK_OR_AFRICAN_AMERICAN":                 3,
		"ETHNICITY_HISPANIC_OR_LATINO":                        4,
		"ETHNICITY_NATIVE_HAWAIIAN_OR_OTHER_PACIFIC_ISLANDER": 5,
		"ETHNICITY_TWO_OR_MORE_RACES":                         6,
		"ETHNICITY_WHITE":                                     7,
		"ETHNICITY_PREFER_NOT_TO_DISCLOSE":                    8,
	}
)

func (x Ethnicity) Enum() *Ethnicity {
	p := new(Ethnicity)
	*p = x
	return p
}

func (x Ethnicity) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Ethnicity) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[6].Descriptor()
}

func (Ethnicity) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[6]
}

func (x Ethnicity) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Ethnicity.Descriptor instead.
func (Ethnicity) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{6}
}

// The employee's filing status as related to marital status. Possible values include: SINGLE,
// MARRIED_FILING_JOINTLY, MARRIED_FILING_SEPARATELY, HEAD_OF_HOUSEHOLD, QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD.
// In cases where there is no clear mapping, the original value passed through will be returned.
type MaritalStatus int32

const (
	MaritalStatus_MARITAL_STATUS_UNSPECIFIED                                      MaritalStatus = 0
	MaritalStatus_MARITAL_STATUS_SINGLE                                           MaritalStatus = 1
	MaritalStatus_MARITAL_STATUS_MARRIED_FILING_JOINTLY                           MaritalStatus = 2
	MaritalStatus_MARITAL_STATUS_MARRIED_FILING_SEPARATELY                        MaritalStatus = 3
	MaritalStatus_MARITAL_STATUS_HEAD_OF_HOUSEHOLD                                MaritalStatus = 4
	MaritalStatus_MARITAL_STATUS_QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD MaritalStatus = 5
)

// Enum value maps for MaritalStatus.
var (
	MaritalStatus_name = map[int32]string{
		0: "MARITAL_STATUS_UNSPECIFIED",
		1: "MARITAL_STATUS_SINGLE",
		2: "MARITAL_STATUS_MARRIED_FILING_JOINTLY",
		3: "MARITAL_STATUS_MARRIED_FILING_SEPARATELY",
		4: "MARITAL_STATUS_HEAD_OF_HOUSEHOLD",
		5: "MARITAL_STATUS_QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD",
	}
	MaritalStatus_value = map[string]int32{
		"MARITAL_STATUS_UNSPECIFIED":                                      0,
		"MARITAL_STATUS_SINGLE":                                           1,
		"MARITAL_STATUS_MARRIED_FILING_JOINTLY":                           2,
		"MARITAL_STATUS_MARRIED_FILING_SEPARATELY":                        3,
		"MARITAL_STATUS_HEAD_OF_HOUSEHOLD":                                4,
		"MARITAL_STATUS_QUALIFYING_WIDOW_OR_WIDOWER_WITH_DEPENDENT_CHILD": 5,
	}
)

func (x MaritalStatus) Enum() *MaritalStatus {
	p := new(MaritalStatus)
	*p = x
	return p
}

func (x MaritalStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MaritalStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[7].Descriptor()
}

func (MaritalStatus) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[7]
}

func (x MaritalStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MaritalStatus.Descriptor instead.
func (MaritalStatus) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{7}
}

type EmploymentStatus int32

const (
	EmploymentStatus_EMPLOYMENT_STATUS_UNSPECIFIED EmploymentStatus = 0
	EmploymentStatus_EMPLOYMENT_STATUS_ACTIVE      EmploymentStatus = 1
	EmploymentStatus_EMPLOYMENT_STATUS_PENDING     EmploymentStatus = 2
	EmploymentStatus_EMPLOYMENT_STATUS_INACTIVE    EmploymentStatus = 3
)

// Enum value maps for EmploymentStatus.
var (
	EmploymentStatus_name = map[int32]string{
		0: "EMPLOYMENT_STATUS_UNSPECIFIED",
		1: "EMPLOYMENT_STATUS_ACTIVE",
		2: "EMPLOYMENT_STATUS_PENDING",
		3: "EMPLOYMENT_STATUS_INACTIVE",
	}
	EmploymentStatus_value = map[string]int32{
		"EMPLOYMENT_STATUS_UNSPECIFIED": 0,
		"EMPLOYMENT_STATUS_ACTIVE":      1,
		"EMPLOYMENT_STATUS_PENDING":     2,
		"EMPLOYMENT_STATUS_INACTIVE":    3,
	}
)

func (x EmploymentStatus) Enum() *EmploymentStatus {
	p := new(EmploymentStatus)
	*p = x
	return p
}

func (x EmploymentStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EmploymentStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[8].Descriptor()
}

func (EmploymentStatus) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[8]
}

func (x EmploymentStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EmploymentStatus.Descriptor instead.
func (EmploymentStatus) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{8}
}

type BankAccountType int32

const (
	BankAccountType_BANK_ACCOUNT_TYPE_UNSPECIFIED BankAccountType = 0
	BankAccountType_BANK_ACCOUNT_TYPE_CHECKING    BankAccountType = 1
	BankAccountType_BANK_ACCOUNT_TYPE_SAVINGS     BankAccountType = 2
)

// Enum value maps for BankAccountType.
var (
	BankAccountType_name = map[int32]string{
		0: "BANK_ACCOUNT_TYPE_UNSPECIFIED",
		1: "BANK_ACCOUNT_TYPE_CHECKING",
		2: "BANK_ACCOUNT_TYPE_SAVINGS",
	}
	BankAccountType_value = map[string]int32{
		"BANK_ACCOUNT_TYPE_UNSPECIFIED": 0,
		"BANK_ACCOUNT_TYPE_CHECKING":    1,
		"BANK_ACCOUNT_TYPE_SAVINGS":     2,
	}
)

func (x BankAccountType) Enum() *BankAccountType {
	p := new(BankAccountType)
	*p = x
	return p
}

func (x BankAccountType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BankAccountType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[9].Descriptor()
}

func (BankAccountType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[9]
}

func (x BankAccountType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BankAccountType.Descriptor instead.
func (BankAccountType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{9}
}

// The type of benefit plan. Possible values include: MEDICAL, HEALTH_SAVINGS,
// INSURANCE, RETIREMENT, OTHER. In cases where there is no clear mapping,
// the original value passed through will be returned.
type BenefitPlanType int32

const (
	BenefitPlanType_BENEFIT_PLAN_TYPE_UNSPECIFIED    BenefitPlanType = 0
	BenefitPlanType_BENEFIT_PLAN_TYPE_MEDICAL        BenefitPlanType = 1
	BenefitPlanType_BENEFIT_PLAN_TYPE_HEALTH_SAVINGS BenefitPlanType = 2
	BenefitPlanType_BENEFIT_PLAN_TYPE_INSURANCE      BenefitPlanType = 3
	BenefitPlanType_BENEFIT_PLAN_TYPE_RETIREMENT     BenefitPlanType = 4
	BenefitPlanType_BENEFIT_PLAN_TYPE_OTHER          BenefitPlanType = 5
)

// Enum value maps for BenefitPlanType.
var (
	BenefitPlanType_name = map[int32]string{
		0: "BENEFIT_PLAN_TYPE_UNSPECIFIED",
		1: "BENEFIT_PLAN_TYPE_MEDICAL",
		2: "BENEFIT_PLAN_TYPE_HEALTH_SAVINGS",
		3: "BENEFIT_PLAN_TYPE_INSURANCE",
		4: "BENEFIT_PLAN_TYPE_RETIREMENT",
		5: "BENEFIT_PLAN_TYPE_OTHER",
	}
	BenefitPlanType_value = map[string]int32{
		"BENEFIT_PLAN_TYPE_UNSPECIFIED":    0,
		"BENEFIT_PLAN_TYPE_MEDICAL":        1,
		"BENEFIT_PLAN_TYPE_HEALTH_SAVINGS": 2,
		"BENEFIT_PLAN_TYPE_INSURANCE":      3,
		"BENEFIT_PLAN_TYPE_RETIREMENT":     4,
		"BENEFIT_PLAN_TYPE_OTHER":          5,
	}
)

func (x BenefitPlanType) Enum() *BenefitPlanType {
	p := new(BenefitPlanType)
	*p = x
	return p
}

func (x BenefitPlanType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BenefitPlanType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[10].Descriptor()
}

func (BenefitPlanType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[10]
}

func (x BenefitPlanType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BenefitPlanType.Descriptor instead.
func (BenefitPlanType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{10}
}

// The dependent's relationship to the employee. Possible values include: CHILD,
// SPOUSE, DOMESTIC_PARTNER. In cases where there is no clear mapping,
// the original value passed through will be returned.
type DependentRelationship int32

const (
	DependentRelationship_DEPENDENT_RELATIONSHIP_UNSPECIFIED      DependentRelationship = 0
	DependentRelationship_DEPENDENT_RELATIONSHIP_CHILD            DependentRelationship = 1
	DependentRelationship_DEPENDENT_RELATIONSHIP_SPOUSE           DependentRelationship = 2
	DependentRelationship_DEPENDENT_RELATIONSHIP_DOMESTIC_PARTNER DependentRelationship = 3
)

// Enum value maps for DependentRelationship.
var (
	DependentRelationship_name = map[int32]string{
		0: "DEPENDENT_RELATIONSHIP_UNSPECIFIED",
		1: "DEPENDENT_RELATIONSHIP_CHILD",
		2: "DEPENDENT_RELATIONSHIP_SPOUSE",
		3: "DEPENDENT_RELATIONSHIP_DOMESTIC_PARTNER",
	}
	DependentRelationship_value = map[string]int32{
		"DEPENDENT_RELATIONSHIP_UNSPECIFIED":      0,
		"DEPENDENT_RELATIONSHIP_CHILD":            1,
		"DEPENDENT_RELATIONSHIP_SPOUSE":           2,
		"DEPENDENT_RELATIONSHIP_DOMESTIC_PARTNER": 3,
	}
)

func (x DependentRelationship) Enum() *DependentRelationship {
	p := new(DependentRelationship)
	*p = x
	return p
}

func (x DependentRelationship) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DependentRelationship) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[11].Descriptor()
}

func (DependentRelationship) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[11]
}

func (x DependentRelationship) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DependentRelationship.Descriptor instead.
func (DependentRelationship) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{11}
}

// The location's type. Can be either WORK or HOME Possible values include: HOME, WORK.
// In cases where there is no clear mapping, the original value passed through will be returned.
type LocationType int32

const (
	LocationType_LOCATION_TYPE_UNSPECIFIED LocationType = 0
	LocationType_LOCATION_TYPE_HOME        LocationType = 1
	LocationType_LOCATION_TYPE_WORK        LocationType = 2
)

// Enum value maps for LocationType.
var (
	LocationType_name = map[int32]string{
		0: "LOCATION_TYPE_UNSPECIFIED",
		1: "LOCATION_TYPE_HOME",
		2: "LOCATION_TYPE_WORK",
	}
	LocationType_value = map[string]int32{
		"LOCATION_TYPE_UNSPECIFIED": 0,
		"LOCATION_TYPE_HOME":        1,
		"LOCATION_TYPE_WORK":        2,
	}
)

func (x LocationType) Enum() *LocationType {
	p := new(LocationType)
	*p = x
	return p
}

func (x LocationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LocationType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[12].Descriptor()
}

func (LocationType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[12]
}

func (x LocationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LocationType.Descriptor instead.
func (LocationType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{12}
}

// The state of the payroll run Possible values include: PAID, DRAFT, APPROVED, FAILED, CLOSED.
// In cases where there is no clear mapping, the original value passed through will be returned.
type PayrollRunState int32

const (
	PayrollRunState_PAYROLL_RUN_STATE_UNSPECIFIED PayrollRunState = 0
	PayrollRunState_PAYROLL_RUN_STATE_PAID        PayrollRunState = 1
	PayrollRunState_PAYROLL_RUN_STATE_DRAFT       PayrollRunState = 2
	PayrollRunState_PAYROLL_RUN_STATE_APPROVED    PayrollRunState = 3
	PayrollRunState_PAYROLL_RUN_STATE_FAILED      PayrollRunState = 4
	PayrollRunState_PAYROLL_RUN_STATE_CLOSED      PayrollRunState = 5
)

// Enum value maps for PayrollRunState.
var (
	PayrollRunState_name = map[int32]string{
		0: "PAYROLL_RUN_STATE_UNSPECIFIED",
		1: "PAYROLL_RUN_STATE_PAID",
		2: "PAYROLL_RUN_STATE_DRAFT",
		3: "PAYROLL_RUN_STATE_APPROVED",
		4: "PAYROLL_RUN_STATE_FAILED",
		5: "PAYROLL_RUN_STATE_CLOSED",
	}
	PayrollRunState_value = map[string]int32{
		"PAYROLL_RUN_STATE_UNSPECIFIED": 0,
		"PAYROLL_RUN_STATE_PAID":        1,
		"PAYROLL_RUN_STATE_DRAFT":       2,
		"PAYROLL_RUN_STATE_APPROVED":    3,
		"PAYROLL_RUN_STATE_FAILED":      4,
		"PAYROLL_RUN_STATE_CLOSED":      5,
	}
)

func (x PayrollRunState) Enum() *PayrollRunState {
	p := new(PayrollRunState)
	*p = x
	return p
}

func (x PayrollRunState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayrollRunState) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[13].Descriptor()
}

func (PayrollRunState) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[13]
}

func (x PayrollRunState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayrollRunState.Descriptor instead.
func (PayrollRunState) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{13}
}

// The type of the payroll run Possible values include: REGULAR, OFF_CYCLE, CORRECTION, TERMINATION, SIGN_ON_BONUS.
// In cases where there is no clear mapping, the original value passed through will be returned.
type PayrollRunType int32

const (
	PayrollRunType_PAYROLL_RUN_TYPE_UNSPECIFIED   PayrollRunType = 0
	PayrollRunType_PAYROLL_RUN_TYPE_REGULAR       PayrollRunType = 1
	PayrollRunType_PAYROLL_RUN_TYPE_OFF_CYCLE     PayrollRunType = 2
	PayrollRunType_PAYROLL_RUN_TYPE_CORRECTION    PayrollRunType = 3
	PayrollRunType_PAYROLL_RUN_TYPE_TERMINATION   PayrollRunType = 4
	PayrollRunType_PAYROLL_RUN_TYPE_SIGN_ON_BONUS PayrollRunType = 5
)

// Enum value maps for PayrollRunType.
var (
	PayrollRunType_name = map[int32]string{
		0: "PAYROLL_RUN_TYPE_UNSPECIFIED",
		1: "PAYROLL_RUN_TYPE_REGULAR",
		2: "PAYROLL_RUN_TYPE_OFF_CYCLE",
		3: "PAYROLL_RUN_TYPE_CORRECTION",
		4: "PAYROLL_RUN_TYPE_TERMINATION",
		5: "PAYROLL_RUN_TYPE_SIGN_ON_BONUS",
	}
	PayrollRunType_value = map[string]int32{
		"PAYROLL_RUN_TYPE_UNSPECIFIED":   0,
		"PAYROLL_RUN_TYPE_REGULAR":       1,
		"PAYROLL_RUN_TYPE_OFF_CYCLE":     2,
		"PAYROLL_RUN_TYPE_CORRECTION":    3,
		"PAYROLL_RUN_TYPE_TERMINATION":   4,
		"PAYROLL_RUN_TYPE_SIGN_ON_BONUS": 5,
	}
)

func (x PayrollRunType) Enum() *PayrollRunType {
	p := new(PayrollRunType)
	*p = x
	return p
}

func (x PayrollRunType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PayrollRunType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[14].Descriptor()
}

func (PayrollRunType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[14]
}

func (x PayrollRunType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PayrollRunType.Descriptor instead.
func (PayrollRunType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{14}
}

// The type of earning. Possible values include: SALARY, REIMBURSEMENT, OVERTIME, BONUS.
// In cases where there is no clear mapping, the original value passed through will be returned.
type EarningType int32

const (
	EarningType_EARNING_TYPE_UNSPECIFIED   EarningType = 0
	EarningType_EARNING_TYPE_SALARY        EarningType = 1
	EarningType_EARNING_TYPE_REIMBURSEMENT EarningType = 2
	EarningType_EARNING_TYPE_OVERTIME      EarningType = 3
	EarningType_EARNING_TYPE_BONUS         EarningType = 4
)

// Enum value maps for EarningType.
var (
	EarningType_name = map[int32]string{
		0: "EARNING_TYPE_UNSPECIFIED",
		1: "EARNING_TYPE_SALARY",
		2: "EARNING_TYPE_REIMBURSEMENT",
		3: "EARNING_TYPE_OVERTIME",
		4: "EARNING_TYPE_BONUS",
	}
	EarningType_value = map[string]int32{
		"EARNING_TYPE_UNSPECIFIED":   0,
		"EARNING_TYPE_SALARY":        1,
		"EARNING_TYPE_REIMBURSEMENT": 2,
		"EARNING_TYPE_OVERTIME":      3,
		"EARNING_TYPE_BONUS":         4,
	}
)

func (x EarningType) Enum() *EarningType {
	p := new(EarningType)
	*p = x
	return p
}

func (x EarningType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EarningType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[15].Descriptor()
}

func (EarningType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[15]
}

func (x EarningType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EarningType.Descriptor instead.
func (EarningType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{15}
}

// The policy type of this time off balance. Possible values include: VACATION, SICK, PERSONAL,
// JURY_DUTY, VOLUNTEER, BEREAVEMENT. In cases where there is no clear mapping, the original
// value passed through will be returned
type PolicyType int32

const (
	PolicyType_POLICY_TYPE_UNSPECIFIED PolicyType = 0
	PolicyType_POLICY_TYPE_VACATION    PolicyType = 1
	PolicyType_POLICY_TYPE_SICK        PolicyType = 2
	PolicyType_POLICY_TYPE_PERSONAL    PolicyType = 3
	PolicyType_POLICY_TYPE_JURY_DUTY   PolicyType = 4
	PolicyType_POLICY_TYPE_VOLUNTEER   PolicyType = 5
	PolicyType_POLICY_TYPE_BEREAVEMENT PolicyType = 6
)

// Enum value maps for PolicyType.
var (
	PolicyType_name = map[int32]string{
		0: "POLICY_TYPE_UNSPECIFIED",
		1: "POLICY_TYPE_VACATION",
		2: "POLICY_TYPE_SICK",
		3: "POLICY_TYPE_PERSONAL",
		4: "POLICY_TYPE_JURY_DUTY",
		5: "POLICY_TYPE_VOLUNTEER",
		6: "POLICY_TYPE_BEREAVEMENT",
	}
	PolicyType_value = map[string]int32{
		"POLICY_TYPE_UNSPECIFIED": 0,
		"POLICY_TYPE_VACATION":    1,
		"POLICY_TYPE_SICK":        2,
		"POLICY_TYPE_PERSONAL":    3,
		"POLICY_TYPE_JURY_DUTY":   4,
		"POLICY_TYPE_VOLUNTEER":   5,
		"POLICY_TYPE_BEREAVEMENT": 6,
	}
)

func (x PolicyType) Enum() *PolicyType {
	p := new(PolicyType)
	*p = x
	return p
}

func (x PolicyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[16].Descriptor()
}

func (PolicyType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[16]
}

func (x PolicyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyType.Descriptor instead.
func (PolicyType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{16}
}

// The status of this time off request. Possible values include: REQUESTED,
// APPROVED, DECLINED, CANCELLED, DELETED. In cases where there is no clear mapping,
// the original value passed through will be returned.
type TimeOffStatus int32

const (
	TimeOffStatus_TIME_OFF_STATUS_UNSPECIFIED TimeOffStatus = 0
	TimeOffStatus_TIME_OFF_STATUS_REQUESTED   TimeOffStatus = 1
	TimeOffStatus_TIME_OFF_STATUS_APPROVED    TimeOffStatus = 2
	TimeOffStatus_TIME_OFF_STATUS_DECLINED    TimeOffStatus = 3
	TimeOffStatus_TIME_OFF_STATUS_CANCELLED   TimeOffStatus = 4
	TimeOffStatus_TIME_OFF_STATUS_DELETED     TimeOffStatus = 5
)

// Enum value maps for TimeOffStatus.
var (
	TimeOffStatus_name = map[int32]string{
		0: "TIME_OFF_STATUS_UNSPECIFIED",
		1: "TIME_OFF_STATUS_REQUESTED",
		2: "TIME_OFF_STATUS_APPROVED",
		3: "TIME_OFF_STATUS_DECLINED",
		4: "TIME_OFF_STATUS_CANCELLED",
		5: "TIME_OFF_STATUS_DELETED",
	}
	TimeOffStatus_value = map[string]int32{
		"TIME_OFF_STATUS_UNSPECIFIED": 0,
		"TIME_OFF_STATUS_REQUESTED":   1,
		"TIME_OFF_STATUS_APPROVED":    2,
		"TIME_OFF_STATUS_DECLINED":    3,
		"TIME_OFF_STATUS_CANCELLED":   4,
		"TIME_OFF_STATUS_DELETED":     5,
	}
)

func (x TimeOffStatus) Enum() *TimeOffStatus {
	p := new(TimeOffStatus)
	*p = x
	return p
}

func (x TimeOffStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TimeOffStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[17].Descriptor()
}

func (TimeOffStatus) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[17]
}

func (x TimeOffStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TimeOffStatus.Descriptor instead.
func (TimeOffStatus) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{17}
}

// The measurement that the third-party integration uses to count time requested.
// Possible values include: HOURS, DAYS. In cases where there is no clear mapping,
// the original value passed through will be returned.
type TimeOffUnits int32

const (
	TimeOffUnits_TIME_OFF_UNITS_UNSPECIFIED TimeOffUnits = 0
	TimeOffUnits_TIME_OFF_UNITS_HOURS       TimeOffUnits = 1
	TimeOffUnits_TIME_OFF_UNITS_DAYS        TimeOffUnits = 2
)

// Enum value maps for TimeOffUnits.
var (
	TimeOffUnits_name = map[int32]string{
		0: "TIME_OFF_UNITS_UNSPECIFIED",
		1: "TIME_OFF_UNITS_HOURS",
		2: "TIME_OFF_UNITS_DAYS",
	}
	TimeOffUnits_value = map[string]int32{
		"TIME_OFF_UNITS_UNSPECIFIED": 0,
		"TIME_OFF_UNITS_HOURS":       1,
		"TIME_OFF_UNITS_DAYS":        2,
	}
)

func (x TimeOffUnits) Enum() *TimeOffUnits {
	p := new(TimeOffUnits)
	*p = x
	return p
}

func (x TimeOffUnits) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TimeOffUnits) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[18].Descriptor()
}

func (TimeOffUnits) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[18]
}

func (x TimeOffUnits) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TimeOffUnits.Descriptor instead.
func (TimeOffUnits) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{18}
}

// BusinessActionableInsightType is the type of actionable insight
type BusinessActionableInsightType int32

const (
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_UNSPECIFIED BusinessActionableInsightType = 0
	// Operating Expenses: Insights on managing day-to-day operational costs.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_OPERATING_EXPENSES BusinessActionableInsightType = 1
	// Cash Flow Management: Insights into cash inflows and outflows.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_CASH_FLOW_MANAGEMENT BusinessActionableInsightType = 2
	// Revenue Growth: Strategies or opportunities to increase revenue.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_REVENUE_GROWTH BusinessActionableInsightType = 3
	// Cost Reduction: Identifying areas where expenses can be minimized.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_COST_REDUCTION BusinessActionableInsightType = 4
	// Inventory Management: Insights on optimizing inventory levels and costs.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_INVENTORY_MANAGEMENT BusinessActionableInsightType = 5
	// Capital Allocation: Guidance on efficient allocation of financial resources.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_CAPITAL_ALLOCATION BusinessActionableInsightType = 6
	// Investment Opportunities: Identifying potential profitable investments.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_INVESTMENT_OPPORTUNITIES BusinessActionableInsightType = 7
	// Risk Assessment: Insights into potential risks and mitigation strategies.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_RISK_ASSESSMENT BusinessActionableInsightType = 8
	// Tax Planning: Suggestions for tax optimization.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_TAX_PLANNING BusinessActionableInsightType = 9
	// Debt Management: Strategies for managing and reducing debt.
	BusinessActionableInsightType_BUSINESS_ACTIONABLE_INSIGHT_TYPE_DEBT_MANAGEMENT BusinessActionableInsightType = 10
)

// Enum value maps for BusinessActionableInsightType.
var (
	BusinessActionableInsightType_name = map[int32]string{
		0:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_UNSPECIFIED",
		1:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_OPERATING_EXPENSES",
		2:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_CASH_FLOW_MANAGEMENT",
		3:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_REVENUE_GROWTH",
		4:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_COST_REDUCTION",
		5:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_INVENTORY_MANAGEMENT",
		6:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_CAPITAL_ALLOCATION",
		7:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_INVESTMENT_OPPORTUNITIES",
		8:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_RISK_ASSESSMENT",
		9:  "BUSINESS_ACTIONABLE_INSIGHT_TYPE_TAX_PLANNING",
		10: "BUSINESS_ACTIONABLE_INSIGHT_TYPE_DEBT_MANAGEMENT",
	}
	BusinessActionableInsightType_value = map[string]int32{
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_UNSPECIFIED":              0,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_OPERATING_EXPENSES":       1,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_CASH_FLOW_MANAGEMENT":     2,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_REVENUE_GROWTH":           3,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_COST_REDUCTION":           4,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_INVENTORY_MANAGEMENT":     5,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_CAPITAL_ALLOCATION":       6,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_INVESTMENT_OPPORTUNITIES": 7,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_RISK_ASSESSMENT":          8,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_TAX_PLANNING":             9,
		"BUSINESS_ACTIONABLE_INSIGHT_TYPE_DEBT_MANAGEMENT":          10,
	}
)

func (x BusinessActionableInsightType) Enum() *BusinessActionableInsightType {
	p := new(BusinessActionableInsightType)
	*p = x
	return p
}

func (x BusinessActionableInsightType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BusinessActionableInsightType) Descriptor() protoreflect.EnumDescriptor {
	return file_accounting_service_v1_enums_proto_enumTypes[19].Descriptor()
}

func (BusinessActionableInsightType) Type() protoreflect.EnumType {
	return &file_accounting_service_v1_enums_proto_enumTypes[19]
}

func (x BusinessActionableInsightType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BusinessActionableInsightType.Descriptor instead.
func (BusinessActionableInsightType) EnumDescriptor() ([]byte, []int) {
	return file_accounting_service_v1_enums_proto_rawDescGZIP(), []int{19}
}

var File_accounting_service_v1_enums_proto protoreflect.FileDescriptor

var file_accounting_service_v1_enums_proto_rawDesc = []byte{
	0x0a, 0x21, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x72,
	0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x65, 0x6e, 0x75, 0x6d, 0x73, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x15, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x5f,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x76, 0x31, 0x2a, 0x85, 0x02, 0x0a, 0x09, 0x50,
	0x61, 0x79, 0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x12, 0x1a, 0x0a, 0x16, 0x50, 0x41, 0x59, 0x5f,
	0x50, 0x45, 0x52, 0x49, 0x4f, 0x44, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x13, 0x0a, 0x0f, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49,
	0x4f, 0x44, 0x5f, 0x48, 0x4f, 0x55, 0x52, 0x10, 0x01, 0x12, 0x12, 0x0a, 0x0e, 0x50, 0x41, 0x59,
	0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44, 0x5f, 0x44, 0x41, 0x59, 0x10, 0x02, 0x12, 0x13, 0x0a,
	0x0f, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44, 0x5f, 0x57, 0x45, 0x45, 0x4b,
	0x10, 0x03, 0x12, 0x1e, 0x0a, 0x1a, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44,
	0x5f, 0x45, 0x56, 0x45, 0x52, 0x59, 0x5f, 0x54, 0x57, 0x4f, 0x5f, 0x57, 0x45, 0x45, 0x4b, 0x53,
	0x10, 0x04, 0x12, 0x1a, 0x0a, 0x16, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44,
	0x5f, 0x53, 0x45, 0x4d, 0x49, 0x4d, 0x4f, 0x4e, 0x54, 0x48, 0x4c, 0x59, 0x10, 0x05, 0x12, 0x14,
	0x0a, 0x10, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44, 0x5f, 0x4d, 0x4f, 0x4e,
	0x54, 0x48, 0x10, 0x06, 0x12, 0x16, 0x0a, 0x12, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49,
	0x4f, 0x44, 0x5f, 0x51, 0x55, 0x41, 0x52, 0x54, 0x45, 0x52, 0x10, 0x07, 0x12, 0x1f, 0x0a, 0x1b,
	0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44, 0x5f, 0x45, 0x56, 0x45, 0x52, 0x59,
	0x5f, 0x53, 0x49, 0x58, 0x5f, 0x4d, 0x4f, 0x4e, 0x54, 0x48, 0x53, 0x10, 0x08, 0x12, 0x13, 0x0a,
	0x0f, 0x50, 0x41, 0x59, 0x5f, 0x50, 0x45, 0x52, 0x49, 0x4f, 0x44, 0x5f, 0x59, 0x45, 0x41, 0x52,
	0x10, 0x09, 0x2a, 0xb6, 0x02, 0x0a, 0x0c, 0x50, 0x61, 0x79, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65,
	0x6e, 0x63, 0x79, 0x12, 0x1d, 0x0a, 0x19, 0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55,
	0x45, 0x4e, 0x43, 0x59, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44,
	0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45,
	0x4e, 0x43, 0x59, 0x5f, 0x57, 0x45, 0x45, 0x4b, 0x4c, 0x59, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16,
	0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43, 0x59, 0x5f, 0x42, 0x49,
	0x57, 0x45, 0x45, 0x4b, 0x4c, 0x59, 0x10, 0x02, 0x12, 0x19, 0x0a, 0x15, 0x50, 0x41, 0x59, 0x5f,
	0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43, 0x59, 0x5f, 0x4d, 0x4f, 0x4e, 0x54, 0x48, 0x4c,
	0x59, 0x10, 0x03, 0x12, 0x1b, 0x0a, 0x17, 0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55,
	0x45, 0x4e, 0x43, 0x59, 0x5f, 0x51, 0x55, 0x41, 0x52, 0x54, 0x45, 0x52, 0x4c, 0x59, 0x10, 0x04,
	0x12, 0x1e, 0x0a, 0x1a, 0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43,
	0x59, 0x5f, 0x53, 0x45, 0x4d, 0x49, 0x41, 0x4e, 0x4e, 0x55, 0x41, 0x4c, 0x4c, 0x59, 0x10, 0x05,
	0x12, 0x1a, 0x0a, 0x16, 0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43,
	0x59, 0x5f, 0x41, 0x4e, 0x4e, 0x55, 0x41, 0x4c, 0x4c, 0x59, 0x10, 0x06, 0x12, 0x22, 0x0a, 0x1e,
	0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43, 0x59, 0x5f, 0x54, 0x48,
	0x49, 0x52, 0x54, 0x45, 0x45, 0x4e, 0x5f, 0x4d, 0x4f, 0x4e, 0x54, 0x48, 0x4c, 0x59, 0x10, 0x07,
	0x12, 0x1a, 0x0a, 0x16, 0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43,
	0x59, 0x5f, 0x50, 0x52, 0x4f, 0x5f, 0x52, 0x41, 0x54, 0x41, 0x10, 0x08, 0x12, 0x1d, 0x0a, 0x19,
	0x50, 0x41, 0x59, 0x5f, 0x46, 0x52, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43, 0x59, 0x5f, 0x53, 0x45,
	0x4d, 0x49, 0x4d, 0x4f, 0x4e, 0x54, 0x48, 0x4c, 0x59, 0x10, 0x09, 0x2a, 0x99, 0x01, 0x0a, 0x0a,
	0x46, 0x6c, 0x73, 0x61, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1b, 0x0a, 0x17, 0x46, 0x4c,
	0x53, 0x41, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x46, 0x4c, 0x53, 0x41, 0x5f,
	0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x45, 0x58, 0x45, 0x4d, 0x50, 0x54, 0x10, 0x01, 0x12,
	0x1a, 0x0a, 0x16, 0x46, 0x4c, 0x53, 0x41, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x4e,
	0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x4d, 0x50, 0x54, 0x10, 0x02, 0x12, 0x23, 0x0a, 0x1f, 0x46,
	0x4c, 0x53, 0x41, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x41, 0x4c, 0x41, 0x52,
	0x49, 0x45, 0x44, 0x5f, 0x4e, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x4d, 0x50, 0x54, 0x10, 0x03,
	0x12, 0x15, 0x0a, 0x11, 0x46, 0x4c, 0x53, 0x41, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
	0x4f, 0x57, 0x4e, 0x45, 0x52, 0x10, 0x04, 0x2a, 0xca, 0x01, 0x0a, 0x0e, 0x45, 0x6d, 0x70, 0x6c,
	0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x1b, 0x45, 0x4d,
	0x50, 0x4c, 0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e,
	0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a, 0x19, 0x45,
	0x4d, 0x50, 0x4c, 0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46,
	0x55, 0x4c, 0x4c, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19, 0x45, 0x4d,
	0x50, 0x4c, 0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x50, 0x41,
	0x52, 0x54, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x10, 0x02, 0x12, 0x1a, 0x0a, 0x16, 0x45, 0x4d, 0x50,
	0x4c, 0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x54,
	0x45, 0x52, 0x4e, 0x10, 0x03, 0x12, 0x1e, 0x0a, 0x1a, 0x45, 0x4d, 0x50, 0x4c, 0x4f, 0x59, 0x4d,
	0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x41, 0x43,
	0x54, 0x4f, 0x52, 0x10, 0x04, 0x12, 0x1d, 0x0a, 0x19, 0x45, 0x4d, 0x50, 0x4c, 0x4f, 0x59, 0x4d,
	0x45, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x46, 0x52, 0x45, 0x45, 0x4c, 0x41, 0x4e,
	0x43, 0x45, 0x10, 0x05, 0x2a, 0xc2, 0x01, 0x0a, 0x0c, 0x50, 0x61, 0x79, 0x47, 0x72, 0x6f, 0x75,
	0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x1a, 0x50, 0x41, 0x59, 0x5f, 0x47, 0x52, 0x4f,
	0x55, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46,
	0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13, 0x50, 0x41, 0x59, 0x5f, 0x47, 0x52, 0x4f,
	0x55, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x54, 0x45, 0x41, 0x4d, 0x10, 0x01, 0x12, 0x1d,
	0x0a, 0x19, 0x50, 0x41, 0x59, 0x5f, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x44, 0x45, 0x50, 0x41, 0x52, 0x54, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x02, 0x12, 0x1e, 0x0a,
	0x1a, 0x50, 0x41, 0x59, 0x5f, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x43, 0x4f, 0x53, 0x54, 0x5f, 0x43, 0x45, 0x4e, 0x54, 0x45, 0x52, 0x10, 0x03, 0x12, 0x20, 0x0a,
	0x1c, 0x50, 0x41, 0x59, 0x5f, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x10, 0x04, 0x12,
	0x18, 0x0a, 0x14, 0x50, 0x41, 0x59, 0x5f, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x47, 0x52, 0x4f, 0x55, 0x50, 0x10, 0x05, 0x2a, 0x90, 0x01, 0x0a, 0x06, 0x47, 0x65,
	0x6e, 0x64, 0x65, 0x72, 0x12, 0x16, 0x0a, 0x12, 0x47, 0x45, 0x4e, 0x44, 0x45, 0x52, 0x5f, 0x55,
	0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b,
	0x47, 0x45, 0x4e, 0x44, 0x45, 0x52, 0x5f, 0x4d, 0x41, 0x4c, 0x45, 0x10, 0x01, 0x12, 0x11, 0x0a,
	0x0d, 0x47, 0x45, 0x4e, 0x44, 0x45, 0x52, 0x5f, 0x46, 0x45, 0x4d, 0x41, 0x4c, 0x45, 0x10, 0x02,
	0x12, 0x15, 0x0a, 0x11, 0x47, 0x45, 0x4e, 0x44, 0x45, 0x52, 0x5f, 0x4e, 0x4f, 0x4e, 0x5f, 0x42,
	0x49, 0x4e, 0x41, 0x52, 0x59, 0x10, 0x03, 0x12, 0x10, 0x0a, 0x0c, 0x47, 0x45, 0x4e, 0x44, 0x45,
	0x52, 0x5f, 0x4f, 0x54, 0x48, 0x45, 0x52, 0x10, 0x04, 0x12, 0x21, 0x0a, 0x1d, 0x47, 0x45, 0x4e,
	0x44, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x45, 0x46, 0x45, 0x52, 0x5f, 0x4e, 0x4f, 0x54, 0x5f, 0x54,
	0x4f, 0x5f, 0x44, 0x49, 0x53, 0x43, 0x4c, 0x4f, 0x53, 0x45, 0x10, 0x05, 0x2a, 0xe2, 0x02, 0x0a,
	0x09, 0x45, 0x74, 0x68, 0x6e, 0x69, 0x63, 0x69, 0x74, 0x79, 0x12, 0x19, 0x0a, 0x15, 0x45, 0x54,
	0x48, 0x4e, 0x49, 0x43, 0x49, 0x54, 0x59, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46,
	0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x2e, 0x0a, 0x2a, 0x45, 0x54, 0x48, 0x4e, 0x49, 0x43, 0x49,
	0x54, 0x59, 0x5f, 0x41, 0x4d, 0x45, 0x52, 0x49, 0x43, 0x41, 0x4e, 0x5f, 0x49, 0x4e, 0x44, 0x49,
	0x41, 0x4e, 0x5f, 0x4f, 0x52, 0x5f, 0x41, 0x4c, 0x41, 0x53, 0x4b, 0x41, 0x5f, 0x4e, 0x41, 0x54,
	0x49, 0x56, 0x45, 0x10, 0x01, 0x12, 0x2a, 0x0a, 0x26, 0x45, 0x54, 0x48, 0x4e, 0x49, 0x43, 0x49,
	0x54, 0x59, 0x5f, 0x41, 0x53, 0x49, 0x41, 0x4e, 0x5f, 0x4f, 0x52, 0x5f, 0x49, 0x4e, 0x44, 0x49,
	0x41, 0x4e, 0x5f, 0x53, 0x55, 0x42, 0x43, 0x4f, 0x4e, 0x54, 0x49, 0x4e, 0x45, 0x4e, 0x54, 0x10,
	0x02, 0x12, 0x27, 0x0a, 0x23, 0x45, 0x54, 0x48, 0x4e, 0x49, 0x43, 0x49, 0x54, 0x59, 0x5f, 0x42,
	0x4c, 0x41, 0x43, 0x4b, 0x5f, 0x4f, 0x52, 0x5f, 0x41, 0x46, 0x52, 0x49, 0x43, 0x41, 0x4e, 0x5f,
	0x41, 0x4d, 0x45, 0x52, 0x49, 0x43, 0x41, 0x4e, 0x10, 0x03, 0x12, 0x20, 0x0a, 0x1c, 0x45, 0x54,
	0x48, 0x4e, 0x49, 0x43, 0x49, 0x54, 0x59, 0x5f, 0x48, 0x49, 0x53, 0x50, 0x41, 0x4e, 0x49, 0x43,
	0x5f, 0x4f, 0x52, 0x5f, 0x4c, 0x41, 0x54, 0x49, 0x4e, 0x4f, 0x10, 0x04, 0x12, 0x37, 0x0a, 0x33,
	0x45, 0x54, 0x48, 0x4e, 0x49, 0x43, 0x49, 0x54, 0x59, 0x5f, 0x4e, 0x41, 0x54, 0x49, 0x56, 0x45,
	0x5f, 0x48, 0x41, 0x57, 0x41, 0x49, 0x49, 0x41, 0x4e, 0x5f, 0x4f, 0x52, 0x5f, 0x4f, 0x54, 0x48,
	0x45, 0x52, 0x5f, 0x50, 0x41, 0x43, 0x49, 0x46, 0x49, 0x43, 0x5f, 0x49, 0x53, 0x4c, 0x41, 0x4e,
	0x44, 0x45, 0x52, 0x10, 0x05, 0x12, 0x1f, 0x0a, 0x1b, 0x45, 0x54, 0x48, 0x4e, 0x49, 0x43, 0x49,
	0x54, 0x59, 0x5f, 0x54, 0x57, 0x4f, 0x5f, 0x4f, 0x52, 0x5f, 0x4d, 0x4f, 0x52, 0x45, 0x5f, 0x52,
	0x41, 0x43, 0x45, 0x53, 0x10, 0x06, 0x12, 0x13, 0x0a, 0x0f, 0x45, 0x54, 0x48, 0x4e, 0x49, 0x43,
	0x49, 0x54, 0x59, 0x5f, 0x57, 0x48, 0x49, 0x54, 0x45, 0x10, 0x07, 0x12, 0x24, 0x0a, 0x20, 0x45,
	0x54, 0x48, 0x4e, 0x49, 0x43, 0x49, 0x54, 0x59, 0x5f, 0x50, 0x52, 0x45, 0x46, 0x45, 0x52, 0x5f,
	0x4e, 0x4f, 0x54, 0x5f, 0x54, 0x4f, 0x5f, 0x44, 0x49, 0x53, 0x43, 0x4c, 0x4f, 0x53, 0x45, 0x10,
	0x08, 0x2a, 0x8e, 0x02, 0x0a, 0x0d, 0x4d, 0x61, 0x72, 0x69, 0x74, 0x61, 0x6c, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x1e, 0x0a, 0x1a, 0x4d, 0x41, 0x52, 0x49, 0x54, 0x41, 0x4c, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45,
	0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x4d, 0x41, 0x52, 0x49, 0x54, 0x41, 0x4c, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x53, 0x49, 0x4e, 0x47, 0x4c, 0x45, 0x10, 0x01, 0x12, 0x29,
	0x0a, 0x25, 0x4d, 0x41, 0x52, 0x49, 0x54, 0x41, 0x4c, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53,
	0x5f, 0x4d, 0x41, 0x52, 0x52, 0x49, 0x45, 0x44, 0x5f, 0x46, 0x49, 0x4c, 0x49, 0x4e, 0x47, 0x5f,
	0x4a, 0x4f, 0x49, 0x4e, 0x54, 0x4c, 0x59, 0x10, 0x02, 0x12, 0x2c, 0x0a, 0x28, 0x4d, 0x41, 0x52,
	0x49, 0x54, 0x41, 0x4c, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x4d, 0x41, 0x52, 0x52,
	0x49, 0x45, 0x44, 0x5f, 0x46, 0x49, 0x4c, 0x49, 0x4e, 0x47, 0x5f, 0x53, 0x45, 0x50, 0x41, 0x52,
	0x41, 0x54, 0x45, 0x4c, 0x59, 0x10, 0x03, 0x12, 0x24, 0x0a, 0x20, 0x4d, 0x41, 0x52, 0x49, 0x54,
	0x41, 0x4c, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x48, 0x45, 0x41, 0x44, 0x5f, 0x4f,
	0x46, 0x5f, 0x48, 0x4f, 0x55, 0x53, 0x45, 0x48, 0x4f, 0x4c, 0x44, 0x10, 0x04, 0x12, 0x43, 0x0a,
	0x3f, 0x4d, 0x41, 0x52, 0x49, 0x54, 0x41, 0x4c, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
	0x51, 0x55, 0x41, 0x4c, 0x49, 0x46, 0x59, 0x49, 0x4e, 0x47, 0x5f, 0x57, 0x49, 0x44, 0x4f, 0x57,
	0x5f, 0x4f, 0x52, 0x5f, 0x57, 0x49, 0x44, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x57, 0x49, 0x54, 0x48,
	0x5f, 0x44, 0x45, 0x50, 0x45, 0x4e, 0x44, 0x45, 0x4e, 0x54, 0x5f, 0x43, 0x48, 0x49, 0x4c, 0x44,
	0x10, 0x05, 0x2a, 0x92, 0x01, 0x0a, 0x10, 0x45, 0x6d, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e,
	0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x21, 0x0a, 0x1d, 0x45, 0x4d, 0x50, 0x4c, 0x4f,
	0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18, 0x45, 0x4d,
	0x50, 0x4c, 0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f,
	0x41, 0x43, 0x54, 0x49, 0x56, 0x45, 0x10, 0x01, 0x12, 0x1d, 0x0a, 0x19, 0x45, 0x4d, 0x50, 0x4c,
	0x4f, 0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x50, 0x45,
	0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x1e, 0x0a, 0x1a, 0x45, 0x4d, 0x50, 0x4c, 0x4f,
	0x59, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x49, 0x4e, 0x41,
	0x43, 0x54, 0x49, 0x56, 0x45, 0x10, 0x03, 0x2a, 0x73, 0x0a, 0x0f, 0x42, 0x61, 0x6e, 0x6b, 0x41,
	0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a, 0x1d, 0x42, 0x41,
	0x4e, 0x4b, 0x5f, 0x41, 0x43, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1e, 0x0a,
	0x1a, 0x42, 0x41, 0x4e, 0x4b, 0x5f, 0x41, 0x43, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x43, 0x48, 0x45, 0x43, 0x4b, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x1d, 0x0a,
	0x19, 0x42, 0x41, 0x4e, 0x4b, 0x5f, 0x41, 0x43, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x53, 0x41, 0x56, 0x49, 0x4e, 0x47, 0x53, 0x10, 0x02, 0x2a, 0xd9, 0x01, 0x0a,
	0x0f, 0x42, 0x65, 0x6e, 0x65, 0x66, 0x69, 0x74, 0x50, 0x6c, 0x61, 0x6e, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x21, 0x0a, 0x1d, 0x42, 0x45, 0x4e, 0x45, 0x46, 0x49, 0x54, 0x5f, 0x50, 0x4c, 0x41, 0x4e,
	0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45,
	0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a, 0x19, 0x42, 0x45, 0x4e, 0x45, 0x46, 0x49, 0x54, 0x5f, 0x50,
	0x4c, 0x41, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x43, 0x41, 0x4c,
	0x10, 0x01, 0x12, 0x24, 0x0a, 0x20, 0x42, 0x45, 0x4e, 0x45, 0x46, 0x49, 0x54, 0x5f, 0x50, 0x4c,
	0x41, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x45, 0x41, 0x4c, 0x54, 0x48, 0x5f, 0x53,
	0x41, 0x56, 0x49, 0x4e, 0x47, 0x53, 0x10, 0x02, 0x12, 0x1f, 0x0a, 0x1b, 0x42, 0x45, 0x4e, 0x45,
	0x46, 0x49, 0x54, 0x5f, 0x50, 0x4c, 0x41, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e,
	0x53, 0x55, 0x52, 0x41, 0x4e, 0x43, 0x45, 0x10, 0x03, 0x12, 0x20, 0x0a, 0x1c, 0x42, 0x45, 0x4e,
	0x45, 0x46, 0x49, 0x54, 0x5f, 0x50, 0x4c, 0x41, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52,
	0x45, 0x54, 0x49, 0x52, 0x45, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x04, 0x12, 0x1b, 0x0a, 0x17, 0x42,
	0x45, 0x4e, 0x45, 0x46, 0x49, 0x54, 0x5f, 0x50, 0x4c, 0x41, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x4f, 0x54, 0x48, 0x45, 0x52, 0x10, 0x05, 0x2a, 0xb1, 0x01, 0x0a, 0x15, 0x44, 0x65, 0x70,
	0x65, 0x6e, 0x64, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68,
	0x69, 0x70, 0x12, 0x26, 0x0a, 0x22, 0x44, 0x45, 0x50, 0x45, 0x4e, 0x44, 0x45, 0x4e, 0x54, 0x5f,
	0x52, 0x45, 0x4c, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x48, 0x49, 0x50, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x20, 0x0a, 0x1c, 0x44, 0x45,
	0x50, 0x45, 0x4e, 0x44, 0x45, 0x4e, 0x54, 0x5f, 0x52, 0x45, 0x4c, 0x41, 0x54, 0x49, 0x4f, 0x4e,
	0x53, 0x48, 0x49, 0x50, 0x5f, 0x43, 0x48, 0x49, 0x4c, 0x44, 0x10, 0x01, 0x12, 0x21, 0x0a, 0x1d,
	0x44, 0x45, 0x50, 0x45, 0x4e, 0x44, 0x45, 0x4e, 0x54, 0x5f, 0x52, 0x45, 0x4c, 0x41, 0x54, 0x49,
	0x4f, 0x4e, 0x53, 0x48, 0x49, 0x50, 0x5f, 0x53, 0x50, 0x4f, 0x55, 0x53, 0x45, 0x10, 0x02, 0x12,
	0x2b, 0x0a, 0x27, 0x44, 0x45, 0x50, 0x45, 0x4e, 0x44, 0x45, 0x4e, 0x54, 0x5f, 0x52, 0x45, 0x4c,
	0x41, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x48, 0x49, 0x50, 0x5f, 0x44, 0x4f, 0x4d, 0x45, 0x53, 0x54,
	0x49, 0x43, 0x5f, 0x50, 0x41, 0x52, 0x54, 0x4e, 0x45, 0x52, 0x10, 0x03, 0x2a, 0x5d, 0x0a, 0x0c,
	0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1d, 0x0a, 0x19,
	0x4c, 0x4f, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e,
	0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x16, 0x0a, 0x12, 0x4c,
	0x4f, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x48, 0x4f, 0x4d,
	0x45, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x4c, 0x4f, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x57, 0x4f, 0x52, 0x4b, 0x10, 0x02, 0x2a, 0xc9, 0x01, 0x0a, 0x0f,
	0x50, 0x61, 0x79, 0x72, 0x6f, 0x6c, 0x6c, 0x52, 0x75, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12,
	0x21, 0x0a, 0x1d, 0x50, 0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44,
	0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x50, 0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55,
	0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x50, 0x41, 0x49, 0x44, 0x10, 0x01, 0x12, 0x1b,
	0x0a, 0x17, 0x50, 0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53, 0x54,
	0x41, 0x54, 0x45, 0x5f, 0x44, 0x52, 0x41, 0x46, 0x54, 0x10, 0x02, 0x12, 0x1e, 0x0a, 0x1a, 0x50,
	0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45,
	0x5f, 0x41, 0x50, 0x50, 0x52, 0x4f, 0x56, 0x45, 0x44, 0x10, 0x03, 0x12, 0x1c, 0x0a, 0x18, 0x50,
	0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45,
	0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x04, 0x12, 0x1c, 0x0a, 0x18, 0x50, 0x41, 0x59,
	0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x5f, 0x43,
	0x4c, 0x4f, 0x53, 0x45, 0x44, 0x10, 0x05, 0x2a, 0xd7, 0x01, 0x0a, 0x0e, 0x50, 0x61, 0x79, 0x72,
	0x6f, 0x6c, 0x6c, 0x52, 0x75, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x1c, 0x50, 0x41,
	0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55,
	0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18,
	0x50, 0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x52, 0x45, 0x47, 0x55, 0x4c, 0x41, 0x52, 0x10, 0x01, 0x12, 0x1e, 0x0a, 0x1a, 0x50, 0x41,
	0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f,
	0x46, 0x46, 0x5f, 0x43, 0x59, 0x43, 0x4c, 0x45, 0x10, 0x02, 0x12, 0x1f, 0x0a, 0x1b, 0x50, 0x41,
	0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43,
	0x4f, 0x52, 0x52, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12, 0x20, 0x0a, 0x1c, 0x50,
	0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x04, 0x12, 0x22, 0x0a,
	0x1e, 0x50, 0x41, 0x59, 0x52, 0x4f, 0x4c, 0x4c, 0x5f, 0x52, 0x55, 0x4e, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x53, 0x49, 0x47, 0x4e, 0x5f, 0x4f, 0x4e, 0x5f, 0x42, 0x4f, 0x4e, 0x55, 0x53, 0x10,
	0x05, 0x2a, 0x97, 0x01, 0x0a, 0x0b, 0x45, 0x61, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x1c, 0x0a, 0x18, 0x45, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50,
	0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12,
	0x17, 0x0a, 0x13, 0x45, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x53, 0x41, 0x4c, 0x41, 0x52, 0x59, 0x10, 0x01, 0x12, 0x1e, 0x0a, 0x1a, 0x45, 0x41, 0x52, 0x4e,
	0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45, 0x49, 0x4d, 0x42, 0x55, 0x52,
	0x53, 0x45, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x02, 0x12, 0x19, 0x0a, 0x15, 0x45, 0x41, 0x52, 0x4e,
	0x49, 0x4e, 0x47, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x56, 0x45, 0x52, 0x54, 0x49, 0x4d,
	0x45, 0x10, 0x03, 0x12, 0x16, 0x0a, 0x12, 0x45, 0x41, 0x52, 0x4e, 0x49, 0x4e, 0x47, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x42, 0x4f, 0x4e, 0x55, 0x53, 0x10, 0x04, 0x2a, 0xc6, 0x01, 0x0a, 0x0a,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x17, 0x50, 0x4f,
	0x4c, 0x49, 0x43, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x50, 0x4f, 0x4c, 0x49, 0x43,
	0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x41, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10,
	0x01, 0x12, 0x14, 0x0a, 0x10, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x53, 0x49, 0x43, 0x4b, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x50, 0x4f, 0x4c, 0x49, 0x43,
	0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x50, 0x45, 0x52, 0x53, 0x4f, 0x4e, 0x41, 0x4c, 0x10,
	0x03, 0x12, 0x19, 0x0a, 0x15, 0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x4a, 0x55, 0x52, 0x59, 0x5f, 0x44, 0x55, 0x54, 0x59, 0x10, 0x04, 0x12, 0x19, 0x0a, 0x15,
	0x50, 0x4f, 0x4c, 0x49, 0x43, 0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x56, 0x4f, 0x4c, 0x55,
	0x4e, 0x54, 0x45, 0x45, 0x52, 0x10, 0x05, 0x12, 0x1b, 0x0a, 0x17, 0x50, 0x4f, 0x4c, 0x49, 0x43,
	0x59, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x45, 0x52, 0x45, 0x41, 0x56, 0x45, 0x4d, 0x45,
	0x4e, 0x54, 0x10, 0x06, 0x2a, 0xc7, 0x01, 0x0a, 0x0d, 0x54, 0x69, 0x6d, 0x65, 0x4f, 0x66, 0x66,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x1f, 0x0a, 0x1b, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f,
	0x46, 0x46, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1d, 0x0a, 0x19, 0x54, 0x49, 0x4d, 0x45, 0x5f,
	0x4f, 0x46, 0x46, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x52, 0x45, 0x51, 0x55, 0x45,
	0x53, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x1c, 0x0a, 0x18, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f,
	0x46, 0x46, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x41, 0x50, 0x50, 0x52, 0x4f, 0x56,
	0x45, 0x44, 0x10, 0x02, 0x12, 0x1c, 0x0a, 0x18, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f, 0x46, 0x46,
	0x5f, 0x53, 0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x44, 0x45, 0x43, 0x4c, 0x49, 0x4e, 0x45, 0x44,
	0x10, 0x03, 0x12, 0x1d, 0x0a, 0x19, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x5f, 0x53,
	0x54, 0x41, 0x54, 0x55, 0x53, 0x5f, 0x43, 0x41, 0x4e, 0x43, 0x45, 0x4c, 0x4c, 0x45, 0x44, 0x10,
	0x04, 0x12, 0x1b, 0x0a, 0x17, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x5f, 0x53, 0x54,
	0x41, 0x54, 0x55, 0x53, 0x5f, 0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x44, 0x10, 0x05, 0x2a, 0x61,
	0x0a, 0x0c, 0x54, 0x69, 0x6d, 0x65, 0x4f, 0x66, 0x66, 0x55, 0x6e, 0x69, 0x74, 0x73, 0x12, 0x1e,
	0x0a, 0x1a, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x53,
	0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x18,
	0x0a, 0x14, 0x54, 0x49, 0x4d, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x53,
	0x5f, 0x48, 0x4f, 0x55, 0x52, 0x53, 0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x54, 0x49, 0x4d, 0x45,
	0x5f, 0x4f, 0x46, 0x46, 0x5f, 0x55, 0x4e, 0x49, 0x54, 0x53, 0x5f, 0x44, 0x41, 0x59, 0x53, 0x10,
	0x02, 0x2a, 0x81, 0x05, 0x0a, 0x1d, 0x42, 0x75, 0x73, 0x69, 0x6e, 0x65, 0x73, 0x73, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x73, 0x69, 0x67, 0x68, 0x74, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x30, 0x0a, 0x2c, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f,
	0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47,
	0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46,
	0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x37, 0x0a, 0x33, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53,
	0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53,
	0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54,
	0x49, 0x4e, 0x47, 0x5f, 0x45, 0x58, 0x50, 0x45, 0x4e, 0x53, 0x45, 0x53, 0x10, 0x01, 0x12, 0x39,
	0x0a, 0x35, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f,
	0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x43, 0x41, 0x53, 0x48, 0x5f, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x4d, 0x41, 0x4e,
	0x41, 0x47, 0x45, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x02, 0x12, 0x33, 0x0a, 0x2f, 0x42, 0x55, 0x53,
	0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45,
	0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x45,
	0x56, 0x45, 0x4e, 0x55, 0x45, 0x5f, 0x47, 0x52, 0x4f, 0x57, 0x54, 0x48, 0x10, 0x03, 0x12, 0x33,
	0x0a, 0x2f, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f,
	0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x43, 0x4f, 0x53, 0x54, 0x5f, 0x52, 0x45, 0x44, 0x55, 0x43, 0x54, 0x49, 0x4f,
	0x4e, 0x10, 0x04, 0x12, 0x39, 0x0a, 0x35, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f,
	0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47,
	0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x45, 0x4e, 0x54, 0x4f, 0x52,
	0x59, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x05, 0x12, 0x37,
	0x0a, 0x33, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f,
	0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x43, 0x41, 0x50, 0x49, 0x54, 0x41, 0x4c, 0x5f, 0x41, 0x4c, 0x4c, 0x4f, 0x43,
	0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x06, 0x12, 0x3d, 0x0a, 0x39, 0x42, 0x55, 0x53, 0x49, 0x4e,
	0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49,
	0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x45,
	0x53, 0x54, 0x4d, 0x45, 0x4e, 0x54, 0x5f, 0x4f, 0x50, 0x50, 0x4f, 0x52, 0x54, 0x55, 0x4e, 0x49,
	0x54, 0x49, 0x45, 0x53, 0x10, 0x07, 0x12, 0x34, 0x0a, 0x30, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45,
	0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e,
	0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x52, 0x49, 0x53, 0x4b, 0x5f,
	0x41, 0x53, 0x53, 0x45, 0x53, 0x53, 0x4d, 0x45, 0x4e, 0x54, 0x10, 0x08, 0x12, 0x31, 0x0a, 0x2d,
	0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x41,
	0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45,
	0x5f, 0x54, 0x41, 0x58, 0x5f, 0x50, 0x4c, 0x41, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x09, 0x12,
	0x34, 0x0a, 0x30, 0x42, 0x55, 0x53, 0x49, 0x4e, 0x45, 0x53, 0x53, 0x5f, 0x41, 0x43, 0x54, 0x49,
	0x4f, 0x4e, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x49, 0x4e, 0x53, 0x49, 0x47, 0x48, 0x54, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x44, 0x45, 0x42, 0x54, 0x5f, 0x4d, 0x41, 0x4e, 0x41, 0x47, 0x45, 0x4d,
	0x45, 0x4e, 0x54, 0x10, 0x0a, 0x42, 0x9b, 0x02, 0x0a, 0x19, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x63,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x2e, 0x76, 0x31, 0x42, 0x0a, 0x45, 0x6e, 0x75, 0x6d, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50,
	0x01, 0x5a, 0x80, 0x01, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x53,
	0x6f, 0x6c, 0x6f, 0x6d, 0x6f, 0x6e, 0x41, 0x49, 0x45, 0x6e, 0x67, 0x69, 0x6e, 0x65, 0x65, 0x72,
	0x69, 0x6e, 0x67, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x6c, 0x65, 0x76, 0x65,
	0x6c, 0x2d, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x6b, 0x67, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61,
	0x74, 0x65, 0x64, 0x2f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x2d, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e,
	0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2f, 0x76, 0x31, 0x3b,
	0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69,
	0x63, 0x65, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x41, 0x58, 0x58, 0xaa, 0x02, 0x14, 0x41, 0x63, 0x63,
	0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x56,
	0x31, 0xca, 0x02, 0x14, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x20, 0x41, 0x63, 0x63, 0x6f, 0x75,
	0x6e, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5c, 0x56, 0x31, 0x5c,
	0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x15, 0x41, 0x63,
	0x63, 0x6f, 0x75, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x3a,
	0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_accounting_service_v1_enums_proto_rawDescOnce sync.Once
	file_accounting_service_v1_enums_proto_rawDescData = file_accounting_service_v1_enums_proto_rawDesc
)

func file_accounting_service_v1_enums_proto_rawDescGZIP() []byte {
	file_accounting_service_v1_enums_proto_rawDescOnce.Do(func() {
		file_accounting_service_v1_enums_proto_rawDescData = protoimpl.X.CompressGZIP(file_accounting_service_v1_enums_proto_rawDescData)
	})
	return file_accounting_service_v1_enums_proto_rawDescData
}

var file_accounting_service_v1_enums_proto_enumTypes = make([]protoimpl.EnumInfo, 20)
var file_accounting_service_v1_enums_proto_goTypes = []interface{}{
	(PayPeriod)(0),                     // 0: accounting_service.v1.PayPeriod
	(PayFrequency)(0),                  // 1: accounting_service.v1.PayFrequency
	(FlsaStatus)(0),                    // 2: accounting_service.v1.FlsaStatus
	(EmploymentType)(0),                // 3: accounting_service.v1.EmploymentType
	(PayGroupType)(0),                  // 4: accounting_service.v1.PayGroupType
	(Gender)(0),                        // 5: accounting_service.v1.Gender
	(Ethnicity)(0),                     // 6: accounting_service.v1.Ethnicity
	(MaritalStatus)(0),                 // 7: accounting_service.v1.MaritalStatus
	(EmploymentStatus)(0),              // 8: accounting_service.v1.EmploymentStatus
	(BankAccountType)(0),               // 9: accounting_service.v1.BankAccountType
	(BenefitPlanType)(0),               // 10: accounting_service.v1.BenefitPlanType
	(DependentRelationship)(0),         // 11: accounting_service.v1.DependentRelationship
	(LocationType)(0),                  // 12: accounting_service.v1.LocationType
	(PayrollRunState)(0),               // 13: accounting_service.v1.PayrollRunState
	(PayrollRunType)(0),                // 14: accounting_service.v1.PayrollRunType
	(EarningType)(0),                   // 15: accounting_service.v1.EarningType
	(PolicyType)(0),                    // 16: accounting_service.v1.PolicyType
	(TimeOffStatus)(0),                 // 17: accounting_service.v1.TimeOffStatus
	(TimeOffUnits)(0),                  // 18: accounting_service.v1.TimeOffUnits
	(BusinessActionableInsightType)(0), // 19: accounting_service.v1.BusinessActionableInsightType
}
var file_accounting_service_v1_enums_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_accounting_service_v1_enums_proto_init() }
func file_accounting_service_v1_enums_proto_init() {
	if File_accounting_service_v1_enums_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_accounting_service_v1_enums_proto_rawDesc,
			NumEnums:      20,
			NumMessages:   0,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_accounting_service_v1_enums_proto_goTypes,
		DependencyIndexes: file_accounting_service_v1_enums_proto_depIdxs,
		EnumInfos:         file_accounting_service_v1_enums_proto_enumTypes,
	}.Build()
	File_accounting_service_v1_enums_proto = out.File
	file_accounting_service_v1_enums_proto_rawDesc = nil
	file_accounting_service_v1_enums_proto_goTypes = nil
	file_accounting_service_v1_enums_proto_depIdxs = nil
}
