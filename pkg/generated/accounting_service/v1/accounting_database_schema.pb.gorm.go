package accounting_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type AccountingIntegrationMergeLinkORM struct {
	Account                 *LinkedAccountingAccountORM `gorm:"foreignkey:AccountingIntegrationMergeLinkId;association_foreignkey:Id;preload:true"`
	Category                string
	EndUserEmailAddress     string
	EndUserOrganizationName string
	EndUserOriginId         string
	Id                      uint64 `gorm:"unique_index:idx_accounting_integration_merge_link_id"`
	Integration             string
	IntegrationImage        string
	IntegrationName         string
	IntegrationSlug         string
	IntegrationSquareImage  string
	IsDuplicate             bool
	LastModifiedAt          *time.Time
	MergeBusinessProfileId  *uint64
	MergeLinkedAccountId    string
	Status                  string
	Token                   *MergeLinkedAccountTokenORM `gorm:"foreignkey:AccountingIntegrationMergeLinkId;association_foreignkey:Id;preload:true"`
	WebhookListenerUrl      string
}

// TableName overrides the default tablename generated by GORM
func (AccountingIntegrationMergeLinkORM) TableName() string {
	return "accounting_integration_merge_links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountingIntegrationMergeLink) ToORM(ctx context.Context) (AccountingIntegrationMergeLinkORM, error) {
	to := AccountingIntegrationMergeLinkORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	if m.Account != nil {
		tempAccount, err := m.Account.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if m.LastModifiedAt != nil {
		t := m.LastModifiedAt.AsTime()
		to.LastModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountingIntegrationMergeLinkORM) ToPB(ctx context.Context) (AccountingIntegrationMergeLink, error) {
	to := AccountingIntegrationMergeLink{}
	var err error
	if prehook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	if m.Account != nil {
		tempAccount, err := m.Account.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if m.LastModifiedAt != nil {
		to.LastModifiedAt = timestamppb.New(*m.LastModifiedAt)
	}
	if posthook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountingIntegrationMergeLink the arg will be the target, the caller the one being converted from

// AccountingIntegrationMergeLinkBeforeToORM called before default ToORM code
type AccountingIntegrationMergeLinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountingIntegrationMergeLinkORM) error
}

// AccountingIntegrationMergeLinkAfterToORM called after default ToORM code
type AccountingIntegrationMergeLinkWithAfterToORM interface {
	AfterToORM(context.Context, *AccountingIntegrationMergeLinkORM) error
}

// AccountingIntegrationMergeLinkBeforeToPB called before default ToPB code
type AccountingIntegrationMergeLinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountingIntegrationMergeLink) error
}

// AccountingIntegrationMergeLinkAfterToPB called after default ToPB code
type AccountingIntegrationMergeLinkWithAfterToPB interface {
	AfterToPB(context.Context, *AccountingIntegrationMergeLink) error
}

type LinkedAccountingAccountORM struct {
	AccountingIntegrationMergeLinkId *uint64
	Attachments                      []*AccountingAttachmentORM   `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	BalanceSheets                    []*BalanceSheetORM           `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	CashFlowStatements               []*CashFlowStatementORM      `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	ChartOfAccounts                  []*BusinessChartOfAccountORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	CompanyInfo                      []*CompanyInfoORM            `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Contacts                         []*ContactsORM               `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	CreditNotes                      []*CreditNoteORM             `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Expenses                         []*ExpenseORM                `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Id                               uint64                       `gorm:"unique_index:idx_linked_accounting_account_id"`
	IncomeStatements                 []*IncomeStatementORM        `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Invoices                         []*InvoiceORM                `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Items                            []*ItemORM                   `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	JournalEntries                   []*JournalEntryORM           `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Payments                         []*PaymentORM                `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	PurchaseOrders                   []*PurchaseOrderORM          `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	TaxRates                         []*TaxRateORM                `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Transactions                     []*BusinessTransactionORM    `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	VendorCredits                    []*VendorCreditORM           `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (LinkedAccountingAccountORM) TableName() string {
	return "linked_accounting_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LinkedAccountingAccount) ToORM(ctx context.Context) (LinkedAccountingAccountORM, error) {
	to := LinkedAccountingAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(LinkedAccountingAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Attachments {
		if v != nil {
			if tempAttachments, cErr := v.ToORM(ctx); cErr == nil {
				to.Attachments = append(to.Attachments, &tempAttachments)
			} else {
				return to, cErr
			}
		} else {
			to.Attachments = append(to.Attachments, nil)
		}
	}
	for _, v := range m.CompanyInfo {
		if v != nil {
			if tempCompanyInfo, cErr := v.ToORM(ctx); cErr == nil {
				to.CompanyInfo = append(to.CompanyInfo, &tempCompanyInfo)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyInfo = append(to.CompanyInfo, nil)
		}
	}
	for _, v := range m.PurchaseOrders {
		if v != nil {
			if tempPurchaseOrders, cErr := v.ToORM(ctx); cErr == nil {
				to.PurchaseOrders = append(to.PurchaseOrders, &tempPurchaseOrders)
			} else {
				return to, cErr
			}
		} else {
			to.PurchaseOrders = append(to.PurchaseOrders, nil)
		}
	}
	for _, v := range m.BalanceSheets {
		if v != nil {
			if tempBalanceSheets, cErr := v.ToORM(ctx); cErr == nil {
				to.BalanceSheets = append(to.BalanceSheets, &tempBalanceSheets)
			} else {
				return to, cErr
			}
		} else {
			to.BalanceSheets = append(to.BalanceSheets, nil)
		}
	}
	for _, v := range m.CashFlowStatements {
		if v != nil {
			if tempCashFlowStatements, cErr := v.ToORM(ctx); cErr == nil {
				to.CashFlowStatements = append(to.CashFlowStatements, &tempCashFlowStatements)
			} else {
				return to, cErr
			}
		} else {
			to.CashFlowStatements = append(to.CashFlowStatements, nil)
		}
	}
	for _, v := range m.IncomeStatements {
		if v != nil {
			if tempIncomeStatements, cErr := v.ToORM(ctx); cErr == nil {
				to.IncomeStatements = append(to.IncomeStatements, &tempIncomeStatements)
			} else {
				return to, cErr
			}
		} else {
			to.IncomeStatements = append(to.IncomeStatements, nil)
		}
	}
	for _, v := range m.ChartOfAccounts {
		if v != nil {
			if tempChartOfAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.ChartOfAccounts = append(to.ChartOfAccounts, &tempChartOfAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.ChartOfAccounts = append(to.ChartOfAccounts, nil)
		}
	}
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToORM(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	for _, v := range m.TaxRates {
		if v != nil {
			if tempTaxRates, cErr := v.ToORM(ctx); cErr == nil {
				to.TaxRates = append(to.TaxRates, &tempTaxRates)
			} else {
				return to, cErr
			}
		} else {
			to.TaxRates = append(to.TaxRates, nil)
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	for _, v := range m.Invoices {
		if v != nil {
			if tempInvoices, cErr := v.ToORM(ctx); cErr == nil {
				to.Invoices = append(to.Invoices, &tempInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.Invoices = append(to.Invoices, nil)
		}
	}
	for _, v := range m.Payments {
		if v != nil {
			if tempPayments, cErr := v.ToORM(ctx); cErr == nil {
				to.Payments = append(to.Payments, &tempPayments)
			} else {
				return to, cErr
			}
		} else {
			to.Payments = append(to.Payments, nil)
		}
	}
	for _, v := range m.Expenses {
		if v != nil {
			if tempExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.Expenses = append(to.Expenses, &tempExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.Expenses = append(to.Expenses, nil)
		}
	}
	for _, v := range m.JournalEntries {
		if v != nil {
			if tempJournalEntries, cErr := v.ToORM(ctx); cErr == nil {
				to.JournalEntries = append(to.JournalEntries, &tempJournalEntries)
			} else {
				return to, cErr
			}
		} else {
			to.JournalEntries = append(to.JournalEntries, nil)
		}
	}
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.VendorCredits {
		if v != nil {
			if tempVendorCredits, cErr := v.ToORM(ctx); cErr == nil {
				to.VendorCredits = append(to.VendorCredits, &tempVendorCredits)
			} else {
				return to, cErr
			}
		} else {
			to.VendorCredits = append(to.VendorCredits, nil)
		}
	}
	for _, v := range m.CreditNotes {
		if v != nil {
			if tempCreditNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.CreditNotes = append(to.CreditNotes, &tempCreditNotes)
			} else {
				return to, cErr
			}
		} else {
			to.CreditNotes = append(to.CreditNotes, nil)
		}
	}
	if posthook, ok := interface{}(m).(LinkedAccountingAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LinkedAccountingAccountORM) ToPB(ctx context.Context) (LinkedAccountingAccount, error) {
	to := LinkedAccountingAccount{}
	var err error
	if prehook, ok := interface{}(m).(LinkedAccountingAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Attachments {
		if v != nil {
			if tempAttachments, cErr := v.ToPB(ctx); cErr == nil {
				to.Attachments = append(to.Attachments, &tempAttachments)
			} else {
				return to, cErr
			}
		} else {
			to.Attachments = append(to.Attachments, nil)
		}
	}
	for _, v := range m.CompanyInfo {
		if v != nil {
			if tempCompanyInfo, cErr := v.ToPB(ctx); cErr == nil {
				to.CompanyInfo = append(to.CompanyInfo, &tempCompanyInfo)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyInfo = append(to.CompanyInfo, nil)
		}
	}
	for _, v := range m.PurchaseOrders {
		if v != nil {
			if tempPurchaseOrders, cErr := v.ToPB(ctx); cErr == nil {
				to.PurchaseOrders = append(to.PurchaseOrders, &tempPurchaseOrders)
			} else {
				return to, cErr
			}
		} else {
			to.PurchaseOrders = append(to.PurchaseOrders, nil)
		}
	}
	for _, v := range m.BalanceSheets {
		if v != nil {
			if tempBalanceSheets, cErr := v.ToPB(ctx); cErr == nil {
				to.BalanceSheets = append(to.BalanceSheets, &tempBalanceSheets)
			} else {
				return to, cErr
			}
		} else {
			to.BalanceSheets = append(to.BalanceSheets, nil)
		}
	}
	for _, v := range m.CashFlowStatements {
		if v != nil {
			if tempCashFlowStatements, cErr := v.ToPB(ctx); cErr == nil {
				to.CashFlowStatements = append(to.CashFlowStatements, &tempCashFlowStatements)
			} else {
				return to, cErr
			}
		} else {
			to.CashFlowStatements = append(to.CashFlowStatements, nil)
		}
	}
	for _, v := range m.IncomeStatements {
		if v != nil {
			if tempIncomeStatements, cErr := v.ToPB(ctx); cErr == nil {
				to.IncomeStatements = append(to.IncomeStatements, &tempIncomeStatements)
			} else {
				return to, cErr
			}
		} else {
			to.IncomeStatements = append(to.IncomeStatements, nil)
		}
	}
	for _, v := range m.ChartOfAccounts {
		if v != nil {
			if tempChartOfAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.ChartOfAccounts = append(to.ChartOfAccounts, &tempChartOfAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.ChartOfAccounts = append(to.ChartOfAccounts, nil)
		}
	}
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToPB(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	for _, v := range m.TaxRates {
		if v != nil {
			if tempTaxRates, cErr := v.ToPB(ctx); cErr == nil {
				to.TaxRates = append(to.TaxRates, &tempTaxRates)
			} else {
				return to, cErr
			}
		} else {
			to.TaxRates = append(to.TaxRates, nil)
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	for _, v := range m.Invoices {
		if v != nil {
			if tempInvoices, cErr := v.ToPB(ctx); cErr == nil {
				to.Invoices = append(to.Invoices, &tempInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.Invoices = append(to.Invoices, nil)
		}
	}
	for _, v := range m.Payments {
		if v != nil {
			if tempPayments, cErr := v.ToPB(ctx); cErr == nil {
				to.Payments = append(to.Payments, &tempPayments)
			} else {
				return to, cErr
			}
		} else {
			to.Payments = append(to.Payments, nil)
		}
	}
	for _, v := range m.Expenses {
		if v != nil {
			if tempExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.Expenses = append(to.Expenses, &tempExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.Expenses = append(to.Expenses, nil)
		}
	}
	for _, v := range m.JournalEntries {
		if v != nil {
			if tempJournalEntries, cErr := v.ToPB(ctx); cErr == nil {
				to.JournalEntries = append(to.JournalEntries, &tempJournalEntries)
			} else {
				return to, cErr
			}
		} else {
			to.JournalEntries = append(to.JournalEntries, nil)
		}
	}
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.VendorCredits {
		if v != nil {
			if tempVendorCredits, cErr := v.ToPB(ctx); cErr == nil {
				to.VendorCredits = append(to.VendorCredits, &tempVendorCredits)
			} else {
				return to, cErr
			}
		} else {
			to.VendorCredits = append(to.VendorCredits, nil)
		}
	}
	for _, v := range m.CreditNotes {
		if v != nil {
			if tempCreditNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.CreditNotes = append(to.CreditNotes, &tempCreditNotes)
			} else {
				return to, cErr
			}
		} else {
			to.CreditNotes = append(to.CreditNotes, nil)
		}
	}
	if posthook, ok := interface{}(m).(LinkedAccountingAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LinkedAccountingAccount the arg will be the target, the caller the one being converted from

// LinkedAccountingAccountBeforeToORM called before default ToORM code
type LinkedAccountingAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *LinkedAccountingAccountORM) error
}

// LinkedAccountingAccountAfterToORM called after default ToORM code
type LinkedAccountingAccountWithAfterToORM interface {
	AfterToORM(context.Context, *LinkedAccountingAccountORM) error
}

// LinkedAccountingAccountBeforeToPB called before default ToPB code
type LinkedAccountingAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *LinkedAccountingAccount) error
}

// LinkedAccountingAccountAfterToPB called after default ToPB code
type LinkedAccountingAccountWithAfterToPB interface {
	AfterToPB(context.Context, *LinkedAccountingAccount) error
}

type BusinessChartOfAccountORM struct {
	AccountNumber             string
	Classification            string
	Company                   string
	CreatedAt                 *time.Time
	Currency                  string
	CurrentBalance            float64
	Description               string
	Id                        uint64 `gorm:"unique_index:idx_business_chart_of_account_id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_business_chart_of_account_merge_record_id"`
	ModifiedAt                *time.Time
	Name                      string
	ParentAccountId           string
	RemoteId                  string
	RemoteWasDeleted          bool
	Status                    string
	Type                      string
}

// TableName overrides the default tablename generated by GORM
func (BusinessChartOfAccountORM) TableName() string {
	return "business_chart_of_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessChartOfAccount) ToORM(ctx context.Context) (BusinessChartOfAccountORM, error) {
	to := BusinessChartOfAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessChartOfAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeRecordId = m.MergeRecordId
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Description = m.Description
	to.Classification = m.Classification
	to.Type = m.Type
	to.Status = m.Status
	to.CurrentBalance = m.CurrentBalance
	to.Currency = m.Currency
	to.AccountNumber = m.AccountNumber
	to.ParentAccountId = m.ParentAccountId
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(BusinessChartOfAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessChartOfAccountORM) ToPB(ctx context.Context) (BusinessChartOfAccount, error) {
	to := BusinessChartOfAccount{}
	var err error
	if prehook, ok := interface{}(m).(BusinessChartOfAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeRecordId = m.MergeRecordId
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Description = m.Description
	to.Classification = m.Classification
	to.Type = m.Type
	to.Status = m.Status
	to.CurrentBalance = m.CurrentBalance
	to.Currency = m.Currency
	to.AccountNumber = m.AccountNumber
	to.ParentAccountId = m.ParentAccountId
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(BusinessChartOfAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessChartOfAccount the arg will be the target, the caller the one being converted from

// BusinessChartOfAccountBeforeToORM called before default ToORM code
type BusinessChartOfAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessChartOfAccountORM) error
}

// BusinessChartOfAccountAfterToORM called after default ToORM code
type BusinessChartOfAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessChartOfAccountORM) error
}

// BusinessChartOfAccountBeforeToPB called before default ToPB code
type BusinessChartOfAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessChartOfAccount) error
}

// BusinessChartOfAccountAfterToPB called after default ToPB code
type BusinessChartOfAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessChartOfAccount) error
}

type CompanyAddressORM struct {
	City               string
	CompanyInfoId      *uint64
	Country            string
	CountrySubdivision string
	Id                 uint64 `gorm:"unique_index:idx_company_address_id"`
	ModifiedAt         *time.Time
	PurchaseOrderId    *uint64
	State              string
	Street_1           string
	Street_2           string
	Type               string
	ZipCode            string
}

// TableName overrides the default tablename generated by GORM
func (CompanyAddressORM) TableName() string {
	return "company_addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyAddress) ToORM(ctx context.Context) (CompanyAddressORM, error) {
	to := CompanyAddressORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyAddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(CompanyAddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyAddressORM) ToPB(ctx context.Context) (CompanyAddress, error) {
	to := CompanyAddress{}
	var err error
	if prehook, ok := interface{}(m).(CompanyAddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(CompanyAddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyAddress the arg will be the target, the caller the one being converted from

// CompanyAddressBeforeToORM called before default ToORM code
type CompanyAddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyAddressORM) error
}

// CompanyAddressAfterToORM called after default ToORM code
type CompanyAddressWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyAddressORM) error
}

// CompanyAddressBeforeToPB called before default ToPB code
type CompanyAddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyAddress) error
}

// CompanyAddressAfterToPB called after default ToPB code
type CompanyAddressWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyAddress) error
}

type BalanceSheetORM struct {
	Assets                    []*ReportItemORM `gorm:"foreignkey:AssetsBalanceSheetId;association_foreignkey:Id;preload:true"`
	Company                   string
	CreatedAt                 *time.Time
	Currency                  string
	Date                      *time.Time
	Equity                    []*ReportItemORM `gorm:"foreignkey:EquityBalanceSheetId;association_foreignkey:Id;preload:true"`
	Id                        uint64           `gorm:"unique_index:idx_balance_sheet_id"`
	Liabilities               []*ReportItemORM `gorm:"foreignkey:LiabilitiesBalanceSheetId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_balance_sheet_merge_record_id"`
	ModifiedAt                *time.Time
	Name                      string
	NetAssets                 float64
	RemoteGeneratedAt         *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
}

// TableName overrides the default tablename generated by GORM
func (BalanceSheetORM) TableName() string {
	return "balance_sheets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BalanceSheet) ToORM(ctx context.Context) (BalanceSheetORM, error) {
	to := BalanceSheetORM{}
	var err error
	if prehook, ok := interface{}(m).(BalanceSheetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.Date != nil {
		t := m.Date.AsTime()
		to.Date = &t
	}
	to.NetAssets = m.NetAssets
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToORM(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Liabilities {
		if v != nil {
			if tempLiabilities, cErr := v.ToORM(ctx); cErr == nil {
				to.Liabilities = append(to.Liabilities, &tempLiabilities)
			} else {
				return to, cErr
			}
		} else {
			to.Liabilities = append(to.Liabilities, nil)
		}
	}
	for _, v := range m.Equity {
		if v != nil {
			if tempEquity, cErr := v.ToORM(ctx); cErr == nil {
				to.Equity = append(to.Equity, &tempEquity)
			} else {
				return to, cErr
			}
		} else {
			to.Equity = append(to.Equity, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		t := m.RemoteGeneratedAt.AsTime()
		to.RemoteGeneratedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(BalanceSheetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BalanceSheetORM) ToPB(ctx context.Context) (BalanceSheet, error) {
	to := BalanceSheet{}
	var err error
	if prehook, ok := interface{}(m).(BalanceSheetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.Date != nil {
		to.Date = timestamppb.New(*m.Date)
	}
	to.NetAssets = m.NetAssets
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToPB(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Liabilities {
		if v != nil {
			if tempLiabilities, cErr := v.ToPB(ctx); cErr == nil {
				to.Liabilities = append(to.Liabilities, &tempLiabilities)
			} else {
				return to, cErr
			}
		} else {
			to.Liabilities = append(to.Liabilities, nil)
		}
	}
	for _, v := range m.Equity {
		if v != nil {
			if tempEquity, cErr := v.ToPB(ctx); cErr == nil {
				to.Equity = append(to.Equity, &tempEquity)
			} else {
				return to, cErr
			}
		} else {
			to.Equity = append(to.Equity, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		to.RemoteGeneratedAt = timestamppb.New(*m.RemoteGeneratedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(BalanceSheetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BalanceSheet the arg will be the target, the caller the one being converted from

// BalanceSheetBeforeToORM called before default ToORM code
type BalanceSheetWithBeforeToORM interface {
	BeforeToORM(context.Context, *BalanceSheetORM) error
}

// BalanceSheetAfterToORM called after default ToORM code
type BalanceSheetWithAfterToORM interface {
	AfterToORM(context.Context, *BalanceSheetORM) error
}

// BalanceSheetBeforeToPB called before default ToPB code
type BalanceSheetWithBeforeToPB interface {
	BeforeToPB(context.Context, *BalanceSheet) error
}

// BalanceSheetAfterToPB called after default ToPB code
type BalanceSheetWithAfterToPB interface {
	AfterToPB(context.Context, *BalanceSheet) error
}

type ReportItemORM struct {
	AssetsBalanceSheetId                   *uint64
	Company                                string
	CostOfSalesIncomeStatementId           *uint64
	EquityBalanceSheetId                   *uint64
	FinancingActivitiesCashFlowStatementId *uint64
	Id                                     uint64 `gorm:"unique_index:idx_report_item_id"`
	IncomeIncomeStatementId                *uint64
	InvestingActivitiesCashFlowStatementId *uint64
	LiabilitiesBalanceSheetId              *uint64
	ModifiedAt                             *time.Time
	Name                                   string
	NonOperatingExpensesIncomeStatementId  *uint64
	OperatingActivitiesCashFlowStatementId *uint64
	OperatingExpensesIncomeStatementId     *uint64
	RemoteId                               string
	Value                                  int64
}

// TableName overrides the default tablename generated by GORM
func (ReportItemORM) TableName() string {
	return "report_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReportItem) ToORM(ctx context.Context) (ReportItemORM, error) {
	to := ReportItemORM{}
	var err error
	if prehook, ok := interface{}(m).(ReportItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Value = m.Value
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(ReportItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReportItemORM) ToPB(ctx context.Context) (ReportItem, error) {
	to := ReportItem{}
	var err error
	if prehook, ok := interface{}(m).(ReportItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Value = m.Value
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(ReportItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReportItem the arg will be the target, the caller the one being converted from

// ReportItemBeforeToORM called before default ToORM code
type ReportItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReportItemORM) error
}

// ReportItemAfterToORM called after default ToORM code
type ReportItemWithAfterToORM interface {
	AfterToORM(context.Context, *ReportItemORM) error
}

// ReportItemBeforeToPB called before default ToPB code
type ReportItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReportItem) error
}

// ReportItemAfterToPB called after default ToPB code
type ReportItemWithAfterToPB interface {
	AfterToPB(context.Context, *ReportItem) error
}

type CashFlowStatementORM struct {
	CashAtBeginningOfPeriod   float64
	CashAtEndOfPeriod         float64
	Company                   string
	Currency                  string
	EndPeriod                 *time.Time
	FinancingActivities       []*ReportItemORM `gorm:"foreignkey:FinancingActivitiesCashFlowStatementId;association_foreignkey:Id;preload:true"`
	Id                        uint64           `gorm:"unique_index:idx_cash_flow_statement_id"`
	InvestingActivities       []*ReportItemORM `gorm:"foreignkey:InvestingActivitiesCashFlowStatementId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_cash_flow_statement_merge_record_id"`
	ModifiedAt                *time.Time
	Name                      string
	OperatingActivities       []*ReportItemORM `gorm:"foreignkey:OperatingActivitiesCashFlowStatementId;association_foreignkey:Id;preload:true"`
	RemoteGeneratedAt         *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
	StartPeriod               *time.Time
}

// TableName overrides the default tablename generated by GORM
func (CashFlowStatementORM) TableName() string {
	return "cash_flow_statements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CashFlowStatement) ToORM(ctx context.Context) (CashFlowStatementORM, error) {
	to := CashFlowStatementORM{}
	var err error
	if prehook, ok := interface{}(m).(CashFlowStatementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		t := m.StartPeriod.AsTime()
		to.StartPeriod = &t
	}
	if m.EndPeriod != nil {
		t := m.EndPeriod.AsTime()
		to.EndPeriod = &t
	}
	to.CashAtBeginningOfPeriod = m.CashAtBeginningOfPeriod
	to.CashAtEndOfPeriod = m.CashAtEndOfPeriod
	for _, v := range m.OperatingActivities {
		if v != nil {
			if tempOperatingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.OperatingActivities = append(to.OperatingActivities, &tempOperatingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingActivities = append(to.OperatingActivities, nil)
		}
	}
	for _, v := range m.InvestingActivities {
		if v != nil {
			if tempInvestingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestingActivities = append(to.InvestingActivities, &tempInvestingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.InvestingActivities = append(to.InvestingActivities, nil)
		}
	}
	for _, v := range m.FinancingActivities {
		if v != nil {
			if tempFinancingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.FinancingActivities = append(to.FinancingActivities, &tempFinancingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.FinancingActivities = append(to.FinancingActivities, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		t := m.RemoteGeneratedAt.AsTime()
		to.RemoteGeneratedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CashFlowStatementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CashFlowStatementORM) ToPB(ctx context.Context) (CashFlowStatement, error) {
	to := CashFlowStatement{}
	var err error
	if prehook, ok := interface{}(m).(CashFlowStatementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		to.StartPeriod = timestamppb.New(*m.StartPeriod)
	}
	if m.EndPeriod != nil {
		to.EndPeriod = timestamppb.New(*m.EndPeriod)
	}
	to.CashAtBeginningOfPeriod = m.CashAtBeginningOfPeriod
	to.CashAtEndOfPeriod = m.CashAtEndOfPeriod
	for _, v := range m.OperatingActivities {
		if v != nil {
			if tempOperatingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.OperatingActivities = append(to.OperatingActivities, &tempOperatingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingActivities = append(to.OperatingActivities, nil)
		}
	}
	for _, v := range m.InvestingActivities {
		if v != nil {
			if tempInvestingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestingActivities = append(to.InvestingActivities, &tempInvestingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.InvestingActivities = append(to.InvestingActivities, nil)
		}
	}
	for _, v := range m.FinancingActivities {
		if v != nil {
			if tempFinancingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.FinancingActivities = append(to.FinancingActivities, &tempFinancingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.FinancingActivities = append(to.FinancingActivities, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		to.RemoteGeneratedAt = timestamppb.New(*m.RemoteGeneratedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CashFlowStatementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CashFlowStatement the arg will be the target, the caller the one being converted from

// CashFlowStatementBeforeToORM called before default ToORM code
type CashFlowStatementWithBeforeToORM interface {
	BeforeToORM(context.Context, *CashFlowStatementORM) error
}

// CashFlowStatementAfterToORM called after default ToORM code
type CashFlowStatementWithAfterToORM interface {
	AfterToORM(context.Context, *CashFlowStatementORM) error
}

// CashFlowStatementBeforeToPB called before default ToPB code
type CashFlowStatementWithBeforeToPB interface {
	BeforeToPB(context.Context, *CashFlowStatement) error
}

// CashFlowStatementAfterToPB called after default ToPB code
type CashFlowStatementWithAfterToPB interface {
	AfterToPB(context.Context, *CashFlowStatement) error
}

type CompanyInfoORM struct {
	Addresses                 []*CompanyAddressORM `gorm:"foreignkey:CompanyInfoId;association_foreignkey:Id"`
	Currency                  string
	FiscalYearEndDay          int32
	FiscalYearEndMonth        int32
	Id                        uint64 `gorm:"unique_index:idx_company_info_id"`
	LegalName                 string
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_company_info_merge_record_id"`
	ModifiedAt                *time.Time
	Name                      string
	PhoneNumbers              pq.StringArray `gorm:"type:text[]"`
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
	TaxNumber                 string
	Urls                      pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyInfoORM) TableName() string {
	return "company_infos"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyInfo) ToORM(ctx context.Context) (CompanyInfoORM, error) {
	to := CompanyInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.LegalName = m.LegalName
	to.TaxNumber = m.TaxNumber
	to.FiscalYearEndMonth = m.FiscalYearEndMonth
	to.FiscalYearEndDay = m.FiscalYearEndDay
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.Urls != nil {
		to.Urls = make(pq.StringArray, len(m.Urls))
		copy(to.Urls, m.Urls)
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToORM(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CompanyInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyInfoORM) ToPB(ctx context.Context) (CompanyInfo, error) {
	to := CompanyInfo{}
	var err error
	if prehook, ok := interface{}(m).(CompanyInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.LegalName = m.LegalName
	to.TaxNumber = m.TaxNumber
	to.FiscalYearEndMonth = m.FiscalYearEndMonth
	to.FiscalYearEndDay = m.FiscalYearEndDay
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.Urls != nil {
		to.Urls = make(pq.StringArray, len(m.Urls))
		copy(to.Urls, m.Urls)
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToPB(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CompanyInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyInfo the arg will be the target, the caller the one being converted from

// CompanyInfoBeforeToORM called before default ToORM code
type CompanyInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyInfoORM) error
}

// CompanyInfoAfterToORM called after default ToORM code
type CompanyInfoWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyInfoORM) error
}

// CompanyInfoBeforeToPB called before default ToPB code
type CompanyInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyInfo) error
}

// CompanyInfoAfterToPB called after default ToPB code
type CompanyInfoWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyInfo) error
}

type AccountingAttachmentORM struct {
	Company                   string
	CreatedAt                 *time.Time
	FileName                  string
	FileUrl                   string
	Id                        uint64 `gorm:"unique_index:idx_accounting_attachment_id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:index_accounting_attachment_merge_record_id"`
	ModifiedAt                *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
}

// TableName overrides the default tablename generated by GORM
func (AccountingAttachmentORM) TableName() string {
	return "accounting_attachments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountingAttachment) ToORM(ctx context.Context) (AccountingAttachmentORM, error) {
	to := AccountingAttachmentORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountingAttachmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(AccountingAttachmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountingAttachmentORM) ToPB(ctx context.Context) (AccountingAttachment, error) {
	to := AccountingAttachment{}
	var err error
	if prehook, ok := interface{}(m).(AccountingAttachmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(AccountingAttachmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountingAttachment the arg will be the target, the caller the one being converted from

// AccountingAttachmentBeforeToORM called before default ToORM code
type AccountingAttachmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountingAttachmentORM) error
}

// AccountingAttachmentAfterToORM called after default ToORM code
type AccountingAttachmentWithAfterToORM interface {
	AfterToORM(context.Context, *AccountingAttachmentORM) error
}

// AccountingAttachmentBeforeToPB called before default ToPB code
type AccountingAttachmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountingAttachment) error
}

// AccountingAttachmentAfterToPB called after default ToPB code
type AccountingAttachmentWithAfterToPB interface {
	AfterToPB(context.Context, *AccountingAttachment) error
}

type ContactsORM struct {
	AddressesIds              pq.StringArray `gorm:"type:text[]"`
	Company                   string
	Currency                  string
	EmailAddress              string
	Id                        uint64 `gorm:"unique_index:idx_contact_id"`
	IsCustomer                bool
	IsSupplier                bool
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_contact_merge_record_id"`
	ModifiedAt                *time.Time
	Name                      string
	PhoneNumbers              pq.StringArray `gorm:"type:text[]"`
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	Status                    string
	TaxNumber                 string
}

// TableName overrides the default tablename generated by GORM
func (ContactsORM) TableName() string {
	return "contacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Contacts) ToORM(ctx context.Context) (ContactsORM, error) {
	to := ContactsORM{}
	var err error
	if prehook, ok := interface{}(m).(ContactsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.IsSupplier = m.IsSupplier
	to.IsCustomer = m.IsCustomer
	to.EmailAddress = m.EmailAddress
	to.TaxNumber = m.TaxNumber
	to.Status = m.Status
	to.Currency = m.Currency
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.Company = m.Company
	if m.AddressesIds != nil {
		to.AddressesIds = make(pq.StringArray, len(m.AddressesIds))
		copy(to.AddressesIds, m.AddressesIds)
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(ContactsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContactsORM) ToPB(ctx context.Context) (Contacts, error) {
	to := Contacts{}
	var err error
	if prehook, ok := interface{}(m).(ContactsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.IsSupplier = m.IsSupplier
	to.IsCustomer = m.IsCustomer
	to.EmailAddress = m.EmailAddress
	to.TaxNumber = m.TaxNumber
	to.Status = m.Status
	to.Currency = m.Currency
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.Company = m.Company
	if m.AddressesIds != nil {
		to.AddressesIds = make(pq.StringArray, len(m.AddressesIds))
		copy(to.AddressesIds, m.AddressesIds)
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(ContactsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Contacts the arg will be the target, the caller the one being converted from

// ContactsBeforeToORM called before default ToORM code
type ContactsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContactsORM) error
}

// ContactsAfterToORM called after default ToORM code
type ContactsWithAfterToORM interface {
	AfterToORM(context.Context, *ContactsORM) error
}

// ContactsBeforeToPB called before default ToPB code
type ContactsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Contacts) error
}

// ContactsAfterToPB called after default ToPB code
type ContactsWithAfterToPB interface {
	AfterToPB(context.Context, *Contacts) error
}

type CreditNoteORM struct {
	AccountingPeriod          string
	Company                   string
	Contact                   string
	CreatedAt                 *time.Time
	Currency                  string
	ExchangeRate              string
	Id                        uint64                   `gorm:"unique_index:idx_credit_note_id"`
	LineItems                 []*CreditNoteLineItemORM `gorm:"foreignkey:CreditNoteId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_credit_note_merge_record_id"`
	ModifiedAt                *time.Time
	Number                    string
	PaymentIds                pq.StringArray `gorm:"type:text[]"`
	RemainingCredit           float64
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	Status                    string
	TotalAmount               float64
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	TransactionDate           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (CreditNoteORM) TableName() string {
	return "credit_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditNote) ToORM(ctx context.Context) (CreditNoteORM, error) {
	to := CreditNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Status = m.Status
	to.Number = m.Number
	to.Contact = m.Contact
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	to.TotalAmount = m.TotalAmount
	to.RemainingCredit = m.RemainingCredit
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(CreditNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditNoteORM) ToPB(ctx context.Context) (CreditNote, error) {
	to := CreditNote{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Status = m.Status
	to.Number = m.Number
	to.Contact = m.Contact
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	to.TotalAmount = m.TotalAmount
	to.RemainingCredit = m.RemainingCredit
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(CreditNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditNote the arg will be the target, the caller the one being converted from

// CreditNoteBeforeToORM called before default ToORM code
type CreditNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditNoteORM) error
}

// CreditNoteAfterToORM called after default ToORM code
type CreditNoteWithAfterToORM interface {
	AfterToORM(context.Context, *CreditNoteORM) error
}

// CreditNoteBeforeToPB called before default ToPB code
type CreditNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditNote) error
}

// CreditNoteAfterToPB called after default ToPB code
type CreditNoteWithAfterToPB interface {
	AfterToPB(context.Context, *CreditNote) error
}

type CreditNoteLineItemORM struct {
	Account            string
	Company            string
	CreditNoteId       *uint64
	Description        string
	Id                 uint64 `gorm:"unique_index:idx_credit_note_line_item_id"`
	Item               string
	Memo               string
	Name               string `gorm:"index:idx_credit_note_line_item_name"`
	Quantity           string
	RemoteId           string
	RemoteWasDeleted   bool
	TaxRate            string
	TotalLineAmount    string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          string
}

// TableName overrides the default tablename generated by GORM
func (CreditNoteLineItemORM) TableName() string {
	return "credit_note_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditNoteLineItem) ToORM(ctx context.Context) (CreditNoteLineItemORM, error) {
	to := CreditNoteLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.TaxRate = m.TaxRate
	to.TotalLineAmount = m.TotalLineAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Account = m.Account
	to.Company = m.Company
	to.RemoteId = m.RemoteId
	to.Item = m.Item
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.Memo = m.Memo
	if posthook, ok := interface{}(m).(CreditNoteLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditNoteLineItemORM) ToPB(ctx context.Context) (CreditNoteLineItem, error) {
	to := CreditNoteLineItem{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.TaxRate = m.TaxRate
	to.TotalLineAmount = m.TotalLineAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Account = m.Account
	to.Company = m.Company
	to.RemoteId = m.RemoteId
	to.Item = m.Item
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.Memo = m.Memo
	if posthook, ok := interface{}(m).(CreditNoteLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditNoteLineItem the arg will be the target, the caller the one being converted from

// CreditNoteLineItemBeforeToORM called before default ToORM code
type CreditNoteLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditNoteLineItemORM) error
}

// CreditNoteLineItemAfterToORM called after default ToORM code
type CreditNoteLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *CreditNoteLineItemORM) error
}

// CreditNoteLineItemBeforeToPB called before default ToPB code
type CreditNoteLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditNoteLineItem) error
}

// CreditNoteLineItemAfterToPB called after default ToPB code
type CreditNoteLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *CreditNoteLineItem) error
}

type ExpenseORM struct {
	Account                   string
	AccountingPeriod          string
	Company                   string
	Contact                   string
	Currency                  string
	ExchangeRate              string
	Id                        uint64            `gorm:"unique_index:idx_expense_id"`
	Lines                     []*ExpenseLineORM `gorm:"foreignkey:ExpenseId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	Memo                      string
	MergeRecordId             string `gorm:"index:idx_expense_merge_record_id"`
	ModifiedAt                *time.Time
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
	SubTotal                  float64
	TotalAmount               float64
	TotalTaxAmount            float64
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	TransactionDate           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ExpenseORM) TableName() string {
	return "expenses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Expense) ToORM(ctx context.Context) (ExpenseORM, error) {
	to := ExpenseORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.SubTotal = m.SubTotal
	to.TotalTaxAmount = m.TotalTaxAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.Memo = m.Memo
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(ExpenseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseORM) ToPB(ctx context.Context) (Expense, error) {
	to := Expense{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.SubTotal = m.SubTotal
	to.TotalTaxAmount = m.TotalTaxAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.Memo = m.Memo
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(ExpenseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Expense the arg will be the target, the caller the one being converted from

// ExpenseBeforeToORM called before default ToORM code
type ExpenseWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseORM) error
}

// ExpenseAfterToORM called after default ToORM code
type ExpenseWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseORM) error
}

// ExpenseBeforeToPB called before default ToPB code
type ExpenseWithBeforeToPB interface {
	BeforeToPB(context.Context, *Expense) error
}

// ExpenseAfterToPB called after default ToPB code
type ExpenseWithAfterToPB interface {
	AfterToPB(context.Context, *Expense) error
}

type ExpenseLineORM struct {
	Account            string
	Company            string `gorm:"index:idx_expense_line_company"`
	Contact            string
	CreatedAt          *time.Time
	Currency           string
	Description        string
	ExchangeRate       string
	ExpenseId          *uint64
	Id                 uint64 `gorm:"unique_index:idx_expense_line_id"`
	Item               string
	ModifiedAt         *time.Time
	NetAmount          float64
	RemoteId           string
	RemoteWasDeleted   bool
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
}

// TableName overrides the default tablename generated by GORM
func (ExpenseLineORM) TableName() string {
	return "expense_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExpenseLine) ToORM(ctx context.Context) (ExpenseLineORM, error) {
	to := ExpenseLineORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.Item = m.Item
	to.Account = m.Account
	to.Contact = m.Contact
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	to.RemoteId = m.RemoteId
	to.Currency = m.Currency
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(ExpenseLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseLineORM) ToPB(ctx context.Context) (ExpenseLine, error) {
	to := ExpenseLine{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.Item = m.Item
	to.Account = m.Account
	to.Contact = m.Contact
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	to.RemoteId = m.RemoteId
	to.Currency = m.Currency
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(ExpenseLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExpenseLine the arg will be the target, the caller the one being converted from

// ExpenseLineBeforeToORM called before default ToORM code
type ExpenseLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseLineORM) error
}

// ExpenseLineAfterToORM called after default ToORM code
type ExpenseLineWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseLineORM) error
}

// ExpenseLineBeforeToPB called before default ToPB code
type ExpenseLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExpenseLine) error
}

// ExpenseLineAfterToPB called after default ToPB code
type ExpenseLineWithAfterToPB interface {
	AfterToPB(context.Context, *ExpenseLine) error
}

type IncomeStatementORM struct {
	Company                   string
	CostOfSales               []*ReportItemORM `gorm:"foreignkey:CostOfSalesIncomeStatementId;association_foreignkey:Id"`
	CreatedAt                 *time.Time
	Currency                  string
	EndPeriod                 *time.Time
	GrossProfit               float64
	Id                        uint64           `gorm:"unique_index:idx_income_statement_id"`
	Income                    []*ReportItemORM `gorm:"foreignkey:IncomeIncomeStatementId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_income_statement_merge_record_id"`
	ModifiedAt                *time.Time
	Name                      string
	NetIncome                 float64
	NetOperatingIncome        float64
	NonOperatingExpenses      []*ReportItemORM `gorm:"foreignkey:NonOperatingExpensesIncomeStatementId;association_foreignkey:Id"`
	OperatingExpenses         []*ReportItemORM `gorm:"foreignkey:OperatingExpensesIncomeStatementId;association_foreignkey:Id"`
	RemoteId                  string
	RemoteWasDeleted          bool
	StartPeriod               *time.Time
}

// TableName overrides the default tablename generated by GORM
func (IncomeStatementORM) TableName() string {
	return "income_statements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IncomeStatement) ToORM(ctx context.Context) (IncomeStatementORM, error) {
	to := IncomeStatementORM{}
	var err error
	if prehook, ok := interface{}(m).(IncomeStatementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		t := m.StartPeriod.AsTime()
		to.StartPeriod = &t
	}
	if m.EndPeriod != nil {
		t := m.EndPeriod.AsTime()
		to.EndPeriod = &t
	}
	for _, v := range m.Income {
		if v != nil {
			if tempIncome, cErr := v.ToORM(ctx); cErr == nil {
				to.Income = append(to.Income, &tempIncome)
			} else {
				return to, cErr
			}
		} else {
			to.Income = append(to.Income, nil)
		}
	}
	for _, v := range m.CostOfSales {
		if v != nil {
			if tempCostOfSales, cErr := v.ToORM(ctx); cErr == nil {
				to.CostOfSales = append(to.CostOfSales, &tempCostOfSales)
			} else {
				return to, cErr
			}
		} else {
			to.CostOfSales = append(to.CostOfSales, nil)
		}
	}
	to.GrossProfit = m.GrossProfit
	for _, v := range m.OperatingExpenses {
		if v != nil {
			if tempOperatingExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.OperatingExpenses = append(to.OperatingExpenses, &tempOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingExpenses = append(to.OperatingExpenses, nil)
		}
	}
	to.NetOperatingIncome = m.NetOperatingIncome
	for _, v := range m.NonOperatingExpenses {
		if v != nil {
			if tempNonOperatingExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.NonOperatingExpenses = append(to.NonOperatingExpenses, &tempNonOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.NonOperatingExpenses = append(to.NonOperatingExpenses, nil)
		}
	}
	to.NetIncome = m.NetIncome
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(IncomeStatementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IncomeStatementORM) ToPB(ctx context.Context) (IncomeStatement, error) {
	to := IncomeStatement{}
	var err error
	if prehook, ok := interface{}(m).(IncomeStatementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		to.StartPeriod = timestamppb.New(*m.StartPeriod)
	}
	if m.EndPeriod != nil {
		to.EndPeriod = timestamppb.New(*m.EndPeriod)
	}
	for _, v := range m.Income {
		if v != nil {
			if tempIncome, cErr := v.ToPB(ctx); cErr == nil {
				to.Income = append(to.Income, &tempIncome)
			} else {
				return to, cErr
			}
		} else {
			to.Income = append(to.Income, nil)
		}
	}
	for _, v := range m.CostOfSales {
		if v != nil {
			if tempCostOfSales, cErr := v.ToPB(ctx); cErr == nil {
				to.CostOfSales = append(to.CostOfSales, &tempCostOfSales)
			} else {
				return to, cErr
			}
		} else {
			to.CostOfSales = append(to.CostOfSales, nil)
		}
	}
	to.GrossProfit = m.GrossProfit
	for _, v := range m.OperatingExpenses {
		if v != nil {
			if tempOperatingExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.OperatingExpenses = append(to.OperatingExpenses, &tempOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingExpenses = append(to.OperatingExpenses, nil)
		}
	}
	to.NetOperatingIncome = m.NetOperatingIncome
	for _, v := range m.NonOperatingExpenses {
		if v != nil {
			if tempNonOperatingExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.NonOperatingExpenses = append(to.NonOperatingExpenses, &tempNonOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.NonOperatingExpenses = append(to.NonOperatingExpenses, nil)
		}
	}
	to.NetIncome = m.NetIncome
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(IncomeStatementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IncomeStatement the arg will be the target, the caller the one being converted from

// IncomeStatementBeforeToORM called before default ToORM code
type IncomeStatementWithBeforeToORM interface {
	BeforeToORM(context.Context, *IncomeStatementORM) error
}

// IncomeStatementAfterToORM called after default ToORM code
type IncomeStatementWithAfterToORM interface {
	AfterToORM(context.Context, *IncomeStatementORM) error
}

// IncomeStatementBeforeToPB called before default ToPB code
type IncomeStatementWithBeforeToPB interface {
	BeforeToPB(context.Context, *IncomeStatement) error
}

// IncomeStatementAfterToPB called after default ToPB code
type IncomeStatementWithAfterToPB interface {
	AfterToPB(context.Context, *IncomeStatement) error
}

type InvoiceORM struct {
	AccountingPeriod          string
	Balance                   float32
	Company                   string
	Contact                   string
	Currency                  string
	DueDate                   *time.Time
	ExchangeRate              string
	Id                        uint64 `gorm:"unique_index:idx_invoice_id"`
	IssueDate                 *time.Time
	LineItems                 []*InvoiceLineItemORM `gorm:"foreignkey:InvoiceId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	Memo                      string
	MergeRecordId             string `gorm:"index:idx_invoice_merge_record_id"`
	ModifiedAt                *time.Time
	Number                    string
	PaidOnDate                *time.Time
	Payments                  pq.StringArray `gorm:"type:text[]"`
	PurchaseOrders            pq.StringArray `gorm:"type:text[]"`
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	Status                    string
	SubTotal                  float32
	TotalAmount               float32
	TotalDiscount             float32
	TotalTaxAmount            float32
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	Type                      string
}

// TableName overrides the default tablename generated by GORM
func (InvoiceORM) TableName() string {
	return "invoices"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Invoice) ToORM(ctx context.Context) (InvoiceORM, error) {
	to := InvoiceORM{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Contact = m.Contact
	to.Number = m.Number
	if m.IssueDate != nil {
		t := m.IssueDate.AsTime()
		to.IssueDate = &t
	}
	if m.DueDate != nil {
		t := m.DueDate.AsTime()
		to.DueDate = &t
	}
	if m.PaidOnDate != nil {
		t := m.PaidOnDate.AsTime()
		to.PaidOnDate = &t
	}
	to.Memo = m.Memo
	to.Company = m.Company
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.TotalDiscount = m.TotalDiscount
	to.SubTotal = m.SubTotal
	to.Status = m.Status
	to.TotalTaxAmount = m.TotalTaxAmount
	to.TotalAmount = m.TotalAmount
	to.Balance = m.Balance
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.PurchaseOrders != nil {
		to.PurchaseOrders = make(pq.StringArray, len(m.PurchaseOrders))
		copy(to.PurchaseOrders, m.PurchaseOrders)
	}
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(InvoiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvoiceORM) ToPB(ctx context.Context) (Invoice, error) {
	to := Invoice{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Contact = m.Contact
	to.Number = m.Number
	if m.IssueDate != nil {
		to.IssueDate = timestamppb.New(*m.IssueDate)
	}
	if m.DueDate != nil {
		to.DueDate = timestamppb.New(*m.DueDate)
	}
	if m.PaidOnDate != nil {
		to.PaidOnDate = timestamppb.New(*m.PaidOnDate)
	}
	to.Memo = m.Memo
	to.Company = m.Company
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.TotalDiscount = m.TotalDiscount
	to.SubTotal = m.SubTotal
	to.Status = m.Status
	to.TotalTaxAmount = m.TotalTaxAmount
	to.TotalAmount = m.TotalAmount
	to.Balance = m.Balance
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.PurchaseOrders != nil {
		to.PurchaseOrders = make(pq.StringArray, len(m.PurchaseOrders))
		copy(to.PurchaseOrders, m.PurchaseOrders)
	}
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(InvoiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Invoice the arg will be the target, the caller the one being converted from

// InvoiceBeforeToORM called before default ToORM code
type InvoiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvoiceORM) error
}

// InvoiceAfterToORM called after default ToORM code
type InvoiceWithAfterToORM interface {
	AfterToORM(context.Context, *InvoiceORM) error
}

// InvoiceBeforeToPB called before default ToPB code
type InvoiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Invoice) error
}

// InvoiceAfterToPB called after default ToPB code
type InvoiceWithAfterToPB interface {
	AfterToPB(context.Context, *Invoice) error
}

type InvoiceLineItemORM struct {
	Account            string `gorm:"index:idx_invoice_line_item_account"`
	Company            string
	Currency           string
	Description        string
	ExchangeRate       string
	Id                 uint64 `gorm:"unique_index:idx_invoice_line_item_id"`
	InvoiceId          *uint64
	Item               string
	MergeRecordId      string `gorm:"index:idx_invoice_line_item_merge_record_id"`
	ModifiedAt         *time.Time
	Quantity           int32
	RemoteId           string
	TotalAmount        float32
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          float32
}

// TableName overrides the default tablename generated by GORM
func (InvoiceLineItemORM) TableName() string {
	return "invoice_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvoiceLineItem) ToORM(ctx context.Context) (InvoiceLineItemORM, error) {
	to := InvoiceLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.MergeRecordId = m.MergeRecordId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(InvoiceLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvoiceLineItemORM) ToPB(ctx context.Context) (InvoiceLineItem, error) {
	to := InvoiceLineItem{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.MergeRecordId = m.MergeRecordId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(InvoiceLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvoiceLineItem the arg will be the target, the caller the one being converted from

// InvoiceLineItemBeforeToORM called before default ToORM code
type InvoiceLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvoiceLineItemORM) error
}

// InvoiceLineItemAfterToORM called after default ToORM code
type InvoiceLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *InvoiceLineItemORM) error
}

// InvoiceLineItemBeforeToPB called before default ToPB code
type InvoiceLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvoiceLineItem) error
}

// InvoiceLineItemAfterToPB called after default ToPB code
type InvoiceLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *InvoiceLineItem) error
}

type ItemORM struct {
	Company                   string `gorm:"unique_index:idx_item_company"`
	CreatedAt                 *time.Time
	Id                        uint64 `gorm:"unique_index:idx_item_id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string
	ModifiedAt                *time.Time
	Name                      string `gorm:"index:idx_item_name"`
	PurchaseAccount           string
	PurchasePrice             float32
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	SalesAccount              string
	Status                    string
	UnitPrice                 float32
}

// TableName overrides the default tablename generated by GORM
func (ItemORM) TableName() string {
	return "items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Item) ToORM(ctx context.Context) (ItemORM, error) {
	to := ItemORM{}
	var err error
	if prehook, ok := interface{}(m).(ItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Status = m.Status
	to.UnitPrice = m.UnitPrice
	to.PurchasePrice = m.PurchasePrice
	to.PurchaseAccount = m.PurchaseAccount
	to.SalesAccount = m.SalesAccount
	to.Company = m.Company
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(ItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ItemORM) ToPB(ctx context.Context) (Item, error) {
	to := Item{}
	var err error
	if prehook, ok := interface{}(m).(ItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Status = m.Status
	to.UnitPrice = m.UnitPrice
	to.PurchasePrice = m.PurchasePrice
	to.PurchaseAccount = m.PurchaseAccount
	to.SalesAccount = m.SalesAccount
	to.Company = m.Company
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(ItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Item the arg will be the target, the caller the one being converted from

// ItemBeforeToORM called before default ToORM code
type ItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *ItemORM) error
}

// ItemAfterToORM called after default ToORM code
type ItemWithAfterToORM interface {
	AfterToORM(context.Context, *ItemORM) error
}

// ItemBeforeToPB called before default ToPB code
type ItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *Item) error
}

// ItemAfterToPB called after default ToPB code
type ItemWithAfterToPB interface {
	AfterToPB(context.Context, *Item) error
}

type JournalEntryORM struct {
	AccountingPeriod          string
	AppliedPayments           pq.StringArray `gorm:"type:text[]"`
	Company                   string         `gorm:"index:idx_journal_entry_company"`
	CreatedAt                 *time.Time
	Currency                  string
	ExchangeRate              string
	Id                        uint64 `gorm:"unique_index:idx_journal_entry_id"`
	JournalNumber             string
	Lines                     []*JournalLineORM `gorm:"foreignkey:JournalEntryId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	Memo                      string
	MergeRecordId             string `gorm:"index:idx_journal_entry_merge_record_id"`
	ModifiedAt                *time.Time
	Payments                  pq.StringArray `gorm:"type:text[]"`
	PostingStatus             string
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	TransactionDate           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (JournalEntryORM) TableName() string {
	return "journal_entries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalEntry) ToORM(ctx context.Context) (JournalEntryORM, error) {
	to := JournalEntryORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	to.Memo = m.Memo
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	to.JournalNumber = m.JournalNumber
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.PostingStatus = m.PostingStatus
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.AppliedPayments != nil {
		to.AppliedPayments = make(pq.StringArray, len(m.AppliedPayments))
		copy(to.AppliedPayments, m.AppliedPayments)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalEntryORM) ToPB(ctx context.Context) (JournalEntry, error) {
	to := JournalEntry{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	to.Memo = m.Memo
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	to.JournalNumber = m.JournalNumber
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.PostingStatus = m.PostingStatus
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.AppliedPayments != nil {
		to.AppliedPayments = make(pq.StringArray, len(m.AppliedPayments))
		copy(to.AppliedPayments, m.AppliedPayments)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalEntry the arg will be the target, the caller the one being converted from

// JournalEntryBeforeToORM called before default ToORM code
type JournalEntryWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryAfterToORM called after default ToORM code
type JournalEntryWithAfterToORM interface {
	AfterToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryBeforeToPB called before default ToPB code
type JournalEntryWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalEntry) error
}

// JournalEntryAfterToPB called after default ToPB code
type JournalEntryWithAfterToPB interface {
	AfterToPB(context.Context, *JournalEntry) error
}

type JournalLineORM struct {
	Account            string `gorm:"index:idx_journal_line_account"`
	Company            string `gorm:"index:idx_journal_line_company"`
	Contact            string
	CreatedAt          *time.Time
	Description        string
	ExchangeRate       string
	Id                 uint64 `gorm:"unique_index:idx_journal_line_id"`
	JournalEntryId     *uint64
	ModifiedAt         *time.Time
	NetAmount          float32
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
}

// TableName overrides the default tablename generated by GORM
func (JournalLineORM) TableName() string {
	return "journal_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalLine) ToORM(ctx context.Context) (JournalLineORM, error) {
	to := JournalLineORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Account = m.Account
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Contact = m.Contact
	to.Company = m.Company
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(JournalLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalLineORM) ToPB(ctx context.Context) (JournalLine, error) {
	to := JournalLine{}
	var err error
	if prehook, ok := interface{}(m).(JournalLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Account = m.Account
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Contact = m.Contact
	to.Company = m.Company
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(JournalLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalLine the arg will be the target, the caller the one being converted from

// JournalLineBeforeToORM called before default ToORM code
type JournalLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalLineORM) error
}

// JournalLineAfterToORM called after default ToORM code
type JournalLineWithAfterToORM interface {
	AfterToORM(context.Context, *JournalLineORM) error
}

// JournalLineBeforeToPB called before default ToPB code
type JournalLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalLine) error
}

// JournalLineAfterToPB called after default ToPB code
type JournalLineWithAfterToPB interface {
	AfterToPB(context.Context, *JournalLine) error
}

type PaymentORM struct {
	Account                   string `gorm:"index:idx_payment_account"`
	AccountingPeriod          string
	Company                   string `gorm:"index:idx_payment_company"`
	Contact                   string
	CreatedAt                 *time.Time
	Currency                  string
	ExchangeRate              string
	Id                        uint64 `gorm:"unique_index:idx_payment_id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_payment_merge_record_id"`
	ModifiedAt                *time.Time
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	TotalAmount               float32
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	TransactionDate           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PaymentORM) TableName() string {
	return "payments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Payment) ToORM(ctx context.Context) (PaymentORM, error) {
	to := PaymentORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Contact = m.Contact
	to.Account = m.Account
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(PaymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentORM) ToPB(ctx context.Context) (Payment, error) {
	to := Payment{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Contact = m.Contact
	to.Account = m.Account
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(PaymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Payment the arg will be the target, the caller the one being converted from

// PaymentBeforeToORM called before default ToORM code
type PaymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentORM) error
}

// PaymentAfterToORM called after default ToORM code
type PaymentWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentORM) error
}

// PaymentBeforeToPB called before default ToPB code
type PaymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Payment) error
}

// PaymentAfterToPB called after default ToPB code
type PaymentWithAfterToPB interface {
	AfterToPB(context.Context, *Payment) error
}

type PaymentLineItemORM struct {
	AppliedAmount     float32
	AppliedDate       *time.Time
	CreatedAt         *time.Time
	Id                uint64 `gorm:"unique_index:idx_payment_line_item_id"`
	MergeRecordId     string `gorm:"index:idx_payment_line_item_merge_record_id"`
	ModifiedAt        *time.Time
	RelatedObjectId   string
	RelatedObjectType string
	RemoteId          string
}

// TableName overrides the default tablename generated by GORM
func (PaymentLineItemORM) TableName() string {
	return "payment_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PaymentLineItem) ToORM(ctx context.Context) (PaymentLineItemORM, error) {
	to := PaymentLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppliedAmount = m.AppliedAmount
	if m.AppliedDate != nil {
		t := m.AppliedDate.AsTime()
		to.AppliedDate = &t
	}
	to.RemoteId = m.RemoteId
	to.RelatedObjectId = m.RelatedObjectId
	to.RelatedObjectType = m.RelatedObjectType
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(PaymentLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentLineItemORM) ToPB(ctx context.Context) (PaymentLineItem, error) {
	to := PaymentLineItem{}
	var err error
	if prehook, ok := interface{}(m).(PaymentLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppliedAmount = m.AppliedAmount
	if m.AppliedDate != nil {
		to.AppliedDate = timestamppb.New(*m.AppliedDate)
	}
	to.RemoteId = m.RemoteId
	to.RelatedObjectId = m.RelatedObjectId
	to.RelatedObjectType = m.RelatedObjectType
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(PaymentLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PaymentLineItem the arg will be the target, the caller the one being converted from

// PaymentLineItemBeforeToORM called before default ToORM code
type PaymentLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentLineItemORM) error
}

// PaymentLineItemAfterToORM called after default ToORM code
type PaymentLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentLineItemORM) error
}

// PaymentLineItemBeforeToPB called before default ToPB code
type PaymentLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *PaymentLineItem) error
}

// PaymentLineItemAfterToPB called after default ToPB code
type PaymentLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *PaymentLineItem) error
}

type PurchaseOrderORM struct {
	AccountingPeriod          string
	Company                   string `gorm:"index:idx_purchase_order_company"`
	CreatedAt                 *time.Time
	Currency                  string
	Customer                  string
	DeliveryAddress           *CompanyAddressORM `gorm:"foreignkey:PurchaseOrderId;association_foreignkey:Id"`
	DeliveryDate              *time.Time
	ExchangeRate              string
	Id                        uint64 `gorm:"unique_index:idx_purchase_order_id"`
	IssueDate                 *time.Time
	LineItems                 []*PurchaseOrderLineItemORM `gorm:"foreignkey:PurchaseOrderId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	Memo                      string
	MergeRecordId             string
	ModifiedAt                *time.Time
	PurchaseOrderNumber       string
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	Status                    string
	TotalAmount               float32
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	Vendor                    string
}

// TableName overrides the default tablename generated by GORM
func (PurchaseOrderORM) TableName() string {
	return "purchase_orders"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PurchaseOrder) ToORM(ctx context.Context) (PurchaseOrderORM, error) {
	to := PurchaseOrderORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeRecordId = m.MergeRecordId
	to.Status = m.Status
	if m.IssueDate != nil {
		t := m.IssueDate.AsTime()
		to.IssueDate = &t
	}
	to.PurchaseOrderNumber = m.PurchaseOrderNumber
	if m.DeliveryDate != nil {
		t := m.DeliveryDate.AsTime()
		to.DeliveryDate = &t
	}
	if m.DeliveryAddress != nil {
		tempDeliveryAddress, err := m.DeliveryAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DeliveryAddress = &tempDeliveryAddress
	}
	to.Customer = m.Customer
	to.Vendor = m.Vendor
	to.Memo = m.Memo
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(PurchaseOrderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseOrderORM) ToPB(ctx context.Context) (PurchaseOrder, error) {
	to := PurchaseOrder{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeRecordId = m.MergeRecordId
	to.Status = m.Status
	if m.IssueDate != nil {
		to.IssueDate = timestamppb.New(*m.IssueDate)
	}
	to.PurchaseOrderNumber = m.PurchaseOrderNumber
	if m.DeliveryDate != nil {
		to.DeliveryDate = timestamppb.New(*m.DeliveryDate)
	}
	if m.DeliveryAddress != nil {
		tempDeliveryAddress, err := m.DeliveryAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DeliveryAddress = &tempDeliveryAddress
	}
	to.Customer = m.Customer
	to.Vendor = m.Vendor
	to.Memo = m.Memo
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(PurchaseOrderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PurchaseOrder the arg will be the target, the caller the one being converted from

// PurchaseOrderBeforeToORM called before default ToORM code
type PurchaseOrderWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseOrderORM) error
}

// PurchaseOrderAfterToORM called after default ToORM code
type PurchaseOrderWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseOrderORM) error
}

// PurchaseOrderBeforeToPB called before default ToPB code
type PurchaseOrderWithBeforeToPB interface {
	BeforeToPB(context.Context, *PurchaseOrder) error
}

// PurchaseOrderAfterToPB called after default ToPB code
type PurchaseOrderWithAfterToPB interface {
	AfterToPB(context.Context, *PurchaseOrder) error
}

type PurchaseOrderLineItemORM struct {
	Account            string `gorm:"index:idx_purchase_order_line_item_account"`
	Company            string
	CreatedAt          *time.Time
	Currency           string
	Description        string
	ExchangeRate       string
	Id                 uint64 `gorm:"unique_index:idx_purchase_order_line_item_id"`
	Item               string
	ModifiedAt         *time.Time
	PurchaseOrderId    *uint64
	Quantity           int32
	RemoteId           string
	RemoteWasDeleted   bool
	TaxAmount          string
	TotalLineAmount    string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          string
}

// TableName overrides the default tablename generated by GORM
func (PurchaseOrderLineItemORM) TableName() string {
	return "purchase_order_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PurchaseOrderLineItem) ToORM(ctx context.Context) (PurchaseOrderLineItemORM, error) {
	to := PurchaseOrderLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TaxAmount = m.TaxAmount
	to.TotalLineAmount = m.TotalLineAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(PurchaseOrderLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseOrderLineItemORM) ToPB(ctx context.Context) (PurchaseOrderLineItem, error) {
	to := PurchaseOrderLineItem{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TaxAmount = m.TaxAmount
	to.TotalLineAmount = m.TotalLineAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(PurchaseOrderLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PurchaseOrderLineItem the arg will be the target, the caller the one being converted from

// PurchaseOrderLineItemBeforeToORM called before default ToORM code
type PurchaseOrderLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseOrderLineItemORM) error
}

// PurchaseOrderLineItemAfterToORM called after default ToORM code
type PurchaseOrderLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseOrderLineItemORM) error
}

// PurchaseOrderLineItemBeforeToPB called before default ToPB code
type PurchaseOrderLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *PurchaseOrderLineItem) error
}

// PurchaseOrderLineItemAfterToPB called after default ToPB code
type PurchaseOrderLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *PurchaseOrderLineItem) error
}

type TaxRateORM struct {
	Company                   string `gorm:"index:idx_tax_rate_company"`
	CreatedAt                 *time.Time
	Description               string
	EffectiveTaxRate          float64
	Id                        uint64 `gorm:"unique_index:idx_tax_rate_id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_tax_rate_merge_record_id"`
	ModifiedAt                *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
	TotalTaxRate              float64
}

// TableName overrides the default tablename generated by GORM
func (TaxRateORM) TableName() string {
	return "tax_rates"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TaxRate) ToORM(ctx context.Context) (TaxRateORM, error) {
	to := TaxRateORM{}
	var err error
	if prehook, ok := interface{}(m).(TaxRateWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.TotalTaxRate = m.TotalTaxRate
	to.EffectiveTaxRate = m.EffectiveTaxRate
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(TaxRateWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TaxRateORM) ToPB(ctx context.Context) (TaxRate, error) {
	to := TaxRate{}
	var err error
	if prehook, ok := interface{}(m).(TaxRateWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.TotalTaxRate = m.TotalTaxRate
	to.EffectiveTaxRate = m.EffectiveTaxRate
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(TaxRateWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TaxRate the arg will be the target, the caller the one being converted from

// TaxRateBeforeToORM called before default ToORM code
type TaxRateWithBeforeToORM interface {
	BeforeToORM(context.Context, *TaxRateORM) error
}

// TaxRateAfterToORM called after default ToORM code
type TaxRateWithAfterToORM interface {
	AfterToORM(context.Context, *TaxRateORM) error
}

// TaxRateBeforeToPB called before default ToPB code
type TaxRateWithBeforeToPB interface {
	BeforeToPB(context.Context, *TaxRate) error
}

// TaxRateAfterToPB called after default ToPB code
type TaxRateWithAfterToPB interface {
	AfterToPB(context.Context, *TaxRate) error
}

type TrackingCategoryORM struct {
	CategoryType     string
	Company          string `gorm:"index:idx_tracking_category_company"`
	CreatedAt        *time.Time
	Id               uint64 `gorm:"unique_index:idx_tracking_category_id"`
	MergeRecordId    string `gorm:"index:idx_tracking_category_merge_record_id"`
	ModifiedAt       *time.Time
	Name             string
	ParentCategory   string
	RemoteId         string
	RemoteWasDeleted bool
	Status           string
}

// TableName overrides the default tablename generated by GORM
func (TrackingCategoryORM) TableName() string {
	return "tracking_categories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TrackingCategory) ToORM(ctx context.Context) (TrackingCategoryORM, error) {
	to := TrackingCategoryORM{}
	var err error
	if prehook, ok := interface{}(m).(TrackingCategoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.MergeRecordId = m.MergeRecordId
	to.CategoryType = TrackingCategory_CategoryType_name[int32(m.CategoryType)]
	to.ParentCategory = m.ParentCategory
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Name = m.Name
	to.Status = m.Status
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(TrackingCategoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TrackingCategoryORM) ToPB(ctx context.Context) (TrackingCategory, error) {
	to := TrackingCategory{}
	var err error
	if prehook, ok := interface{}(m).(TrackingCategoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.MergeRecordId = m.MergeRecordId
	to.CategoryType = TrackingCategory_CategoryType(TrackingCategory_CategoryType_value[m.CategoryType])
	to.ParentCategory = m.ParentCategory
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Name = m.Name
	to.Status = m.Status
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(TrackingCategoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TrackingCategory the arg will be the target, the caller the one being converted from

// TrackingCategoryBeforeToORM called before default ToORM code
type TrackingCategoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *TrackingCategoryORM) error
}

// TrackingCategoryAfterToORM called after default ToORM code
type TrackingCategoryWithAfterToORM interface {
	AfterToORM(context.Context, *TrackingCategoryORM) error
}

// TrackingCategoryBeforeToPB called before default ToPB code
type TrackingCategoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *TrackingCategory) error
}

// TrackingCategoryAfterToPB called after default ToPB code
type TrackingCategoryWithAfterToPB interface {
	AfterToPB(context.Context, *TrackingCategory) error
}

type BusinessTransactionORM struct {
	Account                   string `gorm:"index:idx_transaction_account"`
	AccountingPeriod          string
	Company                   string `gorm:"index:idx_transaction_company"`
	Contact                   string
	CreatedAt                 *time.Time
	Currency                  string
	ExchangeRate              string
	Id                        uint64                    `gorm:"unique_index:idx_transaction_id"`
	LineItems                 []*TransactionLineItemORM `gorm:"foreignkey:BusinessTransactionId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_transaction_merge_record_id"`
	ModifiedAt                *time.Time
	Number                    string
	RemoteId                  string
	RemoteWasDeleted          bool
	TotalAmount               string
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	TransactionDate           *time.Time
	TransactionType           string
}

// TableName overrides the default tablename generated by GORM
func (BusinessTransactionORM) TableName() string {
	return "business_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessTransaction) ToORM(ctx context.Context) (BusinessTransactionORM, error) {
	to := BusinessTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TransactionType = m.TransactionType
	to.Number = m.Number
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.MergeRecordId = m.MergeRecordId
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(BusinessTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessTransactionORM) ToPB(ctx context.Context) (BusinessTransaction, error) {
	to := BusinessTransaction{}
	var err error
	if prehook, ok := interface{}(m).(BusinessTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TransactionType = m.TransactionType
	to.Number = m.Number
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.MergeRecordId = m.MergeRecordId
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(BusinessTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessTransaction the arg will be the target, the caller the one being converted from

// BusinessTransactionBeforeToORM called before default ToORM code
type BusinessTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessTransactionORM) error
}

// BusinessTransactionAfterToORM called after default ToORM code
type BusinessTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessTransactionORM) error
}

// BusinessTransactionBeforeToPB called before default ToPB code
type BusinessTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessTransaction) error
}

// BusinessTransactionAfterToPB called after default ToPB code
type BusinessTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessTransaction) error
}

type TransactionLineItemORM struct {
	Account               string `gorm:"index:idx_transaction_line_account"`
	BusinessTransactionId *uint64
	Company               string `gorm:"index:idx_transaction_line_company"`
	CreatedAt             *time.Time
	Currency              string
	ExchangeRate          string
	Id                    uint64 `gorm:"unique_index:idx_transaction_line_id"`
	Item                  string
	Memo                  string
	ModifiedAt            *time.Time
	Quantity              string
	RemoteId              string
	RemoteWasDeleted      bool
	TaxRate               string
	TotalLineAmount       string
	TrackingCategories    pq.StringArray `gorm:"type:text[]"`
	TrackingCategory      string
	UnitPrice             string
}

// TableName overrides the default tablename generated by GORM
func (TransactionLineItemORM) TableName() string {
	return "transaction_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionLineItem) ToORM(ctx context.Context) (TransactionLineItemORM, error) {
	to := TransactionLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Memo = m.Memo
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TotalLineAmount = m.TotalLineAmount
	to.TaxRate = m.TaxRate
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if posthook, ok := interface{}(m).(TransactionLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionLineItemORM) ToPB(ctx context.Context) (TransactionLineItem, error) {
	to := TransactionLineItem{}
	var err error
	if prehook, ok := interface{}(m).(TransactionLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Memo = m.Memo
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TotalLineAmount = m.TotalLineAmount
	to.TaxRate = m.TaxRate
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if posthook, ok := interface{}(m).(TransactionLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionLineItem the arg will be the target, the caller the one being converted from

// TransactionLineItemBeforeToORM called before default ToORM code
type TransactionLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionLineItemORM) error
}

// TransactionLineItemAfterToORM called after default ToORM code
type TransactionLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionLineItemORM) error
}

// TransactionLineItemBeforeToPB called before default ToPB code
type TransactionLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionLineItem) error
}

// TransactionLineItemAfterToPB called after default ToPB code
type TransactionLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionLineItem) error
}

type VendorCreditORM struct {
	AccountingPeriod          string
	Company                   string `gorm:"index:idx_vendor_credit_company"`
	Currency                  string
	ExchangeRate              string
	Id                        uint64                 `gorm:"unique_index:idx_vendor_credit_id"`
	Lines                     []*VendorCreditLineORM `gorm:"foreignkey:VendorCreditId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	MergeRecordId             string `gorm:"index:idx_vendor_credit_merge_record_id"`
	ModifiedAt                *time.Time
	Number                    string
	RemoteId                  string
	RemoteWasDeleted          bool
	TotalAmount               float64
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	TransactionDate           *time.Time
	Vendor                    string
}

// TableName overrides the default tablename generated by GORM
func (VendorCreditORM) TableName() string {
	return "vendor_credits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VendorCredit) ToORM(ctx context.Context) (VendorCreditORM, error) {
	to := VendorCreditORM{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MergeRecordId = m.MergeRecordId
	to.RemoteId = m.RemoteId
	to.Number = m.Number
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Vendor = m.Vendor
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VendorCreditORM) ToPB(ctx context.Context) (VendorCredit, error) {
	to := VendorCredit{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MergeRecordId = m.MergeRecordId
	to.RemoteId = m.RemoteId
	to.Number = m.Number
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Vendor = m.Vendor
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VendorCredit the arg will be the target, the caller the one being converted from

// VendorCreditBeforeToORM called before default ToORM code
type VendorCreditWithBeforeToORM interface {
	BeforeToORM(context.Context, *VendorCreditORM) error
}

// VendorCreditAfterToORM called after default ToORM code
type VendorCreditWithAfterToORM interface {
	AfterToORM(context.Context, *VendorCreditORM) error
}

// VendorCreditBeforeToPB called before default ToPB code
type VendorCreditWithBeforeToPB interface {
	BeforeToPB(context.Context, *VendorCredit) error
}

// VendorCreditAfterToPB called after default ToPB code
type VendorCreditWithAfterToPB interface {
	AfterToPB(context.Context, *VendorCredit) error
}

type VendorCreditLineORM struct {
	Account            string `gorm:"index:idx_vendor_credit_line_account"`
	Company            string `gorm:"index:idx_vendor_credit_line_company"`
	Description        string
	ExchangeRate       string
	Id                 uint64 `gorm:"unique_index:idx_vendor_credit_line_id"`
	ModifiedAt         *time.Time
	NetAmount          float64
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string         `gorm:"index:idx_vendor_credit_line_tracking_category"`
	VendorCreditId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (VendorCreditLineORM) TableName() string {
	return "vendor_credit_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VendorCreditLine) ToORM(ctx context.Context) (VendorCreditLineORM, error) {
	to := VendorCreditLineORM{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.RemoteId = m.RemoteId
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Description = m.Description
	to.Account = m.Account
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VendorCreditLineORM) ToPB(ctx context.Context) (VendorCreditLine, error) {
	to := VendorCreditLine{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.RemoteId = m.RemoteId
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Description = m.Description
	to.Account = m.Account
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VendorCreditLine the arg will be the target, the caller the one being converted from

// VendorCreditLineBeforeToORM called before default ToORM code
type VendorCreditLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *VendorCreditLineORM) error
}

// VendorCreditLineAfterToORM called after default ToORM code
type VendorCreditLineWithAfterToORM interface {
	AfterToORM(context.Context, *VendorCreditLineORM) error
}

// VendorCreditLineBeforeToPB called before default ToPB code
type VendorCreditLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *VendorCreditLine) error
}

// VendorCreditLineAfterToPB called after default ToPB code
type VendorCreditLineWithAfterToPB interface {
	AfterToPB(context.Context, *VendorCreditLine) error
}

// DefaultCreateAccountingIntegrationMergeLink executes a basic gorm create call
func DefaultCreateAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountingIntegrationMergeLinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountingIntegrationMergeLinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountingIntegrationMergeLinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountingIntegrationMergeLinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountingIntegrationMergeLinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountingIntegrationMergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountingIntegrationMergeLinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingIntegrationMergeLinkSet(ctx context.Context, in []*AccountingIntegrationMergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountingIntegrationMergeLinkORM{})).(AccountingIntegrationMergeLinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountingIntegrationMergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountingIntegrationMergeLinkORM{})).(AccountingIntegrationMergeLinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountingIntegrationMergeLinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountingIntegrationMergeLink, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountingIntegrationMergeLink, *gorm.DB) error
}

// DefaultStrictUpdateAccountingIntegrationMergeLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountingIntegrationMergeLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountingIntegrationMergeLinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccount := LinkedAccountingAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccount.AccountingIntegrationMergeLinkId = new(uint64)
	*filterAccount.AccountingIntegrationMergeLinkId = ormObj.Id
	if err = db.Where(filterAccount).Delete(LinkedAccountingAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterToken := MergeLinkedAccountTokenORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterToken.AccountingIntegrationMergeLinkId = new(uint64)
	*filterToken.AccountingIntegrationMergeLinkId = ormObj.Id
	if err = db.Where(filterToken).Delete(MergeLinkedAccountTokenORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountingIntegrationMergeLink executes a basic gorm update call with patch behavior
func DefaultPatchAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountingIntegrationMergeLink
	var err error
	if hook, ok := interface{}(&pbObj).(AccountingIntegrationMergeLinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountingIntegrationMergeLink(ctx, &AccountingIntegrationMergeLink{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountingIntegrationMergeLinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountingIntegrationMergeLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountingIntegrationMergeLinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountingIntegrationMergeLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountingIntegrationMergeLinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountingIntegrationMergeLinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountingIntegrationMergeLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountingIntegrationMergeLink(ctx context.Context, objects []*AccountingIntegrationMergeLink, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountingIntegrationMergeLink, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountingIntegrationMergeLink, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountingIntegrationMergeLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountingIntegrationMergeLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountingIntegrationMergeLink(ctx context.Context, patchee *AccountingIntegrationMergeLink, patcher *AccountingIntegrationMergeLink, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedToken bool
	var updatedAccount bool
	var updatedLastModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Integration" {
			patchee.Integration = patcher.Integration
			continue
		}
		if f == prefix+"IntegrationSlug" {
			patchee.IntegrationSlug = patcher.IntegrationSlug
			continue
		}
		if f == prefix+"Category" {
			patchee.Category = patcher.Category
			continue
		}
		if f == prefix+"EndUserOriginId" {
			patchee.EndUserOriginId = patcher.EndUserOriginId
			continue
		}
		if f == prefix+"EndUserOrganizationName" {
			patchee.EndUserOrganizationName = patcher.EndUserOrganizationName
			continue
		}
		if f == prefix+"EndUserEmailAddress" {
			patchee.EndUserEmailAddress = patcher.EndUserEmailAddress
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"WebhookListenerUrl" {
			patchee.WebhookListenerUrl = patcher.WebhookListenerUrl
			continue
		}
		if f == prefix+"IsDuplicate" {
			patchee.IsDuplicate = patcher.IsDuplicate
			continue
		}
		if !updatedToken && strings.HasPrefix(f, prefix+"Token.") {
			updatedToken = true
			if patcher.Token == nil {
				patchee.Token = nil
				continue
			}
			if patchee.Token == nil {
				patchee.Token = &MergeLinkedAccountToken{}
			}
			if o, err := DefaultApplyFieldMaskMergeLinkedAccountToken(ctx, patchee.Token, patcher.Token, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Token.", db); err != nil {
				return nil, err
			} else {
				patchee.Token = o
			}
			continue
		}
		if f == prefix+"Token" {
			updatedToken = true
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"IntegrationName" {
			patchee.IntegrationName = patcher.IntegrationName
			continue
		}
		if f == prefix+"IntegrationImage" {
			patchee.IntegrationImage = patcher.IntegrationImage
			continue
		}
		if f == prefix+"IntegrationSquareImage" {
			patchee.IntegrationSquareImage = patcher.IntegrationSquareImage
			continue
		}
		if !updatedAccount && strings.HasPrefix(f, prefix+"Account.") {
			updatedAccount = true
			if patcher.Account == nil {
				patchee.Account = nil
				continue
			}
			if patchee.Account == nil {
				patchee.Account = &LinkedAccountingAccount{}
			}
			if o, err := DefaultApplyFieldMaskLinkedAccountingAccount(ctx, patchee.Account, patcher.Account, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Account.", db); err != nil {
				return nil, err
			} else {
				patchee.Account = o
			}
			continue
		}
		if f == prefix+"Account" {
			updatedAccount = true
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"MergeLinkedAccountId" {
			patchee.MergeLinkedAccountId = patcher.MergeLinkedAccountId
			continue
		}
		if !updatedLastModifiedAt && strings.HasPrefix(f, prefix+"LastModifiedAt.") {
			if patcher.LastModifiedAt == nil {
				patchee.LastModifiedAt = nil
				continue
			}
			if patchee.LastModifiedAt == nil {
				patchee.LastModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastModifiedAt, patchee.LastModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastModifiedAt" {
			updatedLastModifiedAt = true
			patchee.LastModifiedAt = patcher.LastModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountingIntegrationMergeLink executes a gorm list call
func DefaultListAccountingIntegrationMergeLink(ctx context.Context, db *gorm.DB) ([]*AccountingIntegrationMergeLink, error) {
	in := AccountingIntegrationMergeLink{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountingIntegrationMergeLinkORM{}, &AccountingIntegrationMergeLink{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountingIntegrationMergeLinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountingIntegrationMergeLink{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountingIntegrationMergeLinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountingIntegrationMergeLinkORM) error
}

// DefaultCreateLinkedAccountingAccount executes a basic gorm create call
func DefaultCreateLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LinkedAccountingAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LinkedAccountingAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LinkedAccountingAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LinkedAccountingAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LinkedAccountingAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkedAccountingAccountSet(ctx context.Context, in []*LinkedAccountingAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LinkedAccountingAccountORM{})).(LinkedAccountingAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LinkedAccountingAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LinkedAccountingAccountORM{})).(LinkedAccountingAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LinkedAccountingAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LinkedAccountingAccount, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LinkedAccountingAccount, *gorm.DB) error
}

// DefaultStrictUpdateLinkedAccountingAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLinkedAccountingAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LinkedAccountingAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAttachments := AccountingAttachmentORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAttachments.LinkedAccountingAccountId = new(uint64)
	*filterAttachments.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterAttachments).Delete(AccountingAttachmentORM{}).Error; err != nil {
		return nil, err
	}
	filterBalanceSheets := BalanceSheetORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceSheets.LinkedAccountingAccountId = new(uint64)
	*filterBalanceSheets.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterBalanceSheets).Delete(BalanceSheetORM{}).Error; err != nil {
		return nil, err
	}
	filterCashFlowStatements := CashFlowStatementORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCashFlowStatements.LinkedAccountingAccountId = new(uint64)
	*filterCashFlowStatements.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterCashFlowStatements).Delete(CashFlowStatementORM{}).Error; err != nil {
		return nil, err
	}
	filterChartOfAccounts := BusinessChartOfAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterChartOfAccounts.LinkedAccountingAccountId = new(uint64)
	*filterChartOfAccounts.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterChartOfAccounts).Delete(BusinessChartOfAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterCompanyInfo := CompanyInfoORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompanyInfo.LinkedAccountingAccountId = new(uint64)
	*filterCompanyInfo.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterCompanyInfo).Delete(CompanyInfoORM{}).Error; err != nil {
		return nil, err
	}
	filterContacts := ContactsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterContacts.LinkedAccountingAccountId = new(uint64)
	*filterContacts.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterContacts).Delete(ContactsORM{}).Error; err != nil {
		return nil, err
	}
	filterCreditNotes := CreditNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCreditNotes.LinkedAccountingAccountId = new(uint64)
	*filterCreditNotes.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterCreditNotes).Delete(CreditNoteORM{}).Error; err != nil {
		return nil, err
	}
	filterExpenses := ExpenseORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterExpenses.LinkedAccountingAccountId = new(uint64)
	*filterExpenses.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterExpenses).Delete(ExpenseORM{}).Error; err != nil {
		return nil, err
	}
	filterIncomeStatements := IncomeStatementORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIncomeStatements.LinkedAccountingAccountId = new(uint64)
	*filterIncomeStatements.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterIncomeStatements).Delete(IncomeStatementORM{}).Error; err != nil {
		return nil, err
	}
	filterInvoices := InvoiceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvoices.LinkedAccountingAccountId = new(uint64)
	*filterInvoices.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterInvoices).Delete(InvoiceORM{}).Error; err != nil {
		return nil, err
	}
	filterItems := ItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterItems.LinkedAccountingAccountId = new(uint64)
	*filterItems.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterItems).Delete(ItemORM{}).Error; err != nil {
		return nil, err
	}
	filterJournalEntries := JournalEntryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterJournalEntries.LinkedAccountingAccountId = new(uint64)
	*filterJournalEntries.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterJournalEntries).Delete(JournalEntryORM{}).Error; err != nil {
		return nil, err
	}
	filterPayments := PaymentORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayments.LinkedAccountingAccountId = new(uint64)
	*filterPayments.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterPayments).Delete(PaymentORM{}).Error; err != nil {
		return nil, err
	}
	filterPurchaseOrders := PurchaseOrderORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPurchaseOrders.LinkedAccountingAccountId = new(uint64)
	*filterPurchaseOrders.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterPurchaseOrders).Delete(PurchaseOrderORM{}).Error; err != nil {
		return nil, err
	}
	filterTaxRates := TaxRateORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTaxRates.LinkedAccountingAccountId = new(uint64)
	*filterTaxRates.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterTaxRates).Delete(TaxRateORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := BusinessTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.LinkedAccountingAccountId = new(uint64)
	*filterTransactions.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(BusinessTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterVendorCredits := VendorCreditORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVendorCredits.LinkedAccountingAccountId = new(uint64)
	*filterVendorCredits.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterVendorCredits).Delete(VendorCreditORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLinkedAccountingAccount executes a basic gorm update call with patch behavior
func DefaultPatchLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LinkedAccountingAccount
	var err error
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLinkedAccountingAccount(ctx, &LinkedAccountingAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLinkedAccountingAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLinkedAccountingAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LinkedAccountingAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LinkedAccountingAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLinkedAccountingAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetLinkedAccountingAccount(ctx context.Context, objects []*LinkedAccountingAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LinkedAccountingAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LinkedAccountingAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLinkedAccountingAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLinkedAccountingAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLinkedAccountingAccount(ctx context.Context, patchee *LinkedAccountingAccount, patcher *LinkedAccountingAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Attachments" {
			patchee.Attachments = patcher.Attachments
			continue
		}
		if f == prefix+"CompanyInfo" {
			patchee.CompanyInfo = patcher.CompanyInfo
			continue
		}
		if f == prefix+"PurchaseOrders" {
			patchee.PurchaseOrders = patcher.PurchaseOrders
			continue
		}
		if f == prefix+"BalanceSheets" {
			patchee.BalanceSheets = patcher.BalanceSheets
			continue
		}
		if f == prefix+"CashFlowStatements" {
			patchee.CashFlowStatements = patcher.CashFlowStatements
			continue
		}
		if f == prefix+"IncomeStatements" {
			patchee.IncomeStatements = patcher.IncomeStatements
			continue
		}
		if f == prefix+"ChartOfAccounts" {
			patchee.ChartOfAccounts = patcher.ChartOfAccounts
			continue
		}
		if f == prefix+"Items" {
			patchee.Items = patcher.Items
			continue
		}
		if f == prefix+"TaxRates" {
			patchee.TaxRates = patcher.TaxRates
			continue
		}
		if f == prefix+"Contacts" {
			patchee.Contacts = patcher.Contacts
			continue
		}
		if f == prefix+"Invoices" {
			patchee.Invoices = patcher.Invoices
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"Expenses" {
			patchee.Expenses = patcher.Expenses
			continue
		}
		if f == prefix+"JournalEntries" {
			patchee.JournalEntries = patcher.JournalEntries
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"VendorCredits" {
			patchee.VendorCredits = patcher.VendorCredits
			continue
		}
		if f == prefix+"CreditNotes" {
			patchee.CreditNotes = patcher.CreditNotes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLinkedAccountingAccount executes a gorm list call
func DefaultListLinkedAccountingAccount(ctx context.Context, db *gorm.DB) ([]*LinkedAccountingAccount, error) {
	in := LinkedAccountingAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LinkedAccountingAccountORM{}, &LinkedAccountingAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LinkedAccountingAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LinkedAccountingAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LinkedAccountingAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LinkedAccountingAccountORM) error
}

// DefaultCreateBusinessChartOfAccount executes a basic gorm create call
func DefaultCreateBusinessChartOfAccount(ctx context.Context, in *BusinessChartOfAccount, db *gorm.DB) (*BusinessChartOfAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessChartOfAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessChartOfAccount(ctx context.Context, in *BusinessChartOfAccount, db *gorm.DB) (*BusinessChartOfAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessChartOfAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessChartOfAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessChartOfAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessChartOfAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessChartOfAccount(ctx context.Context, in *BusinessChartOfAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessChartOfAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessChartOfAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessChartOfAccountSet(ctx context.Context, in []*BusinessChartOfAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessChartOfAccountORM{})).(BusinessChartOfAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessChartOfAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessChartOfAccountORM{})).(BusinessChartOfAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessChartOfAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessChartOfAccount, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessChartOfAccount, *gorm.DB) error
}

// DefaultStrictUpdateBusinessChartOfAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessChartOfAccount(ctx context.Context, in *BusinessChartOfAccount, db *gorm.DB) (*BusinessChartOfAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessChartOfAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessChartOfAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessChartOfAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessChartOfAccount executes a basic gorm update call with patch behavior
func DefaultPatchBusinessChartOfAccount(ctx context.Context, in *BusinessChartOfAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessChartOfAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessChartOfAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessChartOfAccount(ctx, &BusinessChartOfAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessChartOfAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessChartOfAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessChartOfAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessChartOfAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessChartOfAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessChartOfAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessChartOfAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessChartOfAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessChartOfAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessChartOfAccount(ctx context.Context, objects []*BusinessChartOfAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessChartOfAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessChartOfAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessChartOfAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessChartOfAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessChartOfAccount(ctx context.Context, patchee *BusinessChartOfAccount, patcher *BusinessChartOfAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessChartOfAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Classification" {
			patchee.Classification = patcher.Classification
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"CurrentBalance" {
			patchee.CurrentBalance = patcher.CurrentBalance
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"ParentAccountId" {
			patchee.ParentAccountId = patcher.ParentAccountId
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessChartOfAccount executes a gorm list call
func DefaultListBusinessChartOfAccount(ctx context.Context, db *gorm.DB) ([]*BusinessChartOfAccount, error) {
	in := BusinessChartOfAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessChartOfAccountORM{}, &BusinessChartOfAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessChartOfAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessChartOfAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessChartOfAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessChartOfAccountORM) error
}

// DefaultCreateCompanyAddress executes a basic gorm create call
func DefaultCreateCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyAddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyAddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyAddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyAddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyAddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyAddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyAddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyAddressSet(ctx context.Context, in []*CompanyAddress, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyAddressORM{})).(CompanyAddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyAddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyAddressORM{})).(CompanyAddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyAddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyAddress, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyAddress, *gorm.DB) error
}

// DefaultStrictUpdateCompanyAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyAddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyAddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyAddress executes a basic gorm update call with patch behavior
func DefaultPatchCompanyAddress(ctx context.Context, in *CompanyAddress, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyAddress
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyAddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompanyAddress(ctx, &CompanyAddress{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyAddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyAddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyAddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyAddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyAddress(ctx context.Context, objects []*CompanyAddress, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyAddress, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyAddress, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyAddress(ctx context.Context, patchee *CompanyAddress, patcher *CompanyAddress, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyAddress, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Street_1" {
			patchee.Street_1 = patcher.Street_1
			continue
		}
		if f == prefix+"Street_2" {
			patchee.Street_2 = patcher.Street_2
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"CountrySubdivision" {
			patchee.CountrySubdivision = patcher.CountrySubdivision
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyAddress executes a gorm list call
func DefaultListCompanyAddress(ctx context.Context, db *gorm.DB) ([]*CompanyAddress, error) {
	in := CompanyAddress{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyAddressORM{}, &CompanyAddress{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyAddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyAddress{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyAddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyAddressORM) error
}

// DefaultCreateBalanceSheet executes a basic gorm create call
func DefaultCreateBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BalanceSheetORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BalanceSheetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BalanceSheetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BalanceSheetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BalanceSheetORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSheetSet(ctx context.Context, in []*BalanceSheet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BalanceSheetORM{})).(BalanceSheetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BalanceSheetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BalanceSheetORM{})).(BalanceSheetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BalanceSheetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BalanceSheet, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BalanceSheet, *gorm.DB) error
}

// DefaultStrictUpdateBalanceSheet clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBalanceSheet")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BalanceSheetORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAssets := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAssets.AssetsBalanceSheetId = new(uint64)
	*filterAssets.AssetsBalanceSheetId = ormObj.Id
	if err = db.Where(filterAssets).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterEquity := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEquity.EquityBalanceSheetId = new(uint64)
	*filterEquity.EquityBalanceSheetId = ormObj.Id
	if err = db.Where(filterEquity).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterLiabilities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLiabilities.LiabilitiesBalanceSheetId = new(uint64)
	*filterLiabilities.LiabilitiesBalanceSheetId = ormObj.Id
	if err = db.Where(filterLiabilities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBalanceSheet executes a basic gorm update call with patch behavior
func DefaultPatchBalanceSheet(ctx context.Context, in *BalanceSheet, updateMask *field_mask.FieldMask, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BalanceSheet
	var err error
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBalanceSheet(ctx, &BalanceSheet{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBalanceSheet(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBalanceSheet(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BalanceSheetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BalanceSheetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBalanceSheet executes a bulk gorm update call with patch behavior
func DefaultPatchSetBalanceSheet(ctx context.Context, objects []*BalanceSheet, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BalanceSheet, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BalanceSheet, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBalanceSheet(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBalanceSheet patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBalanceSheet(ctx context.Context, patchee *BalanceSheet, patcher *BalanceSheet, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BalanceSheet, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDate bool
	var updatedRemoteGeneratedAt bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedDate && strings.HasPrefix(f, prefix+"Date.") {
			if patcher.Date == nil {
				patchee.Date = nil
				continue
			}
			if patchee.Date == nil {
				patchee.Date = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Date."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Date, patchee.Date, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Date" {
			updatedDate = true
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"NetAssets" {
			patchee.NetAssets = patcher.NetAssets
			continue
		}
		if f == prefix+"Assets" {
			patchee.Assets = patcher.Assets
			continue
		}
		if f == prefix+"Liabilities" {
			patchee.Liabilities = patcher.Liabilities
			continue
		}
		if f == prefix+"Equity" {
			patchee.Equity = patcher.Equity
			continue
		}
		if !updatedRemoteGeneratedAt && strings.HasPrefix(f, prefix+"RemoteGeneratedAt.") {
			if patcher.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = nil
				continue
			}
			if patchee.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteGeneratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteGeneratedAt, patchee.RemoteGeneratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteGeneratedAt" {
			updatedRemoteGeneratedAt = true
			patchee.RemoteGeneratedAt = patcher.RemoteGeneratedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBalanceSheet executes a gorm list call
func DefaultListBalanceSheet(ctx context.Context, db *gorm.DB) ([]*BalanceSheet, error) {
	in := BalanceSheet{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BalanceSheetORM{}, &BalanceSheet{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BalanceSheetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BalanceSheet{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BalanceSheetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BalanceSheetORM) error
}

// DefaultCreateReportItem executes a basic gorm create call
func DefaultCreateReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReportItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReportItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReportItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReportItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReportItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReportItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReportItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReportItemSet(ctx context.Context, in []*ReportItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReportItemORM{})).(ReportItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReportItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReportItemORM{})).(ReportItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReportItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReportItem, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReportItem, *gorm.DB) error
}

// DefaultStrictUpdateReportItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReportItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReportItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReportItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReportItem executes a basic gorm update call with patch behavior
func DefaultPatchReportItem(ctx context.Context, in *ReportItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReportItem
	var err error
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReportItem(ctx, &ReportItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReportItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReportItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReportItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReportItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReportItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetReportItem(ctx context.Context, objects []*ReportItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReportItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReportItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReportItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReportItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReportItem(ctx context.Context, patchee *ReportItem, patcher *ReportItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReportItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReportItem executes a gorm list call
func DefaultListReportItem(ctx context.Context, db *gorm.DB) ([]*ReportItem, error) {
	in := ReportItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReportItemORM{}, &ReportItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReportItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReportItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReportItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReportItemORM) error
}

// DefaultCreateCashFlowStatement executes a basic gorm create call
func DefaultCreateCashFlowStatement(ctx context.Context, in *CashFlowStatement, db *gorm.DB) (*CashFlowStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CashFlowStatementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCashFlowStatement(ctx context.Context, in *CashFlowStatement, db *gorm.DB) (*CashFlowStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CashFlowStatementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CashFlowStatementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CashFlowStatementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CashFlowStatementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCashFlowStatement(ctx context.Context, in *CashFlowStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CashFlowStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CashFlowStatementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCashFlowStatementSet(ctx context.Context, in []*CashFlowStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CashFlowStatementORM{})).(CashFlowStatementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CashFlowStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CashFlowStatementORM{})).(CashFlowStatementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CashFlowStatementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CashFlowStatement, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CashFlowStatement, *gorm.DB) error
}

// DefaultStrictUpdateCashFlowStatement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCashFlowStatement(ctx context.Context, in *CashFlowStatement, db *gorm.DB) (*CashFlowStatement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCashFlowStatement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CashFlowStatementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFinancingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFinancingActivities.FinancingActivitiesCashFlowStatementId = new(uint64)
	*filterFinancingActivities.FinancingActivitiesCashFlowStatementId = ormObj.Id
	if err = db.Where(filterFinancingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvestingActivities.InvestingActivitiesCashFlowStatementId = new(uint64)
	*filterInvestingActivities.InvestingActivitiesCashFlowStatementId = ormObj.Id
	if err = db.Where(filterInvestingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterOperatingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOperatingActivities.OperatingActivitiesCashFlowStatementId = new(uint64)
	*filterOperatingActivities.OperatingActivitiesCashFlowStatementId = ormObj.Id
	if err = db.Where(filterOperatingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CashFlowStatementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCashFlowStatement executes a basic gorm update call with patch behavior
func DefaultPatchCashFlowStatement(ctx context.Context, in *CashFlowStatement, updateMask *field_mask.FieldMask, db *gorm.DB) (*CashFlowStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CashFlowStatement
	var err error
	if hook, ok := interface{}(&pbObj).(CashFlowStatementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCashFlowStatement(ctx, &CashFlowStatement{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CashFlowStatementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCashFlowStatement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CashFlowStatementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCashFlowStatement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CashFlowStatementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CashFlowStatementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CashFlowStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CashFlowStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CashFlowStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CashFlowStatement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCashFlowStatement executes a bulk gorm update call with patch behavior
func DefaultPatchSetCashFlowStatement(ctx context.Context, objects []*CashFlowStatement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CashFlowStatement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CashFlowStatement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCashFlowStatement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCashFlowStatement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCashFlowStatement(ctx context.Context, patchee *CashFlowStatement, patcher *CashFlowStatement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CashFlowStatement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartPeriod bool
	var updatedEndPeriod bool
	var updatedRemoteGeneratedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedStartPeriod && strings.HasPrefix(f, prefix+"StartPeriod.") {
			if patcher.StartPeriod == nil {
				patchee.StartPeriod = nil
				continue
			}
			if patchee.StartPeriod == nil {
				patchee.StartPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartPeriod, patchee.StartPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartPeriod" {
			updatedStartPeriod = true
			patchee.StartPeriod = patcher.StartPeriod
			continue
		}
		if !updatedEndPeriod && strings.HasPrefix(f, prefix+"EndPeriod.") {
			if patcher.EndPeriod == nil {
				patchee.EndPeriod = nil
				continue
			}
			if patchee.EndPeriod == nil {
				patchee.EndPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndPeriod, patchee.EndPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndPeriod" {
			updatedEndPeriod = true
			patchee.EndPeriod = patcher.EndPeriod
			continue
		}
		if f == prefix+"CashAtBeginningOfPeriod" {
			patchee.CashAtBeginningOfPeriod = patcher.CashAtBeginningOfPeriod
			continue
		}
		if f == prefix+"CashAtEndOfPeriod" {
			patchee.CashAtEndOfPeriod = patcher.CashAtEndOfPeriod
			continue
		}
		if f == prefix+"OperatingActivities" {
			patchee.OperatingActivities = patcher.OperatingActivities
			continue
		}
		if f == prefix+"InvestingActivities" {
			patchee.InvestingActivities = patcher.InvestingActivities
			continue
		}
		if f == prefix+"FinancingActivities" {
			patchee.FinancingActivities = patcher.FinancingActivities
			continue
		}
		if !updatedRemoteGeneratedAt && strings.HasPrefix(f, prefix+"RemoteGeneratedAt.") {
			if patcher.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = nil
				continue
			}
			if patchee.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteGeneratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteGeneratedAt, patchee.RemoteGeneratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteGeneratedAt" {
			updatedRemoteGeneratedAt = true
			patchee.RemoteGeneratedAt = patcher.RemoteGeneratedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCashFlowStatement executes a gorm list call
func DefaultListCashFlowStatement(ctx context.Context, db *gorm.DB) ([]*CashFlowStatement, error) {
	in := CashFlowStatement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CashFlowStatementORM{}, &CashFlowStatement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CashFlowStatementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CashFlowStatement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CashFlowStatementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CashFlowStatementORM) error
}

// DefaultCreateCompanyInfo executes a basic gorm create call
func DefaultCreateCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyInfoORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyInfoSet(ctx context.Context, in []*CompanyInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyInfoORM{})).(CompanyInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyInfoORM{})).(CompanyInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyInfo, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyInfo, *gorm.DB) error
}

// DefaultStrictUpdateCompanyInfo clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddresses := CompanyAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddresses.CompanyInfoId = new(uint64)
	*filterAddresses.CompanyInfoId = ormObj.Id
	if err = db.Where(filterAddresses).Delete(CompanyAddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyInfo executes a basic gorm update call with patch behavior
func DefaultPatchCompanyInfo(ctx context.Context, in *CompanyInfo, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyInfo
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompanyInfo(ctx, &CompanyInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyInfo(ctx context.Context, objects []*CompanyInfo, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyInfo(ctx context.Context, patchee *CompanyInfo, patcher *CompanyInfo, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"LegalName" {
			patchee.LegalName = patcher.LegalName
			continue
		}
		if f == prefix+"TaxNumber" {
			patchee.TaxNumber = patcher.TaxNumber
			continue
		}
		if f == prefix+"FiscalYearEndMonth" {
			patchee.FiscalYearEndMonth = patcher.FiscalYearEndMonth
			continue
		}
		if f == prefix+"FiscalYearEndDay" {
			patchee.FiscalYearEndDay = patcher.FiscalYearEndDay
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"Urls" {
			patchee.Urls = patcher.Urls
			continue
		}
		if f == prefix+"Addresses" {
			patchee.Addresses = patcher.Addresses
			continue
		}
		if f == prefix+"PhoneNumbers" {
			patchee.PhoneNumbers = patcher.PhoneNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyInfo executes a gorm list call
func DefaultListCompanyInfo(ctx context.Context, db *gorm.DB) ([]*CompanyInfo, error) {
	in := CompanyInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyInfoORM{}, &CompanyInfo{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyInfoORM) error
}

// DefaultCreateAccountingAttachment executes a basic gorm create call
func DefaultCreateAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountingAttachmentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountingAttachmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountingAttachmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountingAttachmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountingAttachmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingAttachmentSet(ctx context.Context, in []*AccountingAttachment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountingAttachmentORM{})).(AccountingAttachmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountingAttachmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountingAttachmentORM{})).(AccountingAttachmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountingAttachmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountingAttachment, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountingAttachment, *gorm.DB) error
}

// DefaultStrictUpdateAccountingAttachment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountingAttachment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountingAttachmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountingAttachment executes a basic gorm update call with patch behavior
func DefaultPatchAccountingAttachment(ctx context.Context, in *AccountingAttachment, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountingAttachment
	var err error
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountingAttachment(ctx, &AccountingAttachment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountingAttachment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountingAttachment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountingAttachmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountingAttachmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountingAttachment executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountingAttachment(ctx context.Context, objects []*AccountingAttachment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountingAttachment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountingAttachment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountingAttachment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountingAttachment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountingAttachment(ctx context.Context, patchee *AccountingAttachment, patcher *AccountingAttachment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountingAttachment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"FileUrl" {
			patchee.FileUrl = patcher.FileUrl
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountingAttachment executes a gorm list call
func DefaultListAccountingAttachment(ctx context.Context, db *gorm.DB) ([]*AccountingAttachment, error) {
	in := AccountingAttachment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountingAttachmentORM{}, &AccountingAttachment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountingAttachmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountingAttachment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountingAttachmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountingAttachmentORM) error
}

// DefaultCreateContacts executes a basic gorm create call
func DefaultCreateContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContactsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ContactsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContactsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContactsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContactsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteContacts(ctx context.Context, in *Contacts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContactsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ContactsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteContactsSet(ctx context.Context, in []*Contacts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContactsORM{})).(ContactsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ContactsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContactsORM{})).(ContactsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContactsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Contacts, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Contacts, *gorm.DB) error
}

// DefaultStrictUpdateContacts clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContacts")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ContactsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContactsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchContacts executes a basic gorm update call with patch behavior
func DefaultPatchContacts(ctx context.Context, in *Contacts, updateMask *field_mask.FieldMask, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Contacts
	var err error
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContacts(ctx, &Contacts{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContacts(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContacts(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContactsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContactsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetContacts executes a bulk gorm update call with patch behavior
func DefaultPatchSetContacts(ctx context.Context, objects []*Contacts, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Contacts, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Contacts, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchContacts(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskContacts patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContacts(ctx context.Context, patchee *Contacts, patcher *Contacts, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Contacts, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsSupplier" {
			patchee.IsSupplier = patcher.IsSupplier
			continue
		}
		if f == prefix+"IsCustomer" {
			patchee.IsCustomer = patcher.IsCustomer
			continue
		}
		if f == prefix+"EmailAddress" {
			patchee.EmailAddress = patcher.EmailAddress
			continue
		}
		if f == prefix+"TaxNumber" {
			patchee.TaxNumber = patcher.TaxNumber
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"AddressesIds" {
			patchee.AddressesIds = patcher.AddressesIds
			continue
		}
		if f == prefix+"PhoneNumbers" {
			patchee.PhoneNumbers = patcher.PhoneNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContacts executes a gorm list call
func DefaultListContacts(ctx context.Context, db *gorm.DB) ([]*Contacts, error) {
	in := Contacts{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ContactsORM{}, &Contacts{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContactsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Contacts{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContactsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ContactsORM) error
}

// DefaultCreateCreditNote executes a basic gorm create call
func DefaultCreateCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteSet(ctx context.Context, in []*CreditNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditNoteORM{})).(CreditNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditNoteORM{})).(CreditNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditNote, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditNote, *gorm.DB) error
}

// DefaultStrictUpdateCreditNote clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := CreditNoteLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.CreditNoteId = new(uint64)
	*filterLineItems.CreditNoteId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(CreditNoteLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditNote executes a basic gorm update call with patch behavior
func DefaultPatchCreditNote(ctx context.Context, in *CreditNote, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditNote
	var err error
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditNote(ctx, &CreditNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditNote(ctx context.Context, objects []*CreditNote, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditNote(ctx context.Context, patchee *CreditNote, patcher *CreditNote, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"RemainingCredit" {
			patchee.RemainingCredit = patcher.RemainingCredit
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"PaymentIds" {
			patchee.PaymentIds = patcher.PaymentIds
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditNote executes a gorm list call
func DefaultListCreditNote(ctx context.Context, db *gorm.DB) ([]*CreditNote, error) {
	in := CreditNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditNoteORM{}, &CreditNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditNoteORM) error
}

// DefaultCreateCreditNoteLineItem executes a basic gorm create call
func DefaultCreateCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditNoteLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditNoteLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditNoteLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditNoteLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditNoteLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteLineItemSet(ctx context.Context, in []*CreditNoteLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditNoteLineItemORM{})).(CreditNoteLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditNoteLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditNoteLineItemORM{})).(CreditNoteLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditNoteLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditNoteLineItem, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditNoteLineItem, *gorm.DB) error
}

// DefaultStrictUpdateCreditNoteLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditNoteLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditNoteLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditNoteLineItem executes a basic gorm update call with patch behavior
func DefaultPatchCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditNoteLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditNoteLineItem(ctx, &CreditNoteLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditNoteLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditNoteLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditNoteLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditNoteLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditNoteLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditNoteLineItem(ctx context.Context, objects []*CreditNoteLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditNoteLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditNoteLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditNoteLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditNoteLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditNoteLineItem(ctx context.Context, patchee *CreditNoteLineItem, patcher *CreditNoteLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditNoteLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"TaxRate" {
			patchee.TaxRate = patcher.TaxRate
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditNoteLineItem executes a gorm list call
func DefaultListCreditNoteLineItem(ctx context.Context, db *gorm.DB) ([]*CreditNoteLineItem, error) {
	in := CreditNoteLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditNoteLineItemORM{}, &CreditNoteLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditNoteLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditNoteLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditNoteLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditNoteLineItemORM) error
}

// DefaultCreateExpense executes a basic gorm create call
func DefaultCreateExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ExpenseORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExpenseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExpenseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExpense(ctx context.Context, in *Expense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExpenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExpenseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseSet(ctx context.Context, in []*Expense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExpenseORM{})).(ExpenseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExpenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExpenseORM{})).(ExpenseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExpenseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Expense, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Expense, *gorm.DB) error
}

// DefaultStrictUpdateExpense clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExpense")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExpenseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := ExpenseLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.ExpenseId = new(uint64)
	*filterLines.ExpenseId = ormObj.Id
	if err = db.Where(filterLines).Delete(ExpenseLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExpenseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExpense executes a basic gorm update call with patch behavior
func DefaultPatchExpense(ctx context.Context, in *Expense, updateMask *field_mask.FieldMask, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Expense
	var err error
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExpense(ctx, &Expense{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExpense(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExpense(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExpenseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExpenseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExpense executes a bulk gorm update call with patch behavior
func DefaultPatchSetExpense(ctx context.Context, objects []*Expense, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Expense, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Expense, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExpense(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExpense patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpense(ctx context.Context, patchee *Expense, patcher *Expense, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Expense, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"SubTotal" {
			patchee.SubTotal = patcher.SubTotal
			continue
		}
		if f == prefix+"TotalTaxAmount" {
			patchee.TotalTaxAmount = patcher.TotalTaxAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpense executes a gorm list call
func DefaultListExpense(ctx context.Context, db *gorm.DB) ([]*Expense, error) {
	in := Expense{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseORM{}, &Expense{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExpenseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Expense{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseORM) error
}

// DefaultCreateExpenseLine executes a basic gorm create call
func DefaultCreateExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ExpenseLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExpenseLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExpenseLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExpenseLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExpenseLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseLineSet(ctx context.Context, in []*ExpenseLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExpenseLineORM{})).(ExpenseLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExpenseLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExpenseLineORM{})).(ExpenseLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExpenseLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ExpenseLine, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ExpenseLine, *gorm.DB) error
}

// DefaultStrictUpdateExpenseLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExpenseLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExpenseLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExpenseLine executes a basic gorm update call with patch behavior
func DefaultPatchExpenseLine(ctx context.Context, in *ExpenseLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ExpenseLine
	var err error
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExpenseLine(ctx, &ExpenseLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExpenseLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExpenseLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExpenseLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExpenseLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExpenseLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetExpenseLine(ctx context.Context, objects []*ExpenseLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ExpenseLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ExpenseLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExpenseLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExpenseLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpenseLine(ctx context.Context, patchee *ExpenseLine, patcher *ExpenseLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExpenseLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpenseLine executes a gorm list call
func DefaultListExpenseLine(ctx context.Context, db *gorm.DB) ([]*ExpenseLine, error) {
	in := ExpenseLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseLineORM{}, &ExpenseLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExpenseLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExpenseLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseLineORM) error
}

// DefaultCreateIncomeStatement executes a basic gorm create call
func DefaultCreateIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &IncomeStatementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := IncomeStatementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(IncomeStatementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&IncomeStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type IncomeStatementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteIncomeStatementSet(ctx context.Context, in []*IncomeStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&IncomeStatementORM{})).(IncomeStatementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&IncomeStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&IncomeStatementORM{})).(IncomeStatementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type IncomeStatementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*IncomeStatement, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*IncomeStatement, *gorm.DB) error
}

// DefaultStrictUpdateIncomeStatement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateIncomeStatement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &IncomeStatementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCostOfSales := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCostOfSales.CostOfSalesIncomeStatementId = new(uint64)
	*filterCostOfSales.CostOfSalesIncomeStatementId = ormObj.Id
	if err = db.Where(filterCostOfSales).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterIncome := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIncome.IncomeIncomeStatementId = new(uint64)
	*filterIncome.IncomeIncomeStatementId = ormObj.Id
	if err = db.Where(filterIncome).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterNonOperatingExpenses := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNonOperatingExpenses.NonOperatingExpensesIncomeStatementId = new(uint64)
	*filterNonOperatingExpenses.NonOperatingExpensesIncomeStatementId = ormObj.Id
	if err = db.Where(filterNonOperatingExpenses).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterOperatingExpenses := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOperatingExpenses.OperatingExpensesIncomeStatementId = new(uint64)
	*filterOperatingExpenses.OperatingExpensesIncomeStatementId = ormObj.Id
	if err = db.Where(filterOperatingExpenses).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchIncomeStatement executes a basic gorm update call with patch behavior
func DefaultPatchIncomeStatement(ctx context.Context, in *IncomeStatement, updateMask *field_mask.FieldMask, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj IncomeStatement
	var err error
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadIncomeStatement(ctx, &IncomeStatement{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskIncomeStatement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateIncomeStatement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(IncomeStatementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type IncomeStatementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetIncomeStatement executes a bulk gorm update call with patch behavior
func DefaultPatchSetIncomeStatement(ctx context.Context, objects []*IncomeStatement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*IncomeStatement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*IncomeStatement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchIncomeStatement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskIncomeStatement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIncomeStatement(ctx context.Context, patchee *IncomeStatement, patcher *IncomeStatement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IncomeStatement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartPeriod bool
	var updatedEndPeriod bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedStartPeriod && strings.HasPrefix(f, prefix+"StartPeriod.") {
			if patcher.StartPeriod == nil {
				patchee.StartPeriod = nil
				continue
			}
			if patchee.StartPeriod == nil {
				patchee.StartPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartPeriod, patchee.StartPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartPeriod" {
			updatedStartPeriod = true
			patchee.StartPeriod = patcher.StartPeriod
			continue
		}
		if !updatedEndPeriod && strings.HasPrefix(f, prefix+"EndPeriod.") {
			if patcher.EndPeriod == nil {
				patchee.EndPeriod = nil
				continue
			}
			if patchee.EndPeriod == nil {
				patchee.EndPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndPeriod, patchee.EndPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndPeriod" {
			updatedEndPeriod = true
			patchee.EndPeriod = patcher.EndPeriod
			continue
		}
		if f == prefix+"Income" {
			patchee.Income = patcher.Income
			continue
		}
		if f == prefix+"CostOfSales" {
			patchee.CostOfSales = patcher.CostOfSales
			continue
		}
		if f == prefix+"GrossProfit" {
			patchee.GrossProfit = patcher.GrossProfit
			continue
		}
		if f == prefix+"OperatingExpenses" {
			patchee.OperatingExpenses = patcher.OperatingExpenses
			continue
		}
		if f == prefix+"NetOperatingIncome" {
			patchee.NetOperatingIncome = patcher.NetOperatingIncome
			continue
		}
		if f == prefix+"NonOperatingExpenses" {
			patchee.NonOperatingExpenses = patcher.NonOperatingExpenses
			continue
		}
		if f == prefix+"NetIncome" {
			patchee.NetIncome = patcher.NetIncome
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIncomeStatement executes a gorm list call
func DefaultListIncomeStatement(ctx context.Context, db *gorm.DB) ([]*IncomeStatement, error) {
	in := IncomeStatement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IncomeStatementORM{}, &IncomeStatement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []IncomeStatementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IncomeStatement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IncomeStatementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IncomeStatementORM) error
}

// DefaultCreateInvoice executes a basic gorm create call
func DefaultCreateInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvoiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvoiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvoiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoice(ctx context.Context, in *Invoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvoiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceSet(ctx context.Context, in []*Invoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvoiceORM{})).(InvoiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvoiceORM{})).(InvoiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvoiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Invoice, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Invoice, *gorm.DB) error
}

// DefaultStrictUpdateInvoice clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvoice")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvoiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := InvoiceLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.InvoiceId = new(uint64)
	*filterLineItems.InvoiceId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(InvoiceLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvoiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvoice executes a basic gorm update call with patch behavior
func DefaultPatchInvoice(ctx context.Context, in *Invoice, updateMask *field_mask.FieldMask, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Invoice
	var err error
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvoice(ctx, &Invoice{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvoice(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvoice(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvoiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvoiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvoice executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvoice(ctx context.Context, objects []*Invoice, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Invoice, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Invoice, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvoice(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvoice patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvoice(ctx context.Context, patchee *Invoice, patcher *Invoice, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Invoice, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedIssueDate bool
	var updatedDueDate bool
	var updatedPaidOnDate bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedIssueDate && strings.HasPrefix(f, prefix+"IssueDate.") {
			if patcher.IssueDate == nil {
				patchee.IssueDate = nil
				continue
			}
			if patchee.IssueDate == nil {
				patchee.IssueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IssueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IssueDate, patchee.IssueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IssueDate" {
			updatedIssueDate = true
			patchee.IssueDate = patcher.IssueDate
			continue
		}
		if !updatedDueDate && strings.HasPrefix(f, prefix+"DueDate.") {
			if patcher.DueDate == nil {
				patchee.DueDate = nil
				continue
			}
			if patchee.DueDate == nil {
				patchee.DueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DueDate, patchee.DueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DueDate" {
			updatedDueDate = true
			patchee.DueDate = patcher.DueDate
			continue
		}
		if !updatedPaidOnDate && strings.HasPrefix(f, prefix+"PaidOnDate.") {
			if patcher.PaidOnDate == nil {
				patchee.PaidOnDate = nil
				continue
			}
			if patchee.PaidOnDate == nil {
				patchee.PaidOnDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PaidOnDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.PaidOnDate, patchee.PaidOnDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PaidOnDate" {
			updatedPaidOnDate = true
			patchee.PaidOnDate = patcher.PaidOnDate
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"TotalDiscount" {
			patchee.TotalDiscount = patcher.TotalDiscount
			continue
		}
		if f == prefix+"SubTotal" {
			patchee.SubTotal = patcher.SubTotal
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"TotalTaxAmount" {
			patchee.TotalTaxAmount = patcher.TotalTaxAmount
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"PurchaseOrders" {
			patchee.PurchaseOrders = patcher.PurchaseOrders
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvoice executes a gorm list call
func DefaultListInvoice(ctx context.Context, db *gorm.DB) ([]*Invoice, error) {
	in := Invoice{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvoiceORM{}, &Invoice{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvoiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Invoice{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvoiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvoiceORM) error
}

// DefaultCreateInvoiceLineItem executes a basic gorm create call
func DefaultCreateInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvoiceLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvoiceLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvoiceLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvoiceLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvoiceLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceLineItemSet(ctx context.Context, in []*InvoiceLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvoiceLineItemORM{})).(InvoiceLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvoiceLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvoiceLineItemORM{})).(InvoiceLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvoiceLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvoiceLineItem, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvoiceLineItem, *gorm.DB) error
}

// DefaultStrictUpdateInvoiceLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvoiceLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvoiceLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvoiceLineItem executes a basic gorm update call with patch behavior
func DefaultPatchInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvoiceLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvoiceLineItem(ctx, &InvoiceLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvoiceLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvoiceLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvoiceLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvoiceLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvoiceLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvoiceLineItem(ctx context.Context, objects []*InvoiceLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvoiceLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvoiceLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvoiceLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvoiceLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvoiceLineItem(ctx context.Context, patchee *InvoiceLineItem, patcher *InvoiceLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvoiceLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvoiceLineItem executes a gorm list call
func DefaultListInvoiceLineItem(ctx context.Context, db *gorm.DB) ([]*InvoiceLineItem, error) {
	in := InvoiceLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvoiceLineItemORM{}, &InvoiceLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvoiceLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvoiceLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvoiceLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvoiceLineItemORM) error
}

// DefaultCreateItem executes a basic gorm create call
func DefaultCreateItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteItem(ctx context.Context, in *Item, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteItemSet(ctx context.Context, in []*Item, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ItemORM{})).(ItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ItemORM{})).(ItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Item, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Item, *gorm.DB) error
}

// DefaultStrictUpdateItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchItem executes a basic gorm update call with patch behavior
func DefaultPatchItem(ctx context.Context, in *Item, updateMask *field_mask.FieldMask, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Item
	var err error
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadItem(ctx, &Item{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetItem(ctx context.Context, objects []*Item, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Item, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Item, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskItem(ctx context.Context, patchee *Item, patcher *Item, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Item, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"PurchasePrice" {
			patchee.PurchasePrice = patcher.PurchasePrice
			continue
		}
		if f == prefix+"PurchaseAccount" {
			patchee.PurchaseAccount = patcher.PurchaseAccount
			continue
		}
		if f == prefix+"SalesAccount" {
			patchee.SalesAccount = patcher.SalesAccount
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListItem executes a gorm list call
func DefaultListItem(ctx context.Context, db *gorm.DB) ([]*Item, error) {
	in := Item{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ItemORM{}, &Item{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Item{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ItemORM) error
}

// DefaultCreateJournalEntry executes a basic gorm create call
func DefaultCreateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JournalEntryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalEntryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalEntryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalEntryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalEntrySet(ctx context.Context, in []*JournalEntry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalEntryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalEntry, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalEntry, *gorm.DB) error
}

// DefaultStrictUpdateJournalEntry clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalEntry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalEntryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := JournalLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.JournalEntryId = new(uint64)
	*filterLines.JournalEntryId = ormObj.Id
	if err = db.Where(filterLines).Delete(JournalLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalEntryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJournalEntry executes a basic gorm update call with patch behavior
func DefaultPatchJournalEntry(ctx context.Context, in *JournalEntry, updateMask *field_mask.FieldMask, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj JournalEntry
	var err error
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalEntry(ctx, &JournalEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalEntry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalEntry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalEntryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalEntryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJournalEntry executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalEntry(ctx context.Context, objects []*JournalEntry, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*JournalEntry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalEntry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalEntry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalEntry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalEntry(ctx context.Context, patchee *JournalEntry, patcher *JournalEntry, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*JournalEntry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"JournalNumber" {
			patchee.JournalNumber = patcher.JournalNumber
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"PostingStatus" {
			patchee.PostingStatus = patcher.PostingStatus
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if f == prefix+"AppliedPayments" {
			patchee.AppliedPayments = patcher.AppliedPayments
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalEntry executes a gorm list call
func DefaultListJournalEntry(ctx context.Context, db *gorm.DB) ([]*JournalEntry, error) {
	in := JournalEntry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JournalEntryORM{}, &JournalEntry{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalEntryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalEntry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalEntryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JournalEntryORM) error
}

// DefaultCreateJournalLine executes a basic gorm create call
func DefaultCreateJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JournalLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalLineSet(ctx context.Context, in []*JournalLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalLineORM{})).(JournalLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalLineORM{})).(JournalLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalLine, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalLine, *gorm.DB) error
}

// DefaultStrictUpdateJournalLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJournalLine executes a basic gorm update call with patch behavior
func DefaultPatchJournalLine(ctx context.Context, in *JournalLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj JournalLine
	var err error
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalLine(ctx, &JournalLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJournalLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalLine(ctx context.Context, objects []*JournalLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*JournalLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalLine(ctx context.Context, patchee *JournalLine, patcher *JournalLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*JournalLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalLine executes a gorm list call
func DefaultListJournalLine(ctx context.Context, db *gorm.DB) ([]*JournalLine, error) {
	in := JournalLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JournalLineORM{}, &JournalLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JournalLineORM) error
}

// DefaultCreatePayment executes a basic gorm create call
func DefaultCreatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PaymentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PaymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PaymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePayment(ctx context.Context, in *Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PaymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePaymentSet(ctx context.Context, in []*Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PaymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Payment, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Payment, *gorm.DB) error
}

// DefaultStrictUpdatePayment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePayment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PaymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PaymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPayment executes a basic gorm update call with patch behavior
func DefaultPatchPayment(ctx context.Context, in *Payment, updateMask *field_mask.FieldMask, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Payment
	var err error
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPayment(ctx, &Payment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPayment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePayment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PaymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PaymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPayment executes a bulk gorm update call with patch behavior
func DefaultPatchSetPayment(ctx context.Context, objects []*Payment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Payment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Payment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPayment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPayment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPayment(ctx context.Context, patchee *Payment, patcher *Payment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Payment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPayment executes a gorm list call
func DefaultListPayment(ctx context.Context, db *gorm.DB) ([]*Payment, error) {
	in := Payment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PaymentORM{}, &Payment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PaymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Payment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentORM) error
}

// DefaultCreatePaymentLineItem executes a basic gorm create call
func DefaultCreatePaymentLineItem(ctx context.Context, in *PaymentLineItem, db *gorm.DB) (*PaymentLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPaymentLineItem(ctx context.Context, in *PaymentLineItem, db *gorm.DB) (*PaymentLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PaymentLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PaymentLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PaymentLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PaymentLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePaymentLineItem(ctx context.Context, in *PaymentLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PaymentLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PaymentLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePaymentLineItemSet(ctx context.Context, in []*PaymentLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PaymentLineItemORM{})).(PaymentLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PaymentLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PaymentLineItemORM{})).(PaymentLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PaymentLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PaymentLineItem, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PaymentLineItem, *gorm.DB) error
}

// DefaultStrictUpdatePaymentLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePaymentLineItem(ctx context.Context, in *PaymentLineItem, db *gorm.DB) (*PaymentLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePaymentLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PaymentLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PaymentLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPaymentLineItem executes a basic gorm update call with patch behavior
func DefaultPatchPaymentLineItem(ctx context.Context, in *PaymentLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*PaymentLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PaymentLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(PaymentLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPaymentLineItem(ctx, &PaymentLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PaymentLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPaymentLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PaymentLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePaymentLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PaymentLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PaymentLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PaymentLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PaymentLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PaymentLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PaymentLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPaymentLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetPaymentLineItem(ctx context.Context, objects []*PaymentLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PaymentLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PaymentLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPaymentLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPaymentLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPaymentLineItem(ctx context.Context, patchee *PaymentLineItem, patcher *PaymentLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PaymentLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAppliedDate bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppliedAmount" {
			patchee.AppliedAmount = patcher.AppliedAmount
			continue
		}
		if !updatedAppliedDate && strings.HasPrefix(f, prefix+"AppliedDate.") {
			if patcher.AppliedDate == nil {
				patchee.AppliedDate = nil
				continue
			}
			if patchee.AppliedDate == nil {
				patchee.AppliedDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AppliedDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AppliedDate, patchee.AppliedDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AppliedDate" {
			updatedAppliedDate = true
			patchee.AppliedDate = patcher.AppliedDate
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"RelatedObjectId" {
			patchee.RelatedObjectId = patcher.RelatedObjectId
			continue
		}
		if f == prefix+"RelatedObjectType" {
			patchee.RelatedObjectType = patcher.RelatedObjectType
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPaymentLineItem executes a gorm list call
func DefaultListPaymentLineItem(ctx context.Context, db *gorm.DB) ([]*PaymentLineItem, error) {
	in := PaymentLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PaymentLineItemORM{}, &PaymentLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PaymentLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PaymentLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentLineItemORM) error
}

// DefaultCreatePurchaseOrder executes a basic gorm create call
func DefaultCreatePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PurchaseOrderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseOrderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseOrderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseOrderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseOrderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderSet(ctx context.Context, in []*PurchaseOrder, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseOrderORM{})).(PurchaseOrderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseOrderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseOrderORM{})).(PurchaseOrderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseOrderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PurchaseOrder, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PurchaseOrder, *gorm.DB) error
}

// DefaultStrictUpdatePurchaseOrder clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchaseOrder")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseOrderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDeliveryAddress := CompanyAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDeliveryAddress.PurchaseOrderId = new(uint64)
	*filterDeliveryAddress.PurchaseOrderId = ormObj.Id
	if err = db.Where(filterDeliveryAddress).Delete(CompanyAddressORM{}).Error; err != nil {
		return nil, err
	}
	filterLineItems := PurchaseOrderLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.PurchaseOrderId = new(uint64)
	*filterLineItems.PurchaseOrderId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(PurchaseOrderLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPurchaseOrder executes a basic gorm update call with patch behavior
func DefaultPatchPurchaseOrder(ctx context.Context, in *PurchaseOrder, updateMask *field_mask.FieldMask, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PurchaseOrder
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchaseOrder(ctx, &PurchaseOrder{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchaseOrder(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchaseOrder(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseOrderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseOrderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPurchaseOrder executes a bulk gorm update call with patch behavior
func DefaultPatchSetPurchaseOrder(ctx context.Context, objects []*PurchaseOrder, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PurchaseOrder, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PurchaseOrder, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPurchaseOrder(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPurchaseOrder patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchaseOrder(ctx context.Context, patchee *PurchaseOrder, patcher *PurchaseOrder, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PurchaseOrder, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedIssueDate bool
	var updatedDeliveryDate bool
	var updatedDeliveryAddress bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedIssueDate && strings.HasPrefix(f, prefix+"IssueDate.") {
			if patcher.IssueDate == nil {
				patchee.IssueDate = nil
				continue
			}
			if patchee.IssueDate == nil {
				patchee.IssueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IssueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IssueDate, patchee.IssueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IssueDate" {
			updatedIssueDate = true
			patchee.IssueDate = patcher.IssueDate
			continue
		}
		if f == prefix+"PurchaseOrderNumber" {
			patchee.PurchaseOrderNumber = patcher.PurchaseOrderNumber
			continue
		}
		if !updatedDeliveryDate && strings.HasPrefix(f, prefix+"DeliveryDate.") {
			if patcher.DeliveryDate == nil {
				patchee.DeliveryDate = nil
				continue
			}
			if patchee.DeliveryDate == nil {
				patchee.DeliveryDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeliveryDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeliveryDate, patchee.DeliveryDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeliveryDate" {
			updatedDeliveryDate = true
			patchee.DeliveryDate = patcher.DeliveryDate
			continue
		}
		if !updatedDeliveryAddress && strings.HasPrefix(f, prefix+"DeliveryAddress.") {
			updatedDeliveryAddress = true
			if patcher.DeliveryAddress == nil {
				patchee.DeliveryAddress = nil
				continue
			}
			if patchee.DeliveryAddress == nil {
				patchee.DeliveryAddress = &CompanyAddress{}
			}
			if o, err := DefaultApplyFieldMaskCompanyAddress(ctx, patchee.DeliveryAddress, patcher.DeliveryAddress, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DeliveryAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.DeliveryAddress = o
			}
			continue
		}
		if f == prefix+"DeliveryAddress" {
			updatedDeliveryAddress = true
			patchee.DeliveryAddress = patcher.DeliveryAddress
			continue
		}
		if f == prefix+"Customer" {
			patchee.Customer = patcher.Customer
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchaseOrder executes a gorm list call
func DefaultListPurchaseOrder(ctx context.Context, db *gorm.DB) ([]*PurchaseOrder, error) {
	in := PurchaseOrder{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PurchaseOrderORM{}, &PurchaseOrder{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseOrderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PurchaseOrder{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseOrderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PurchaseOrderORM) error
}

// DefaultCreatePurchaseOrderLineItem executes a basic gorm create call
func DefaultCreatePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PurchaseOrderLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseOrderLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseOrderLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseOrderLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseOrderLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderLineItemSet(ctx context.Context, in []*PurchaseOrderLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseOrderLineItemORM{})).(PurchaseOrderLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseOrderLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseOrderLineItemORM{})).(PurchaseOrderLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseOrderLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PurchaseOrderLineItem, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PurchaseOrderLineItem, *gorm.DB) error
}

// DefaultStrictUpdatePurchaseOrderLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchaseOrderLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseOrderLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPurchaseOrderLineItem executes a basic gorm update call with patch behavior
func DefaultPatchPurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PurchaseOrderLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchaseOrderLineItem(ctx, &PurchaseOrderLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchaseOrderLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchaseOrderLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseOrderLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseOrderLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPurchaseOrderLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetPurchaseOrderLineItem(ctx context.Context, objects []*PurchaseOrderLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PurchaseOrderLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PurchaseOrderLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPurchaseOrderLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPurchaseOrderLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchaseOrderLineItem(ctx context.Context, patchee *PurchaseOrderLineItem, patcher *PurchaseOrderLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"TaxAmount" {
			patchee.TaxAmount = patcher.TaxAmount
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchaseOrderLineItem executes a gorm list call
func DefaultListPurchaseOrderLineItem(ctx context.Context, db *gorm.DB) ([]*PurchaseOrderLineItem, error) {
	in := PurchaseOrderLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PurchaseOrderLineItemORM{}, &PurchaseOrderLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseOrderLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PurchaseOrderLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseOrderLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PurchaseOrderLineItemORM) error
}

// DefaultCreateTaxRate executes a basic gorm create call
func DefaultCreateTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TaxRateORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TaxRateORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TaxRateORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TaxRateORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TaxRateORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TaxRateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TaxRateORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxRateSet(ctx context.Context, in []*TaxRate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TaxRateORM{})).(TaxRateORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TaxRateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TaxRateORM{})).(TaxRateORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TaxRateORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TaxRate, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TaxRate, *gorm.DB) error
}

// DefaultStrictUpdateTaxRate clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTaxRate")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TaxRateORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TaxRateORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTaxRate executes a basic gorm update call with patch behavior
func DefaultPatchTaxRate(ctx context.Context, in *TaxRate, updateMask *field_mask.FieldMask, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TaxRate
	var err error
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTaxRate(ctx, &TaxRate{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTaxRate(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTaxRate(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TaxRateWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TaxRateWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTaxRate executes a bulk gorm update call with patch behavior
func DefaultPatchSetTaxRate(ctx context.Context, objects []*TaxRate, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TaxRate, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TaxRate, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTaxRate(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTaxRate patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTaxRate(ctx context.Context, patchee *TaxRate, patcher *TaxRate, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TaxRate, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"TotalTaxRate" {
			patchee.TotalTaxRate = patcher.TotalTaxRate
			continue
		}
		if f == prefix+"EffectiveTaxRate" {
			patchee.EffectiveTaxRate = patcher.EffectiveTaxRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTaxRate executes a gorm list call
func DefaultListTaxRate(ctx context.Context, db *gorm.DB) ([]*TaxRate, error) {
	in := TaxRate{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TaxRateORM{}, &TaxRate{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TaxRateORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TaxRate{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TaxRateORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TaxRateORM) error
}

// DefaultCreateTrackingCategory executes a basic gorm create call
func DefaultCreateTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TrackingCategoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TrackingCategoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TrackingCategoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TrackingCategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TrackingCategoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTrackingCategorySet(ctx context.Context, in []*TrackingCategory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TrackingCategoryORM{})).(TrackingCategoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TrackingCategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TrackingCategoryORM{})).(TrackingCategoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TrackingCategoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TrackingCategory, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TrackingCategory, *gorm.DB) error
}

// DefaultStrictUpdateTrackingCategory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTrackingCategory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TrackingCategoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTrackingCategory executes a basic gorm update call with patch behavior
func DefaultPatchTrackingCategory(ctx context.Context, in *TrackingCategory, updateMask *field_mask.FieldMask, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TrackingCategory
	var err error
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTrackingCategory(ctx, &TrackingCategory{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTrackingCategory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTrackingCategory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TrackingCategoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TrackingCategoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTrackingCategory executes a bulk gorm update call with patch behavior
func DefaultPatchSetTrackingCategory(ctx context.Context, objects []*TrackingCategory, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TrackingCategory, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TrackingCategory, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTrackingCategory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTrackingCategory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTrackingCategory(ctx context.Context, patchee *TrackingCategory, patcher *TrackingCategory, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TrackingCategory, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if f == prefix+"CategoryType" {
			patchee.CategoryType = patcher.CategoryType
			continue
		}
		if f == prefix+"ParentCategory" {
			patchee.ParentCategory = patcher.ParentCategory
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTrackingCategory executes a gorm list call
func DefaultListTrackingCategory(ctx context.Context, db *gorm.DB) ([]*TrackingCategory, error) {
	in := TrackingCategory{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TrackingCategoryORM{}, &TrackingCategory{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TrackingCategoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TrackingCategory{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TrackingCategoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TrackingCategoryORM) error
}

// DefaultCreateBusinessTransaction executes a basic gorm create call
func DefaultCreateBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessTransactionSet(ctx context.Context, in []*BusinessTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessTransactionORM{})).(BusinessTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessTransactionORM{})).(BusinessTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessTransaction, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessTransaction, *gorm.DB) error
}

// DefaultStrictUpdateBusinessTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := TransactionLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.BusinessTransactionId = new(uint64)
	*filterLineItems.BusinessTransactionId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(TransactionLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessTransaction executes a basic gorm update call with patch behavior
func DefaultPatchBusinessTransaction(ctx context.Context, in *BusinessTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessTransaction(ctx, &BusinessTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessTransaction(ctx context.Context, objects []*BusinessTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessTransaction(ctx context.Context, patchee *BusinessTransaction, patcher *BusinessTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TransactionType" {
			patchee.TransactionType = patcher.TransactionType
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessTransaction executes a gorm list call
func DefaultListBusinessTransaction(ctx context.Context, db *gorm.DB) ([]*BusinessTransaction, error) {
	in := BusinessTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessTransactionORM{}, &BusinessTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessTransactionORM) error
}

// DefaultCreateTransactionLineItem executes a basic gorm create call
func DefaultCreateTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionLineItemSet(ctx context.Context, in []*TransactionLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionLineItemORM{})).(TransactionLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionLineItemORM{})).(TransactionLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionLineItem, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionLineItem, *gorm.DB) error
}

// DefaultStrictUpdateTransactionLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionLineItem executes a basic gorm update call with patch behavior
func DefaultPatchTransactionLineItem(ctx context.Context, in *TransactionLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionLineItem(ctx, &TransactionLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionLineItem(ctx context.Context, objects []*TransactionLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionLineItem(ctx context.Context, patchee *TransactionLineItem, patcher *TransactionLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"TaxRate" {
			patchee.TaxRate = patcher.TaxRate
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionLineItem executes a gorm list call
func DefaultListTransactionLineItem(ctx context.Context, db *gorm.DB) ([]*TransactionLineItem, error) {
	in := TransactionLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionLineItemORM{}, &TransactionLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionLineItemORM) error
}

// DefaultCreateVendorCredit executes a basic gorm create call
func DefaultCreateVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VendorCreditORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VendorCreditORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VendorCreditORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VendorCreditORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VendorCreditORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditSet(ctx context.Context, in []*VendorCredit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VendorCreditORM{})).(VendorCreditORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VendorCreditORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VendorCreditORM{})).(VendorCreditORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VendorCreditORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VendorCredit, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VendorCredit, *gorm.DB) error
}

// DefaultStrictUpdateVendorCredit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVendorCredit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VendorCreditORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := VendorCreditLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.VendorCreditId = new(uint64)
	*filterLines.VendorCreditId = ormObj.Id
	if err = db.Where(filterLines).Delete(VendorCreditLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VendorCreditORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVendorCredit executes a basic gorm update call with patch behavior
func DefaultPatchVendorCredit(ctx context.Context, in *VendorCredit, updateMask *field_mask.FieldMask, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VendorCredit
	var err error
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVendorCredit(ctx, &VendorCredit{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVendorCredit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVendorCredit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VendorCreditWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VendorCreditWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVendorCredit executes a bulk gorm update call with patch behavior
func DefaultPatchSetVendorCredit(ctx context.Context, objects []*VendorCredit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VendorCredit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VendorCredit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVendorCredit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVendorCredit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVendorCredit(ctx context.Context, patchee *VendorCredit, patcher *VendorCredit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VendorCredit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVendorCredit executes a gorm list call
func DefaultListVendorCredit(ctx context.Context, db *gorm.DB) ([]*VendorCredit, error) {
	in := VendorCredit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VendorCreditORM{}, &VendorCredit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VendorCreditORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VendorCredit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VendorCreditORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VendorCreditORM) error
}

// DefaultCreateVendorCreditLine executes a basic gorm create call
func DefaultCreateVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VendorCreditLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VendorCreditLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VendorCreditLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VendorCreditLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VendorCreditLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditLineSet(ctx context.Context, in []*VendorCreditLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VendorCreditLineORM{})).(VendorCreditLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VendorCreditLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VendorCreditLineORM{})).(VendorCreditLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VendorCreditLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VendorCreditLine, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VendorCreditLine, *gorm.DB) error
}

// DefaultStrictUpdateVendorCreditLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVendorCreditLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VendorCreditLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVendorCreditLine executes a basic gorm update call with patch behavior
func DefaultPatchVendorCreditLine(ctx context.Context, in *VendorCreditLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VendorCreditLine
	var err error
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVendorCreditLine(ctx, &VendorCreditLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVendorCreditLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVendorCreditLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VendorCreditLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VendorCreditLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVendorCreditLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetVendorCreditLine(ctx context.Context, objects []*VendorCreditLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VendorCreditLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VendorCreditLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVendorCreditLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVendorCreditLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVendorCreditLine(ctx context.Context, patchee *VendorCreditLine, patcher *VendorCreditLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VendorCreditLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVendorCreditLine executes a gorm list call
func DefaultListVendorCreditLine(ctx context.Context, db *gorm.DB) ([]*VendorCreditLine, error) {
	in := VendorCreditLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VendorCreditLineORM{}, &VendorCreditLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VendorCreditLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VendorCreditLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VendorCreditLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VendorCreditLineORM) error
}
