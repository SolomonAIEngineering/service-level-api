// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: accounting_service/v1/accounting_database_schema.proto

package accounting_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AccountingIntegrationMergeLink with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountingIntegrationMergeLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountingIntegrationMergeLink with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AccountingIntegrationMergeLinkMultiError, or nil if none found.
func (m *AccountingIntegrationMergeLink) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountingIntegrationMergeLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Integration

	// no validation rules for IntegrationSlug

	// no validation rules for Category

	// no validation rules for EndUserOriginId

	// no validation rules for EndUserOrganizationName

	// no validation rules for EndUserEmailAddress

	// no validation rules for Status

	// no validation rules for WebhookListenerUrl

	// no validation rules for IsDuplicate

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountingIntegrationMergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountingIntegrationMergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountingIntegrationMergeLinkValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IntegrationName

	// no validation rules for IntegrationImage

	// no validation rules for IntegrationSquareImage

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountingIntegrationMergeLinkValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountingIntegrationMergeLinkValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountingIntegrationMergeLinkValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeLinkedAccountId

	if all {
		switch v := interface{}(m.GetLastModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountingIntegrationMergeLinkValidationError{
					field:  "LastModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountingIntegrationMergeLinkValidationError{
					field:  "LastModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountingIntegrationMergeLinkValidationError{
				field:  "LastModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AccountingIntegrationMergeLinkMultiError(errors)
	}

	return nil
}

// AccountingIntegrationMergeLinkMultiError is an error wrapping multiple
// validation errors returned by AccountingIntegrationMergeLink.ValidateAll()
// if the designated constraints aren't met.
type AccountingIntegrationMergeLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountingIntegrationMergeLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountingIntegrationMergeLinkMultiError) AllErrors() []error { return m }

// AccountingIntegrationMergeLinkValidationError is the validation error
// returned by AccountingIntegrationMergeLink.Validate if the designated
// constraints aren't met.
type AccountingIntegrationMergeLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountingIntegrationMergeLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountingIntegrationMergeLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountingIntegrationMergeLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountingIntegrationMergeLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountingIntegrationMergeLinkValidationError) ErrorName() string {
	return "AccountingIntegrationMergeLinkValidationError"
}

// Error satisfies the builtin error interface
func (e AccountingIntegrationMergeLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountingIntegrationMergeLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountingIntegrationMergeLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountingIntegrationMergeLinkValidationError{}

// Validate checks the field values on LinkedAccountingAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LinkedAccountingAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkedAccountingAccount with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LinkedAccountingAccountMultiError, or nil if none found.
func (m *LinkedAccountingAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkedAccountingAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetAttachments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Attachments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Attachments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCompanyInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CompanyInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CompanyInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("CompanyInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPurchaseOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("PurchaseOrders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBalanceSheets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("BalanceSheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("BalanceSheets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("BalanceSheets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCashFlowStatements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("CashFlowStatements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIncomeStatements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("IncomeStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("IncomeStatements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("IncomeStatements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChartOfAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("ChartOfAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTaxRates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("TaxRates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("TaxRates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("TaxRates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetContacts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Contacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Contacts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Contacts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Invoices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPayments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Payments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Payments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Payments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Expenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Expenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetJournalEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("JournalEntries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("JournalEntries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("JournalEntries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVendorCredits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("VendorCredits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("VendorCredits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("VendorCredits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCreditNotes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CreditNotes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LinkedAccountingAccountValidationError{
						field:  fmt.Sprintf("CreditNotes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LinkedAccountingAccountValidationError{
					field:  fmt.Sprintf("CreditNotes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LinkedAccountingAccountMultiError(errors)
	}

	return nil
}

// LinkedAccountingAccountMultiError is an error wrapping multiple validation
// errors returned by LinkedAccountingAccount.ValidateAll() if the designated
// constraints aren't met.
type LinkedAccountingAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkedAccountingAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkedAccountingAccountMultiError) AllErrors() []error { return m }

// LinkedAccountingAccountValidationError is the validation error returned by
// LinkedAccountingAccount.Validate if the designated constraints aren't met.
type LinkedAccountingAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkedAccountingAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkedAccountingAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkedAccountingAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkedAccountingAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkedAccountingAccountValidationError) ErrorName() string {
	return "LinkedAccountingAccountValidationError"
}

// Error satisfies the builtin error interface
func (e LinkedAccountingAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkedAccountingAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkedAccountingAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkedAccountingAccountValidationError{}

// Validate checks the field values on BusinessChartOfAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessChartOfAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessChartOfAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessChartOfAccountMultiError, or nil if none found.
func (m *BusinessChartOfAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessChartOfAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeRecordId

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Classification

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for CurrentBalance

	// no validation rules for Currency

	// no validation rules for AccountNumber

	// no validation rules for ParentAccountId

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessChartOfAccountValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessChartOfAccountValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessChartOfAccountValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessChartOfAccountValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessChartOfAccountValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessChartOfAccountValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BusinessChartOfAccountMultiError(errors)
	}

	return nil
}

// BusinessChartOfAccountMultiError is an error wrapping multiple validation
// errors returned by BusinessChartOfAccount.ValidateAll() if the designated
// constraints aren't met.
type BusinessChartOfAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessChartOfAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessChartOfAccountMultiError) AllErrors() []error { return m }

// BusinessChartOfAccountValidationError is the validation error returned by
// BusinessChartOfAccount.Validate if the designated constraints aren't met.
type BusinessChartOfAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessChartOfAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessChartOfAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessChartOfAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessChartOfAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessChartOfAccountValidationError) ErrorName() string {
	return "BusinessChartOfAccountValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessChartOfAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessChartOfAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessChartOfAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessChartOfAccountValidationError{}

// Validate checks the field values on CompanyAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyAddressMultiError,
// or nil if none found.
func (m *CompanyAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Street_1

	// no validation rules for Street_2

	// no validation rules for City

	// no validation rules for State

	// no validation rules for CountrySubdivision

	// no validation rules for Country

	// no validation rules for ZipCode

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyAddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyAddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyAddressValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompanyAddressMultiError(errors)
	}

	return nil
}

// CompanyAddressMultiError is an error wrapping multiple validation errors
// returned by CompanyAddress.ValidateAll() if the designated constraints
// aren't met.
type CompanyAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyAddressMultiError) AllErrors() []error { return m }

// CompanyAddressValidationError is the validation error returned by
// CompanyAddress.Validate if the designated constraints aren't met.
type CompanyAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyAddressValidationError) ErrorName() string { return "CompanyAddressValidationError" }

// Error satisfies the builtin error interface
func (e CompanyAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyAddressValidationError{}

// Validate checks the field values on BalanceSheet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceSheet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceSheet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceSheetMultiError, or
// nil if none found.
func (m *BalanceSheet) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceSheet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NetAssets

	for idx, item := range m.GetAssets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Assets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetLiabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Liabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Liabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Liabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEquity() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Equity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BalanceSheetValidationError{
						field:  fmt.Sprintf("Equity[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BalanceSheetValidationError{
					field:  fmt.Sprintf("Equity[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteGeneratedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteGeneratedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "RemoteGeneratedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSheetValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSheetValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BalanceSheetMultiError(errors)
	}

	return nil
}

// BalanceSheetMultiError is an error wrapping multiple validation errors
// returned by BalanceSheet.ValidateAll() if the designated constraints aren't met.
type BalanceSheetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceSheetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceSheetMultiError) AllErrors() []error { return m }

// BalanceSheetValidationError is the validation error returned by
// BalanceSheet.Validate if the designated constraints aren't met.
type BalanceSheetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceSheetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceSheetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceSheetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceSheetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceSheetValidationError) ErrorName() string { return "BalanceSheetValidationError" }

// Error satisfies the builtin error interface
func (e BalanceSheetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceSheet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceSheetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceSheetValidationError{}

// Validate checks the field values on ReportItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportItemMultiError, or
// nil if none found.
func (m *ReportItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Value

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportItemMultiError(errors)
	}

	return nil
}

// ReportItemMultiError is an error wrapping multiple validation errors
// returned by ReportItem.ValidateAll() if the designated constraints aren't met.
type ReportItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportItemMultiError) AllErrors() []error { return m }

// ReportItemValidationError is the validation error returned by
// ReportItem.Validate if the designated constraints aren't met.
type ReportItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportItemValidationError) ErrorName() string { return "ReportItemValidationError" }

// Error satisfies the builtin error interface
func (e ReportItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportItemValidationError{}

// Validate checks the field values on CashFlowStatement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CashFlowStatement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CashFlowStatement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CashFlowStatementMultiError, or nil if none found.
func (m *CashFlowStatement) ValidateAll() error {
	return m.validate(true)
}

func (m *CashFlowStatement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetStartPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementValidationError{
				field:  "StartPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementValidationError{
				field:  "EndPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CashAtBeginningOfPeriod

	// no validation rules for CashAtEndOfPeriod

	for idx, item := range m.GetOperatingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementValidationError{
						field:  fmt.Sprintf("OperatingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementValidationError{
						field:  fmt.Sprintf("OperatingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementValidationError{
					field:  fmt.Sprintf("OperatingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInvestingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementValidationError{
						field:  fmt.Sprintf("InvestingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementValidationError{
						field:  fmt.Sprintf("InvestingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementValidationError{
					field:  fmt.Sprintf("InvestingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFinancingActivities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CashFlowStatementValidationError{
						field:  fmt.Sprintf("FinancingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CashFlowStatementValidationError{
						field:  fmt.Sprintf("FinancingActivities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CashFlowStatementValidationError{
					field:  fmt.Sprintf("FinancingActivities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteGeneratedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "RemoteGeneratedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteGeneratedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementValidationError{
				field:  "RemoteGeneratedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CashFlowStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CashFlowStatementValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return CashFlowStatementMultiError(errors)
	}

	return nil
}

// CashFlowStatementMultiError is an error wrapping multiple validation errors
// returned by CashFlowStatement.ValidateAll() if the designated constraints
// aren't met.
type CashFlowStatementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CashFlowStatementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CashFlowStatementMultiError) AllErrors() []error { return m }

// CashFlowStatementValidationError is the validation error returned by
// CashFlowStatement.Validate if the designated constraints aren't met.
type CashFlowStatementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CashFlowStatementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CashFlowStatementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CashFlowStatementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CashFlowStatementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CashFlowStatementValidationError) ErrorName() string {
	return "CashFlowStatementValidationError"
}

// Error satisfies the builtin error interface
func (e CashFlowStatementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCashFlowStatement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CashFlowStatementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CashFlowStatementValidationError{}

// Validate checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyInfoMultiError, or
// nil if none found.
func (m *CompanyInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for LegalName

	// no validation rules for TaxNumber

	// no validation rules for FiscalYearEndMonth

	// no validation rules for FiscalYearEndDay

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyInfoValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompanyInfoValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompanyInfoValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyInfoValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return CompanyInfoMultiError(errors)
	}

	return nil
}

// CompanyInfoMultiError is an error wrapping multiple validation errors
// returned by CompanyInfo.ValidateAll() if the designated constraints aren't met.
type CompanyInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyInfoMultiError) AllErrors() []error { return m }

// CompanyInfoValidationError is the validation error returned by
// CompanyInfo.Validate if the designated constraints aren't met.
type CompanyInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyInfoValidationError) ErrorName() string { return "CompanyInfoValidationError" }

// Error satisfies the builtin error interface
func (e CompanyInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyInfoValidationError{}

// Validate checks the field values on AccountingAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountingAttachment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountingAttachment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccountingAttachmentMultiError, or nil if none found.
func (m *AccountingAttachment) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountingAttachment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for FileName

	// no validation rules for FileUrl

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountingAttachmentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountingAttachmentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountingAttachmentValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountingAttachmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountingAttachmentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountingAttachmentValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AccountingAttachmentMultiError(errors)
	}

	return nil
}

// AccountingAttachmentMultiError is an error wrapping multiple validation
// errors returned by AccountingAttachment.ValidateAll() if the designated
// constraints aren't met.
type AccountingAttachmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountingAttachmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountingAttachmentMultiError) AllErrors() []error { return m }

// AccountingAttachmentValidationError is the validation error returned by
// AccountingAttachment.Validate if the designated constraints aren't met.
type AccountingAttachmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountingAttachmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountingAttachmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountingAttachmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountingAttachmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountingAttachmentValidationError) ErrorName() string {
	return "AccountingAttachmentValidationError"
}

// Error satisfies the builtin error interface
func (e AccountingAttachmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountingAttachment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountingAttachmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountingAttachmentValidationError{}

// Validate checks the field values on Contacts with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Contacts) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Contacts with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContactsMultiError, or nil
// if none found.
func (m *Contacts) ValidateAll() error {
	return m.validate(true)
}

func (m *Contacts) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for IsSupplier

	// no validation rules for IsCustomer

	// no validation rules for EmailAddress

	// no validation rules for TaxNumber

	// no validation rules for Status

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContactsValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ContactsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ContactsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return ContactsMultiError(errors)
	}

	return nil
}

// ContactsMultiError is an error wrapping multiple validation errors returned
// by Contacts.ValidateAll() if the designated constraints aren't met.
type ContactsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContactsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContactsMultiError) AllErrors() []error { return m }

// ContactsValidationError is the validation error returned by
// Contacts.Validate if the designated constraints aren't met.
type ContactsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContactsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContactsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContactsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContactsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContactsValidationError) ErrorName() string { return "ContactsValidationError" }

// Error satisfies the builtin error interface
func (e ContactsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContacts.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContactsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContactsValidationError{}

// Validate checks the field values on CreditNote with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreditNote) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditNote with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreditNoteMultiError, or
// nil if none found.
func (m *CreditNote) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditNote) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Number

	// no validation rules for Contact

	// no validation rules for Company

	// no validation rules for ExchangeRate

	// no validation rules for TotalAmount

	// no validation rules for RemainingCredit

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreditNoteValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreditNoteValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreditNoteValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreditNoteValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreditNoteValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreditNoteMultiError(errors)
	}

	return nil
}

// CreditNoteMultiError is an error wrapping multiple validation errors
// returned by CreditNote.ValidateAll() if the designated constraints aren't met.
type CreditNoteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditNoteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditNoteMultiError) AllErrors() []error { return m }

// CreditNoteValidationError is the validation error returned by
// CreditNote.Validate if the designated constraints aren't met.
type CreditNoteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditNoteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditNoteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditNoteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditNoteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditNoteValidationError) ErrorName() string { return "CreditNoteValidationError" }

// Error satisfies the builtin error interface
func (e CreditNoteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditNote.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditNoteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditNoteValidationError{}

// Validate checks the field values on CreditNoteLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreditNoteLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreditNoteLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreditNoteLineItemMultiError, or nil if none found.
func (m *CreditNoteLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CreditNoteLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Quantity

	// no validation rules for UnitPrice

	// no validation rules for TaxRate

	// no validation rules for TotalLineAmount

	// no validation rules for TrackingCategory

	// no validation rules for Account

	// no validation rules for Company

	// no validation rules for RemoteId

	// no validation rules for Item

	// no validation rules for RemoteWasDeleted

	// no validation rules for Memo

	if len(errors) > 0 {
		return CreditNoteLineItemMultiError(errors)
	}

	return nil
}

// CreditNoteLineItemMultiError is an error wrapping multiple validation errors
// returned by CreditNoteLineItem.ValidateAll() if the designated constraints
// aren't met.
type CreditNoteLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreditNoteLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreditNoteLineItemMultiError) AllErrors() []error { return m }

// CreditNoteLineItemValidationError is the validation error returned by
// CreditNoteLineItem.Validate if the designated constraints aren't met.
type CreditNoteLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreditNoteLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreditNoteLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreditNoteLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreditNoteLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreditNoteLineItemValidationError) ErrorName() string {
	return "CreditNoteLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e CreditNoteLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreditNoteLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreditNoteLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreditNoteLineItemValidationError{}

// Validate checks the field values on Expense with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Expense) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Expense with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExpenseMultiError, or nil if none found.
func (m *Expense) ValidateAll() error {
	return m.validate(true)
}

func (m *Expense) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for TotalAmount

	// no validation rules for SubTotal

	// no validation rules for TotalTaxAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	// no validation rules for Memo

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExpenseValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExpenseValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExpenseValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return ExpenseMultiError(errors)
	}

	return nil
}

// ExpenseMultiError is an error wrapping multiple validation errors returned
// by Expense.ValidateAll() if the designated constraints aren't met.
type ExpenseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseMultiError) AllErrors() []error { return m }

// ExpenseValidationError is the validation error returned by Expense.Validate
// if the designated constraints aren't met.
type ExpenseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseValidationError) ErrorName() string { return "ExpenseValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpense.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseValidationError{}

// Validate checks the field values on ExpenseLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExpenseLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExpenseLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExpenseLineMultiError, or
// nil if none found.
func (m *ExpenseLine) ValidateAll() error {
	return m.validate(true)
}

func (m *ExpenseLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Company

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for Description

	// no validation rules for ExchangeRate

	// no validation rules for RemoteId

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExpenseLineValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExpenseLineValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExpenseLineMultiError(errors)
	}

	return nil
}

// ExpenseLineMultiError is an error wrapping multiple validation errors
// returned by ExpenseLine.ValidateAll() if the designated constraints aren't met.
type ExpenseLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpenseLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpenseLineMultiError) AllErrors() []error { return m }

// ExpenseLineValidationError is the validation error returned by
// ExpenseLine.Validate if the designated constraints aren't met.
type ExpenseLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpenseLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpenseLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpenseLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpenseLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpenseLineValidationError) ErrorName() string { return "ExpenseLineValidationError" }

// Error satisfies the builtin error interface
func (e ExpenseLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpenseLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpenseLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpenseLineValidationError{}

// Validate checks the field values on IncomeStatement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IncomeStatement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IncomeStatement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IncomeStatementMultiError, or nil if none found.
func (m *IncomeStatement) ValidateAll() error {
	return m.validate(true)
}

func (m *IncomeStatement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetStartPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "StartPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "StartPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "EndPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "EndPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetIncome() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("Income[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("Income[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCostOfSales() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("CostOfSales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("CostOfSales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("CostOfSales[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for GrossProfit

	for idx, item := range m.GetOperatingExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("OperatingExpenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NetOperatingIncome

	for idx, item := range m.GetNonOperatingExpenses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IncomeStatementValidationError{
						field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IncomeStatementValidationError{
					field:  fmt.Sprintf("NonOperatingExpenses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NetIncome

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IncomeStatementValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IncomeStatementValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IncomeStatementMultiError(errors)
	}

	return nil
}

// IncomeStatementMultiError is an error wrapping multiple validation errors
// returned by IncomeStatement.ValidateAll() if the designated constraints
// aren't met.
type IncomeStatementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IncomeStatementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IncomeStatementMultiError) AllErrors() []error { return m }

// IncomeStatementValidationError is the validation error returned by
// IncomeStatement.Validate if the designated constraints aren't met.
type IncomeStatementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IncomeStatementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IncomeStatementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IncomeStatementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IncomeStatementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IncomeStatementValidationError) ErrorName() string { return "IncomeStatementValidationError" }

// Error satisfies the builtin error interface
func (e IncomeStatementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIncomeStatement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IncomeStatementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IncomeStatementValidationError{}

// Validate checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InvoiceMultiError, or nil if none found.
func (m *Invoice) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Contact

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "DueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaidOnDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidOnDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "PaidOnDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaidOnDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "PaidOnDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Memo

	// no validation rules for Company

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for TotalDiscount

	// no validation rules for SubTotal

	// no validation rules for Status

	// no validation rules for TotalTaxAmount

	// no validation rules for TotalAmount

	// no validation rules for Balance

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvoiceValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvoiceValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvoiceValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if len(errors) > 0 {
		return InvoiceMultiError(errors)
	}

	return nil
}

// InvoiceMultiError is an error wrapping multiple validation errors returned
// by Invoice.ValidateAll() if the designated constraints aren't met.
type InvoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceMultiError) AllErrors() []error { return m }

// InvoiceValidationError is the validation error returned by Invoice.Validate
// if the designated constraints aren't met.
type InvoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceValidationError) ErrorName() string { return "InvoiceValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceValidationError{}

// Validate checks the field values on InvoiceLineItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemMultiError, or nil if none found.
func (m *InvoiceLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for UnitPrice

	// no validation rules for Quantity

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for Company

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineItemMultiError(errors)
	}

	return nil
}

// InvoiceLineItemMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItem.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemMultiError) AllErrors() []error { return m }

// InvoiceLineItemValidationError is the validation error returned by
// InvoiceLineItem.Validate if the designated constraints aren't met.
type InvoiceLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemValidationError) ErrorName() string { return "InvoiceLineItemValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemValidationError{}

// Validate checks the field values on Item with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Item) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Item with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ItemMultiError, or nil if none found.
func (m *Item) ValidateAll() error {
	return m.validate(true)
}

func (m *Item) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for UnitPrice

	// no validation rules for PurchasePrice

	// no validation rules for PurchaseAccount

	// no validation rules for SalesAccount

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ItemValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ItemMultiError(errors)
	}

	return nil
}

// ItemMultiError is an error wrapping multiple validation errors returned by
// Item.ValidateAll() if the designated constraints aren't met.
type ItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItemMultiError) AllErrors() []error { return m }

// ItemValidationError is the validation error returned by Item.Validate if the
// designated constraints aren't met.
type ItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItemValidationError) ErrorName() string { return "ItemValidationError" }

// Error satisfies the builtin error interface
func (e ItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItemValidationError{}

// Validate checks the field values on JournalEntry with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JournalEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JournalEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JournalEntryMultiError, or
// nil if none found.
func (m *JournalEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *JournalEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Memo

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JournalEntryValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JournalEntryValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JournalEntryValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for JournalNumber

	// no validation rules for RemoteWasDeleted

	// no validation rules for PostingStatus

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalEntryValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalEntryValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JournalEntryMultiError(errors)
	}

	return nil
}

// JournalEntryMultiError is an error wrapping multiple validation errors
// returned by JournalEntry.ValidateAll() if the designated constraints aren't met.
type JournalEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JournalEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JournalEntryMultiError) AllErrors() []error { return m }

// JournalEntryValidationError is the validation error returned by
// JournalEntry.Validate if the designated constraints aren't met.
type JournalEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JournalEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JournalEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JournalEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JournalEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JournalEntryValidationError) ErrorName() string { return "JournalEntryValidationError" }

// Error satisfies the builtin error interface
func (e JournalEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJournalEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JournalEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JournalEntryValidationError{}

// Validate checks the field values on JournalLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JournalLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JournalLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JournalLineMultiError, or
// nil if none found.
func (m *JournalLine) ValidateAll() error {
	return m.validate(true)
}

func (m *JournalLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Account

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Contact

	// no validation rules for Company

	// no validation rules for Description

	// no validation rules for ExchangeRate

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JournalLineValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JournalLineValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JournalLineMultiError(errors)
	}

	return nil
}

// JournalLineMultiError is an error wrapping multiple validation errors
// returned by JournalLine.ValidateAll() if the designated constraints aren't met.
type JournalLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JournalLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JournalLineMultiError) AllErrors() []error { return m }

// JournalLineValidationError is the validation error returned by
// JournalLine.Validate if the designated constraints aren't met.
type JournalLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JournalLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JournalLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JournalLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JournalLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JournalLineValidationError) ErrorName() string { return "JournalLineValidationError" }

// Error satisfies the builtin error interface
func (e JournalLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJournalLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JournalLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JournalLineValidationError{}

// Validate checks the field values on Payment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PaymentMultiError, or nil if none found.
func (m *Payment) ValidateAll() error {
	return m.validate(true)
}

func (m *Payment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Contact

	// no validation rules for Account

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	// no validation rules for TotalAmount

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaymentMultiError(errors)
	}

	return nil
}

// PaymentMultiError is an error wrapping multiple validation errors returned
// by Payment.ValidateAll() if the designated constraints aren't met.
type PaymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentMultiError) AllErrors() []error { return m }

// PaymentValidationError is the validation error returned by Payment.Validate
// if the designated constraints aren't met.
type PaymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentValidationError) ErrorName() string { return "PaymentValidationError" }

// Error satisfies the builtin error interface
func (e PaymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentValidationError{}

// Validate checks the field values on PaymentLineItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PaymentLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaymentLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PaymentLineItemMultiError, or nil if none found.
func (m *PaymentLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PaymentLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppliedAmount

	if all {
		switch v := interface{}(m.GetAppliedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentLineItemValidationError{
					field:  "AppliedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentLineItemValidationError{
					field:  "AppliedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAppliedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentLineItemValidationError{
				field:  "AppliedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteId

	// no validation rules for RelatedObjectId

	// no validation rules for RelatedObjectType

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentLineItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentLineItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentLineItemValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaymentLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaymentLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaymentLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaymentLineItemMultiError(errors)
	}

	return nil
}

// PaymentLineItemMultiError is an error wrapping multiple validation errors
// returned by PaymentLineItem.ValidateAll() if the designated constraints
// aren't met.
type PaymentLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaymentLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaymentLineItemMultiError) AllErrors() []error { return m }

// PaymentLineItemValidationError is the validation error returned by
// PaymentLineItem.Validate if the designated constraints aren't met.
type PaymentLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaymentLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaymentLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaymentLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaymentLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaymentLineItemValidationError) ErrorName() string { return "PaymentLineItemValidationError" }

// Error satisfies the builtin error interface
func (e PaymentLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaymentLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaymentLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaymentLineItemValidationError{}

// Validate checks the field values on PurchaseOrder with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PurchaseOrder) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PurchaseOrder with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PurchaseOrderMultiError, or
// nil if none found.
func (m *PurchaseOrder) ValidateAll() error {
	return m.validate(true)
}

func (m *PurchaseOrder) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MergeRecordId

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PurchaseOrderNumber

	if all {
		switch v := interface{}(m.GetDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "DeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeliveryAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "DeliveryAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Customer

	// no validation rules for Vendor

	// no validation rules for Memo

	// no validation rules for Company

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PurchaseOrderValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PurchaseOrderValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PurchaseOrderValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "RemoteUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "RemoteUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PurchaseOrderMultiError(errors)
	}

	return nil
}

// PurchaseOrderMultiError is an error wrapping multiple validation errors
// returned by PurchaseOrder.ValidateAll() if the designated constraints
// aren't met.
type PurchaseOrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PurchaseOrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PurchaseOrderMultiError) AllErrors() []error { return m }

// PurchaseOrderValidationError is the validation error returned by
// PurchaseOrder.Validate if the designated constraints aren't met.
type PurchaseOrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PurchaseOrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PurchaseOrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PurchaseOrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PurchaseOrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PurchaseOrderValidationError) ErrorName() string { return "PurchaseOrderValidationError" }

// Error satisfies the builtin error interface
func (e PurchaseOrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPurchaseOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PurchaseOrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PurchaseOrderValidationError{}

// Validate checks the field values on PurchaseOrderLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PurchaseOrderLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PurchaseOrderLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PurchaseOrderLineItemMultiError, or nil if none found.
func (m *PurchaseOrderLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PurchaseOrderLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for Quantity

	// no validation rules for UnitPrice

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for TaxAmount

	// no validation rules for TotalLineAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PurchaseOrderLineItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PurchaseOrderLineItemValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if len(errors) > 0 {
		return PurchaseOrderLineItemMultiError(errors)
	}

	return nil
}

// PurchaseOrderLineItemMultiError is an error wrapping multiple validation
// errors returned by PurchaseOrderLineItem.ValidateAll() if the designated
// constraints aren't met.
type PurchaseOrderLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PurchaseOrderLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PurchaseOrderLineItemMultiError) AllErrors() []error { return m }

// PurchaseOrderLineItemValidationError is the validation error returned by
// PurchaseOrderLineItem.Validate if the designated constraints aren't met.
type PurchaseOrderLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PurchaseOrderLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PurchaseOrderLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PurchaseOrderLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PurchaseOrderLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PurchaseOrderLineItemValidationError) ErrorName() string {
	return "PurchaseOrderLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e PurchaseOrderLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPurchaseOrderLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PurchaseOrderLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PurchaseOrderLineItemValidationError{}

// Validate checks the field values on TaxRate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaxRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaxRate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaxRateMultiError, or nil if none found.
func (m *TaxRate) ValidateAll() error {
	return m.validate(true)
}

func (m *TaxRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Description

	// no validation rules for TotalTaxRate

	// no validation rules for EffectiveTaxRate

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxRateValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeRecordId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxRateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxRateValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaxRateMultiError(errors)
	}

	return nil
}

// TaxRateMultiError is an error wrapping multiple validation errors returned
// by TaxRate.ValidateAll() if the designated constraints aren't met.
type TaxRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxRateMultiError) AllErrors() []error { return m }

// TaxRateValidationError is the validation error returned by TaxRate.Validate
// if the designated constraints aren't met.
type TaxRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxRateValidationError) ErrorName() string { return "TaxRateValidationError" }

// Error satisfies the builtin error interface
func (e TaxRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaxRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxRateValidationError{}

// Validate checks the field values on TrackingCategory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TrackingCategory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackingCategory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TrackingCategoryMultiError, or nil if none found.
func (m *TrackingCategory) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackingCategory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for MergeRecordId

	// no validation rules for CategoryType

	// no validation rules for ParentCategory

	// no validation rules for Company

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackingCategoryValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackingCategoryValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackingCategoryValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackingCategoryMultiError(errors)
	}

	return nil
}

// TrackingCategoryMultiError is an error wrapping multiple validation errors
// returned by TrackingCategory.ValidateAll() if the designated constraints
// aren't met.
type TrackingCategoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackingCategoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackingCategoryMultiError) AllErrors() []error { return m }

// TrackingCategoryValidationError is the validation error returned by
// TrackingCategory.Validate if the designated constraints aren't met.
type TrackingCategoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackingCategoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackingCategoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackingCategoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackingCategoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackingCategoryValidationError) ErrorName() string { return "TrackingCategoryValidationError" }

// Error satisfies the builtin error interface
func (e TrackingCategoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackingCategory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackingCategoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackingCategoryValidationError{}

// Validate checks the field values on BusinessTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BusinessTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BusinessTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BusinessTransactionMultiError, or nil if none found.
func (m *BusinessTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *BusinessTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TransactionType

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Account

	// no validation rules for Contact

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BusinessTransactionValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BusinessTransactionValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BusinessTransactionValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	// no validation rules for MergeRecordId

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BusinessTransactionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BusinessTransactionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BusinessTransactionMultiError(errors)
	}

	return nil
}

// BusinessTransactionMultiError is an error wrapping multiple validation
// errors returned by BusinessTransaction.ValidateAll() if the designated
// constraints aren't met.
type BusinessTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BusinessTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BusinessTransactionMultiError) AllErrors() []error { return m }

// BusinessTransactionValidationError is the validation error returned by
// BusinessTransaction.Validate if the designated constraints aren't met.
type BusinessTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BusinessTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BusinessTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BusinessTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BusinessTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BusinessTransactionValidationError) ErrorName() string {
	return "BusinessTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e BusinessTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBusinessTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BusinessTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BusinessTransactionValidationError{}

// Validate checks the field values on TransactionLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionLineItemMultiError, or nil if none found.
func (m *TransactionLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Memo

	// no validation rules for UnitPrice

	// no validation rules for Quantity

	// no validation rules for Item

	// no validation rules for Account

	// no validation rules for TrackingCategory

	// no validation rules for TotalLineAmount

	// no validation rules for TaxRate

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionLineItemValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionLineItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionLineItemValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionLineItemMultiError(errors)
	}

	return nil
}

// TransactionLineItemMultiError is an error wrapping multiple validation
// errors returned by TransactionLineItem.ValidateAll() if the designated
// constraints aren't met.
type TransactionLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionLineItemMultiError) AllErrors() []error { return m }

// TransactionLineItemValidationError is the validation error returned by
// TransactionLineItem.Validate if the designated constraints aren't met.
type TransactionLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionLineItemValidationError) ErrorName() string {
	return "TransactionLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionLineItemValidationError{}

// Validate checks the field values on VendorCredit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *VendorCredit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorCredit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VendorCreditMultiError, or
// nil if none found.
func (m *VendorCredit) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorCredit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MergeRecordId

	// no validation rules for RemoteId

	// no validation rules for Number

	if all {
		switch v := interface{}(m.GetTransactionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "TransactionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditValidationError{
				field:  "TransactionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Vendor

	// no validation rules for TotalAmount

	// no validation rules for Currency

	// no validation rules for ExchangeRate

	// no validation rules for Company

	for idx, item := range m.GetLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VendorCreditValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VendorCreditValidationError{
						field:  fmt.Sprintf("Lines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VendorCreditValidationError{
					field:  fmt.Sprintf("Lines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	// no validation rules for AccountingPeriod

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorCreditMultiError(errors)
	}

	return nil
}

// VendorCreditMultiError is an error wrapping multiple validation errors
// returned by VendorCredit.ValidateAll() if the designated constraints aren't met.
type VendorCreditMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorCreditMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorCreditMultiError) AllErrors() []error { return m }

// VendorCreditValidationError is the validation error returned by
// VendorCredit.Validate if the designated constraints aren't met.
type VendorCreditValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorCreditValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorCreditValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorCreditValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorCreditValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorCreditValidationError) ErrorName() string { return "VendorCreditValidationError" }

// Error satisfies the builtin error interface
func (e VendorCreditValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorCredit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorCreditValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorCreditValidationError{}

// Validate checks the field values on VendorCreditLine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *VendorCreditLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VendorCreditLine with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VendorCreditLineMultiError, or nil if none found.
func (m *VendorCreditLine) ValidateAll() error {
	return m.validate(true)
}

func (m *VendorCreditLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RemoteId

	// no validation rules for NetAmount

	// no validation rules for TrackingCategory

	// no validation rules for Description

	// no validation rules for Account

	// no validation rules for Company

	// no validation rules for ExchangeRate

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VendorCreditLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VendorCreditLineValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VendorCreditLineValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return VendorCreditLineMultiError(errors)
	}

	return nil
}

// VendorCreditLineMultiError is an error wrapping multiple validation errors
// returned by VendorCreditLine.ValidateAll() if the designated constraints
// aren't met.
type VendorCreditLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VendorCreditLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VendorCreditLineMultiError) AllErrors() []error { return m }

// VendorCreditLineValidationError is the validation error returned by
// VendorCreditLine.Validate if the designated constraints aren't met.
type VendorCreditLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VendorCreditLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VendorCreditLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VendorCreditLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VendorCreditLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VendorCreditLineValidationError) ErrorName() string { return "VendorCreditLineValidationError" }

// Error satisfies the builtin error interface
func (e VendorCreditLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVendorCreditLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VendorCreditLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VendorCreditLineValidationError{}
