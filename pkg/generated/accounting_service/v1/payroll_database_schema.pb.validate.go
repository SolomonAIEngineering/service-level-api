// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: accounting_service/v1/payroll_database_schema.proto

package accounting_servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on HrisIntegrationMergeLink with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HrisIntegrationMergeLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HrisIntegrationMergeLink with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HrisIntegrationMergeLinkMultiError, or nil if none found.
func (m *HrisIntegrationMergeLink) ValidateAll() error {
	return m.validate(true)
}

func (m *HrisIntegrationMergeLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Integration

	// no validation rules for IntegrationSlug

	// no validation rules for Category

	// no validation rules for EndUserOriginId

	// no validation rules for EndUserOrganizationName

	// no validation rules for EndUserEmailAddress

	// no validation rules for Status

	// no validation rules for WebhookListenerUrl

	// no validation rules for IsDuplicate

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HrisIntegrationMergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HrisIntegrationMergeLinkValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HrisIntegrationMergeLinkValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IntegrationName

	// no validation rules for IntegrationImage

	// no validation rules for IntegrationSquareImage

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HrisIntegrationMergeLinkValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HrisIntegrationMergeLinkValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HrisIntegrationMergeLinkValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeLinkedAccountId

	if all {
		switch v := interface{}(m.GetLastModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HrisIntegrationMergeLinkValidationError{
					field:  "LastModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HrisIntegrationMergeLinkValidationError{
					field:  "LastModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HrisIntegrationMergeLinkValidationError{
				field:  "LastModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HrisIntegrationMergeLinkMultiError(errors)
	}

	return nil
}

// HrisIntegrationMergeLinkMultiError is an error wrapping multiple validation
// errors returned by HrisIntegrationMergeLink.ValidateAll() if the designated
// constraints aren't met.
type HrisIntegrationMergeLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HrisIntegrationMergeLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HrisIntegrationMergeLinkMultiError) AllErrors() []error { return m }

// HrisIntegrationMergeLinkValidationError is the validation error returned by
// HrisIntegrationMergeLink.Validate if the designated constraints aren't met.
type HrisIntegrationMergeLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HrisIntegrationMergeLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HrisIntegrationMergeLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HrisIntegrationMergeLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HrisIntegrationMergeLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HrisIntegrationMergeLinkValidationError) ErrorName() string {
	return "HrisIntegrationMergeLinkValidationError"
}

// Error satisfies the builtin error interface
func (e HrisIntegrationMergeLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHrisIntegrationMergeLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HrisIntegrationMergeLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HrisIntegrationMergeLinkValidationError{}

// Validate checks the field values on HrisLinkedAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HrisLinkedAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HrisLinkedAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HrisLinkedAccountMultiError, or nil if none found.
func (m *HrisLinkedAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *HrisLinkedAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HrisLinkedAccountValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HrisLinkedAccountValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HrisLinkedAccountValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBenefitPlans() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HrisLinkedAccountValidationError{
						field:  fmt.Sprintf("BenefitPlans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HrisLinkedAccountValidationError{
						field:  fmt.Sprintf("BenefitPlans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HrisLinkedAccountValidationError{
					field:  fmt.Sprintf("BenefitPlans[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEmployees() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HrisLinkedAccountValidationError{
						field:  fmt.Sprintf("Employees[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HrisLinkedAccountValidationError{
						field:  fmt.Sprintf("Employees[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HrisLinkedAccountValidationError{
					field:  fmt.Sprintf("Employees[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPayrollRuns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HrisLinkedAccountValidationError{
						field:  fmt.Sprintf("PayrollRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HrisLinkedAccountValidationError{
						field:  fmt.Sprintf("PayrollRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HrisLinkedAccountValidationError{
					field:  fmt.Sprintf("PayrollRuns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HrisLinkedAccountMultiError(errors)
	}

	return nil
}

// HrisLinkedAccountMultiError is an error wrapping multiple validation errors
// returned by HrisLinkedAccount.ValidateAll() if the designated constraints
// aren't met.
type HrisLinkedAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HrisLinkedAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HrisLinkedAccountMultiError) AllErrors() []error { return m }

// HrisLinkedAccountValidationError is the validation error returned by
// HrisLinkedAccount.Validate if the designated constraints aren't met.
type HrisLinkedAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HrisLinkedAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HrisLinkedAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HrisLinkedAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HrisLinkedAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HrisLinkedAccountValidationError) ErrorName() string {
	return "HrisLinkedAccountValidationError"
}

// Error satisfies the builtin error interface
func (e HrisLinkedAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHrisLinkedAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HrisLinkedAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HrisLinkedAccountValidationError{}

// Validate checks the field values on CompanyProfile with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CompanyProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompanyProfile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CompanyProfileMultiError,
// or nil if none found.
func (m *CompanyProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *CompanyProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for LegalName

	// no validation rules for DisplayName

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyProfileValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyProfileValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyProfileValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompanyProfileValidationError{
					field:  "LastUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompanyProfileValidationError{
					field:  "LastUpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompanyProfileValidationError{
				field:  "LastUpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return CompanyProfileMultiError(errors)
	}

	return nil
}

// CompanyProfileMultiError is an error wrapping multiple validation errors
// returned by CompanyProfile.ValidateAll() if the designated constraints
// aren't met.
type CompanyProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompanyProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompanyProfileMultiError) AllErrors() []error { return m }

// CompanyProfileValidationError is the validation error returned by
// CompanyProfile.Validate if the designated constraints aren't met.
type CompanyProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompanyProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompanyProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompanyProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompanyProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompanyProfileValidationError) ErrorName() string { return "CompanyProfileValidationError" }

// Error satisfies the builtin error interface
func (e CompanyProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompanyProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompanyProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompanyProfileValidationError{}

// Validate checks the field values on EmployerBenefits with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmployerBenefits) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmployerBenefits with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmployerBenefitsMultiError, or nil if none found.
func (m *EmployerBenefits) ValidateAll() error {
	return m.validate(true)
}

func (m *EmployerBenefits) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for BenefitPlanType

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for DeductionCode

	if all {
		switch v := interface{}(m.GetRemoteWasDeleted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerBenefitsValidationError{
					field:  "RemoteWasDeleted",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerBenefitsValidationError{
					field:  "RemoteWasDeleted",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteWasDeleted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerBenefitsValidationError{
				field:  "RemoteWasDeleted",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerBenefitsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerBenefitsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerBenefitsValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerBenefitsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerBenefitsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerBenefitsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	for idx, item := range m.GetEmployeeBenefits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployerBenefitsValidationError{
						field:  fmt.Sprintf("EmployeeBenefits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployerBenefitsValidationError{
						field:  fmt.Sprintf("EmployeeBenefits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployerBenefitsValidationError{
					field:  fmt.Sprintf("EmployeeBenefits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EmployerBenefitsMultiError(errors)
	}

	return nil
}

// EmployerBenefitsMultiError is an error wrapping multiple validation errors
// returned by EmployerBenefits.ValidateAll() if the designated constraints
// aren't met.
type EmployerBenefitsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployerBenefitsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployerBenefitsMultiError) AllErrors() []error { return m }

// EmployerBenefitsValidationError is the validation error returned by
// EmployerBenefits.Validate if the designated constraints aren't met.
type EmployerBenefitsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployerBenefitsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployerBenefitsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployerBenefitsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployerBenefitsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployerBenefitsValidationError) ErrorName() string { return "EmployerBenefitsValidationError" }

// Error satisfies the builtin error interface
func (e EmployerBenefitsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployerBenefits.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployerBenefitsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployerBenefitsValidationError{}

// Validate checks the field values on Employee with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Employee) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Employee with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmployeeMultiError, or nil
// if none found.
func (m *Employee) ValidateAll() error {
	return m.validate(true)
}

func (m *Employee) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for EmployeeNumber

	// no validation rules for CompanyId

	// no validation rules for FirstName

	// no validation rules for LastName

	// no validation rules for EmployeesPreferredName

	// no validation rules for DisplayFullName

	// no validation rules for EmployeeUserNameAsSeenInRemoteUi

	// no validation rules for WorkEmail

	// no validation rules for PersonalEmail

	// no validation rules for MobilePhoneNumber

	for idx, item := range m.GetEmployments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("Employments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("Employments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeeValidationError{
					field:  fmt.Sprintf("Employments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for EmploymentType

	if all {
		switch v := interface{}(m.GetHomeLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "HomeLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "HomeLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHomeLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "HomeLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWorkLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "WorkLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "WorkLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWorkLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "WorkLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetManager()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "Manager",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "Manager",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetManager()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "Manager",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Ssn

	// no validation rules for Gender

	// no validation rules for Ethnicity

	// no validation rules for MaritalStatus

	// no validation rules for DateOfBirth

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRemoteCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "RemoteCreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRemoteCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "RemoteCreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EmploymentStatus

	if all {
		switch v := interface{}(m.GetTerminationDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "TerminationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "TerminationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTerminationDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "TerminationDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Avatar

	for idx, item := range m.GetBankAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("BankAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeeValidationError{
					field:  fmt.Sprintf("BankAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDependents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("Dependents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("Dependents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeeValidationError{
					field:  fmt.Sprintf("Dependents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPayrollRuns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("PayrollRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("PayrollRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeeValidationError{
					field:  fmt.Sprintf("PayrollRuns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPayTimeOffBalance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "PayTimeOffBalance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "PayTimeOffBalance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayTimeOffBalance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "PayTimeOffBalance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBenefits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("Benefits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeeValidationError{
						field:  fmt.Sprintf("Benefits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeeValidationError{
					field:  fmt.Sprintf("Benefits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MergeAccountId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if len(errors) > 0 {
		return EmployeeMultiError(errors)
	}

	return nil
}

// EmployeeMultiError is an error wrapping multiple validation errors returned
// by Employee.ValidateAll() if the designated constraints aren't met.
type EmployeeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployeeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployeeMultiError) AllErrors() []error { return m }

// EmployeeValidationError is the validation error returned by
// Employee.Validate if the designated constraints aren't met.
type EmployeeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployeeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployeeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployeeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployeeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployeeValidationError) ErrorName() string { return "EmployeeValidationError" }

// Error satisfies the builtin error interface
func (e EmployeeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployee.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployeeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployeeValidationError{}

// Validate checks the field values on EmployeeBenefits with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EmployeeBenefits) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmployeeBenefits with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmployeeBenefitsMultiError, or nil if none found.
func (m *EmployeeBenefits) ValidateAll() error {
	return m.validate(true)
}

func (m *EmployeeBenefits) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for ProviderName

	// no validation rules for EmployeeMergeAccountId

	// no validation rules for BenefitPlanMergeAccountId

	// no validation rules for EmployeeContribution

	// no validation rules for CompanyContribution

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeBenefitsValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeBenefitsValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeBenefitsValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeBenefitsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeBenefitsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return EmployeeBenefitsMultiError(errors)
	}

	return nil
}

// EmployeeBenefitsMultiError is an error wrapping multiple validation errors
// returned by EmployeeBenefits.ValidateAll() if the designated constraints
// aren't met.
type EmployeeBenefitsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployeeBenefitsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployeeBenefitsMultiError) AllErrors() []error { return m }

// EmployeeBenefitsValidationError is the validation error returned by
// EmployeeBenefits.Validate if the designated constraints aren't met.
type EmployeeBenefitsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployeeBenefitsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployeeBenefitsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployeeBenefitsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployeeBenefitsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployeeBenefitsValidationError) ErrorName() string { return "EmployeeBenefitsValidationError" }

// Error satisfies the builtin error interface
func (e EmployeeBenefitsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployeeBenefits.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployeeBenefitsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployeeBenefitsValidationError{}

// Validate checks the field values on EmployerPayrollRun with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmployerPayrollRun) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmployerPayrollRun with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmployerPayrollRunMultiError, or nil if none found.
func (m *EmployerPayrollRun) ValidateAll() error {
	return m.validate(true)
}

func (m *EmployerPayrollRun) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for RunState

	// no validation rules for RunType

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerPayrollRunValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerPayrollRunValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCheckDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "CheckDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "CheckDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerPayrollRunValidationError{
				field:  "CheckDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerPayrollRunValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployerPayrollRunValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployerPayrollRunValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPayrollRuns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployerPayrollRunValidationError{
						field:  fmt.Sprintf("PayrollRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployerPayrollRunValidationError{
						field:  fmt.Sprintf("PayrollRuns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployerPayrollRunValidationError{
					field:  fmt.Sprintf("PayrollRuns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EmployerPayrollRunMultiError(errors)
	}

	return nil
}

// EmployerPayrollRunMultiError is an error wrapping multiple validation errors
// returned by EmployerPayrollRun.ValidateAll() if the designated constraints
// aren't met.
type EmployerPayrollRunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployerPayrollRunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployerPayrollRunMultiError) AllErrors() []error { return m }

// EmployerPayrollRunValidationError is the validation error returned by
// EmployerPayrollRun.Validate if the designated constraints aren't met.
type EmployerPayrollRunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployerPayrollRunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployerPayrollRunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployerPayrollRunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployerPayrollRunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployerPayrollRunValidationError) ErrorName() string {
	return "EmployerPayrollRunValidationError"
}

// Error satisfies the builtin error interface
func (e EmployerPayrollRunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployerPayrollRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployerPayrollRunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployerPayrollRunValidationError{}

// Validate checks the field values on EmployeeJobPositionAtCompany with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmployeeJobPositionAtCompany) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmployeeJobPositionAtCompany with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmployeeJobPositionAtCompanyMultiError, or nil if none found.
func (m *EmployeeJobPositionAtCompany) ValidateAll() error {
	return m.validate(true)
}

func (m *EmployeeJobPositionAtCompany) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for JobTitle

	// no validation rules for PayRate

	// no validation rules for PayPeriod

	// no validation rules for PayFrequency

	// no validation rules for PayCurrency

	// no validation rules for FlsaStatus

	if all {
		switch v := interface{}(m.GetEffectiveDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeJobPositionAtCompanyValidationError{
					field:  "EffectiveDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeJobPositionAtCompanyValidationError{
					field:  "EffectiveDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEffectiveDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeJobPositionAtCompanyValidationError{
				field:  "EffectiveDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeJobPositionAtCompanyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeJobPositionAtCompanyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeJobPositionAtCompanyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeeJobPositionAtCompanyValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeeJobPositionAtCompanyValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeeJobPositionAtCompanyValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return EmployeeJobPositionAtCompanyMultiError(errors)
	}

	return nil
}

// EmployeeJobPositionAtCompanyMultiError is an error wrapping multiple
// validation errors returned by EmployeeJobPositionAtCompany.ValidateAll() if
// the designated constraints aren't met.
type EmployeeJobPositionAtCompanyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployeeJobPositionAtCompanyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployeeJobPositionAtCompanyMultiError) AllErrors() []error { return m }

// EmployeeJobPositionAtCompanyValidationError is the validation error returned
// by EmployeeJobPositionAtCompany.Validate if the designated constraints
// aren't met.
type EmployeeJobPositionAtCompanyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployeeJobPositionAtCompanyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployeeJobPositionAtCompanyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployeeJobPositionAtCompanyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployeeJobPositionAtCompanyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployeeJobPositionAtCompanyValidationError) ErrorName() string {
	return "EmployeeJobPositionAtCompanyValidationError"
}

// Error satisfies the builtin error interface
func (e EmployeeJobPositionAtCompanyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployeeJobPositionAtCompany.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployeeJobPositionAtCompanyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployeeJobPositionAtCompanyValidationError{}

// Validate checks the field values on Group with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Group) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Group with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GroupMultiError, or nil if none found.
func (m *Group) ValidateAll() error {
	return m.validate(true)
}

func (m *Group) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for ParentGroupMergeAccountId

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GroupValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GroupValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GroupValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return GroupMultiError(errors)
	}

	return nil
}

// GroupMultiError is an error wrapping multiple validation errors returned by
// Group.ValidateAll() if the designated constraints aren't met.
type GroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMultiError) AllErrors() []error { return m }

// GroupValidationError is the validation error returned by Group.Validate if
// the designated constraints aren't met.
type GroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupValidationError) ErrorName() string { return "GroupValidationError" }

// Error satisfies the builtin error interface
func (e GroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupValidationError{}

// Validate checks the field values on LocationAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LocationAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocationAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LocationAddressMultiError, or nil if none found.
func (m *LocationAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *LocationAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for PhoneNumber

	// no validation rules for Street_1

	// no validation rules for Street_2

	// no validation rules for City

	// no validation rules for State

	// no validation rules for ZipCode

	// no validation rules for Country

	// no validation rules for LocationType

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocationAddressValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocationAddressValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocationAddressValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LocationAddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LocationAddressValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LocationAddressValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return LocationAddressMultiError(errors)
	}

	return nil
}

// LocationAddressMultiError is an error wrapping multiple validation errors
// returned by LocationAddress.ValidateAll() if the designated constraints
// aren't met.
type LocationAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocationAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocationAddressMultiError) AllErrors() []error { return m }

// LocationAddressValidationError is the validation error returned by
// LocationAddress.Validate if the designated constraints aren't met.
type LocationAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocationAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocationAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocationAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocationAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocationAddressValidationError) ErrorName() string { return "LocationAddressValidationError" }

// Error satisfies the builtin error interface
func (e LocationAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocationAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocationAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocationAddressValidationError{}

// Validate checks the field values on BankInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BankInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BankInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BankInfoMultiError, or nil
// if none found.
func (m *BankInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BankInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for AccountNumber

	// no validation rules for RoutingNumber

	// no validation rules for BankName

	// no validation rules for AccountType

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BankInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BankInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BankInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BankInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BankInfoValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BankInfoValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BankInfoMultiError(errors)
	}

	return nil
}

// BankInfoMultiError is an error wrapping multiple validation errors returned
// by BankInfo.ValidateAll() if the designated constraints aren't met.
type BankInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BankInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BankInfoMultiError) AllErrors() []error { return m }

// BankInfoValidationError is the validation error returned by
// BankInfo.Validate if the designated constraints aren't met.
type BankInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BankInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BankInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BankInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BankInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BankInfoValidationError) ErrorName() string { return "BankInfoValidationError" }

// Error satisfies the builtin error interface
func (e BankInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBankInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BankInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BankInfoValidationError{}

// Validate checks the field values on Dependents with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Dependents) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dependents with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DependentsMultiError, or
// nil if none found.
func (m *Dependents) ValidateAll() error {
	return m.validate(true)
}

func (m *Dependents) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for FirstName

	// no validation rules for LastName

	// no validation rules for MiddleName

	// no validation rules for DependentRelationshipToEmployee

	if all {
		switch v := interface{}(m.GetDateOfBirth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "DateOfBirth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "DateOfBirth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDateOfBirth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependentsValidationError{
				field:  "DateOfBirth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Gender

	// no validation rules for PhoneNumber

	if all {
		switch v := interface{}(m.GetHomeLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "HomeLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "HomeLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHomeLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependentsValidationError{
				field:  "HomeLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsStudent

	// no validation rules for Ssn

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependentsValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependentsValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependentsValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return DependentsMultiError(errors)
	}

	return nil
}

// DependentsMultiError is an error wrapping multiple validation errors
// returned by Dependents.ValidateAll() if the designated constraints aren't met.
type DependentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependentsMultiError) AllErrors() []error { return m }

// DependentsValidationError is the validation error returned by
// Dependents.Validate if the designated constraints aren't met.
type DependentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependentsValidationError) ErrorName() string { return "DependentsValidationError" }

// Error satisfies the builtin error interface
func (e DependentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependents.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependentsValidationError{}

// Validate checks the field values on EmployeePayrollRun with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmployeePayrollRun) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmployeePayrollRun with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmployeePayrollRunMultiError, or nil if none found.
func (m *EmployeePayrollRun) ValidateAll() error {
	return m.validate(true)
}

func (m *EmployeePayrollRun) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for GrossPay

	// no validation rules for NetPay

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeePayrollRunValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeePayrollRunValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCheckDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "CheckDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "CheckDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeePayrollRunValidationError{
				field:  "CheckDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetEarnings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeePayrollRunValidationError{
						field:  fmt.Sprintf("Earnings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeePayrollRunValidationError{
						field:  fmt.Sprintf("Earnings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeePayrollRunValidationError{
					field:  fmt.Sprintf("Earnings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeductions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeePayrollRunValidationError{
						field:  fmt.Sprintf("Deductions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeePayrollRunValidationError{
						field:  fmt.Sprintf("Deductions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeePayrollRunValidationError{
					field:  fmt.Sprintf("Deductions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTaxes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmployeePayrollRunValidationError{
						field:  fmt.Sprintf("Taxes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmployeePayrollRunValidationError{
						field:  fmt.Sprintf("Taxes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmployeePayrollRunValidationError{
					field:  fmt.Sprintf("Taxes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeePayrollRunValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeePayrollRunValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeePayrollRunValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PayrollRunMergeAccountId

	// no validation rules for EmployeeMergeAccountId

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return EmployeePayrollRunMultiError(errors)
	}

	return nil
}

// EmployeePayrollRunMultiError is an error wrapping multiple validation errors
// returned by EmployeePayrollRun.ValidateAll() if the designated constraints
// aren't met.
type EmployeePayrollRunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployeePayrollRunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployeePayrollRunMultiError) AllErrors() []error { return m }

// EmployeePayrollRunValidationError is the validation error returned by
// EmployeePayrollRun.Validate if the designated constraints aren't met.
type EmployeePayrollRunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployeePayrollRunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployeePayrollRunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployeePayrollRunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployeePayrollRunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployeePayrollRunValidationError) ErrorName() string {
	return "EmployeePayrollRunValidationError"
}

// Error satisfies the builtin error interface
func (e EmployeePayrollRunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployeePayrollRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployeePayrollRunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployeePayrollRunValidationError{}

// Validate checks the field values on Earning with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Earning) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Earning with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EarningMultiError, or nil if none found.
func (m *Earning) ValidateAll() error {
	return m.validate(true)
}

func (m *Earning) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Amount

	// no validation rules for Type

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EarningValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EarningValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EarningValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EarningValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EarningValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EarningValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PayrollRunMergeAccountId

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return EarningMultiError(errors)
	}

	return nil
}

// EarningMultiError is an error wrapping multiple validation errors returned
// by Earning.ValidateAll() if the designated constraints aren't met.
type EarningMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EarningMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EarningMultiError) AllErrors() []error { return m }

// EarningValidationError is the validation error returned by Earning.Validate
// if the designated constraints aren't met.
type EarningValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EarningValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EarningValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EarningValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EarningValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EarningValidationError) ErrorName() string { return "EarningValidationError" }

// Error satisfies the builtin error interface
func (e EarningValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEarning.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EarningValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EarningValidationError{}

// Validate checks the field values on Deduction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Deduction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Deduction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeductionMultiError, or nil
// if none found.
func (m *Deduction) ValidateAll() error {
	return m.validate(true)
}

func (m *Deduction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for EmployeeDeduction

	// no validation rules for CompanyDeduction

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeductionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeductionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeductionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeductionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeductionValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeductionValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PayrollRunMergeAccountId

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return DeductionMultiError(errors)
	}

	return nil
}

// DeductionMultiError is an error wrapping multiple validation errors returned
// by Deduction.ValidateAll() if the designated constraints aren't met.
type DeductionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeductionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeductionMultiError) AllErrors() []error { return m }

// DeductionValidationError is the validation error returned by
// Deduction.Validate if the designated constraints aren't met.
type DeductionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeductionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeductionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeductionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeductionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeductionValidationError) ErrorName() string { return "DeductionValidationError" }

// Error satisfies the builtin error interface
func (e DeductionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeduction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeductionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeductionValidationError{}

// Validate checks the field values on Tax with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Tax) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tax with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaxMultiError, or nil if none found.
func (m *Tax) ValidateAll() error {
	return m.validate(true)
}

func (m *Tax) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Name

	// no validation rules for Amount

	// no validation rules for EmployerTax

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaxValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaxValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaxValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PayrollRunMergeAccountId

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return TaxMultiError(errors)
	}

	return nil
}

// TaxMultiError is an error wrapping multiple validation errors returned by
// Tax.ValidateAll() if the designated constraints aren't met.
type TaxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaxMultiError) AllErrors() []error { return m }

// TaxValidationError is the validation error returned by Tax.Validate if the
// designated constraints aren't met.
type TaxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaxValidationError) ErrorName() string { return "TaxValidationError" }

// Error satisfies the builtin error interface
func (e TaxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTax.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaxValidationError{}

// Validate checks the field values on EmployeTimeOffBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmployeTimeOffBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmployeTimeOffBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmployeTimeOffBalanceMultiError, or nil if none found.
func (m *EmployeTimeOffBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *EmployeTimeOffBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	// no validation rules for Balance

	// no validation rules for Used

	// no validation rules for PolicyType

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeTimeOffBalanceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeTimeOffBalanceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeTimeOffBalanceValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EmployeTimeOffBalanceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EmployeTimeOffBalanceValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EmployeTimeOffBalanceValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	if len(errors) > 0 {
		return EmployeTimeOffBalanceMultiError(errors)
	}

	return nil
}

// EmployeTimeOffBalanceMultiError is an error wrapping multiple validation
// errors returned by EmployeTimeOffBalance.ValidateAll() if the designated
// constraints aren't met.
type EmployeTimeOffBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmployeTimeOffBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmployeTimeOffBalanceMultiError) AllErrors() []error { return m }

// EmployeTimeOffBalanceValidationError is the validation error returned by
// EmployeTimeOffBalance.Validate if the designated constraints aren't met.
type EmployeTimeOffBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmployeTimeOffBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmployeTimeOffBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmployeTimeOffBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmployeTimeOffBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmployeTimeOffBalanceValidationError) ErrorName() string {
	return "EmployeTimeOffBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e EmployeTimeOffBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmployeTimeOffBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmployeTimeOffBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmployeTimeOffBalanceValidationError{}

// Validate checks the field values on TimeOff with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeOff) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeOff with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TimeOffMultiError, or nil if none found.
func (m *TimeOff) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeOff) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RemoteId

	if all {
		switch v := interface{}(m.GetEmployee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "Employee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "Employee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmployee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeOffValidationError{
				field:  "Employee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetApprover()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "Approver",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "Approver",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApprover()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeOffValidationError{
				field:  "Approver",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for EmploymentNote

	// no validation rules for Units

	// no validation rules for Amount

	// no validation rules for RequestType

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeOffValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeOffValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoteWasDeleted

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeOffValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModifiedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeOffValidationError{
					field:  "ModifiedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModifiedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeOffValidationError{
				field:  "ModifiedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MergeAccountId

	// no validation rules for EmployeeMergeAccountId

	// no validation rules for ApproverMergeAccountId

	if len(errors) > 0 {
		return TimeOffMultiError(errors)
	}

	return nil
}

// TimeOffMultiError is an error wrapping multiple validation errors returned
// by TimeOff.ValidateAll() if the designated constraints aren't met.
type TimeOffMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeOffMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeOffMultiError) AllErrors() []error { return m }

// TimeOffValidationError is the validation error returned by TimeOff.Validate
// if the designated constraints aren't met.
type TimeOffValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeOffValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeOffValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeOffValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeOffValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeOffValidationError) ErrorName() string { return "TimeOffValidationError" }

// Error satisfies the builtin error interface
func (e TimeOffValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeOff.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeOffValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeOffValidationError{}
