package accounting_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type BusinessAccountingProfileORM struct {
	AccountingIntegrationMergeLink []*AccountingIntegrationMergeLinkORM `gorm:"foreignkey:BusinessAccountingProfileId;association_foreignkey:Id"`
	ActionablePersonalInsights     []*BusinessActionableInsightORM      `gorm:"foreignkey:BusinessAccountingProfileId;association_foreignkey:Id;preload:true"`
	CompanyName                    string
	Email                          string
	Id                             uint64
	UserId                         uint64
}

// TableName overrides the default tablename generated by GORM
func (BusinessAccountingProfileORM) TableName() string {
	return "business_accounting_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessAccountingProfile) ToORM(ctx context.Context) (BusinessAccountingProfileORM, error) {
	to := BusinessAccountingProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountingProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.CompanyName = m.CompanyName
	to.Email = m.Email
	for _, v := range m.AccountingIntegrationMergeLink {
		if v != nil {
			if tempAccountingIntegrationMergeLink, cErr := v.ToORM(ctx); cErr == nil {
				to.AccountingIntegrationMergeLink = append(to.AccountingIntegrationMergeLink, &tempAccountingIntegrationMergeLink)
			} else {
				return to, cErr
			}
		} else {
			to.AccountingIntegrationMergeLink = append(to.AccountingIntegrationMergeLink, nil)
		}
	}
	for _, v := range m.ActionablePersonalInsights {
		if v != nil {
			if tempActionablePersonalInsights, cErr := v.ToORM(ctx); cErr == nil {
				to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, &tempActionablePersonalInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, nil)
		}
	}
	if posthook, ok := interface{}(m).(BusinessAccountingProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessAccountingProfileORM) ToPB(ctx context.Context) (BusinessAccountingProfile, error) {
	to := BusinessAccountingProfile{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountingProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	to.CompanyName = m.CompanyName
	to.Email = m.Email
	for _, v := range m.AccountingIntegrationMergeLink {
		if v != nil {
			if tempAccountingIntegrationMergeLink, cErr := v.ToPB(ctx); cErr == nil {
				to.AccountingIntegrationMergeLink = append(to.AccountingIntegrationMergeLink, &tempAccountingIntegrationMergeLink)
			} else {
				return to, cErr
			}
		} else {
			to.AccountingIntegrationMergeLink = append(to.AccountingIntegrationMergeLink, nil)
		}
	}
	for _, v := range m.ActionablePersonalInsights {
		if v != nil {
			if tempActionablePersonalInsights, cErr := v.ToPB(ctx); cErr == nil {
				to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, &tempActionablePersonalInsights)
			} else {
				return to, cErr
			}
		} else {
			to.ActionablePersonalInsights = append(to.ActionablePersonalInsights, nil)
		}
	}
	if posthook, ok := interface{}(m).(BusinessAccountingProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessAccountingProfile the arg will be the target, the caller the one being converted from

// BusinessAccountingProfileBeforeToORM called before default ToORM code
type BusinessAccountingProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessAccountingProfileORM) error
}

// BusinessAccountingProfileAfterToORM called after default ToORM code
type BusinessAccountingProfileWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessAccountingProfileORM) error
}

// BusinessAccountingProfileBeforeToPB called before default ToPB code
type BusinessAccountingProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessAccountingProfile) error
}

// BusinessAccountingProfileAfterToPB called after default ToPB code
type BusinessAccountingProfileWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessAccountingProfile) error
}

type BusinessActionableInsightORM struct {
	Action                      string
	BusinessAccountingProfileId *uint64
	Description                 string
	ExpectedBenefit             string
	GeneratedTime               *time.Time
	Id                          uint64
	InsightName                 string
	MetricsToOptimizeFor        pq.StringArray `gorm:"type:text[]"`
	Tags                        pq.StringArray `gorm:"type:text[]"`
	Takeaway                    string
}

// TableName overrides the default tablename generated by GORM
func (BusinessActionableInsightORM) TableName() string {
	return "business_actionable_insights"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessActionableInsight) ToORM(ctx context.Context) (BusinessActionableInsightORM, error) {
	to := BusinessActionableInsightORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessActionableInsightWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightName = BusinessActionableInsightName_name[int32(m.InsightName)]
	to.Description = m.Description
	to.Takeaway = m.Takeaway
	to.Action = m.Action
	to.ExpectedBenefit = m.ExpectedBenefit
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.GeneratedTime != nil {
		t := m.GeneratedTime.AsTime()
		to.GeneratedTime = &t
	}
	if m.MetricsToOptimizeFor != nil {
		to.MetricsToOptimizeFor = make(pq.StringArray, len(m.MetricsToOptimizeFor))
		copy(to.MetricsToOptimizeFor, m.MetricsToOptimizeFor)
	}
	if posthook, ok := interface{}(m).(BusinessActionableInsightWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessActionableInsightORM) ToPB(ctx context.Context) (BusinessActionableInsight, error) {
	to := BusinessActionableInsight{}
	var err error
	if prehook, ok := interface{}(m).(BusinessActionableInsightWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightName = BusinessActionableInsightName(BusinessActionableInsightName_value[m.InsightName])
	to.Description = m.Description
	to.Takeaway = m.Takeaway
	to.Action = m.Action
	to.ExpectedBenefit = m.ExpectedBenefit
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	if m.GeneratedTime != nil {
		to.GeneratedTime = timestamppb.New(*m.GeneratedTime)
	}
	if m.MetricsToOptimizeFor != nil {
		to.MetricsToOptimizeFor = make(pq.StringArray, len(m.MetricsToOptimizeFor))
		copy(to.MetricsToOptimizeFor, m.MetricsToOptimizeFor)
	}
	if posthook, ok := interface{}(m).(BusinessActionableInsightWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessActionableInsight the arg will be the target, the caller the one being converted from

// BusinessActionableInsightBeforeToORM called before default ToORM code
type BusinessActionableInsightWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessActionableInsightORM) error
}

// BusinessActionableInsightAfterToORM called after default ToORM code
type BusinessActionableInsightWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessActionableInsightORM) error
}

// BusinessActionableInsightBeforeToPB called before default ToPB code
type BusinessActionableInsightWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessActionableInsight) error
}

// BusinessActionableInsightAfterToPB called after default ToPB code
type BusinessActionableInsightWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessActionableInsight) error
}

type MergeLinkedAccountTokenORM struct {
	AccessToken                      string
	AccountingIntegrationMergeLinkId *uint64
	Id                               uint64
	ItemId                           string
	KeyId                            string
	MergeEndUserOriginId             string
	MergeIntegrationSlug             string
	Version                          string
}

// TableName overrides the default tablename generated by GORM
func (MergeLinkedAccountTokenORM) TableName() string {
	return "merge_linked_account_tokens"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MergeLinkedAccountToken) ToORM(ctx context.Context) (MergeLinkedAccountTokenORM, error) {
	to := MergeLinkedAccountTokenORM{}
	var err error
	if prehook, ok := interface{}(m).(MergeLinkedAccountTokenWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ItemId = m.ItemId
	to.KeyId = m.KeyId
	to.AccessToken = m.AccessToken
	to.Version = m.Version
	to.MergeEndUserOriginId = m.MergeEndUserOriginId
	to.MergeIntegrationSlug = m.MergeIntegrationSlug
	if posthook, ok := interface{}(m).(MergeLinkedAccountTokenWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MergeLinkedAccountTokenORM) ToPB(ctx context.Context) (MergeLinkedAccountToken, error) {
	to := MergeLinkedAccountToken{}
	var err error
	if prehook, ok := interface{}(m).(MergeLinkedAccountTokenWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ItemId = m.ItemId
	to.KeyId = m.KeyId
	to.AccessToken = m.AccessToken
	to.Version = m.Version
	to.MergeEndUserOriginId = m.MergeEndUserOriginId
	to.MergeIntegrationSlug = m.MergeIntegrationSlug
	if posthook, ok := interface{}(m).(MergeLinkedAccountTokenWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MergeLinkedAccountToken the arg will be the target, the caller the one being converted from

// MergeLinkedAccountTokenBeforeToORM called before default ToORM code
type MergeLinkedAccountTokenWithBeforeToORM interface {
	BeforeToORM(context.Context, *MergeLinkedAccountTokenORM) error
}

// MergeLinkedAccountTokenAfterToORM called after default ToORM code
type MergeLinkedAccountTokenWithAfterToORM interface {
	AfterToORM(context.Context, *MergeLinkedAccountTokenORM) error
}

// MergeLinkedAccountTokenBeforeToPB called before default ToPB code
type MergeLinkedAccountTokenWithBeforeToPB interface {
	BeforeToPB(context.Context, *MergeLinkedAccountToken) error
}

// MergeLinkedAccountTokenAfterToPB called after default ToPB code
type MergeLinkedAccountTokenWithAfterToPB interface {
	AfterToPB(context.Context, *MergeLinkedAccountToken) error
}

type CategoryORM struct {
	Description   string
	Id            uint64
	Name          string
	Subcategories pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (CategoryORM) TableName() string {
	return "categories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Category) ToORM(ctx context.Context) (CategoryORM, error) {
	to := CategoryORM{}
	var err error
	if prehook, ok := interface{}(m).(CategoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if m.Subcategories != nil {
		to.Subcategories = make(pq.StringArray, len(m.Subcategories))
		copy(to.Subcategories, m.Subcategories)
	}
	if posthook, ok := interface{}(m).(CategoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CategoryORM) ToPB(ctx context.Context) (Category, error) {
	to := Category{}
	var err error
	if prehook, ok := interface{}(m).(CategoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if m.Subcategories != nil {
		to.Subcategories = make(pq.StringArray, len(m.Subcategories))
		copy(to.Subcategories, m.Subcategories)
	}
	if posthook, ok := interface{}(m).(CategoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Category the arg will be the target, the caller the one being converted from

// CategoryBeforeToORM called before default ToORM code
type CategoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *CategoryORM) error
}

// CategoryAfterToORM called after default ToORM code
type CategoryWithAfterToORM interface {
	AfterToORM(context.Context, *CategoryORM) error
}

// CategoryBeforeToPB called before default ToPB code
type CategoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *Category) error
}

// CategoryAfterToPB called after default ToPB code
type CategoryWithAfterToPB interface {
	AfterToPB(context.Context, *Category) error
}

type AccountingIntegrationMergeLinkORM struct {
	Account                     *LinkedAccountingAccountORM `gorm:"foreignkey:AccountingIntegrationMergeLinkId;association_foreignkey:Id;preload:true"`
	BusinessAccountingProfileId *uint64
	Category                    string
	EndUserEmailAddress         string
	EndUserOrganizationName     string
	EndUserOriginId             string
	Id                          uint64
	Integration                 string
	IntegrationImage            string
	IntegrationName             string
	IntegrationSlug             string
	IntegrationSquareImage      string
	IsDuplicate                 bool
	LastModifiedAt              *time.Time
	MergeLinkedAccountId        string
	Status                      string
	Token                       *MergeLinkedAccountTokenORM `gorm:"foreignkey:AccountingIntegrationMergeLinkId;association_foreignkey:Id;preload:true"`
	WebhookListenerUrl          string
}

// TableName overrides the default tablename generated by GORM
func (AccountingIntegrationMergeLinkORM) TableName() string {
	return "accounting_integration_merge_links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountingIntegrationMergeLink) ToORM(ctx context.Context) (AccountingIntegrationMergeLinkORM, error) {
	to := AccountingIntegrationMergeLinkORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	if m.Account != nil {
		tempAccount, err := m.Account.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if m.LastModifiedAt != nil {
		t := m.LastModifiedAt.AsTime()
		to.LastModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountingIntegrationMergeLinkORM) ToPB(ctx context.Context) (AccountingIntegrationMergeLink, error) {
	to := AccountingIntegrationMergeLink{}
	var err error
	if prehook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	if m.Account != nil {
		tempAccount, err := m.Account.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if m.LastModifiedAt != nil {
		to.LastModifiedAt = timestamppb.New(*m.LastModifiedAt)
	}
	if posthook, ok := interface{}(m).(AccountingIntegrationMergeLinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountingIntegrationMergeLink the arg will be the target, the caller the one being converted from

// AccountingIntegrationMergeLinkBeforeToORM called before default ToORM code
type AccountingIntegrationMergeLinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountingIntegrationMergeLinkORM) error
}

// AccountingIntegrationMergeLinkAfterToORM called after default ToORM code
type AccountingIntegrationMergeLinkWithAfterToORM interface {
	AfterToORM(context.Context, *AccountingIntegrationMergeLinkORM) error
}

// AccountingIntegrationMergeLinkBeforeToPB called before default ToPB code
type AccountingIntegrationMergeLinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountingIntegrationMergeLink) error
}

// AccountingIntegrationMergeLinkAfterToPB called after default ToPB code
type AccountingIntegrationMergeLinkWithAfterToPB interface {
	AfterToPB(context.Context, *AccountingIntegrationMergeLink) error
}

type LinkedAccountingAccountORM struct {
	AccountingIntegrationMergeLinkId *uint64
	Attachments                      []*AttachmentsORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	CompanyInfo                      []*CompanyInfoORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	Id                               uint64
	PurchaseOrders                   []*PurchaseOrderORM    `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	ReferenceDetails                 *ReferenceDetailsORM   `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	ReportDetails                    *ReportDetailsORM      `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
	TransactionsDetails              *TransactionDetailsORM `gorm:"foreignkey:LinkedAccountingAccountId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (LinkedAccountingAccountORM) TableName() string {
	return "linked_accounting_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LinkedAccountingAccount) ToORM(ctx context.Context) (LinkedAccountingAccountORM, error) {
	to := LinkedAccountingAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(LinkedAccountingAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Attachments {
		if v != nil {
			if tempAttachments, cErr := v.ToORM(ctx); cErr == nil {
				to.Attachments = append(to.Attachments, &tempAttachments)
			} else {
				return to, cErr
			}
		} else {
			to.Attachments = append(to.Attachments, nil)
		}
	}
	for _, v := range m.CompanyInfo {
		if v != nil {
			if tempCompanyInfo, cErr := v.ToORM(ctx); cErr == nil {
				to.CompanyInfo = append(to.CompanyInfo, &tempCompanyInfo)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyInfo = append(to.CompanyInfo, nil)
		}
	}
	for _, v := range m.PurchaseOrders {
		if v != nil {
			if tempPurchaseOrders, cErr := v.ToORM(ctx); cErr == nil {
				to.PurchaseOrders = append(to.PurchaseOrders, &tempPurchaseOrders)
			} else {
				return to, cErr
			}
		} else {
			to.PurchaseOrders = append(to.PurchaseOrders, nil)
		}
	}
	if m.ReportDetails != nil {
		tempReportDetails, err := m.ReportDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ReportDetails = &tempReportDetails
	}
	if m.ReferenceDetails != nil {
		tempReferenceDetails, err := m.ReferenceDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ReferenceDetails = &tempReferenceDetails
	}
	if m.TransactionsDetails != nil {
		tempTransactionsDetails, err := m.TransactionsDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TransactionsDetails = &tempTransactionsDetails
	}
	if posthook, ok := interface{}(m).(LinkedAccountingAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LinkedAccountingAccountORM) ToPB(ctx context.Context) (LinkedAccountingAccount, error) {
	to := LinkedAccountingAccount{}
	var err error
	if prehook, ok := interface{}(m).(LinkedAccountingAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Attachments {
		if v != nil {
			if tempAttachments, cErr := v.ToPB(ctx); cErr == nil {
				to.Attachments = append(to.Attachments, &tempAttachments)
			} else {
				return to, cErr
			}
		} else {
			to.Attachments = append(to.Attachments, nil)
		}
	}
	for _, v := range m.CompanyInfo {
		if v != nil {
			if tempCompanyInfo, cErr := v.ToPB(ctx); cErr == nil {
				to.CompanyInfo = append(to.CompanyInfo, &tempCompanyInfo)
			} else {
				return to, cErr
			}
		} else {
			to.CompanyInfo = append(to.CompanyInfo, nil)
		}
	}
	for _, v := range m.PurchaseOrders {
		if v != nil {
			if tempPurchaseOrders, cErr := v.ToPB(ctx); cErr == nil {
				to.PurchaseOrders = append(to.PurchaseOrders, &tempPurchaseOrders)
			} else {
				return to, cErr
			}
		} else {
			to.PurchaseOrders = append(to.PurchaseOrders, nil)
		}
	}
	if m.ReportDetails != nil {
		tempReportDetails, err := m.ReportDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ReportDetails = &tempReportDetails
	}
	if m.ReferenceDetails != nil {
		tempReferenceDetails, err := m.ReferenceDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ReferenceDetails = &tempReferenceDetails
	}
	if m.TransactionsDetails != nil {
		tempTransactionsDetails, err := m.TransactionsDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TransactionsDetails = &tempTransactionsDetails
	}
	if posthook, ok := interface{}(m).(LinkedAccountingAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LinkedAccountingAccount the arg will be the target, the caller the one being converted from

// LinkedAccountingAccountBeforeToORM called before default ToORM code
type LinkedAccountingAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *LinkedAccountingAccountORM) error
}

// LinkedAccountingAccountAfterToORM called after default ToORM code
type LinkedAccountingAccountWithAfterToORM interface {
	AfterToORM(context.Context, *LinkedAccountingAccountORM) error
}

// LinkedAccountingAccountBeforeToPB called before default ToPB code
type LinkedAccountingAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *LinkedAccountingAccount) error
}

// LinkedAccountingAccountAfterToPB called after default ToPB code
type LinkedAccountingAccountWithAfterToPB interface {
	AfterToPB(context.Context, *LinkedAccountingAccount) error
}

type TransactionDetailsORM struct {
	CreditNotes               []*CreditNoteORM `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	Expenses                  []*ExpenseORM    `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	Id                        uint64
	Invoices                  []*InvoiceORM      `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	JournalEntries            []*JournalEntryORM `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
	Payments                  []*PaymentORM             `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	Transactions              []*BusinessTransactionORM `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
	VendorCredits             []*VendorCreditORM        `gorm:"foreignkey:TransactionDetailsId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (TransactionDetailsORM) TableName() string {
	return "transaction_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionDetails) ToORM(ctx context.Context) (TransactionDetailsORM, error) {
	to := TransactionDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Invoices {
		if v != nil {
			if tempInvoices, cErr := v.ToORM(ctx); cErr == nil {
				to.Invoices = append(to.Invoices, &tempInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.Invoices = append(to.Invoices, nil)
		}
	}
	for _, v := range m.Payments {
		if v != nil {
			if tempPayments, cErr := v.ToORM(ctx); cErr == nil {
				to.Payments = append(to.Payments, &tempPayments)
			} else {
				return to, cErr
			}
		} else {
			to.Payments = append(to.Payments, nil)
		}
	}
	for _, v := range m.Expenses {
		if v != nil {
			if tempExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.Expenses = append(to.Expenses, &tempExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.Expenses = append(to.Expenses, nil)
		}
	}
	for _, v := range m.JournalEntries {
		if v != nil {
			if tempJournalEntries, cErr := v.ToORM(ctx); cErr == nil {
				to.JournalEntries = append(to.JournalEntries, &tempJournalEntries)
			} else {
				return to, cErr
			}
		} else {
			to.JournalEntries = append(to.JournalEntries, nil)
		}
	}
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToORM(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.VendorCredits {
		if v != nil {
			if tempVendorCredits, cErr := v.ToORM(ctx); cErr == nil {
				to.VendorCredits = append(to.VendorCredits, &tempVendorCredits)
			} else {
				return to, cErr
			}
		} else {
			to.VendorCredits = append(to.VendorCredits, nil)
		}
	}
	for _, v := range m.CreditNotes {
		if v != nil {
			if tempCreditNotes, cErr := v.ToORM(ctx); cErr == nil {
				to.CreditNotes = append(to.CreditNotes, &tempCreditNotes)
			} else {
				return to, cErr
			}
		} else {
			to.CreditNotes = append(to.CreditNotes, nil)
		}
	}
	if posthook, ok := interface{}(m).(TransactionDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionDetailsORM) ToPB(ctx context.Context) (TransactionDetails, error) {
	to := TransactionDetails{}
	var err error
	if prehook, ok := interface{}(m).(TransactionDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Invoices {
		if v != nil {
			if tempInvoices, cErr := v.ToPB(ctx); cErr == nil {
				to.Invoices = append(to.Invoices, &tempInvoices)
			} else {
				return to, cErr
			}
		} else {
			to.Invoices = append(to.Invoices, nil)
		}
	}
	for _, v := range m.Payments {
		if v != nil {
			if tempPayments, cErr := v.ToPB(ctx); cErr == nil {
				to.Payments = append(to.Payments, &tempPayments)
			} else {
				return to, cErr
			}
		} else {
			to.Payments = append(to.Payments, nil)
		}
	}
	for _, v := range m.Expenses {
		if v != nil {
			if tempExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.Expenses = append(to.Expenses, &tempExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.Expenses = append(to.Expenses, nil)
		}
	}
	for _, v := range m.JournalEntries {
		if v != nil {
			if tempJournalEntries, cErr := v.ToPB(ctx); cErr == nil {
				to.JournalEntries = append(to.JournalEntries, &tempJournalEntries)
			} else {
				return to, cErr
			}
		} else {
			to.JournalEntries = append(to.JournalEntries, nil)
		}
	}
	for _, v := range m.Transactions {
		if v != nil {
			if tempTransactions, cErr := v.ToPB(ctx); cErr == nil {
				to.Transactions = append(to.Transactions, &tempTransactions)
			} else {
				return to, cErr
			}
		} else {
			to.Transactions = append(to.Transactions, nil)
		}
	}
	for _, v := range m.VendorCredits {
		if v != nil {
			if tempVendorCredits, cErr := v.ToPB(ctx); cErr == nil {
				to.VendorCredits = append(to.VendorCredits, &tempVendorCredits)
			} else {
				return to, cErr
			}
		} else {
			to.VendorCredits = append(to.VendorCredits, nil)
		}
	}
	for _, v := range m.CreditNotes {
		if v != nil {
			if tempCreditNotes, cErr := v.ToPB(ctx); cErr == nil {
				to.CreditNotes = append(to.CreditNotes, &tempCreditNotes)
			} else {
				return to, cErr
			}
		} else {
			to.CreditNotes = append(to.CreditNotes, nil)
		}
	}
	if posthook, ok := interface{}(m).(TransactionDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionDetails the arg will be the target, the caller the one being converted from

// TransactionDetailsBeforeToORM called before default ToORM code
type TransactionDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionDetailsORM) error
}

// TransactionDetailsAfterToORM called after default ToORM code
type TransactionDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionDetailsORM) error
}

// TransactionDetailsBeforeToPB called before default ToPB code
type TransactionDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionDetails) error
}

// TransactionDetailsAfterToPB called after default ToPB code
type TransactionDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionDetails) error
}

type ReferenceDetailsORM struct {
	ChartOfAccounts           []*BusinessChartOfAccountsORM `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
	Contacts                  []*ContactsORM                `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
	Id                        uint64
	Items                     []*ItemORM `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
	TaxRates                  []*TaxRateORM `gorm:"foreignkey:ReferenceDetailsId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (ReferenceDetailsORM) TableName() string {
	return "reference_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReferenceDetails) ToORM(ctx context.Context) (ReferenceDetailsORM, error) {
	to := ReferenceDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(ReferenceDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.ChartOfAccounts {
		if v != nil {
			if tempChartOfAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.ChartOfAccounts = append(to.ChartOfAccounts, &tempChartOfAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.ChartOfAccounts = append(to.ChartOfAccounts, nil)
		}
	}
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToORM(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	for _, v := range m.TaxRates {
		if v != nil {
			if tempTaxRates, cErr := v.ToORM(ctx); cErr == nil {
				to.TaxRates = append(to.TaxRates, &tempTaxRates)
			} else {
				return to, cErr
			}
		} else {
			to.TaxRates = append(to.TaxRates, nil)
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToORM(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReferenceDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReferenceDetailsORM) ToPB(ctx context.Context) (ReferenceDetails, error) {
	to := ReferenceDetails{}
	var err error
	if prehook, ok := interface{}(m).(ReferenceDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.ChartOfAccounts {
		if v != nil {
			if tempChartOfAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.ChartOfAccounts = append(to.ChartOfAccounts, &tempChartOfAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.ChartOfAccounts = append(to.ChartOfAccounts, nil)
		}
	}
	for _, v := range m.Items {
		if v != nil {
			if tempItems, cErr := v.ToPB(ctx); cErr == nil {
				to.Items = append(to.Items, &tempItems)
			} else {
				return to, cErr
			}
		} else {
			to.Items = append(to.Items, nil)
		}
	}
	for _, v := range m.TaxRates {
		if v != nil {
			if tempTaxRates, cErr := v.ToPB(ctx); cErr == nil {
				to.TaxRates = append(to.TaxRates, &tempTaxRates)
			} else {
				return to, cErr
			}
		} else {
			to.TaxRates = append(to.TaxRates, nil)
		}
	}
	for _, v := range m.Contacts {
		if v != nil {
			if tempContacts, cErr := v.ToPB(ctx); cErr == nil {
				to.Contacts = append(to.Contacts, &tempContacts)
			} else {
				return to, cErr
			}
		} else {
			to.Contacts = append(to.Contacts, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReferenceDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReferenceDetails the arg will be the target, the caller the one being converted from

// ReferenceDetailsBeforeToORM called before default ToORM code
type ReferenceDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReferenceDetailsORM) error
}

// ReferenceDetailsAfterToORM called after default ToORM code
type ReferenceDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *ReferenceDetailsORM) error
}

// ReferenceDetailsBeforeToPB called before default ToPB code
type ReferenceDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReferenceDetails) error
}

// ReferenceDetailsAfterToPB called after default ToPB code
type ReferenceDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *ReferenceDetails) error
}

type ReportDetailsORM struct {
	BalanceSheets             []*BalanceSheetORM       `gorm:"foreignkey:ReportDetailsId;association_foreignkey:Id;preload:true"`
	CashFlowStatements        []*CashFlowStatementsORM `gorm:"foreignkey:ReportDetailsId;association_foreignkey:Id;preload:true"`
	Id                        uint64
	IncomeStatements          []*IncomeStatementORM `gorm:"foreignkey:ReportDetailsId;association_foreignkey:Id;preload:true"`
	LinkedAccountingAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (ReportDetailsORM) TableName() string {
	return "report_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReportDetails) ToORM(ctx context.Context) (ReportDetailsORM, error) {
	to := ReportDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(ReportDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.BalanceSheets {
		if v != nil {
			if tempBalanceSheets, cErr := v.ToORM(ctx); cErr == nil {
				to.BalanceSheets = append(to.BalanceSheets, &tempBalanceSheets)
			} else {
				return to, cErr
			}
		} else {
			to.BalanceSheets = append(to.BalanceSheets, nil)
		}
	}
	for _, v := range m.CashFlowStatements {
		if v != nil {
			if tempCashFlowStatements, cErr := v.ToORM(ctx); cErr == nil {
				to.CashFlowStatements = append(to.CashFlowStatements, &tempCashFlowStatements)
			} else {
				return to, cErr
			}
		} else {
			to.CashFlowStatements = append(to.CashFlowStatements, nil)
		}
	}
	for _, v := range m.IncomeStatements {
		if v != nil {
			if tempIncomeStatements, cErr := v.ToORM(ctx); cErr == nil {
				to.IncomeStatements = append(to.IncomeStatements, &tempIncomeStatements)
			} else {
				return to, cErr
			}
		} else {
			to.IncomeStatements = append(to.IncomeStatements, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReportDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReportDetailsORM) ToPB(ctx context.Context) (ReportDetails, error) {
	to := ReportDetails{}
	var err error
	if prehook, ok := interface{}(m).(ReportDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.BalanceSheets {
		if v != nil {
			if tempBalanceSheets, cErr := v.ToPB(ctx); cErr == nil {
				to.BalanceSheets = append(to.BalanceSheets, &tempBalanceSheets)
			} else {
				return to, cErr
			}
		} else {
			to.BalanceSheets = append(to.BalanceSheets, nil)
		}
	}
	for _, v := range m.CashFlowStatements {
		if v != nil {
			if tempCashFlowStatements, cErr := v.ToPB(ctx); cErr == nil {
				to.CashFlowStatements = append(to.CashFlowStatements, &tempCashFlowStatements)
			} else {
				return to, cErr
			}
		} else {
			to.CashFlowStatements = append(to.CashFlowStatements, nil)
		}
	}
	for _, v := range m.IncomeStatements {
		if v != nil {
			if tempIncomeStatements, cErr := v.ToPB(ctx); cErr == nil {
				to.IncomeStatements = append(to.IncomeStatements, &tempIncomeStatements)
			} else {
				return to, cErr
			}
		} else {
			to.IncomeStatements = append(to.IncomeStatements, nil)
		}
	}
	if posthook, ok := interface{}(m).(ReportDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReportDetails the arg will be the target, the caller the one being converted from

// ReportDetailsBeforeToORM called before default ToORM code
type ReportDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReportDetailsORM) error
}

// ReportDetailsAfterToORM called after default ToORM code
type ReportDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *ReportDetailsORM) error
}

// ReportDetailsBeforeToPB called before default ToPB code
type ReportDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReportDetails) error
}

// ReportDetailsAfterToPB called after default ToPB code
type ReportDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *ReportDetails) error
}

type BusinessChartOfAccountsORM struct {
	AccountNumber      string
	Classification     string
	Company            string
	Currency           string
	CurrentBalance     float64
	Description        string
	Id                 uint64
	MergeAccountId     string
	ModifiedAt         *time.Time
	Name               string
	ParentAccountId    string
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteWasDeleted   bool
	Status             string
	Type               string
}

// TableName overrides the default tablename generated by GORM
func (BusinessChartOfAccountsORM) TableName() string {
	return "business_chart_of_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessChartOfAccounts) ToORM(ctx context.Context) (BusinessChartOfAccountsORM, error) {
	to := BusinessChartOfAccountsORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessChartOfAccountsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Description = m.Description
	to.Classification = m.Classification
	to.Type = m.Type
	to.Status = m.Status
	to.CurrentBalance = m.CurrentBalance
	to.Currency = m.Currency
	to.AccountNumber = m.AccountNumber
	to.ParentAccountId = m.ParentAccountId
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(BusinessChartOfAccountsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessChartOfAccountsORM) ToPB(ctx context.Context) (BusinessChartOfAccounts, error) {
	to := BusinessChartOfAccounts{}
	var err error
	if prehook, ok := interface{}(m).(BusinessChartOfAccountsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Description = m.Description
	to.Classification = m.Classification
	to.Type = m.Type
	to.Status = m.Status
	to.CurrentBalance = m.CurrentBalance
	to.Currency = m.Currency
	to.AccountNumber = m.AccountNumber
	to.ParentAccountId = m.ParentAccountId
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(BusinessChartOfAccountsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessChartOfAccounts the arg will be the target, the caller the one being converted from

// BusinessChartOfAccountsBeforeToORM called before default ToORM code
type BusinessChartOfAccountsWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessChartOfAccountsORM) error
}

// BusinessChartOfAccountsAfterToORM called after default ToORM code
type BusinessChartOfAccountsWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessChartOfAccountsORM) error
}

// BusinessChartOfAccountsBeforeToPB called before default ToPB code
type BusinessChartOfAccountsWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessChartOfAccounts) error
}

// BusinessChartOfAccountsAfterToPB called after default ToPB code
type BusinessChartOfAccountsWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessChartOfAccounts) error
}

type CompanyAddressORM struct {
	City               string
	CompanyInfoId      *uint64
	Country            string
	CountrySubdivision string
	Id                 uint64
	ModifiedAt         *time.Time
	PurchaseOrderId    *uint64
	State              string
	Street_1           string
	Street_2           string
	Type               string
	ZipCode            string
}

// TableName overrides the default tablename generated by GORM
func (CompanyAddressORM) TableName() string {
	return "company_addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyAddress) ToORM(ctx context.Context) (CompanyAddressORM, error) {
	to := CompanyAddressORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyAddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(CompanyAddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyAddressORM) ToPB(ctx context.Context) (CompanyAddress, error) {
	to := CompanyAddress{}
	var err error
	if prehook, ok := interface{}(m).(CompanyAddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.CountrySubdivision = m.CountrySubdivision
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(CompanyAddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyAddress the arg will be the target, the caller the one being converted from

// CompanyAddressBeforeToORM called before default ToORM code
type CompanyAddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyAddressORM) error
}

// CompanyAddressAfterToORM called after default ToORM code
type CompanyAddressWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyAddressORM) error
}

// CompanyAddressBeforeToPB called before default ToPB code
type CompanyAddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyAddress) error
}

// CompanyAddressAfterToPB called after default ToPB code
type CompanyAddressWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyAddress) error
}

type AttachmentsORM struct {
	Company                   string
	FileName                  string
	FileUrl                   string
	Id                        uint64
	LinkedAccountingAccountId *uint64
	MergeAccountId            string
	ModifiedAt                *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
}

// TableName overrides the default tablename generated by GORM
func (AttachmentsORM) TableName() string {
	return "attachments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Attachments) ToORM(ctx context.Context) (AttachmentsORM, error) {
	to := AttachmentsORM{}
	var err error
	if prehook, ok := interface{}(m).(AttachmentsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(AttachmentsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AttachmentsORM) ToPB(ctx context.Context) (Attachments, error) {
	to := Attachments{}
	var err error
	if prehook, ok := interface{}(m).(AttachmentsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(AttachmentsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Attachments the arg will be the target, the caller the one being converted from

// AttachmentsBeforeToORM called before default ToORM code
type AttachmentsWithBeforeToORM interface {
	BeforeToORM(context.Context, *AttachmentsORM) error
}

// AttachmentsAfterToORM called after default ToORM code
type AttachmentsWithAfterToORM interface {
	AfterToORM(context.Context, *AttachmentsORM) error
}

// AttachmentsBeforeToPB called before default ToPB code
type AttachmentsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Attachments) error
}

// AttachmentsAfterToPB called after default ToPB code
type AttachmentsWithAfterToPB interface {
	AfterToPB(context.Context, *Attachments) error
}

type BalanceSheetORM struct {
	Assets            []*ReportItemORM `gorm:"foreignkey:AssetsBalanceSheetId;association_foreignkey:Id;preload:true"`
	Company           string
	Currency          string
	Date              *time.Time
	Equity            []*ReportItemORM `gorm:"foreignkey:EquityBalanceSheetId;association_foreignkey:Id;preload:true"`
	Id                uint64
	Liabilities       []*ReportItemORM `gorm:"foreignkey:LiabilitiesBalanceSheetId;association_foreignkey:Id;preload:true"`
	MergeAccountId    string
	ModifiedAt        *time.Time
	Name              string
	NetAssets         int64
	RemoteGeneratedAt *time.Time
	RemoteId          string
	RemoteWasDeleted  bool
	ReportDetailsId   *uint64
}

// TableName overrides the default tablename generated by GORM
func (BalanceSheetORM) TableName() string {
	return "balance_sheets"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BalanceSheet) ToORM(ctx context.Context) (BalanceSheetORM, error) {
	to := BalanceSheetORM{}
	var err error
	if prehook, ok := interface{}(m).(BalanceSheetWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.Date != nil {
		t := m.Date.AsTime()
		to.Date = &t
	}
	to.NetAssets = m.NetAssets
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToORM(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Liabilities {
		if v != nil {
			if tempLiabilities, cErr := v.ToORM(ctx); cErr == nil {
				to.Liabilities = append(to.Liabilities, &tempLiabilities)
			} else {
				return to, cErr
			}
		} else {
			to.Liabilities = append(to.Liabilities, nil)
		}
	}
	for _, v := range m.Equity {
		if v != nil {
			if tempEquity, cErr := v.ToORM(ctx); cErr == nil {
				to.Equity = append(to.Equity, &tempEquity)
			} else {
				return to, cErr
			}
		} else {
			to.Equity = append(to.Equity, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		t := m.RemoteGeneratedAt.AsTime()
		to.RemoteGeneratedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(BalanceSheetWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BalanceSheetORM) ToPB(ctx context.Context) (BalanceSheet, error) {
	to := BalanceSheet{}
	var err error
	if prehook, ok := interface{}(m).(BalanceSheetWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.Date != nil {
		to.Date = timestamppb.New(*m.Date)
	}
	to.NetAssets = m.NetAssets
	for _, v := range m.Assets {
		if v != nil {
			if tempAssets, cErr := v.ToPB(ctx); cErr == nil {
				to.Assets = append(to.Assets, &tempAssets)
			} else {
				return to, cErr
			}
		} else {
			to.Assets = append(to.Assets, nil)
		}
	}
	for _, v := range m.Liabilities {
		if v != nil {
			if tempLiabilities, cErr := v.ToPB(ctx); cErr == nil {
				to.Liabilities = append(to.Liabilities, &tempLiabilities)
			} else {
				return to, cErr
			}
		} else {
			to.Liabilities = append(to.Liabilities, nil)
		}
	}
	for _, v := range m.Equity {
		if v != nil {
			if tempEquity, cErr := v.ToPB(ctx); cErr == nil {
				to.Equity = append(to.Equity, &tempEquity)
			} else {
				return to, cErr
			}
		} else {
			to.Equity = append(to.Equity, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		to.RemoteGeneratedAt = timestamppb.New(*m.RemoteGeneratedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(BalanceSheetWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BalanceSheet the arg will be the target, the caller the one being converted from

// BalanceSheetBeforeToORM called before default ToORM code
type BalanceSheetWithBeforeToORM interface {
	BeforeToORM(context.Context, *BalanceSheetORM) error
}

// BalanceSheetAfterToORM called after default ToORM code
type BalanceSheetWithAfterToORM interface {
	AfterToORM(context.Context, *BalanceSheetORM) error
}

// BalanceSheetBeforeToPB called before default ToPB code
type BalanceSheetWithBeforeToPB interface {
	BeforeToPB(context.Context, *BalanceSheet) error
}

// BalanceSheetAfterToPB called after default ToPB code
type BalanceSheetWithAfterToPB interface {
	AfterToPB(context.Context, *BalanceSheet) error
}

type ReportItemORM struct {
	AssetsBalanceSheetId                    *uint64
	Company                                 string
	CostOfSalesIncomeStatementId            *uint64
	EquityBalanceSheetId                    *uint64
	FinancingActivitiesCashFlowStatementsId *uint64
	Id                                      uint64
	IncomeIncomeStatementId                 *uint64
	InvestingActivitiesCashFlowStatementsId *uint64
	LiabilitiesBalanceSheetId               *uint64
	ModifiedAt                              *time.Time
	Name                                    string
	NonOperatingExpensesIncomeStatementId   *uint64
	OperatingActivitiesCashFlowStatementsId *uint64
	OperatingExpensesIncomeStatementId      *uint64
	RemoteId                                string
	Value                                   int64
}

// TableName overrides the default tablename generated by GORM
func (ReportItemORM) TableName() string {
	return "report_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ReportItem) ToORM(ctx context.Context) (ReportItemORM, error) {
	to := ReportItemORM{}
	var err error
	if prehook, ok := interface{}(m).(ReportItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Value = m.Value
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(ReportItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReportItemORM) ToPB(ctx context.Context) (ReportItem, error) {
	to := ReportItem{}
	var err error
	if prehook, ok := interface{}(m).(ReportItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Value = m.Value
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(ReportItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ReportItem the arg will be the target, the caller the one being converted from

// ReportItemBeforeToORM called before default ToORM code
type ReportItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReportItemORM) error
}

// ReportItemAfterToORM called after default ToORM code
type ReportItemWithAfterToORM interface {
	AfterToORM(context.Context, *ReportItemORM) error
}

// ReportItemBeforeToPB called before default ToPB code
type ReportItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *ReportItem) error
}

// ReportItemAfterToPB called after default ToPB code
type ReportItemWithAfterToPB interface {
	AfterToPB(context.Context, *ReportItem) error
}

type CashFlowStatementsORM struct {
	CashAtBeginningOfPeriod float64
	CashAtEndOfPeriod       float64
	Company                 string
	Currency                string
	EndPeriod               *time.Time
	FinancingActivities     []*ReportItemORM `gorm:"foreignkey:FinancingActivitiesCashFlowStatementsId;association_foreignkey:Id;preload:true"`
	Id                      uint64
	InvestingActivities     []*ReportItemORM `gorm:"foreignkey:InvestingActivitiesCashFlowStatementsId;association_foreignkey:Id;preload:true"`
	MergeRecordId           string
	ModifiedAt              *time.Time
	Name                    string
	OperatingActivities     []*ReportItemORM `gorm:"foreignkey:OperatingActivitiesCashFlowStatementsId;association_foreignkey:Id;preload:true"`
	RemoteGeneratedAt       *time.Time
	RemoteId                string
	RemoteWasDeleted        bool
	ReportDetailsId         *uint64
	StartPeriod             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (CashFlowStatementsORM) TableName() string {
	return "cash_flow_statements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CashFlowStatements) ToORM(ctx context.Context) (CashFlowStatementsORM, error) {
	to := CashFlowStatementsORM{}
	var err error
	if prehook, ok := interface{}(m).(CashFlowStatementsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		t := m.StartPeriod.AsTime()
		to.StartPeriod = &t
	}
	if m.EndPeriod != nil {
		t := m.EndPeriod.AsTime()
		to.EndPeriod = &t
	}
	to.CashAtBeginningOfPeriod = m.CashAtBeginningOfPeriod
	to.CashAtEndOfPeriod = m.CashAtEndOfPeriod
	for _, v := range m.OperatingActivities {
		if v != nil {
			if tempOperatingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.OperatingActivities = append(to.OperatingActivities, &tempOperatingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingActivities = append(to.OperatingActivities, nil)
		}
	}
	for _, v := range m.InvestingActivities {
		if v != nil {
			if tempInvestingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestingActivities = append(to.InvestingActivities, &tempInvestingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.InvestingActivities = append(to.InvestingActivities, nil)
		}
	}
	for _, v := range m.FinancingActivities {
		if v != nil {
			if tempFinancingActivities, cErr := v.ToORM(ctx); cErr == nil {
				to.FinancingActivities = append(to.FinancingActivities, &tempFinancingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.FinancingActivities = append(to.FinancingActivities, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		t := m.RemoteGeneratedAt.AsTime()
		to.RemoteGeneratedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CashFlowStatementsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CashFlowStatementsORM) ToPB(ctx context.Context) (CashFlowStatements, error) {
	to := CashFlowStatements{}
	var err error
	if prehook, ok := interface{}(m).(CashFlowStatementsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		to.StartPeriod = timestamppb.New(*m.StartPeriod)
	}
	if m.EndPeriod != nil {
		to.EndPeriod = timestamppb.New(*m.EndPeriod)
	}
	to.CashAtBeginningOfPeriod = m.CashAtBeginningOfPeriod
	to.CashAtEndOfPeriod = m.CashAtEndOfPeriod
	for _, v := range m.OperatingActivities {
		if v != nil {
			if tempOperatingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.OperatingActivities = append(to.OperatingActivities, &tempOperatingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingActivities = append(to.OperatingActivities, nil)
		}
	}
	for _, v := range m.InvestingActivities {
		if v != nil {
			if tempInvestingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestingActivities = append(to.InvestingActivities, &tempInvestingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.InvestingActivities = append(to.InvestingActivities, nil)
		}
	}
	for _, v := range m.FinancingActivities {
		if v != nil {
			if tempFinancingActivities, cErr := v.ToPB(ctx); cErr == nil {
				to.FinancingActivities = append(to.FinancingActivities, &tempFinancingActivities)
			} else {
				return to, cErr
			}
		} else {
			to.FinancingActivities = append(to.FinancingActivities, nil)
		}
	}
	if m.RemoteGeneratedAt != nil {
		to.RemoteGeneratedAt = timestamppb.New(*m.RemoteGeneratedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(CashFlowStatementsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CashFlowStatements the arg will be the target, the caller the one being converted from

// CashFlowStatementsBeforeToORM called before default ToORM code
type CashFlowStatementsWithBeforeToORM interface {
	BeforeToORM(context.Context, *CashFlowStatementsORM) error
}

// CashFlowStatementsAfterToORM called after default ToORM code
type CashFlowStatementsWithAfterToORM interface {
	AfterToORM(context.Context, *CashFlowStatementsORM) error
}

// CashFlowStatementsBeforeToPB called before default ToPB code
type CashFlowStatementsWithBeforeToPB interface {
	BeforeToPB(context.Context, *CashFlowStatements) error
}

// CashFlowStatementsAfterToPB called after default ToPB code
type CashFlowStatementsWithAfterToPB interface {
	AfterToPB(context.Context, *CashFlowStatements) error
}

type CompanyInfoORM struct {
	Addresses                 []*CompanyAddressORM `gorm:"foreignkey:CompanyInfoId;association_foreignkey:Id"`
	Currency                  string
	FiscalYearEndDay          int32
	FiscalYearEndMonth        int32
	Id                        uint64
	LegalName                 string
	LinkedAccountingAccountId *uint64
	MergeAccountId            string
	ModifiedAt                *time.Time
	Name                      string
	PhoneNumbers              pq.StringArray `gorm:"type:text[]"`
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteWasDeleted          bool
	TaxNumber                 string
	Urls                      pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (CompanyInfoORM) TableName() string {
	return "company_infos"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyInfo) ToORM(ctx context.Context) (CompanyInfoORM, error) {
	to := CompanyInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.LegalName = m.LegalName
	to.TaxNumber = m.TaxNumber
	to.FiscalYearEndMonth = m.FiscalYearEndMonth
	to.FiscalYearEndDay = m.FiscalYearEndDay
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.Urls != nil {
		to.Urls = make(pq.StringArray, len(m.Urls))
		copy(to.Urls, m.Urls)
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToORM(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CompanyInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyInfoORM) ToPB(ctx context.Context) (CompanyInfo, error) {
	to := CompanyInfo{}
	var err error
	if prehook, ok := interface{}(m).(CompanyInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.LegalName = m.LegalName
	to.TaxNumber = m.TaxNumber
	to.FiscalYearEndMonth = m.FiscalYearEndMonth
	to.FiscalYearEndDay = m.FiscalYearEndDay
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.Urls != nil {
		to.Urls = make(pq.StringArray, len(m.Urls))
		copy(to.Urls, m.Urls)
	}
	for _, v := range m.Addresses {
		if v != nil {
			if tempAddresses, cErr := v.ToPB(ctx); cErr == nil {
				to.Addresses = append(to.Addresses, &tempAddresses)
			} else {
				return to, cErr
			}
		} else {
			to.Addresses = append(to.Addresses, nil)
		}
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CompanyInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyInfo the arg will be the target, the caller the one being converted from

// CompanyInfoBeforeToORM called before default ToORM code
type CompanyInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyInfoORM) error
}

// CompanyInfoAfterToORM called after default ToORM code
type CompanyInfoWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyInfoORM) error
}

// CompanyInfoBeforeToPB called before default ToPB code
type CompanyInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyInfo) error
}

// CompanyInfoAfterToPB called after default ToPB code
type CompanyInfoWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyInfo) error
}

type AccountingAttachmentORM struct {
	Company          string
	FileName         string
	FileUrl          string
	Id               uint64
	MergeRecordId    string
	ModifiedAt       string
	RemoteId         string
	RemoteWasDeleted bool
}

// TableName overrides the default tablename generated by GORM
func (AccountingAttachmentORM) TableName() string {
	return "accounting_attachments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountingAttachment) ToORM(ctx context.Context) (AccountingAttachmentORM, error) {
	to := AccountingAttachmentORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountingAttachmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.ModifiedAt = m.ModifiedAt
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(AccountingAttachmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountingAttachmentORM) ToPB(ctx context.Context) (AccountingAttachment, error) {
	to := AccountingAttachment{}
	var err error
	if prehook, ok := interface{}(m).(AccountingAttachmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FileName = m.FileName
	to.FileUrl = m.FileUrl
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.ModifiedAt = m.ModifiedAt
	to.MergeRecordId = m.MergeRecordId
	if posthook, ok := interface{}(m).(AccountingAttachmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountingAttachment the arg will be the target, the caller the one being converted from

// AccountingAttachmentBeforeToORM called before default ToORM code
type AccountingAttachmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountingAttachmentORM) error
}

// AccountingAttachmentAfterToORM called after default ToORM code
type AccountingAttachmentWithAfterToORM interface {
	AfterToORM(context.Context, *AccountingAttachmentORM) error
}

// AccountingAttachmentBeforeToPB called before default ToPB code
type AccountingAttachmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountingAttachment) error
}

// AccountingAttachmentAfterToPB called after default ToPB code
type AccountingAttachmentWithAfterToPB interface {
	AfterToPB(context.Context, *AccountingAttachment) error
}

type ContactsORM struct {
	AddressesIds       pq.StringArray `gorm:"type:text[]"`
	Company            string
	Currency           string
	EmailAddress       string
	Id                 uint64
	IsCustomer         bool
	IsSupplier         bool
	MergeAccountId     string
	ModifiedAt         *time.Time
	Name               string
	PhoneNumbers       pq.StringArray `gorm:"type:text[]"`
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteUpdatedAt    *time.Time
	RemoteWasDeleted   bool
	Status             string
	TaxNumber          string
}

// TableName overrides the default tablename generated by GORM
func (ContactsORM) TableName() string {
	return "contacts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Contacts) ToORM(ctx context.Context) (ContactsORM, error) {
	to := ContactsORM{}
	var err error
	if prehook, ok := interface{}(m).(ContactsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.IsSupplier = m.IsSupplier
	to.IsCustomer = m.IsCustomer
	to.EmailAddress = m.EmailAddress
	to.TaxNumber = m.TaxNumber
	to.Status = m.Status
	to.Currency = m.Currency
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.Company = m.Company
	if m.AddressesIds != nil {
		to.AddressesIds = make(pq.StringArray, len(m.AddressesIds))
		copy(to.AddressesIds, m.AddressesIds)
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ContactsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContactsORM) ToPB(ctx context.Context) (Contacts, error) {
	to := Contacts{}
	var err error
	if prehook, ok := interface{}(m).(ContactsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.IsSupplier = m.IsSupplier
	to.IsCustomer = m.IsCustomer
	to.EmailAddress = m.EmailAddress
	to.TaxNumber = m.TaxNumber
	to.Status = m.Status
	to.Currency = m.Currency
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.Company = m.Company
	if m.AddressesIds != nil {
		to.AddressesIds = make(pq.StringArray, len(m.AddressesIds))
		copy(to.AddressesIds, m.AddressesIds)
	}
	if m.PhoneNumbers != nil {
		to.PhoneNumbers = make(pq.StringArray, len(m.PhoneNumbers))
		copy(to.PhoneNumbers, m.PhoneNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ContactsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Contacts the arg will be the target, the caller the one being converted from

// ContactsBeforeToORM called before default ToORM code
type ContactsWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContactsORM) error
}

// ContactsAfterToORM called after default ToORM code
type ContactsWithAfterToORM interface {
	AfterToORM(context.Context, *ContactsORM) error
}

// ContactsBeforeToPB called before default ToPB code
type ContactsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Contacts) error
}

// ContactsAfterToPB called after default ToPB code
type ContactsWithAfterToPB interface {
	AfterToPB(context.Context, *Contacts) error
}

type CreditNoteORM struct {
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	LineItems            []*CreditNoteLineItemORM `gorm:"foreignkey:CreditNoteId;association_foreignkey:Id"`
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	PaymentIds           pq.StringArray `gorm:"type:text[]"`
	RemainingCredit      float64
	RemoteCreatedAt      *time.Time
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	Status               string
	TotalAmount          float64
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (CreditNoteORM) TableName() string {
	return "credit_notes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditNote) ToORM(ctx context.Context) (CreditNoteORM, error) {
	to := CreditNoteORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Status = m.Status
	to.Number = m.Number
	to.Contact = m.Contact
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	to.TotalAmount = m.TotalAmount
	to.RemainingCredit = m.RemainingCredit
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CreditNoteWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditNoteORM) ToPB(ctx context.Context) (CreditNote, error) {
	to := CreditNote{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Status = m.Status
	to.Number = m.Number
	to.Contact = m.Contact
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	to.TotalAmount = m.TotalAmount
	to.RemainingCredit = m.RemainingCredit
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Currency = m.Currency
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CreditNoteWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditNote the arg will be the target, the caller the one being converted from

// CreditNoteBeforeToORM called before default ToORM code
type CreditNoteWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditNoteORM) error
}

// CreditNoteAfterToORM called after default ToORM code
type CreditNoteWithAfterToORM interface {
	AfterToORM(context.Context, *CreditNoteORM) error
}

// CreditNoteBeforeToPB called before default ToPB code
type CreditNoteWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditNote) error
}

// CreditNoteAfterToPB called after default ToPB code
type CreditNoteWithAfterToPB interface {
	AfterToPB(context.Context, *CreditNote) error
}

type CreditNoteLineItemORM struct {
	Account            string
	Company            string
	CreditNoteId       *uint64
	Description        string
	Id                 uint64
	Item               string
	Name               string
	Quantity           string
	RemoteId           string
	TaxRate            string
	TotalLineAmount    string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          string
}

// TableName overrides the default tablename generated by GORM
func (CreditNoteLineItemORM) TableName() string {
	return "credit_note_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditNoteLineItem) ToORM(ctx context.Context) (CreditNoteLineItemORM, error) {
	to := CreditNoteLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.TaxRate = m.TaxRate
	to.TotalLineAmount = m.TotalLineAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Account = m.Account
	to.Company = m.Company
	to.RemoteId = m.RemoteId
	to.Item = m.Item
	if posthook, ok := interface{}(m).(CreditNoteLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditNoteLineItemORM) ToPB(ctx context.Context) (CreditNoteLineItem, error) {
	to := CreditNoteLineItem{}
	var err error
	if prehook, ok := interface{}(m).(CreditNoteLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.TaxRate = m.TaxRate
	to.TotalLineAmount = m.TotalLineAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Account = m.Account
	to.Company = m.Company
	to.RemoteId = m.RemoteId
	to.Item = m.Item
	if posthook, ok := interface{}(m).(CreditNoteLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditNoteLineItem the arg will be the target, the caller the one being converted from

// CreditNoteLineItemBeforeToORM called before default ToORM code
type CreditNoteLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditNoteLineItemORM) error
}

// CreditNoteLineItemAfterToORM called after default ToORM code
type CreditNoteLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *CreditNoteLineItemORM) error
}

// CreditNoteLineItemBeforeToPB called before default ToPB code
type CreditNoteLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditNoteLineItem) error
}

// CreditNoteLineItemAfterToPB called after default ToPB code
type CreditNoteLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *CreditNoteLineItem) error
}

type ExpenseORM struct {
	Account              string
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	Lines                []*ExpenseLineORM `gorm:"foreignkey:ExpenseId;association_foreignkey:Id"`
	Memo                 string
	MergeAccountId       string
	ModifiedAt           *time.Time
	RemoteCreatedAt      *time.Time
	RemoteId             string
	RemoteWasDeleted     bool
	SubTotal             float64
	TotalAmount          float64
	TotalTaxAmount       float64
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (ExpenseORM) TableName() string {
	return "expenses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Expense) ToORM(ctx context.Context) (ExpenseORM, error) {
	to := ExpenseORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.SubTotal = m.SubTotal
	to.TotalTaxAmount = m.TotalTaxAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.Memo = m.Memo
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ExpenseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseORM) ToPB(ctx context.Context) (Expense, error) {
	to := Expense{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.SubTotal = m.SubTotal
	to.TotalTaxAmount = m.TotalTaxAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.Memo = m.Memo
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ExpenseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Expense the arg will be the target, the caller the one being converted from

// ExpenseBeforeToORM called before default ToORM code
type ExpenseWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseORM) error
}

// ExpenseAfterToORM called after default ToORM code
type ExpenseWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseORM) error
}

// ExpenseBeforeToPB called before default ToPB code
type ExpenseWithBeforeToPB interface {
	BeforeToPB(context.Context, *Expense) error
}

// ExpenseAfterToPB called after default ToPB code
type ExpenseWithAfterToPB interface {
	AfterToPB(context.Context, *Expense) error
}

type ExpenseLineORM struct {
	Account            string
	Company            string
	Contact            string
	Currency           string
	Description        string
	ExchangeRate       string
	ExpenseId          *uint64
	Id                 uint64
	Item               string
	ModifiedAt         *time.Time
	NetAmount          float64
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
}

// TableName overrides the default tablename generated by GORM
func (ExpenseLineORM) TableName() string {
	return "expense_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ExpenseLine) ToORM(ctx context.Context) (ExpenseLineORM, error) {
	to := ExpenseLineORM{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.Item = m.Item
	to.Account = m.Account
	to.Contact = m.Contact
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	to.RemoteId = m.RemoteId
	to.Currency = m.Currency
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(ExpenseLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExpenseLineORM) ToPB(ctx context.Context) (ExpenseLine, error) {
	to := ExpenseLine{}
	var err error
	if prehook, ok := interface{}(m).(ExpenseLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.Item = m.Item
	to.Account = m.Account
	to.Contact = m.Contact
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	to.RemoteId = m.RemoteId
	to.Currency = m.Currency
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(ExpenseLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ExpenseLine the arg will be the target, the caller the one being converted from

// ExpenseLineBeforeToORM called before default ToORM code
type ExpenseLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExpenseLineORM) error
}

// ExpenseLineAfterToORM called after default ToORM code
type ExpenseLineWithAfterToORM interface {
	AfterToORM(context.Context, *ExpenseLineORM) error
}

// ExpenseLineBeforeToPB called before default ToPB code
type ExpenseLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *ExpenseLine) error
}

// ExpenseLineAfterToPB called after default ToPB code
type ExpenseLineWithAfterToPB interface {
	AfterToPB(context.Context, *ExpenseLine) error
}

type IncomeStatementORM struct {
	Company              string
	CostOfSales          []*ReportItemORM `gorm:"foreignkey:CostOfSalesIncomeStatementId;association_foreignkey:Id"`
	Currency             string
	EndPeriod            *time.Time
	GrossProfit          int32
	Id                   uint64
	Income               []*ReportItemORM `gorm:"foreignkey:IncomeIncomeStatementId;association_foreignkey:Id"`
	ModifiedAt           *time.Time
	Name                 string
	NetIncome            int32
	NetOperatingIncome   int32
	NonOperatingExpenses []*ReportItemORM `gorm:"foreignkey:NonOperatingExpensesIncomeStatementId;association_foreignkey:Id"`
	OperatingExpenses    []*ReportItemORM `gorm:"foreignkey:OperatingExpensesIncomeStatementId;association_foreignkey:Id"`
	RemoteId             string
	RemoteWasDeleted     bool
	ReportDetailsId      *uint64
	StartPeriod          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (IncomeStatementORM) TableName() string {
	return "income_statements"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IncomeStatement) ToORM(ctx context.Context) (IncomeStatementORM, error) {
	to := IncomeStatementORM{}
	var err error
	if prehook, ok := interface{}(m).(IncomeStatementWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		t := m.StartPeriod.AsTime()
		to.StartPeriod = &t
	}
	if m.EndPeriod != nil {
		t := m.EndPeriod.AsTime()
		to.EndPeriod = &t
	}
	for _, v := range m.Income {
		if v != nil {
			if tempIncome, cErr := v.ToORM(ctx); cErr == nil {
				to.Income = append(to.Income, &tempIncome)
			} else {
				return to, cErr
			}
		} else {
			to.Income = append(to.Income, nil)
		}
	}
	for _, v := range m.CostOfSales {
		if v != nil {
			if tempCostOfSales, cErr := v.ToORM(ctx); cErr == nil {
				to.CostOfSales = append(to.CostOfSales, &tempCostOfSales)
			} else {
				return to, cErr
			}
		} else {
			to.CostOfSales = append(to.CostOfSales, nil)
		}
	}
	to.GrossProfit = m.GrossProfit
	for _, v := range m.OperatingExpenses {
		if v != nil {
			if tempOperatingExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.OperatingExpenses = append(to.OperatingExpenses, &tempOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingExpenses = append(to.OperatingExpenses, nil)
		}
	}
	to.NetOperatingIncome = m.NetOperatingIncome
	for _, v := range m.NonOperatingExpenses {
		if v != nil {
			if tempNonOperatingExpenses, cErr := v.ToORM(ctx); cErr == nil {
				to.NonOperatingExpenses = append(to.NonOperatingExpenses, &tempNonOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.NonOperatingExpenses = append(to.NonOperatingExpenses, nil)
		}
	}
	to.NetIncome = m.NetIncome
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(IncomeStatementWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IncomeStatementORM) ToPB(ctx context.Context) (IncomeStatement, error) {
	to := IncomeStatement{}
	var err error
	if prehook, ok := interface{}(m).(IncomeStatementWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Currency = m.Currency
	to.Company = m.Company
	if m.StartPeriod != nil {
		to.StartPeriod = timestamppb.New(*m.StartPeriod)
	}
	if m.EndPeriod != nil {
		to.EndPeriod = timestamppb.New(*m.EndPeriod)
	}
	for _, v := range m.Income {
		if v != nil {
			if tempIncome, cErr := v.ToPB(ctx); cErr == nil {
				to.Income = append(to.Income, &tempIncome)
			} else {
				return to, cErr
			}
		} else {
			to.Income = append(to.Income, nil)
		}
	}
	for _, v := range m.CostOfSales {
		if v != nil {
			if tempCostOfSales, cErr := v.ToPB(ctx); cErr == nil {
				to.CostOfSales = append(to.CostOfSales, &tempCostOfSales)
			} else {
				return to, cErr
			}
		} else {
			to.CostOfSales = append(to.CostOfSales, nil)
		}
	}
	to.GrossProfit = m.GrossProfit
	for _, v := range m.OperatingExpenses {
		if v != nil {
			if tempOperatingExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.OperatingExpenses = append(to.OperatingExpenses, &tempOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.OperatingExpenses = append(to.OperatingExpenses, nil)
		}
	}
	to.NetOperatingIncome = m.NetOperatingIncome
	for _, v := range m.NonOperatingExpenses {
		if v != nil {
			if tempNonOperatingExpenses, cErr := v.ToPB(ctx); cErr == nil {
				to.NonOperatingExpenses = append(to.NonOperatingExpenses, &tempNonOperatingExpenses)
			} else {
				return to, cErr
			}
		} else {
			to.NonOperatingExpenses = append(to.NonOperatingExpenses, nil)
		}
	}
	to.NetIncome = m.NetIncome
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(IncomeStatementWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IncomeStatement the arg will be the target, the caller the one being converted from

// IncomeStatementBeforeToORM called before default ToORM code
type IncomeStatementWithBeforeToORM interface {
	BeforeToORM(context.Context, *IncomeStatementORM) error
}

// IncomeStatementAfterToORM called after default ToORM code
type IncomeStatementWithAfterToORM interface {
	AfterToORM(context.Context, *IncomeStatementORM) error
}

// IncomeStatementBeforeToPB called before default ToPB code
type IncomeStatementWithBeforeToPB interface {
	BeforeToPB(context.Context, *IncomeStatement) error
}

// IncomeStatementAfterToPB called after default ToPB code
type IncomeStatementWithAfterToPB interface {
	AfterToPB(context.Context, *IncomeStatement) error
}

type InvoiceORM struct {
	AccountingPeriod     string
	Balance              float32
	Company              string
	Contact              string
	Currency             string
	DueDate              *time.Time
	ExchangeRate         string
	Id                   uint64
	IssueDate            *time.Time
	LineItems            []*InvoiceLineItemORM `gorm:"foreignkey:InvoiceId;association_foreignkey:Id"`
	Memo                 string
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	PaidOnDate           *time.Time
	Payments             pq.StringArray `gorm:"type:text[]"`
	PurchaseOrders       pq.StringArray `gorm:"type:text[]"`
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	Status               string
	SubTotal             float32
	TotalAmount          float32
	TotalDiscount        float32
	TotalTaxAmount       float32
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDetailsId *uint64
	Type                 string
}

// TableName overrides the default tablename generated by GORM
func (InvoiceORM) TableName() string {
	return "invoices"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Invoice) ToORM(ctx context.Context) (InvoiceORM, error) {
	to := InvoiceORM{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Contact = m.Contact
	to.Number = m.Number
	if m.IssueDate != nil {
		t := m.IssueDate.AsTime()
		to.IssueDate = &t
	}
	if m.DueDate != nil {
		t := m.DueDate.AsTime()
		to.DueDate = &t
	}
	if m.PaidOnDate != nil {
		t := m.PaidOnDate.AsTime()
		to.PaidOnDate = &t
	}
	to.Memo = m.Memo
	to.Company = m.Company
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.TotalDiscount = m.TotalDiscount
	to.SubTotal = m.SubTotal
	to.Status = m.Status
	to.TotalTaxAmount = m.TotalTaxAmount
	to.TotalAmount = m.TotalAmount
	to.Balance = m.Balance
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.PurchaseOrders != nil {
		to.PurchaseOrders = make(pq.StringArray, len(m.PurchaseOrders))
		copy(to.PurchaseOrders, m.PurchaseOrders)
	}
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(InvoiceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvoiceORM) ToPB(ctx context.Context) (Invoice, error) {
	to := Invoice{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = m.Type
	to.Contact = m.Contact
	to.Number = m.Number
	if m.IssueDate != nil {
		to.IssueDate = timestamppb.New(*m.IssueDate)
	}
	if m.DueDate != nil {
		to.DueDate = timestamppb.New(*m.DueDate)
	}
	if m.PaidOnDate != nil {
		to.PaidOnDate = timestamppb.New(*m.PaidOnDate)
	}
	to.Memo = m.Memo
	to.Company = m.Company
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.TotalDiscount = m.TotalDiscount
	to.SubTotal = m.SubTotal
	to.Status = m.Status
	to.TotalTaxAmount = m.TotalTaxAmount
	to.TotalAmount = m.TotalAmount
	to.Balance = m.Balance
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.Payments != nil {
		to.Payments = make(pq.StringArray, len(m.Payments))
		copy(to.Payments, m.Payments)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.PurchaseOrders != nil {
		to.PurchaseOrders = make(pq.StringArray, len(m.PurchaseOrders))
		copy(to.PurchaseOrders, m.PurchaseOrders)
	}
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(InvoiceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Invoice the arg will be the target, the caller the one being converted from

// InvoiceBeforeToORM called before default ToORM code
type InvoiceWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvoiceORM) error
}

// InvoiceAfterToORM called after default ToORM code
type InvoiceWithAfterToORM interface {
	AfterToORM(context.Context, *InvoiceORM) error
}

// InvoiceBeforeToPB called before default ToPB code
type InvoiceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Invoice) error
}

// InvoiceAfterToPB called after default ToPB code
type InvoiceWithAfterToPB interface {
	AfterToPB(context.Context, *Invoice) error
}

type InvoiceLineItemORM struct {
	Account            string
	Company            string
	Currency           string
	Description        string
	ExchangeRate       string
	Id                 uint64
	InvoiceId          *uint64
	Item               string
	MergeAccountId     string
	ModifiedAt         *time.Time
	Quantity           int32
	RemoteId           string
	TotalAmount        float32
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          float32
}

// TableName overrides the default tablename generated by GORM
func (InvoiceLineItemORM) TableName() string {
	return "invoice_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvoiceLineItem) ToORM(ctx context.Context) (InvoiceLineItemORM, error) {
	to := InvoiceLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.MergeAccountId = m.MergeAccountId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(InvoiceLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvoiceLineItemORM) ToPB(ctx context.Context) (InvoiceLineItem, error) {
	to := InvoiceLineItem{}
	var err error
	if prehook, ok := interface{}(m).(InvoiceLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Company = m.Company
	to.MergeAccountId = m.MergeAccountId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(InvoiceLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvoiceLineItem the arg will be the target, the caller the one being converted from

// InvoiceLineItemBeforeToORM called before default ToORM code
type InvoiceLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvoiceLineItemORM) error
}

// InvoiceLineItemAfterToORM called after default ToORM code
type InvoiceLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *InvoiceLineItemORM) error
}

// InvoiceLineItemBeforeToPB called before default ToPB code
type InvoiceLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvoiceLineItem) error
}

// InvoiceLineItemAfterToPB called after default ToPB code
type InvoiceLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *InvoiceLineItem) error
}

type ItemORM struct {
	Company            string
	Id                 uint64
	MergeAccountId     string
	ModifiedAt         *time.Time
	Name               string
	PurchaseAccount    string
	PurchasePrice      float32
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteUpdatedAt    *time.Time
	RemoteWasDeleted   bool
	SalesAccount       string
	Status             string
	UnitPrice          float32
}

// TableName overrides the default tablename generated by GORM
func (ItemORM) TableName() string {
	return "items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Item) ToORM(ctx context.Context) (ItemORM, error) {
	to := ItemORM{}
	var err error
	if prehook, ok := interface{}(m).(ItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Status = m.Status
	to.UnitPrice = m.UnitPrice
	to.PurchasePrice = m.PurchasePrice
	to.PurchaseAccount = m.PurchaseAccount
	to.SalesAccount = m.SalesAccount
	to.Company = m.Company
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ItemORM) ToPB(ctx context.Context) (Item, error) {
	to := Item{}
	var err error
	if prehook, ok := interface{}(m).(ItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Status = m.Status
	to.UnitPrice = m.UnitPrice
	to.PurchasePrice = m.PurchasePrice
	to.PurchaseAccount = m.PurchaseAccount
	to.SalesAccount = m.SalesAccount
	to.Company = m.Company
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(ItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Item the arg will be the target, the caller the one being converted from

// ItemBeforeToORM called before default ToORM code
type ItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *ItemORM) error
}

// ItemAfterToORM called after default ToORM code
type ItemWithAfterToORM interface {
	AfterToORM(context.Context, *ItemORM) error
}

// ItemBeforeToPB called before default ToPB code
type ItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *Item) error
}

// ItemAfterToPB called after default ToPB code
type ItemWithAfterToPB interface {
	AfterToPB(context.Context, *Item) error
}

type JournalEntryORM struct {
	AccountingPeriod     string
	Company              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	JournalNumber        string
	Lines                []*JournalLineORM `gorm:"foreignkey:JournalEntryId;association_foreignkey:Id"`
	Memo                 string
	MergeAccountId       string
	ModifiedAt           *time.Time
	PaymentIds           pq.StringArray `gorm:"type:text[]"`
	PostingStatus        string
	RemoteCreatedAt      *time.Time
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (JournalEntryORM) TableName() string {
	return "journal_entries"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalEntry) ToORM(ctx context.Context) (JournalEntryORM, error) {
	to := JournalEntryORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.Memo = m.Memo
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	to.JournalNumber = m.JournalNumber
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.PostingStatus = m.PostingStatus
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalEntryORM) ToPB(ctx context.Context) (JournalEntry, error) {
	to := JournalEntry{}
	var err error
	if prehook, ok := interface{}(m).(JournalEntryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	if m.PaymentIds != nil {
		to.PaymentIds = make(pq.StringArray, len(m.PaymentIds))
		copy(to.PaymentIds, m.PaymentIds)
	}
	to.Memo = m.Memo
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	to.JournalNumber = m.JournalNumber
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.PostingStatus = m.PostingStatus
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(JournalEntryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalEntry the arg will be the target, the caller the one being converted from

// JournalEntryBeforeToORM called before default ToORM code
type JournalEntryWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryAfterToORM called after default ToORM code
type JournalEntryWithAfterToORM interface {
	AfterToORM(context.Context, *JournalEntryORM) error
}

// JournalEntryBeforeToPB called before default ToPB code
type JournalEntryWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalEntry) error
}

// JournalEntryAfterToPB called after default ToPB code
type JournalEntryWithAfterToPB interface {
	AfterToPB(context.Context, *JournalEntry) error
}

type JournalLineORM struct {
	Account            string
	Company            string
	Contact            string
	Description        string
	ExchangeRate       string
	Id                 uint64
	JournalEntryId     *uint64
	ModifiedAt         *time.Time
	NetAmount          float32
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
}

// TableName overrides the default tablename generated by GORM
func (JournalLineORM) TableName() string {
	return "journal_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *JournalLine) ToORM(ctx context.Context) (JournalLineORM, error) {
	to := JournalLineORM{}
	var err error
	if prehook, ok := interface{}(m).(JournalLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Account = m.Account
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Contact = m.Contact
	to.Company = m.Company
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(JournalLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *JournalLineORM) ToPB(ctx context.Context) (JournalLine, error) {
	to := JournalLine{}
	var err error
	if prehook, ok := interface{}(m).(JournalLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Account = m.Account
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Contact = m.Contact
	to.Company = m.Company
	to.Description = m.Description
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(JournalLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type JournalLine the arg will be the target, the caller the one being converted from

// JournalLineBeforeToORM called before default ToORM code
type JournalLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *JournalLineORM) error
}

// JournalLineAfterToORM called after default ToORM code
type JournalLineWithAfterToORM interface {
	AfterToORM(context.Context, *JournalLineORM) error
}

// JournalLineBeforeToPB called before default ToPB code
type JournalLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *JournalLine) error
}

// JournalLineAfterToPB called after default ToPB code
type JournalLineWithAfterToPB interface {
	AfterToPB(context.Context, *JournalLine) error
}

type PaymentORM struct {
	Account              string
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	MergeAccountId       string
	ModifiedAt           *time.Time
	RemoteId             string
	RemoteUpdatedAt      *time.Time
	RemoteWasDeleted     bool
	TotalAmount          float32
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
}

// TableName overrides the default tablename generated by GORM
func (PaymentORM) TableName() string {
	return "payments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Payment) ToORM(ctx context.Context) (PaymentORM, error) {
	to := PaymentORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Contact = m.Contact
	to.Account = m.Account
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(PaymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentORM) ToPB(ctx context.Context) (Payment, error) {
	to := Payment{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Contact = m.Contact
	to.Account = m.Account
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(PaymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Payment the arg will be the target, the caller the one being converted from

// PaymentBeforeToORM called before default ToORM code
type PaymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentORM) error
}

// PaymentAfterToORM called after default ToORM code
type PaymentWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentORM) error
}

// PaymentBeforeToPB called before default ToPB code
type PaymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Payment) error
}

// PaymentAfterToPB called after default ToPB code
type PaymentWithAfterToPB interface {
	AfterToPB(context.Context, *Payment) error
}

type PurchaseOrderORM struct {
	AccountingPeriod          string
	Company                   string
	Currency                  string
	Customer                  string
	DeliveryAddress           *CompanyAddressORM `gorm:"foreignkey:PurchaseOrderId;association_foreignkey:Id"`
	DeliveryDate              *time.Time
	ExchangeRate              string
	Id                        uint64
	IssueDate                 *time.Time
	LineItems                 []*PurchaseOrderLineItemORM `gorm:"foreignkey:PurchaseOrderId;association_foreignkey:Id"`
	LinkedAccountingAccountId *uint64
	Memo                      string
	MergeAccountId            string
	ModifiedAt                *time.Time
	PurchaseOrderNumber       string
	RemoteCreatedAt           *time.Time
	RemoteId                  string
	RemoteUpdatedAt           *time.Time
	RemoteWasDeleted          bool
	Status                    string
	TotalAmount               float32
	TrackingCategories        pq.StringArray `gorm:"type:text[]"`
	Vendor                    string
}

// TableName overrides the default tablename generated by GORM
func (PurchaseOrderORM) TableName() string {
	return "purchase_orders"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PurchaseOrder) ToORM(ctx context.Context) (PurchaseOrderORM, error) {
	to := PurchaseOrderORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.Status = m.Status
	if m.IssueDate != nil {
		t := m.IssueDate.AsTime()
		to.IssueDate = &t
	}
	to.PurchaseOrderNumber = m.PurchaseOrderNumber
	if m.DeliveryDate != nil {
		t := m.DeliveryDate.AsTime()
		to.DeliveryDate = &t
	}
	if m.DeliveryAddress != nil {
		tempDeliveryAddress, err := m.DeliveryAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DeliveryAddress = &tempDeliveryAddress
	}
	to.Customer = m.Customer
	to.Vendor = m.Vendor
	to.Memo = m.Memo
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	if m.RemoteUpdatedAt != nil {
		t := m.RemoteUpdatedAt.AsTime()
		to.RemoteUpdatedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(PurchaseOrderWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseOrderORM) ToPB(ctx context.Context) (PurchaseOrder, error) {
	to := PurchaseOrder{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.MergeAccountId = m.MergeAccountId
	to.Status = m.Status
	if m.IssueDate != nil {
		to.IssueDate = timestamppb.New(*m.IssueDate)
	}
	to.PurchaseOrderNumber = m.PurchaseOrderNumber
	if m.DeliveryDate != nil {
		to.DeliveryDate = timestamppb.New(*m.DeliveryDate)
	}
	if m.DeliveryAddress != nil {
		tempDeliveryAddress, err := m.DeliveryAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DeliveryAddress = &tempDeliveryAddress
	}
	to.Customer = m.Customer
	to.Vendor = m.Vendor
	to.Memo = m.Memo
	to.Company = m.Company
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	if m.RemoteUpdatedAt != nil {
		to.RemoteUpdatedAt = timestamppb.New(*m.RemoteUpdatedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(PurchaseOrderWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PurchaseOrder the arg will be the target, the caller the one being converted from

// PurchaseOrderBeforeToORM called before default ToORM code
type PurchaseOrderWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseOrderORM) error
}

// PurchaseOrderAfterToORM called after default ToORM code
type PurchaseOrderWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseOrderORM) error
}

// PurchaseOrderBeforeToPB called before default ToPB code
type PurchaseOrderWithBeforeToPB interface {
	BeforeToPB(context.Context, *PurchaseOrder) error
}

// PurchaseOrderAfterToPB called after default ToPB code
type PurchaseOrderWithAfterToPB interface {
	AfterToPB(context.Context, *PurchaseOrder) error
}

type PurchaseOrderLineItemORM struct {
	Account            string
	Company            string
	Currency           string
	Description        string
	ExchangeRate       string
	Id                 uint64
	Item               string
	ModifiedAt         *time.Time
	PurchaseOrderId    *uint64
	Quantity           int32
	RemoteId           string
	TaxAmount          string
	TotalLineAmount    string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	UnitPrice          string
}

// TableName overrides the default tablename generated by GORM
func (PurchaseOrderLineItemORM) TableName() string {
	return "purchase_order_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PurchaseOrderLineItem) ToORM(ctx context.Context) (PurchaseOrderLineItemORM, error) {
	to := PurchaseOrderLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TaxAmount = m.TaxAmount
	to.TotalLineAmount = m.TotalLineAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(PurchaseOrderLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseOrderLineItemORM) ToPB(ctx context.Context) (PurchaseOrderLineItem, error) {
	to := PurchaseOrderLineItem{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseOrderLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.Quantity = m.Quantity
	to.UnitPrice = m.UnitPrice
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TaxAmount = m.TaxAmount
	to.TotalLineAmount = m.TotalLineAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(PurchaseOrderLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PurchaseOrderLineItem the arg will be the target, the caller the one being converted from

// PurchaseOrderLineItemBeforeToORM called before default ToORM code
type PurchaseOrderLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseOrderLineItemORM) error
}

// PurchaseOrderLineItemAfterToORM called after default ToORM code
type PurchaseOrderLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseOrderLineItemORM) error
}

// PurchaseOrderLineItemBeforeToPB called before default ToPB code
type PurchaseOrderLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *PurchaseOrderLineItem) error
}

// PurchaseOrderLineItemAfterToPB called after default ToPB code
type PurchaseOrderLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *PurchaseOrderLineItem) error
}

type TaxRateORM struct {
	Company            string
	Description        string
	EffectiveTaxRate   float64
	Id                 uint64
	MergeAccountId     string
	ModifiedAt         *time.Time
	ReferenceDetailsId *uint64
	RemoteId           string
	RemoteWasDeleted   bool
	TotalTaxRate       float64
}

// TableName overrides the default tablename generated by GORM
func (TaxRateORM) TableName() string {
	return "tax_rates"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TaxRate) ToORM(ctx context.Context) (TaxRateORM, error) {
	to := TaxRateORM{}
	var err error
	if prehook, ok := interface{}(m).(TaxRateWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.TotalTaxRate = m.TotalTaxRate
	to.EffectiveTaxRate = m.EffectiveTaxRate
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(TaxRateWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TaxRateORM) ToPB(ctx context.Context) (TaxRate, error) {
	to := TaxRate{}
	var err error
	if prehook, ok := interface{}(m).(TaxRateWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Description = m.Description
	to.TotalTaxRate = m.TotalTaxRate
	to.EffectiveTaxRate = m.EffectiveTaxRate
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(TaxRateWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TaxRate the arg will be the target, the caller the one being converted from

// TaxRateBeforeToORM called before default ToORM code
type TaxRateWithBeforeToORM interface {
	BeforeToORM(context.Context, *TaxRateORM) error
}

// TaxRateAfterToORM called after default ToORM code
type TaxRateWithAfterToORM interface {
	AfterToORM(context.Context, *TaxRateORM) error
}

// TaxRateBeforeToPB called before default ToPB code
type TaxRateWithBeforeToPB interface {
	BeforeToPB(context.Context, *TaxRate) error
}

// TaxRateAfterToPB called after default ToPB code
type TaxRateWithAfterToPB interface {
	AfterToPB(context.Context, *TaxRate) error
}

type TrackingCategoryORM struct {
	CategoryType     string
	Company          string
	Id               uint64
	MergeAccountId   string
	ModifiedAt       *time.Time
	ParentCategory   string
	RemoteId         string
	RemoteWasDeleted bool
}

// TableName overrides the default tablename generated by GORM
func (TrackingCategoryORM) TableName() string {
	return "tracking_categories"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TrackingCategory) ToORM(ctx context.Context) (TrackingCategoryORM, error) {
	to := TrackingCategoryORM{}
	var err error
	if prehook, ok := interface{}(m).(TrackingCategoryWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.MergeAccountId = m.MergeAccountId
	to.CategoryType = TrackingCategory_CategoryType_name[int32(m.CategoryType)]
	to.ParentCategory = m.ParentCategory
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(TrackingCategoryWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TrackingCategoryORM) ToPB(ctx context.Context) (TrackingCategory, error) {
	to := TrackingCategory{}
	var err error
	if prehook, ok := interface{}(m).(TrackingCategoryWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.MergeAccountId = m.MergeAccountId
	to.CategoryType = TrackingCategory_CategoryType(TrackingCategory_CategoryType_value[m.CategoryType])
	to.ParentCategory = m.ParentCategory
	to.Company = m.Company
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(TrackingCategoryWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TrackingCategory the arg will be the target, the caller the one being converted from

// TrackingCategoryBeforeToORM called before default ToORM code
type TrackingCategoryWithBeforeToORM interface {
	BeforeToORM(context.Context, *TrackingCategoryORM) error
}

// TrackingCategoryAfterToORM called after default ToORM code
type TrackingCategoryWithAfterToORM interface {
	AfterToORM(context.Context, *TrackingCategoryORM) error
}

// TrackingCategoryBeforeToPB called before default ToPB code
type TrackingCategoryWithBeforeToPB interface {
	BeforeToPB(context.Context, *TrackingCategory) error
}

// TrackingCategoryAfterToPB called after default ToPB code
type TrackingCategoryWithAfterToPB interface {
	AfterToPB(context.Context, *TrackingCategory) error
}

type BusinessTransactionORM struct {
	Account              string
	AccountingPeriod     string
	Company              string
	Contact              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	LineItems            []*TransactionLineItemORM `gorm:"foreignkey:BusinessTransactionId;association_foreignkey:Id"`
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	RemoteId             string
	RemoteWasDeleted     bool
	TotalAmount          string
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
	TransactionType      string
}

// TableName overrides the default tablename generated by GORM
func (BusinessTransactionORM) TableName() string {
	return "business_transactions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessTransaction) ToORM(ctx context.Context) (BusinessTransactionORM, error) {
	to := BusinessTransactionORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessTransactionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TransactionType = m.TransactionType
	to.Number = m.Number
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToORM(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(BusinessTransactionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessTransactionORM) ToPB(ctx context.Context) (BusinessTransaction, error) {
	to := BusinessTransaction{}
	var err error
	if prehook, ok := interface{}(m).(BusinessTransactionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TransactionType = m.TransactionType
	to.Number = m.Number
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Account = m.Account
	to.Contact = m.Contact
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	for _, v := range m.LineItems {
		if v != nil {
			if tempLineItems, cErr := v.ToPB(ctx); cErr == nil {
				to.LineItems = append(to.LineItems, &tempLineItems)
			} else {
				return to, cErr
			}
		} else {
			to.LineItems = append(to.LineItems, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(BusinessTransactionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessTransaction the arg will be the target, the caller the one being converted from

// BusinessTransactionBeforeToORM called before default ToORM code
type BusinessTransactionWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessTransactionORM) error
}

// BusinessTransactionAfterToORM called after default ToORM code
type BusinessTransactionWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessTransactionORM) error
}

// BusinessTransactionBeforeToPB called before default ToPB code
type BusinessTransactionWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessTransaction) error
}

// BusinessTransactionAfterToPB called after default ToPB code
type BusinessTransactionWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessTransaction) error
}

type TransactionLineItemORM struct {
	Account               string
	BusinessTransactionId *uint64
	Company               string
	Currency              string
	ExchangeRate          string
	Id                    uint64
	Item                  string
	Memo                  string
	ModifiedAt            *time.Time
	Quantity              string
	RemoteId              string
	TaxRate               string
	TotalLineAmount       string
	TrackingCategories    pq.StringArray `gorm:"type:text[]"`
	TrackingCategory      string
	UnitPrice             string
}

// TableName overrides the default tablename generated by GORM
func (TransactionLineItemORM) TableName() string {
	return "transaction_line_items"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TransactionLineItem) ToORM(ctx context.Context) (TransactionLineItemORM, error) {
	to := TransactionLineItemORM{}
	var err error
	if prehook, ok := interface{}(m).(TransactionLineItemWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Memo = m.Memo
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TotalLineAmount = m.TotalLineAmount
	to.TaxRate = m.TaxRate
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(TransactionLineItemWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TransactionLineItemORM) ToPB(ctx context.Context) (TransactionLineItem, error) {
	to := TransactionLineItem{}
	var err error
	if prehook, ok := interface{}(m).(TransactionLineItemWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Memo = m.Memo
	to.UnitPrice = m.UnitPrice
	to.Quantity = m.Quantity
	to.Item = m.Item
	to.Account = m.Account
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.TotalLineAmount = m.TotalLineAmount
	to.TaxRate = m.TaxRate
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(TransactionLineItemWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TransactionLineItem the arg will be the target, the caller the one being converted from

// TransactionLineItemBeforeToORM called before default ToORM code
type TransactionLineItemWithBeforeToORM interface {
	BeforeToORM(context.Context, *TransactionLineItemORM) error
}

// TransactionLineItemAfterToORM called after default ToORM code
type TransactionLineItemWithAfterToORM interface {
	AfterToORM(context.Context, *TransactionLineItemORM) error
}

// TransactionLineItemBeforeToPB called before default ToPB code
type TransactionLineItemWithBeforeToPB interface {
	BeforeToPB(context.Context, *TransactionLineItem) error
}

// TransactionLineItemAfterToPB called after default ToPB code
type TransactionLineItemWithAfterToPB interface {
	AfterToPB(context.Context, *TransactionLineItem) error
}

type VendorCreditORM struct {
	AccountingPeriod     string
	Company              string
	Currency             string
	ExchangeRate         string
	Id                   uint64
	Lines                []*VendorCreditLineORM `gorm:"foreignkey:VendorCreditId;association_foreignkey:Id"`
	MergeAccountId       string
	ModifiedAt           *time.Time
	Number               string
	RemoteId             string
	RemoteWasDeleted     bool
	TotalAmount          float64
	TrackingCategories   pq.StringArray `gorm:"type:text[]"`
	TransactionDate      *time.Time
	TransactionDetailsId *uint64
	Vendor               string
}

// TableName overrides the default tablename generated by GORM
func (VendorCreditORM) TableName() string {
	return "vendor_credits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VendorCredit) ToORM(ctx context.Context) (VendorCreditORM, error) {
	to := VendorCreditORM{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Number = m.Number
	if m.TransactionDate != nil {
		t := m.TransactionDate.AsTime()
		to.TransactionDate = &t
	}
	to.Vendor = m.Vendor
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToORM(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VendorCreditORM) ToPB(ctx context.Context) (VendorCredit, error) {
	to := VendorCredit{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.MergeAccountId = m.MergeAccountId
	to.RemoteId = m.RemoteId
	to.Number = m.Number
	if m.TransactionDate != nil {
		to.TransactionDate = timestamppb.New(*m.TransactionDate)
	}
	to.Vendor = m.Vendor
	to.TotalAmount = m.TotalAmount
	to.Currency = m.Currency
	to.ExchangeRate = m.ExchangeRate
	to.Company = m.Company
	for _, v := range m.Lines {
		if v != nil {
			if tempLines, cErr := v.ToPB(ctx); cErr == nil {
				to.Lines = append(to.Lines, &tempLines)
			} else {
				return to, cErr
			}
		} else {
			to.Lines = append(to.Lines, nil)
		}
	}
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	to.AccountingPeriod = m.AccountingPeriod
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VendorCredit the arg will be the target, the caller the one being converted from

// VendorCreditBeforeToORM called before default ToORM code
type VendorCreditWithBeforeToORM interface {
	BeforeToORM(context.Context, *VendorCreditORM) error
}

// VendorCreditAfterToORM called after default ToORM code
type VendorCreditWithAfterToORM interface {
	AfterToORM(context.Context, *VendorCreditORM) error
}

// VendorCreditBeforeToPB called before default ToPB code
type VendorCreditWithBeforeToPB interface {
	BeforeToPB(context.Context, *VendorCredit) error
}

// VendorCreditAfterToPB called after default ToPB code
type VendorCreditWithAfterToPB interface {
	AfterToPB(context.Context, *VendorCredit) error
}

type VendorCreditLineORM struct {
	Account            string
	Company            string
	Description        string
	ExchangeRate       string
	Id                 uint64
	ModifiedAt         *time.Time
	NetAmount          float64
	RemoteId           string
	TrackingCategories pq.StringArray `gorm:"type:text[]"`
	TrackingCategory   string
	VendorCreditId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (VendorCreditLineORM) TableName() string {
	return "vendor_credit_lines"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VendorCreditLine) ToORM(ctx context.Context) (VendorCreditLineORM, error) {
	to := VendorCreditLineORM{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditLineWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.RemoteId = m.RemoteId
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Description = m.Description
	to.Account = m.Account
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditLineWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VendorCreditLineORM) ToPB(ctx context.Context) (VendorCreditLine, error) {
	to := VendorCreditLine{}
	var err error
	if prehook, ok := interface{}(m).(VendorCreditLineWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.RemoteId = m.RemoteId
	to.NetAmount = m.NetAmount
	to.TrackingCategory = m.TrackingCategory
	if m.TrackingCategories != nil {
		to.TrackingCategories = make(pq.StringArray, len(m.TrackingCategories))
		copy(to.TrackingCategories, m.TrackingCategories)
	}
	to.Description = m.Description
	to.Account = m.Account
	to.Company = m.Company
	to.ExchangeRate = m.ExchangeRate
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(VendorCreditLineWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VendorCreditLine the arg will be the target, the caller the one being converted from

// VendorCreditLineBeforeToORM called before default ToORM code
type VendorCreditLineWithBeforeToORM interface {
	BeforeToORM(context.Context, *VendorCreditLineORM) error
}

// VendorCreditLineAfterToORM called after default ToORM code
type VendorCreditLineWithAfterToORM interface {
	AfterToORM(context.Context, *VendorCreditLineORM) error
}

// VendorCreditLineBeforeToPB called before default ToPB code
type VendorCreditLineWithBeforeToPB interface {
	BeforeToPB(context.Context, *VendorCreditLine) error
}

// VendorCreditLineAfterToPB called after default ToPB code
type VendorCreditLineWithAfterToPB interface {
	AfterToPB(context.Context, *VendorCreditLine) error
}

// DefaultCreateBusinessAccountingProfile executes a basic gorm create call
func DefaultCreateBusinessAccountingProfile(ctx context.Context, in *BusinessAccountingProfile, db *gorm.DB) (*BusinessAccountingProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountingProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessAccountingProfile(ctx context.Context, in *BusinessAccountingProfile, db *gorm.DB) (*BusinessAccountingProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessAccountingProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessAccountingProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessAccountingProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountingProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountingProfile(ctx context.Context, in *BusinessAccountingProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessAccountingProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessAccountingProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountingProfileSet(ctx context.Context, in []*BusinessAccountingProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessAccountingProfileORM{})).(BusinessAccountingProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessAccountingProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessAccountingProfileORM{})).(BusinessAccountingProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessAccountingProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessAccountingProfile, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessAccountingProfile, *gorm.DB) error
}

// DefaultStrictUpdateBusinessAccountingProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessAccountingProfile(ctx context.Context, in *BusinessAccountingProfile, db *gorm.DB) (*BusinessAccountingProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessAccountingProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessAccountingProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccountingIntegrationMergeLink := AccountingIntegrationMergeLinkORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccountingIntegrationMergeLink.BusinessAccountingProfileId = new(uint64)
	*filterAccountingIntegrationMergeLink.BusinessAccountingProfileId = ormObj.Id
	if err = db.Where(filterAccountingIntegrationMergeLink).Delete(AccountingIntegrationMergeLinkORM{}).Error; err != nil {
		return nil, err
	}
	filterActionablePersonalInsights := BusinessActionableInsightORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterActionablePersonalInsights.BusinessAccountingProfileId = new(uint64)
	*filterActionablePersonalInsights.BusinessAccountingProfileId = ormObj.Id
	if err = db.Where(filterActionablePersonalInsights).Delete(BusinessActionableInsightORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessAccountingProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessAccountingProfile executes a basic gorm update call with patch behavior
func DefaultPatchBusinessAccountingProfile(ctx context.Context, in *BusinessAccountingProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessAccountingProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessAccountingProfile
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessAccountingProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessAccountingProfile(ctx, &BusinessAccountingProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessAccountingProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessAccountingProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessAccountingProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessAccountingProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessAccountingProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessAccountingProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessAccountingProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessAccountingProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessAccountingProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessAccountingProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessAccountingProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessAccountingProfile(ctx context.Context, objects []*BusinessAccountingProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessAccountingProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessAccountingProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessAccountingProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessAccountingProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessAccountingProfile(ctx context.Context, patchee *BusinessAccountingProfile, patcher *BusinessAccountingProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessAccountingProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"AccountingIntegrationMergeLink" {
			patchee.AccountingIntegrationMergeLink = patcher.AccountingIntegrationMergeLink
			continue
		}
		if f == prefix+"ActionablePersonalInsights" {
			patchee.ActionablePersonalInsights = patcher.ActionablePersonalInsights
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessAccountingProfile executes a gorm list call
func DefaultListBusinessAccountingProfile(ctx context.Context, db *gorm.DB) ([]*BusinessAccountingProfile, error) {
	in := BusinessAccountingProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessAccountingProfileORM{}, &BusinessAccountingProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessAccountingProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountingProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessAccountingProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessAccountingProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountingProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessAccountingProfileORM) error
}

// DefaultCreateBusinessActionableInsight executes a basic gorm create call
func DefaultCreateBusinessActionableInsight(ctx context.Context, in *BusinessActionableInsight, db *gorm.DB) (*BusinessActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessActionableInsightORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessActionableInsight(ctx context.Context, in *BusinessActionableInsight, db *gorm.DB) (*BusinessActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessActionableInsightORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessActionableInsightORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessActionableInsightORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessActionableInsightORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessActionableInsight(ctx context.Context, in *BusinessActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessActionableInsightORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessActionableInsightSet(ctx context.Context, in []*BusinessActionableInsight, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessActionableInsightORM{})).(BusinessActionableInsightORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessActionableInsightORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessActionableInsightORM{})).(BusinessActionableInsightORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessActionableInsightORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessActionableInsight, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessActionableInsight, *gorm.DB) error
}

// DefaultStrictUpdateBusinessActionableInsight clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessActionableInsight(ctx context.Context, in *BusinessActionableInsight, db *gorm.DB) (*BusinessActionableInsight, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessActionableInsight")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessActionableInsightORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessActionableInsightORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessActionableInsight executes a basic gorm update call with patch behavior
func DefaultPatchBusinessActionableInsight(ctx context.Context, in *BusinessActionableInsight, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessActionableInsight, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessActionableInsight
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessActionableInsightWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessActionableInsight(ctx, &BusinessActionableInsight{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessActionableInsightWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessActionableInsight(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessActionableInsightWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessActionableInsight(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessActionableInsightWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessActionableInsightWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessActionableInsight, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessActionableInsight, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessActionableInsight executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessActionableInsight(ctx context.Context, objects []*BusinessActionableInsight, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessActionableInsight, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessActionableInsight, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessActionableInsight(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessActionableInsight patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessActionableInsight(ctx context.Context, patchee *BusinessActionableInsight, patcher *BusinessActionableInsight, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessActionableInsight, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedGeneratedTime bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"InsightName" {
			patchee.InsightName = patcher.InsightName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Takeaway" {
			patchee.Takeaway = patcher.Takeaway
			continue
		}
		if f == prefix+"Action" {
			patchee.Action = patcher.Action
			continue
		}
		if f == prefix+"ExpectedBenefit" {
			patchee.ExpectedBenefit = patcher.ExpectedBenefit
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if !updatedGeneratedTime && strings.HasPrefix(f, prefix+"GeneratedTime.") {
			if patcher.GeneratedTime == nil {
				patchee.GeneratedTime = nil
				continue
			}
			if patchee.GeneratedTime == nil {
				patchee.GeneratedTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"GeneratedTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.GeneratedTime, patchee.GeneratedTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"GeneratedTime" {
			updatedGeneratedTime = true
			patchee.GeneratedTime = patcher.GeneratedTime
			continue
		}
		if f == prefix+"MetricsToOptimizeFor" {
			patchee.MetricsToOptimizeFor = patcher.MetricsToOptimizeFor
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessActionableInsight executes a gorm list call
func DefaultListBusinessActionableInsight(ctx context.Context, db *gorm.DB) ([]*BusinessActionableInsight, error) {
	in := BusinessActionableInsight{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessActionableInsightORM{}, &BusinessActionableInsight{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessActionableInsightORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessActionableInsightORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessActionableInsight{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessActionableInsightORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessActionableInsightORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessActionableInsightORM) error
}

// DefaultCreateMergeLinkedAccountToken executes a basic gorm create call
func DefaultCreateMergeLinkedAccountToken(ctx context.Context, in *MergeLinkedAccountToken, db *gorm.DB) (*MergeLinkedAccountToken, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MergeLinkedAccountTokenORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMergeLinkedAccountToken(ctx context.Context, in *MergeLinkedAccountToken, db *gorm.DB) (*MergeLinkedAccountToken, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MergeLinkedAccountTokenORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MergeLinkedAccountTokenORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MergeLinkedAccountTokenORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MergeLinkedAccountTokenORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMergeLinkedAccountToken(ctx context.Context, in *MergeLinkedAccountToken, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MergeLinkedAccountTokenORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MergeLinkedAccountTokenORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMergeLinkedAccountTokenSet(ctx context.Context, in []*MergeLinkedAccountToken, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MergeLinkedAccountTokenORM{})).(MergeLinkedAccountTokenORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MergeLinkedAccountTokenORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MergeLinkedAccountTokenORM{})).(MergeLinkedAccountTokenORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MergeLinkedAccountTokenORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MergeLinkedAccountToken, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MergeLinkedAccountToken, *gorm.DB) error
}

// DefaultStrictUpdateMergeLinkedAccountToken clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMergeLinkedAccountToken(ctx context.Context, in *MergeLinkedAccountToken, db *gorm.DB) (*MergeLinkedAccountToken, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMergeLinkedAccountToken")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MergeLinkedAccountTokenORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MergeLinkedAccountTokenORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMergeLinkedAccountToken executes a basic gorm update call with patch behavior
func DefaultPatchMergeLinkedAccountToken(ctx context.Context, in *MergeLinkedAccountToken, updateMask *field_mask.FieldMask, db *gorm.DB) (*MergeLinkedAccountToken, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MergeLinkedAccountToken
	var err error
	if hook, ok := interface{}(&pbObj).(MergeLinkedAccountTokenWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMergeLinkedAccountToken(ctx, &MergeLinkedAccountToken{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MergeLinkedAccountTokenWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMergeLinkedAccountToken(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MergeLinkedAccountTokenWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMergeLinkedAccountToken(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MergeLinkedAccountTokenWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MergeLinkedAccountTokenWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MergeLinkedAccountToken, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MergeLinkedAccountToken, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MergeLinkedAccountToken, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MergeLinkedAccountToken, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMergeLinkedAccountToken executes a bulk gorm update call with patch behavior
func DefaultPatchSetMergeLinkedAccountToken(ctx context.Context, objects []*MergeLinkedAccountToken, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MergeLinkedAccountToken, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MergeLinkedAccountToken, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMergeLinkedAccountToken(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMergeLinkedAccountToken patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMergeLinkedAccountToken(ctx context.Context, patchee *MergeLinkedAccountToken, patcher *MergeLinkedAccountToken, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MergeLinkedAccountToken, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ItemId" {
			patchee.ItemId = patcher.ItemId
			continue
		}
		if f == prefix+"KeyId" {
			patchee.KeyId = patcher.KeyId
			continue
		}
		if f == prefix+"AccessToken" {
			patchee.AccessToken = patcher.AccessToken
			continue
		}
		if f == prefix+"Version" {
			patchee.Version = patcher.Version
			continue
		}
		if f == prefix+"MergeEndUserOriginId" {
			patchee.MergeEndUserOriginId = patcher.MergeEndUserOriginId
			continue
		}
		if f == prefix+"MergeIntegrationSlug" {
			patchee.MergeIntegrationSlug = patcher.MergeIntegrationSlug
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMergeLinkedAccountToken executes a gorm list call
func DefaultListMergeLinkedAccountToken(ctx context.Context, db *gorm.DB) ([]*MergeLinkedAccountToken, error) {
	in := MergeLinkedAccountToken{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MergeLinkedAccountTokenORM{}, &MergeLinkedAccountToken{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MergeLinkedAccountTokenORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MergeLinkedAccountTokenORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MergeLinkedAccountToken{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MergeLinkedAccountTokenORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MergeLinkedAccountTokenORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MergeLinkedAccountTokenORM) error
}

// DefaultCreateCategory executes a basic gorm create call
func DefaultCreateCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CategoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CategoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CategoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CategoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CategoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCategory(ctx context.Context, in *Category, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CategoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCategorySet(ctx context.Context, in []*Category, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CategoryORM{})).(CategoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CategoryORM{})).(CategoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CategoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Category, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Category, *gorm.DB) error
}

// DefaultStrictUpdateCategory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCategory(ctx context.Context, in *Category, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCategory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CategoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CategoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCategory executes a basic gorm update call with patch behavior
func DefaultPatchCategory(ctx context.Context, in *Category, updateMask *field_mask.FieldMask, db *gorm.DB) (*Category, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Category
	var err error
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCategory(ctx, &Category{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCategory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CategoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCategory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CategoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CategoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CategoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Category, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCategory executes a bulk gorm update call with patch behavior
func DefaultPatchSetCategory(ctx context.Context, objects []*Category, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Category, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Category, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCategory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCategory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCategory(ctx context.Context, patchee *Category, patcher *Category, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Category, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Subcategories" {
			patchee.Subcategories = patcher.Subcategories
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCategory executes a gorm list call
func DefaultListCategory(ctx context.Context, db *gorm.DB) ([]*Category, error) {
	in := Category{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CategoryORM{}, &Category{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CategoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CategoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Category{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CategoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CategoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CategoryORM) error
}

// DefaultCreateAccountingIntegrationMergeLink executes a basic gorm create call
func DefaultCreateAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountingIntegrationMergeLinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountingIntegrationMergeLinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountingIntegrationMergeLinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountingIntegrationMergeLinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountingIntegrationMergeLinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountingIntegrationMergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountingIntegrationMergeLinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingIntegrationMergeLinkSet(ctx context.Context, in []*AccountingIntegrationMergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountingIntegrationMergeLinkORM{})).(AccountingIntegrationMergeLinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountingIntegrationMergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountingIntegrationMergeLinkORM{})).(AccountingIntegrationMergeLinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountingIntegrationMergeLinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountingIntegrationMergeLink, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountingIntegrationMergeLink, *gorm.DB) error
}

// DefaultStrictUpdateAccountingIntegrationMergeLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountingIntegrationMergeLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountingIntegrationMergeLinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccount := LinkedAccountingAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccount.AccountingIntegrationMergeLinkId = new(uint64)
	*filterAccount.AccountingIntegrationMergeLinkId = ormObj.Id
	if err = db.Where(filterAccount).Delete(LinkedAccountingAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterToken := MergeLinkedAccountTokenORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterToken.AccountingIntegrationMergeLinkId = new(uint64)
	*filterToken.AccountingIntegrationMergeLinkId = ormObj.Id
	if err = db.Where(filterToken).Delete(MergeLinkedAccountTokenORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountingIntegrationMergeLink executes a basic gorm update call with patch behavior
func DefaultPatchAccountingIntegrationMergeLink(ctx context.Context, in *AccountingIntegrationMergeLink, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountingIntegrationMergeLink
	var err error
	if hook, ok := interface{}(&pbObj).(AccountingIntegrationMergeLinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountingIntegrationMergeLink(ctx, &AccountingIntegrationMergeLink{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountingIntegrationMergeLinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountingIntegrationMergeLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountingIntegrationMergeLinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountingIntegrationMergeLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountingIntegrationMergeLinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountingIntegrationMergeLinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountingIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountingIntegrationMergeLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountingIntegrationMergeLink(ctx context.Context, objects []*AccountingIntegrationMergeLink, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountingIntegrationMergeLink, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountingIntegrationMergeLink, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountingIntegrationMergeLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountingIntegrationMergeLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountingIntegrationMergeLink(ctx context.Context, patchee *AccountingIntegrationMergeLink, patcher *AccountingIntegrationMergeLink, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountingIntegrationMergeLink, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedToken bool
	var updatedAccount bool
	var updatedLastModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Integration" {
			patchee.Integration = patcher.Integration
			continue
		}
		if f == prefix+"IntegrationSlug" {
			patchee.IntegrationSlug = patcher.IntegrationSlug
			continue
		}
		if f == prefix+"Category" {
			patchee.Category = patcher.Category
			continue
		}
		if f == prefix+"EndUserOriginId" {
			patchee.EndUserOriginId = patcher.EndUserOriginId
			continue
		}
		if f == prefix+"EndUserOrganizationName" {
			patchee.EndUserOrganizationName = patcher.EndUserOrganizationName
			continue
		}
		if f == prefix+"EndUserEmailAddress" {
			patchee.EndUserEmailAddress = patcher.EndUserEmailAddress
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"WebhookListenerUrl" {
			patchee.WebhookListenerUrl = patcher.WebhookListenerUrl
			continue
		}
		if f == prefix+"IsDuplicate" {
			patchee.IsDuplicate = patcher.IsDuplicate
			continue
		}
		if !updatedToken && strings.HasPrefix(f, prefix+"Token.") {
			updatedToken = true
			if patcher.Token == nil {
				patchee.Token = nil
				continue
			}
			if patchee.Token == nil {
				patchee.Token = &MergeLinkedAccountToken{}
			}
			if o, err := DefaultApplyFieldMaskMergeLinkedAccountToken(ctx, patchee.Token, patcher.Token, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Token.", db); err != nil {
				return nil, err
			} else {
				patchee.Token = o
			}
			continue
		}
		if f == prefix+"Token" {
			updatedToken = true
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"IntegrationName" {
			patchee.IntegrationName = patcher.IntegrationName
			continue
		}
		if f == prefix+"IntegrationImage" {
			patchee.IntegrationImage = patcher.IntegrationImage
			continue
		}
		if f == prefix+"IntegrationSquareImage" {
			patchee.IntegrationSquareImage = patcher.IntegrationSquareImage
			continue
		}
		if !updatedAccount && strings.HasPrefix(f, prefix+"Account.") {
			updatedAccount = true
			if patcher.Account == nil {
				patchee.Account = nil
				continue
			}
			if patchee.Account == nil {
				patchee.Account = &LinkedAccountingAccount{}
			}
			if o, err := DefaultApplyFieldMaskLinkedAccountingAccount(ctx, patchee.Account, patcher.Account, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Account.", db); err != nil {
				return nil, err
			} else {
				patchee.Account = o
			}
			continue
		}
		if f == prefix+"Account" {
			updatedAccount = true
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"MergeLinkedAccountId" {
			patchee.MergeLinkedAccountId = patcher.MergeLinkedAccountId
			continue
		}
		if !updatedLastModifiedAt && strings.HasPrefix(f, prefix+"LastModifiedAt.") {
			if patcher.LastModifiedAt == nil {
				patchee.LastModifiedAt = nil
				continue
			}
			if patchee.LastModifiedAt == nil {
				patchee.LastModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastModifiedAt, patchee.LastModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastModifiedAt" {
			updatedLastModifiedAt = true
			patchee.LastModifiedAt = patcher.LastModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountingIntegrationMergeLink executes a gorm list call
func DefaultListAccountingIntegrationMergeLink(ctx context.Context, db *gorm.DB) ([]*AccountingIntegrationMergeLink, error) {
	in := AccountingIntegrationMergeLink{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountingIntegrationMergeLinkORM{}, &AccountingIntegrationMergeLink{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountingIntegrationMergeLinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingIntegrationMergeLinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountingIntegrationMergeLink{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountingIntegrationMergeLinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingIntegrationMergeLinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountingIntegrationMergeLinkORM) error
}

// DefaultCreateLinkedAccountingAccount executes a basic gorm create call
func DefaultCreateLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LinkedAccountingAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LinkedAccountingAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LinkedAccountingAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LinkedAccountingAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LinkedAccountingAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLinkedAccountingAccountSet(ctx context.Context, in []*LinkedAccountingAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LinkedAccountingAccountORM{})).(LinkedAccountingAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LinkedAccountingAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LinkedAccountingAccountORM{})).(LinkedAccountingAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LinkedAccountingAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LinkedAccountingAccount, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LinkedAccountingAccount, *gorm.DB) error
}

// DefaultStrictUpdateLinkedAccountingAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLinkedAccountingAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LinkedAccountingAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAttachments := AttachmentsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAttachments.LinkedAccountingAccountId = new(uint64)
	*filterAttachments.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterAttachments).Delete(AttachmentsORM{}).Error; err != nil {
		return nil, err
	}
	filterCompanyInfo := CompanyInfoORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCompanyInfo.LinkedAccountingAccountId = new(uint64)
	*filterCompanyInfo.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterCompanyInfo).Delete(CompanyInfoORM{}).Error; err != nil {
		return nil, err
	}
	filterPurchaseOrders := PurchaseOrderORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPurchaseOrders.LinkedAccountingAccountId = new(uint64)
	*filterPurchaseOrders.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterPurchaseOrders).Delete(PurchaseOrderORM{}).Error; err != nil {
		return nil, err
	}
	filterReferenceDetails := ReferenceDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterReferenceDetails.LinkedAccountingAccountId = new(uint64)
	*filterReferenceDetails.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterReferenceDetails).Delete(ReferenceDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterReportDetails := ReportDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterReportDetails.LinkedAccountingAccountId = new(uint64)
	*filterReportDetails.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterReportDetails).Delete(ReportDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactionsDetails := TransactionDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactionsDetails.LinkedAccountingAccountId = new(uint64)
	*filterTransactionsDetails.LinkedAccountingAccountId = ormObj.Id
	if err = db.Where(filterTransactionsDetails).Delete(TransactionDetailsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LinkedAccountingAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLinkedAccountingAccount executes a basic gorm update call with patch behavior
func DefaultPatchLinkedAccountingAccount(ctx context.Context, in *LinkedAccountingAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LinkedAccountingAccount
	var err error
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLinkedAccountingAccount(ctx, &LinkedAccountingAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLinkedAccountingAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LinkedAccountingAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLinkedAccountingAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LinkedAccountingAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LinkedAccountingAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LinkedAccountingAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLinkedAccountingAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetLinkedAccountingAccount(ctx context.Context, objects []*LinkedAccountingAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LinkedAccountingAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LinkedAccountingAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLinkedAccountingAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLinkedAccountingAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLinkedAccountingAccount(ctx context.Context, patchee *LinkedAccountingAccount, patcher *LinkedAccountingAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LinkedAccountingAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedReportDetails bool
	var updatedReferenceDetails bool
	var updatedTransactionsDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Attachments" {
			patchee.Attachments = patcher.Attachments
			continue
		}
		if f == prefix+"CompanyInfo" {
			patchee.CompanyInfo = patcher.CompanyInfo
			continue
		}
		if f == prefix+"PurchaseOrders" {
			patchee.PurchaseOrders = patcher.PurchaseOrders
			continue
		}
		if !updatedReportDetails && strings.HasPrefix(f, prefix+"ReportDetails.") {
			updatedReportDetails = true
			if patcher.ReportDetails == nil {
				patchee.ReportDetails = nil
				continue
			}
			if patchee.ReportDetails == nil {
				patchee.ReportDetails = &ReportDetails{}
			}
			if o, err := DefaultApplyFieldMaskReportDetails(ctx, patchee.ReportDetails, patcher.ReportDetails, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ReportDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.ReportDetails = o
			}
			continue
		}
		if f == prefix+"ReportDetails" {
			updatedReportDetails = true
			patchee.ReportDetails = patcher.ReportDetails
			continue
		}
		if !updatedReferenceDetails && strings.HasPrefix(f, prefix+"ReferenceDetails.") {
			updatedReferenceDetails = true
			if patcher.ReferenceDetails == nil {
				patchee.ReferenceDetails = nil
				continue
			}
			if patchee.ReferenceDetails == nil {
				patchee.ReferenceDetails = &ReferenceDetails{}
			}
			if o, err := DefaultApplyFieldMaskReferenceDetails(ctx, patchee.ReferenceDetails, patcher.ReferenceDetails, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ReferenceDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.ReferenceDetails = o
			}
			continue
		}
		if f == prefix+"ReferenceDetails" {
			updatedReferenceDetails = true
			patchee.ReferenceDetails = patcher.ReferenceDetails
			continue
		}
		if !updatedTransactionsDetails && strings.HasPrefix(f, prefix+"TransactionsDetails.") {
			updatedTransactionsDetails = true
			if patcher.TransactionsDetails == nil {
				patchee.TransactionsDetails = nil
				continue
			}
			if patchee.TransactionsDetails == nil {
				patchee.TransactionsDetails = &TransactionDetails{}
			}
			if o, err := DefaultApplyFieldMaskTransactionDetails(ctx, patchee.TransactionsDetails, patcher.TransactionsDetails, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TransactionsDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.TransactionsDetails = o
			}
			continue
		}
		if f == prefix+"TransactionsDetails" {
			updatedTransactionsDetails = true
			patchee.TransactionsDetails = patcher.TransactionsDetails
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLinkedAccountingAccount executes a gorm list call
func DefaultListLinkedAccountingAccount(ctx context.Context, db *gorm.DB) ([]*LinkedAccountingAccount, error) {
	in := LinkedAccountingAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LinkedAccountingAccountORM{}, &LinkedAccountingAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LinkedAccountingAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LinkedAccountingAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LinkedAccountingAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LinkedAccountingAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LinkedAccountingAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LinkedAccountingAccountORM) error
}

// DefaultCreateTransactionDetails executes a basic gorm create call
func DefaultCreateTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionDetailsSet(ctx context.Context, in []*TransactionDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionDetailsORM{})).(TransactionDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionDetailsORM{})).(TransactionDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionDetails, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionDetails, *gorm.DB) error
}

// DefaultStrictUpdateTransactionDetails clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionDetails(ctx context.Context, in *TransactionDetails, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCreditNotes := CreditNoteORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCreditNotes.TransactionDetailsId = new(uint64)
	*filterCreditNotes.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterCreditNotes).Delete(CreditNoteORM{}).Error; err != nil {
		return nil, err
	}
	filterExpenses := ExpenseORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterExpenses.TransactionDetailsId = new(uint64)
	*filterExpenses.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterExpenses).Delete(ExpenseORM{}).Error; err != nil {
		return nil, err
	}
	filterInvoices := InvoiceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvoices.TransactionDetailsId = new(uint64)
	*filterInvoices.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterInvoices).Delete(InvoiceORM{}).Error; err != nil {
		return nil, err
	}
	filterJournalEntries := JournalEntryORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterJournalEntries.TransactionDetailsId = new(uint64)
	*filterJournalEntries.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterJournalEntries).Delete(JournalEntryORM{}).Error; err != nil {
		return nil, err
	}
	filterPayments := PaymentORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayments.TransactionDetailsId = new(uint64)
	*filterPayments.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterPayments).Delete(PaymentORM{}).Error; err != nil {
		return nil, err
	}
	filterTransactions := BusinessTransactionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTransactions.TransactionDetailsId = new(uint64)
	*filterTransactions.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterTransactions).Delete(BusinessTransactionORM{}).Error; err != nil {
		return nil, err
	}
	filterVendorCredits := VendorCreditORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterVendorCredits.TransactionDetailsId = new(uint64)
	*filterVendorCredits.TransactionDetailsId = ormObj.Id
	if err = db.Where(filterVendorCredits).Delete(VendorCreditORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionDetails executes a basic gorm update call with patch behavior
func DefaultPatchTransactionDetails(ctx context.Context, in *TransactionDetails, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionDetails
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionDetails(ctx, &TransactionDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionDetails, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionDetails(ctx context.Context, objects []*TransactionDetails, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionDetails(ctx context.Context, patchee *TransactionDetails, patcher *TransactionDetails, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Invoices" {
			patchee.Invoices = patcher.Invoices
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"Expenses" {
			patchee.Expenses = patcher.Expenses
			continue
		}
		if f == prefix+"JournalEntries" {
			patchee.JournalEntries = patcher.JournalEntries
			continue
		}
		if f == prefix+"Transactions" {
			patchee.Transactions = patcher.Transactions
			continue
		}
		if f == prefix+"VendorCredits" {
			patchee.VendorCredits = patcher.VendorCredits
			continue
		}
		if f == prefix+"CreditNotes" {
			patchee.CreditNotes = patcher.CreditNotes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionDetails executes a gorm list call
func DefaultListTransactionDetails(ctx context.Context, db *gorm.DB) ([]*TransactionDetails, error) {
	in := TransactionDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionDetailsORM{}, &TransactionDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionDetailsORM) error
}

// DefaultCreateReferenceDetails executes a basic gorm create call
func DefaultCreateReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReferenceDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReferenceDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReferenceDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReferenceDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReferenceDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReferenceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReferenceDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReferenceDetailsSet(ctx context.Context, in []*ReferenceDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReferenceDetailsORM{})).(ReferenceDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReferenceDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReferenceDetailsORM{})).(ReferenceDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReferenceDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReferenceDetails, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReferenceDetails, *gorm.DB) error
}

// DefaultStrictUpdateReferenceDetails clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReferenceDetails(ctx context.Context, in *ReferenceDetails, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReferenceDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReferenceDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterChartOfAccounts := BusinessChartOfAccountsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterChartOfAccounts.ReferenceDetailsId = new(uint64)
	*filterChartOfAccounts.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterChartOfAccounts).Delete(BusinessChartOfAccountsORM{}).Error; err != nil {
		return nil, err
	}
	filterContacts := ContactsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterContacts.ReferenceDetailsId = new(uint64)
	*filterContacts.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterContacts).Delete(ContactsORM{}).Error; err != nil {
		return nil, err
	}
	filterItems := ItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterItems.ReferenceDetailsId = new(uint64)
	*filterItems.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterItems).Delete(ItemORM{}).Error; err != nil {
		return nil, err
	}
	filterTaxRates := TaxRateORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTaxRates.ReferenceDetailsId = new(uint64)
	*filterTaxRates.ReferenceDetailsId = ormObj.Id
	if err = db.Where(filterTaxRates).Delete(TaxRateORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReferenceDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReferenceDetails executes a basic gorm update call with patch behavior
func DefaultPatchReferenceDetails(ctx context.Context, in *ReferenceDetails, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReferenceDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReferenceDetails
	var err error
	if hook, ok := interface{}(&pbObj).(ReferenceDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReferenceDetails(ctx, &ReferenceDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReferenceDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReferenceDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReferenceDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReferenceDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReferenceDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReferenceDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReferenceDetails, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReferenceDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetReferenceDetails(ctx context.Context, objects []*ReferenceDetails, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReferenceDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReferenceDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReferenceDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReferenceDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReferenceDetails(ctx context.Context, patchee *ReferenceDetails, patcher *ReferenceDetails, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReferenceDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ChartOfAccounts" {
			patchee.ChartOfAccounts = patcher.ChartOfAccounts
			continue
		}
		if f == prefix+"Items" {
			patchee.Items = patcher.Items
			continue
		}
		if f == prefix+"TaxRates" {
			patchee.TaxRates = patcher.TaxRates
			continue
		}
		if f == prefix+"Contacts" {
			patchee.Contacts = patcher.Contacts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReferenceDetails executes a gorm list call
func DefaultListReferenceDetails(ctx context.Context, db *gorm.DB) ([]*ReferenceDetails, error) {
	in := ReferenceDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReferenceDetailsORM{}, &ReferenceDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReferenceDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReferenceDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReferenceDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReferenceDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReferenceDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReferenceDetailsORM) error
}

// DefaultCreateReportDetails executes a basic gorm create call
func DefaultCreateReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReportDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReportDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReportDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReportDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReportDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReportDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReportDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReportDetailsSet(ctx context.Context, in []*ReportDetails, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReportDetailsORM{})).(ReportDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReportDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReportDetailsORM{})).(ReportDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReportDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReportDetails, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReportDetails, *gorm.DB) error
}

// DefaultStrictUpdateReportDetails clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReportDetails(ctx context.Context, in *ReportDetails, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReportDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReportDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBalanceSheets := BalanceSheetORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBalanceSheets.ReportDetailsId = new(uint64)
	*filterBalanceSheets.ReportDetailsId = ormObj.Id
	if err = db.Where(filterBalanceSheets).Delete(BalanceSheetORM{}).Error; err != nil {
		return nil, err
	}
	filterCashFlowStatements := CashFlowStatementsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCashFlowStatements.ReportDetailsId = new(uint64)
	*filterCashFlowStatements.ReportDetailsId = ormObj.Id
	if err = db.Where(filterCashFlowStatements).Delete(CashFlowStatementsORM{}).Error; err != nil {
		return nil, err
	}
	filterIncomeStatements := IncomeStatementORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIncomeStatements.ReportDetailsId = new(uint64)
	*filterIncomeStatements.ReportDetailsId = ormObj.Id
	if err = db.Where(filterIncomeStatements).Delete(IncomeStatementORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReportDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReportDetails executes a basic gorm update call with patch behavior
func DefaultPatchReportDetails(ctx context.Context, in *ReportDetails, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReportDetails, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReportDetails
	var err error
	if hook, ok := interface{}(&pbObj).(ReportDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReportDetails(ctx, &ReportDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReportDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReportDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReportDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReportDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReportDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReportDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReportDetails, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReportDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetReportDetails(ctx context.Context, objects []*ReportDetails, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReportDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReportDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReportDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReportDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReportDetails(ctx context.Context, patchee *ReportDetails, patcher *ReportDetails, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReportDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"BalanceSheets" {
			patchee.BalanceSheets = patcher.BalanceSheets
			continue
		}
		if f == prefix+"CashFlowStatements" {
			patchee.CashFlowStatements = patcher.CashFlowStatements
			continue
		}
		if f == prefix+"IncomeStatements" {
			patchee.IncomeStatements = patcher.IncomeStatements
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReportDetails executes a gorm list call
func DefaultListReportDetails(ctx context.Context, db *gorm.DB) ([]*ReportDetails, error) {
	in := ReportDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReportDetailsORM{}, &ReportDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReportDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReportDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReportDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReportDetailsORM) error
}

// DefaultCreateBusinessChartOfAccounts executes a basic gorm create call
func DefaultCreateBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessChartOfAccountsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessChartOfAccountsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessChartOfAccountsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessChartOfAccountsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessChartOfAccountsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessChartOfAccountsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessChartOfAccountsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessChartOfAccountsSet(ctx context.Context, in []*BusinessChartOfAccounts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessChartOfAccountsORM{})).(BusinessChartOfAccountsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessChartOfAccountsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessChartOfAccountsORM{})).(BusinessChartOfAccountsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessChartOfAccountsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessChartOfAccounts, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessChartOfAccounts, *gorm.DB) error
}

// DefaultStrictUpdateBusinessChartOfAccounts clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessChartOfAccounts")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessChartOfAccountsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessChartOfAccountsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessChartOfAccounts executes a basic gorm update call with patch behavior
func DefaultPatchBusinessChartOfAccounts(ctx context.Context, in *BusinessChartOfAccounts, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessChartOfAccounts
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessChartOfAccounts(ctx, &BusinessChartOfAccounts{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessChartOfAccounts(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessChartOfAccountsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessChartOfAccounts(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessChartOfAccountsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessChartOfAccountsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessChartOfAccounts, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessChartOfAccounts executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessChartOfAccounts(ctx context.Context, objects []*BusinessChartOfAccounts, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessChartOfAccounts, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessChartOfAccounts, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessChartOfAccounts(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessChartOfAccounts patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessChartOfAccounts(ctx context.Context, patchee *BusinessChartOfAccounts, patcher *BusinessChartOfAccounts, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessChartOfAccounts, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Classification" {
			patchee.Classification = patcher.Classification
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"CurrentBalance" {
			patchee.CurrentBalance = patcher.CurrentBalance
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"ParentAccountId" {
			patchee.ParentAccountId = patcher.ParentAccountId
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessChartOfAccounts executes a gorm list call
func DefaultListBusinessChartOfAccounts(ctx context.Context, db *gorm.DB) ([]*BusinessChartOfAccounts, error) {
	in := BusinessChartOfAccounts{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessChartOfAccountsORM{}, &BusinessChartOfAccounts{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessChartOfAccountsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessChartOfAccountsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessChartOfAccounts{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessChartOfAccountsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessChartOfAccountsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessChartOfAccountsORM) error
}

// DefaultCreateCompanyAddress executes a basic gorm create call
func DefaultCreateCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyAddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyAddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyAddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyAddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyAddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyAddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyAddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyAddressSet(ctx context.Context, in []*CompanyAddress, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyAddressORM{})).(CompanyAddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyAddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyAddressORM{})).(CompanyAddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyAddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyAddress, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyAddress, *gorm.DB) error
}

// DefaultStrictUpdateCompanyAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyAddress(ctx context.Context, in *CompanyAddress, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyAddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyAddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyAddress executes a basic gorm update call with patch behavior
func DefaultPatchCompanyAddress(ctx context.Context, in *CompanyAddress, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyAddress
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyAddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompanyAddress(ctx, &CompanyAddress{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyAddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyAddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyAddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyAddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyAddress, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyAddress(ctx context.Context, objects []*CompanyAddress, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyAddress, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyAddress, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyAddress(ctx context.Context, patchee *CompanyAddress, patcher *CompanyAddress, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyAddress, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Street_1" {
			patchee.Street_1 = patcher.Street_1
			continue
		}
		if f == prefix+"Street_2" {
			patchee.Street_2 = patcher.Street_2
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"CountrySubdivision" {
			patchee.CountrySubdivision = patcher.CountrySubdivision
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyAddress executes a gorm list call
func DefaultListCompanyAddress(ctx context.Context, db *gorm.DB) ([]*CompanyAddress, error) {
	in := CompanyAddress{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyAddressORM{}, &CompanyAddress{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyAddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyAddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyAddress{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyAddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyAddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyAddressORM) error
}

// DefaultCreateAttachments executes a basic gorm create call
func DefaultCreateAttachments(ctx context.Context, in *Attachments, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AttachmentsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAttachments(ctx context.Context, in *Attachments, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AttachmentsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AttachmentsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AttachmentsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AttachmentsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAttachments(ctx context.Context, in *Attachments, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AttachmentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AttachmentsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAttachmentsSet(ctx context.Context, in []*Attachments, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AttachmentsORM{})).(AttachmentsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AttachmentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AttachmentsORM{})).(AttachmentsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AttachmentsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Attachments, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Attachments, *gorm.DB) error
}

// DefaultStrictUpdateAttachments clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAttachments(ctx context.Context, in *Attachments, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAttachments")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AttachmentsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AttachmentsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAttachments executes a basic gorm update call with patch behavior
func DefaultPatchAttachments(ctx context.Context, in *Attachments, updateMask *field_mask.FieldMask, db *gorm.DB) (*Attachments, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Attachments
	var err error
	if hook, ok := interface{}(&pbObj).(AttachmentsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAttachments(ctx, &Attachments{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AttachmentsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAttachments(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AttachmentsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAttachments(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AttachmentsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AttachmentsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Attachments, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAttachments executes a bulk gorm update call with patch behavior
func DefaultPatchSetAttachments(ctx context.Context, objects []*Attachments, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Attachments, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Attachments, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAttachments(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAttachments patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAttachments(ctx context.Context, patchee *Attachments, patcher *Attachments, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Attachments, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"FileUrl" {
			patchee.FileUrl = patcher.FileUrl
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAttachments executes a gorm list call
func DefaultListAttachments(ctx context.Context, db *gorm.DB) ([]*Attachments, error) {
	in := Attachments{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AttachmentsORM{}, &Attachments{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AttachmentsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AttachmentsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Attachments{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AttachmentsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AttachmentsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AttachmentsORM) error
}

// DefaultCreateBalanceSheet executes a basic gorm create call
func DefaultCreateBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BalanceSheetORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BalanceSheetORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BalanceSheetORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BalanceSheetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BalanceSheetORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBalanceSheetSet(ctx context.Context, in []*BalanceSheet, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BalanceSheetORM{})).(BalanceSheetORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BalanceSheetORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BalanceSheetORM{})).(BalanceSheetORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BalanceSheetORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BalanceSheet, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BalanceSheet, *gorm.DB) error
}

// DefaultStrictUpdateBalanceSheet clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBalanceSheet(ctx context.Context, in *BalanceSheet, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBalanceSheet")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BalanceSheetORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAssets := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAssets.AssetsBalanceSheetId = new(uint64)
	*filterAssets.AssetsBalanceSheetId = ormObj.Id
	if err = db.Where(filterAssets).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterEquity := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEquity.EquityBalanceSheetId = new(uint64)
	*filterEquity.EquityBalanceSheetId = ormObj.Id
	if err = db.Where(filterEquity).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterLiabilities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLiabilities.LiabilitiesBalanceSheetId = new(uint64)
	*filterLiabilities.LiabilitiesBalanceSheetId = ormObj.Id
	if err = db.Where(filterLiabilities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BalanceSheetORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBalanceSheet executes a basic gorm update call with patch behavior
func DefaultPatchBalanceSheet(ctx context.Context, in *BalanceSheet, updateMask *field_mask.FieldMask, db *gorm.DB) (*BalanceSheet, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BalanceSheet
	var err error
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBalanceSheet(ctx, &BalanceSheet{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBalanceSheet(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BalanceSheetWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBalanceSheet(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BalanceSheetWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BalanceSheetWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BalanceSheet, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBalanceSheet executes a bulk gorm update call with patch behavior
func DefaultPatchSetBalanceSheet(ctx context.Context, objects []*BalanceSheet, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BalanceSheet, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BalanceSheet, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBalanceSheet(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBalanceSheet patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBalanceSheet(ctx context.Context, patchee *BalanceSheet, patcher *BalanceSheet, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BalanceSheet, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDate bool
	var updatedRemoteGeneratedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedDate && strings.HasPrefix(f, prefix+"Date.") {
			if patcher.Date == nil {
				patchee.Date = nil
				continue
			}
			if patchee.Date == nil {
				patchee.Date = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Date."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Date, patchee.Date, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Date" {
			updatedDate = true
			patchee.Date = patcher.Date
			continue
		}
		if f == prefix+"NetAssets" {
			patchee.NetAssets = patcher.NetAssets
			continue
		}
		if f == prefix+"Assets" {
			patchee.Assets = patcher.Assets
			continue
		}
		if f == prefix+"Liabilities" {
			patchee.Liabilities = patcher.Liabilities
			continue
		}
		if f == prefix+"Equity" {
			patchee.Equity = patcher.Equity
			continue
		}
		if !updatedRemoteGeneratedAt && strings.HasPrefix(f, prefix+"RemoteGeneratedAt.") {
			if patcher.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = nil
				continue
			}
			if patchee.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteGeneratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteGeneratedAt, patchee.RemoteGeneratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteGeneratedAt" {
			updatedRemoteGeneratedAt = true
			patchee.RemoteGeneratedAt = patcher.RemoteGeneratedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBalanceSheet executes a gorm list call
func DefaultListBalanceSheet(ctx context.Context, db *gorm.DB) ([]*BalanceSheet, error) {
	in := BalanceSheet{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BalanceSheetORM{}, &BalanceSheet{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BalanceSheetORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BalanceSheetORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BalanceSheet{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BalanceSheetORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BalanceSheetORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BalanceSheetORM) error
}

// DefaultCreateReportItem executes a basic gorm create call
func DefaultCreateReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReportItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ReportItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReportItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReportItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReportItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReportItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReportItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteReportItemSet(ctx context.Context, in []*ReportItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReportItemORM{})).(ReportItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReportItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReportItemORM{})).(ReportItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReportItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ReportItem, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ReportItem, *gorm.DB) error
}

// DefaultStrictUpdateReportItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReportItem(ctx context.Context, in *ReportItem, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReportItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReportItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReportItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchReportItem executes a basic gorm update call with patch behavior
func DefaultPatchReportItem(ctx context.Context, in *ReportItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*ReportItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ReportItem
	var err error
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReportItem(ctx, &ReportItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReportItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReportItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReportItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReportItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReportItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ReportItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ReportItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetReportItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetReportItem(ctx context.Context, objects []*ReportItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ReportItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ReportItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchReportItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskReportItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReportItem(ctx context.Context, patchee *ReportItem, patcher *ReportItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ReportItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Value" {
			patchee.Value = patcher.Value
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReportItem executes a gorm list call
func DefaultListReportItem(ctx context.Context, db *gorm.DB) ([]*ReportItem, error) {
	in := ReportItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ReportItemORM{}, &ReportItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReportItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReportItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ReportItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReportItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ReportItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ReportItemORM) error
}

// DefaultCreateCashFlowStatements executes a basic gorm create call
func DefaultCreateCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CashFlowStatementsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CashFlowStatementsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CashFlowStatementsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CashFlowStatementsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CashFlowStatementsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CashFlowStatementsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CashFlowStatementsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCashFlowStatementsSet(ctx context.Context, in []*CashFlowStatements, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CashFlowStatementsORM{})).(CashFlowStatementsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CashFlowStatementsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CashFlowStatementsORM{})).(CashFlowStatementsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CashFlowStatementsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CashFlowStatements, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CashFlowStatements, *gorm.DB) error
}

// DefaultStrictUpdateCashFlowStatements clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCashFlowStatements(ctx context.Context, in *CashFlowStatements, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCashFlowStatements")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CashFlowStatementsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterFinancingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFinancingActivities.FinancingActivitiesCashFlowStatementsId = new(uint64)
	*filterFinancingActivities.FinancingActivitiesCashFlowStatementsId = ormObj.Id
	if err = db.Where(filterFinancingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterInvestingActivities.InvestingActivitiesCashFlowStatementsId = new(uint64)
	*filterInvestingActivities.InvestingActivitiesCashFlowStatementsId = ormObj.Id
	if err = db.Where(filterInvestingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterOperatingActivities := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOperatingActivities.OperatingActivitiesCashFlowStatementsId = new(uint64)
	*filterOperatingActivities.OperatingActivitiesCashFlowStatementsId = ormObj.Id
	if err = db.Where(filterOperatingActivities).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CashFlowStatementsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCashFlowStatements executes a basic gorm update call with patch behavior
func DefaultPatchCashFlowStatements(ctx context.Context, in *CashFlowStatements, updateMask *field_mask.FieldMask, db *gorm.DB) (*CashFlowStatements, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CashFlowStatements
	var err error
	if hook, ok := interface{}(&pbObj).(CashFlowStatementsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCashFlowStatements(ctx, &CashFlowStatements{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CashFlowStatementsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCashFlowStatements(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CashFlowStatementsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCashFlowStatements(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CashFlowStatementsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CashFlowStatementsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CashFlowStatements, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCashFlowStatements executes a bulk gorm update call with patch behavior
func DefaultPatchSetCashFlowStatements(ctx context.Context, objects []*CashFlowStatements, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CashFlowStatements, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CashFlowStatements, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCashFlowStatements(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCashFlowStatements patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCashFlowStatements(ctx context.Context, patchee *CashFlowStatements, patcher *CashFlowStatements, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CashFlowStatements, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartPeriod bool
	var updatedEndPeriod bool
	var updatedRemoteGeneratedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedStartPeriod && strings.HasPrefix(f, prefix+"StartPeriod.") {
			if patcher.StartPeriod == nil {
				patchee.StartPeriod = nil
				continue
			}
			if patchee.StartPeriod == nil {
				patchee.StartPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartPeriod, patchee.StartPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartPeriod" {
			updatedStartPeriod = true
			patchee.StartPeriod = patcher.StartPeriod
			continue
		}
		if !updatedEndPeriod && strings.HasPrefix(f, prefix+"EndPeriod.") {
			if patcher.EndPeriod == nil {
				patchee.EndPeriod = nil
				continue
			}
			if patchee.EndPeriod == nil {
				patchee.EndPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndPeriod, patchee.EndPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndPeriod" {
			updatedEndPeriod = true
			patchee.EndPeriod = patcher.EndPeriod
			continue
		}
		if f == prefix+"CashAtBeginningOfPeriod" {
			patchee.CashAtBeginningOfPeriod = patcher.CashAtBeginningOfPeriod
			continue
		}
		if f == prefix+"CashAtEndOfPeriod" {
			patchee.CashAtEndOfPeriod = patcher.CashAtEndOfPeriod
			continue
		}
		if f == prefix+"OperatingActivities" {
			patchee.OperatingActivities = patcher.OperatingActivities
			continue
		}
		if f == prefix+"InvestingActivities" {
			patchee.InvestingActivities = patcher.InvestingActivities
			continue
		}
		if f == prefix+"FinancingActivities" {
			patchee.FinancingActivities = patcher.FinancingActivities
			continue
		}
		if !updatedRemoteGeneratedAt && strings.HasPrefix(f, prefix+"RemoteGeneratedAt.") {
			if patcher.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = nil
				continue
			}
			if patchee.RemoteGeneratedAt == nil {
				patchee.RemoteGeneratedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteGeneratedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteGeneratedAt, patchee.RemoteGeneratedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteGeneratedAt" {
			updatedRemoteGeneratedAt = true
			patchee.RemoteGeneratedAt = patcher.RemoteGeneratedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCashFlowStatements executes a gorm list call
func DefaultListCashFlowStatements(ctx context.Context, db *gorm.DB) ([]*CashFlowStatements, error) {
	in := CashFlowStatements{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CashFlowStatementsORM{}, &CashFlowStatements{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CashFlowStatementsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CashFlowStatementsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CashFlowStatements{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CashFlowStatementsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CashFlowStatementsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CashFlowStatementsORM) error
}

// DefaultCreateCompanyInfo executes a basic gorm create call
func DefaultCreateCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyInfoORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyInfoSet(ctx context.Context, in []*CompanyInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyInfoORM{})).(CompanyInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyInfoORM{})).(CompanyInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyInfo, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyInfo, *gorm.DB) error
}

// DefaultStrictUpdateCompanyInfo clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyInfo(ctx context.Context, in *CompanyInfo, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddresses := CompanyAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddresses.CompanyInfoId = new(uint64)
	*filterAddresses.CompanyInfoId = ormObj.Id
	if err = db.Where(filterAddresses).Delete(CompanyAddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyInfo executes a basic gorm update call with patch behavior
func DefaultPatchCompanyInfo(ctx context.Context, in *CompanyInfo, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyInfo
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompanyInfo(ctx, &CompanyInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyInfo, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyInfo(ctx context.Context, objects []*CompanyInfo, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyInfo(ctx context.Context, patchee *CompanyInfo, patcher *CompanyInfo, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"LegalName" {
			patchee.LegalName = patcher.LegalName
			continue
		}
		if f == prefix+"TaxNumber" {
			patchee.TaxNumber = patcher.TaxNumber
			continue
		}
		if f == prefix+"FiscalYearEndMonth" {
			patchee.FiscalYearEndMonth = patcher.FiscalYearEndMonth
			continue
		}
		if f == prefix+"FiscalYearEndDay" {
			patchee.FiscalYearEndDay = patcher.FiscalYearEndDay
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"Urls" {
			patchee.Urls = patcher.Urls
			continue
		}
		if f == prefix+"Addresses" {
			patchee.Addresses = patcher.Addresses
			continue
		}
		if f == prefix+"PhoneNumbers" {
			patchee.PhoneNumbers = patcher.PhoneNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyInfo executes a gorm list call
func DefaultListCompanyInfo(ctx context.Context, db *gorm.DB) ([]*CompanyInfo, error) {
	in := CompanyInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyInfoORM{}, &CompanyInfo{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyInfoORM) error
}

// DefaultCreateAccountingAttachment executes a basic gorm create call
func DefaultCreateAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountingAttachmentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountingAttachmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountingAttachmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountingAttachmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountingAttachmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountingAttachmentSet(ctx context.Context, in []*AccountingAttachment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountingAttachmentORM{})).(AccountingAttachmentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountingAttachmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountingAttachmentORM{})).(AccountingAttachmentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountingAttachmentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountingAttachment, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountingAttachment, *gorm.DB) error
}

// DefaultStrictUpdateAccountingAttachment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountingAttachment(ctx context.Context, in *AccountingAttachment, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountingAttachment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountingAttachmentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountingAttachmentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountingAttachment executes a basic gorm update call with patch behavior
func DefaultPatchAccountingAttachment(ctx context.Context, in *AccountingAttachment, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountingAttachment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountingAttachment
	var err error
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountingAttachment(ctx, &AccountingAttachment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountingAttachment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountingAttachmentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountingAttachment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountingAttachmentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountingAttachmentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountingAttachment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountingAttachment executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountingAttachment(ctx context.Context, objects []*AccountingAttachment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountingAttachment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountingAttachment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountingAttachment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountingAttachment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountingAttachment(ctx context.Context, patchee *AccountingAttachment, patcher *AccountingAttachment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountingAttachment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"FileName" {
			patchee.FileName = patcher.FileName
			continue
		}
		if f == prefix+"FileUrl" {
			patchee.FileUrl = patcher.FileUrl
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"ModifiedAt" {
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeRecordId" {
			patchee.MergeRecordId = patcher.MergeRecordId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountingAttachment executes a gorm list call
func DefaultListAccountingAttachment(ctx context.Context, db *gorm.DB) ([]*AccountingAttachment, error) {
	in := AccountingAttachment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountingAttachmentORM{}, &AccountingAttachment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountingAttachmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountingAttachmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountingAttachment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountingAttachmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountingAttachmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountingAttachmentORM) error
}

// DefaultCreateContacts executes a basic gorm create call
func DefaultCreateContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContactsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ContactsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContactsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContactsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContactsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteContacts(ctx context.Context, in *Contacts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContactsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ContactsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteContactsSet(ctx context.Context, in []*Contacts, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContactsORM{})).(ContactsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ContactsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContactsORM{})).(ContactsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContactsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Contacts, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Contacts, *gorm.DB) error
}

// DefaultStrictUpdateContacts clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContacts(ctx context.Context, in *Contacts, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContacts")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ContactsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContactsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchContacts executes a basic gorm update call with patch behavior
func DefaultPatchContacts(ctx context.Context, in *Contacts, updateMask *field_mask.FieldMask, db *gorm.DB) (*Contacts, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Contacts
	var err error
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContacts(ctx, &Contacts{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContacts(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContactsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContacts(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContactsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContactsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Contacts, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetContacts executes a bulk gorm update call with patch behavior
func DefaultPatchSetContacts(ctx context.Context, objects []*Contacts, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Contacts, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Contacts, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchContacts(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskContacts patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContacts(ctx context.Context, patchee *Contacts, patcher *Contacts, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Contacts, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"IsSupplier" {
			patchee.IsSupplier = patcher.IsSupplier
			continue
		}
		if f == prefix+"IsCustomer" {
			patchee.IsCustomer = patcher.IsCustomer
			continue
		}
		if f == prefix+"EmailAddress" {
			patchee.EmailAddress = patcher.EmailAddress
			continue
		}
		if f == prefix+"TaxNumber" {
			patchee.TaxNumber = patcher.TaxNumber
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"AddressesIds" {
			patchee.AddressesIds = patcher.AddressesIds
			continue
		}
		if f == prefix+"PhoneNumbers" {
			patchee.PhoneNumbers = patcher.PhoneNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContacts executes a gorm list call
func DefaultListContacts(ctx context.Context, db *gorm.DB) ([]*Contacts, error) {
	in := Contacts{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ContactsORM{}, &Contacts{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContactsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Contacts{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContactsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ContactsORM) error
}

// DefaultCreateCreditNote executes a basic gorm create call
func DefaultCreateCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditNoteORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditNoteORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditNoteORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditNoteORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteSet(ctx context.Context, in []*CreditNote, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditNoteORM{})).(CreditNoteORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditNoteORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditNoteORM{})).(CreditNoteORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditNoteORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditNote, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditNote, *gorm.DB) error
}

// DefaultStrictUpdateCreditNote clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditNote(ctx context.Context, in *CreditNote, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditNote")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditNoteORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := CreditNoteLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.CreditNoteId = new(uint64)
	*filterLineItems.CreditNoteId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(CreditNoteLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditNoteORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditNote executes a basic gorm update call with patch behavior
func DefaultPatchCreditNote(ctx context.Context, in *CreditNote, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditNote, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditNote
	var err error
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditNote(ctx, &CreditNote{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditNote(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditNoteWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditNote(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditNoteWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditNoteWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditNote, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditNote executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditNote(ctx context.Context, objects []*CreditNote, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditNote, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditNote, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditNote(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditNote patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditNote(ctx context.Context, patchee *CreditNote, patcher *CreditNote, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditNote, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"RemainingCredit" {
			patchee.RemainingCredit = patcher.RemainingCredit
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"PaymentIds" {
			patchee.PaymentIds = patcher.PaymentIds
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditNote executes a gorm list call
func DefaultListCreditNote(ctx context.Context, db *gorm.DB) ([]*CreditNote, error) {
	in := CreditNote{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditNoteORM{}, &CreditNote{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditNoteORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditNote{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditNoteORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditNoteORM) error
}

// DefaultCreateCreditNoteLineItem executes a basic gorm create call
func DefaultCreateCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CreditNoteLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditNoteLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditNoteLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditNoteLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditNoteLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditNoteLineItemSet(ctx context.Context, in []*CreditNoteLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditNoteLineItemORM{})).(CreditNoteLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CreditNoteLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CreditNoteLineItemORM{})).(CreditNoteLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditNoteLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditNoteLineItem, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditNoteLineItem, *gorm.DB) error
}

// DefaultStrictUpdateCreditNoteLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditNoteLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CreditNoteLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CreditNoteLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditNoteLineItem executes a basic gorm update call with patch behavior
func DefaultPatchCreditNoteLineItem(ctx context.Context, in *CreditNoteLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditNoteLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditNoteLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditNoteLineItem(ctx, &CreditNoteLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditNoteLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditNoteLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditNoteLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditNoteLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditNoteLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditNoteLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditNoteLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditNoteLineItem(ctx context.Context, objects []*CreditNoteLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditNoteLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditNoteLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditNoteLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditNoteLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditNoteLineItem(ctx context.Context, patchee *CreditNoteLineItem, patcher *CreditNoteLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditNoteLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"TaxRate" {
			patchee.TaxRate = patcher.TaxRate
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditNoteLineItem executes a gorm list call
func DefaultListCreditNoteLineItem(ctx context.Context, db *gorm.DB) ([]*CreditNoteLineItem, error) {
	in := CreditNoteLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CreditNoteLineItemORM{}, &CreditNoteLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditNoteLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditNoteLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditNoteLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditNoteLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditNoteLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditNoteLineItemORM) error
}

// DefaultCreateExpense executes a basic gorm create call
func DefaultCreateExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ExpenseORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExpenseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExpenseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExpense(ctx context.Context, in *Expense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExpenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExpenseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseSet(ctx context.Context, in []*Expense, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExpenseORM{})).(ExpenseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExpenseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExpenseORM{})).(ExpenseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExpenseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Expense, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Expense, *gorm.DB) error
}

// DefaultStrictUpdateExpense clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExpense(ctx context.Context, in *Expense, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExpense")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExpenseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := ExpenseLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.ExpenseId = new(uint64)
	*filterLines.ExpenseId = ormObj.Id
	if err = db.Where(filterLines).Delete(ExpenseLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExpenseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExpense executes a basic gorm update call with patch behavior
func DefaultPatchExpense(ctx context.Context, in *Expense, updateMask *field_mask.FieldMask, db *gorm.DB) (*Expense, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Expense
	var err error
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExpense(ctx, &Expense{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExpense(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExpenseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExpense(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExpenseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExpenseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Expense, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExpense executes a bulk gorm update call with patch behavior
func DefaultPatchSetExpense(ctx context.Context, objects []*Expense, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Expense, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Expense, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExpense(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExpense patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpense(ctx context.Context, patchee *Expense, patcher *Expense, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Expense, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"SubTotal" {
			patchee.SubTotal = patcher.SubTotal
			continue
		}
		if f == prefix+"TotalTaxAmount" {
			patchee.TotalTaxAmount = patcher.TotalTaxAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpense executes a gorm list call
func DefaultListExpense(ctx context.Context, db *gorm.DB) ([]*Expense, error) {
	in := Expense{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseORM{}, &Expense{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExpenseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Expense{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseORM) error
}

// DefaultCreateExpenseLine executes a basic gorm create call
func DefaultCreateExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ExpenseLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ExpenseLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ExpenseLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ExpenseLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ExpenseLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteExpenseLineSet(ctx context.Context, in []*ExpenseLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ExpenseLineORM{})).(ExpenseLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ExpenseLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ExpenseLineORM{})).(ExpenseLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ExpenseLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ExpenseLine, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ExpenseLine, *gorm.DB) error
}

// DefaultStrictUpdateExpenseLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateExpenseLine(ctx context.Context, in *ExpenseLine, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateExpenseLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ExpenseLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ExpenseLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchExpenseLine executes a basic gorm update call with patch behavior
func DefaultPatchExpenseLine(ctx context.Context, in *ExpenseLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*ExpenseLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ExpenseLine
	var err error
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadExpenseLine(ctx, &ExpenseLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskExpenseLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ExpenseLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateExpenseLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ExpenseLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ExpenseLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ExpenseLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetExpenseLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetExpenseLine(ctx context.Context, objects []*ExpenseLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ExpenseLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ExpenseLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchExpenseLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskExpenseLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExpenseLine(ctx context.Context, patchee *ExpenseLine, patcher *ExpenseLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ExpenseLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExpenseLine executes a gorm list call
func DefaultListExpenseLine(ctx context.Context, db *gorm.DB) ([]*ExpenseLine, error) {
	in := ExpenseLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ExpenseLineORM{}, &ExpenseLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ExpenseLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExpenseLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ExpenseLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExpenseLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ExpenseLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ExpenseLineORM) error
}

// DefaultCreateIncomeStatement executes a basic gorm create call
func DefaultCreateIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &IncomeStatementORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := IncomeStatementORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(IncomeStatementORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&IncomeStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type IncomeStatementORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteIncomeStatementSet(ctx context.Context, in []*IncomeStatement, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&IncomeStatementORM{})).(IncomeStatementORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&IncomeStatementORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&IncomeStatementORM{})).(IncomeStatementORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type IncomeStatementORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*IncomeStatement, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*IncomeStatement, *gorm.DB) error
}

// DefaultStrictUpdateIncomeStatement clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateIncomeStatement(ctx context.Context, in *IncomeStatement, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateIncomeStatement")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &IncomeStatementORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCostOfSales := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCostOfSales.CostOfSalesIncomeStatementId = new(uint64)
	*filterCostOfSales.CostOfSalesIncomeStatementId = ormObj.Id
	if err = db.Where(filterCostOfSales).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterIncome := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIncome.IncomeIncomeStatementId = new(uint64)
	*filterIncome.IncomeIncomeStatementId = ormObj.Id
	if err = db.Where(filterIncome).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterNonOperatingExpenses := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNonOperatingExpenses.NonOperatingExpensesIncomeStatementId = new(uint64)
	*filterNonOperatingExpenses.NonOperatingExpensesIncomeStatementId = ormObj.Id
	if err = db.Where(filterNonOperatingExpenses).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	filterOperatingExpenses := ReportItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOperatingExpenses.OperatingExpensesIncomeStatementId = new(uint64)
	*filterOperatingExpenses.OperatingExpensesIncomeStatementId = ormObj.Id
	if err = db.Where(filterOperatingExpenses).Delete(ReportItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type IncomeStatementORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchIncomeStatement executes a basic gorm update call with patch behavior
func DefaultPatchIncomeStatement(ctx context.Context, in *IncomeStatement, updateMask *field_mask.FieldMask, db *gorm.DB) (*IncomeStatement, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj IncomeStatement
	var err error
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadIncomeStatement(ctx, &IncomeStatement{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskIncomeStatement(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(IncomeStatementWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateIncomeStatement(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(IncomeStatementWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type IncomeStatementWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *IncomeStatement, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetIncomeStatement executes a bulk gorm update call with patch behavior
func DefaultPatchSetIncomeStatement(ctx context.Context, objects []*IncomeStatement, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*IncomeStatement, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*IncomeStatement, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchIncomeStatement(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskIncomeStatement patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIncomeStatement(ctx context.Context, patchee *IncomeStatement, patcher *IncomeStatement, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IncomeStatement, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartPeriod bool
	var updatedEndPeriod bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedStartPeriod && strings.HasPrefix(f, prefix+"StartPeriod.") {
			if patcher.StartPeriod == nil {
				patchee.StartPeriod = nil
				continue
			}
			if patchee.StartPeriod == nil {
				patchee.StartPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartPeriod, patchee.StartPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartPeriod" {
			updatedStartPeriod = true
			patchee.StartPeriod = patcher.StartPeriod
			continue
		}
		if !updatedEndPeriod && strings.HasPrefix(f, prefix+"EndPeriod.") {
			if patcher.EndPeriod == nil {
				patchee.EndPeriod = nil
				continue
			}
			if patchee.EndPeriod == nil {
				patchee.EndPeriod = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndPeriod."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndPeriod, patchee.EndPeriod, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndPeriod" {
			updatedEndPeriod = true
			patchee.EndPeriod = patcher.EndPeriod
			continue
		}
		if f == prefix+"Income" {
			patchee.Income = patcher.Income
			continue
		}
		if f == prefix+"CostOfSales" {
			patchee.CostOfSales = patcher.CostOfSales
			continue
		}
		if f == prefix+"GrossProfit" {
			patchee.GrossProfit = patcher.GrossProfit
			continue
		}
		if f == prefix+"OperatingExpenses" {
			patchee.OperatingExpenses = patcher.OperatingExpenses
			continue
		}
		if f == prefix+"NetOperatingIncome" {
			patchee.NetOperatingIncome = patcher.NetOperatingIncome
			continue
		}
		if f == prefix+"NonOperatingExpenses" {
			patchee.NonOperatingExpenses = patcher.NonOperatingExpenses
			continue
		}
		if f == prefix+"NetIncome" {
			patchee.NetIncome = patcher.NetIncome
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIncomeStatement executes a gorm list call
func DefaultListIncomeStatement(ctx context.Context, db *gorm.DB) ([]*IncomeStatement, error) {
	in := IncomeStatement{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IncomeStatementORM{}, &IncomeStatement{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []IncomeStatementORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IncomeStatementORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IncomeStatement{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IncomeStatementORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IncomeStatementORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IncomeStatementORM) error
}

// DefaultCreateInvoice executes a basic gorm create call
func DefaultCreateInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvoiceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvoiceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvoiceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoice(ctx context.Context, in *Invoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvoiceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceSet(ctx context.Context, in []*Invoice, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvoiceORM{})).(InvoiceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvoiceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvoiceORM{})).(InvoiceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvoiceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Invoice, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Invoice, *gorm.DB) error
}

// DefaultStrictUpdateInvoice clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvoice(ctx context.Context, in *Invoice, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvoice")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvoiceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := InvoiceLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.InvoiceId = new(uint64)
	*filterLineItems.InvoiceId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(InvoiceLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvoiceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvoice executes a basic gorm update call with patch behavior
func DefaultPatchInvoice(ctx context.Context, in *Invoice, updateMask *field_mask.FieldMask, db *gorm.DB) (*Invoice, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Invoice
	var err error
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvoice(ctx, &Invoice{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvoice(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvoiceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvoice(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvoiceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvoiceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Invoice, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvoice executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvoice(ctx context.Context, objects []*Invoice, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Invoice, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Invoice, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvoice(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvoice patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvoice(ctx context.Context, patchee *Invoice, patcher *Invoice, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Invoice, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedIssueDate bool
	var updatedDueDate bool
	var updatedPaidOnDate bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedIssueDate && strings.HasPrefix(f, prefix+"IssueDate.") {
			if patcher.IssueDate == nil {
				patchee.IssueDate = nil
				continue
			}
			if patchee.IssueDate == nil {
				patchee.IssueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IssueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IssueDate, patchee.IssueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IssueDate" {
			updatedIssueDate = true
			patchee.IssueDate = patcher.IssueDate
			continue
		}
		if !updatedDueDate && strings.HasPrefix(f, prefix+"DueDate.") {
			if patcher.DueDate == nil {
				patchee.DueDate = nil
				continue
			}
			if patchee.DueDate == nil {
				patchee.DueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DueDate, patchee.DueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DueDate" {
			updatedDueDate = true
			patchee.DueDate = patcher.DueDate
			continue
		}
		if !updatedPaidOnDate && strings.HasPrefix(f, prefix+"PaidOnDate.") {
			if patcher.PaidOnDate == nil {
				patchee.PaidOnDate = nil
				continue
			}
			if patchee.PaidOnDate == nil {
				patchee.PaidOnDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PaidOnDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.PaidOnDate, patchee.PaidOnDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PaidOnDate" {
			updatedPaidOnDate = true
			patchee.PaidOnDate = patcher.PaidOnDate
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"TotalDiscount" {
			patchee.TotalDiscount = patcher.TotalDiscount
			continue
		}
		if f == prefix+"SubTotal" {
			patchee.SubTotal = patcher.SubTotal
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"TotalTaxAmount" {
			patchee.TotalTaxAmount = patcher.TotalTaxAmount
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Payments" {
			patchee.Payments = patcher.Payments
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"PurchaseOrders" {
			patchee.PurchaseOrders = patcher.PurchaseOrders
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvoice executes a gorm list call
func DefaultListInvoice(ctx context.Context, db *gorm.DB) ([]*Invoice, error) {
	in := Invoice{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvoiceORM{}, &Invoice{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvoiceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Invoice{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvoiceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvoiceORM) error
}

// DefaultCreateInvoiceLineItem executes a basic gorm create call
func DefaultCreateInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &InvoiceLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvoiceLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvoiceLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvoiceLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvoiceLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteInvoiceLineItemSet(ctx context.Context, in []*InvoiceLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvoiceLineItemORM{})).(InvoiceLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvoiceLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvoiceLineItemORM{})).(InvoiceLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvoiceLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvoiceLineItem, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvoiceLineItem, *gorm.DB) error
}

// DefaultStrictUpdateInvoiceLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvoiceLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvoiceLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvoiceLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchInvoiceLineItem executes a basic gorm update call with patch behavior
func DefaultPatchInvoiceLineItem(ctx context.Context, in *InvoiceLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*InvoiceLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj InvoiceLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvoiceLineItem(ctx, &InvoiceLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvoiceLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvoiceLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvoiceLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvoiceLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvoiceLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvoiceLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetInvoiceLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvoiceLineItem(ctx context.Context, objects []*InvoiceLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*InvoiceLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvoiceLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvoiceLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvoiceLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvoiceLineItem(ctx context.Context, patchee *InvoiceLineItem, patcher *InvoiceLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*InvoiceLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvoiceLineItem executes a gorm list call
func DefaultListInvoiceLineItem(ctx context.Context, db *gorm.DB) ([]*InvoiceLineItem, error) {
	in := InvoiceLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &InvoiceLineItemORM{}, &InvoiceLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvoiceLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvoiceLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvoiceLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvoiceLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type InvoiceLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]InvoiceLineItemORM) error
}

// DefaultCreateItem executes a basic gorm create call
func DefaultCreateItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteItem(ctx context.Context, in *Item, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteItemSet(ctx context.Context, in []*Item, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ItemORM{})).(ItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ItemORM{})).(ItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Item, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Item, *gorm.DB) error
}

// DefaultStrictUpdateItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateItem(ctx context.Context, in *Item, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchItem executes a basic gorm update call with patch behavior
func DefaultPatchItem(ctx context.Context, in *Item, updateMask *field_mask.FieldMask, db *gorm.DB) (*Item, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Item
	var err error
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadItem(ctx, &Item{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Item, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetItem(ctx context.Context, objects []*Item, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Item, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Item, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskItem(ctx context.Context, patchee *Item, patcher *Item, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Item, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"PurchasePrice" {
			patchee.PurchasePrice = patcher.PurchasePrice
			continue
		}
		if f == prefix+"PurchaseAccount" {
			patchee.PurchaseAccount = patcher.PurchaseAccount
			continue
		}
		if f == prefix+"SalesAccount" {
			patchee.SalesAccount = patcher.SalesAccount
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListItem executes a gorm list call
func DefaultListItem(ctx context.Context, db *gorm.DB) ([]*Item, error) {
	in := Item{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ItemORM{}, &Item{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Item{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ItemORM) error
}

// DefaultCreateJournalEntry executes a basic gorm create call
func DefaultCreateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JournalEntryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalEntryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalEntryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalEntryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalEntryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalEntrySet(ctx context.Context, in []*JournalEntry, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalEntryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalEntryORM{})).(JournalEntryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalEntryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalEntry, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalEntry, *gorm.DB) error
}

// DefaultStrictUpdateJournalEntry clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalEntry(ctx context.Context, in *JournalEntry, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalEntry")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalEntryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := JournalLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.JournalEntryId = new(uint64)
	*filterLines.JournalEntryId = ormObj.Id
	if err = db.Where(filterLines).Delete(JournalLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalEntryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJournalEntry executes a basic gorm update call with patch behavior
func DefaultPatchJournalEntry(ctx context.Context, in *JournalEntry, updateMask *field_mask.FieldMask, db *gorm.DB) (*JournalEntry, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj JournalEntry
	var err error
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalEntry(ctx, &JournalEntry{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalEntry(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalEntryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalEntry(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalEntryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalEntryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalEntry, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJournalEntry executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalEntry(ctx context.Context, objects []*JournalEntry, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*JournalEntry, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalEntry, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalEntry(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalEntry patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalEntry(ctx context.Context, patchee *JournalEntry, patcher *JournalEntry, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*JournalEntry, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"PaymentIds" {
			patchee.PaymentIds = patcher.PaymentIds
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"JournalNumber" {
			patchee.JournalNumber = patcher.JournalNumber
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"PostingStatus" {
			patchee.PostingStatus = patcher.PostingStatus
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalEntry executes a gorm list call
func DefaultListJournalEntry(ctx context.Context, db *gorm.DB) ([]*JournalEntry, error) {
	in := JournalEntry{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JournalEntryORM{}, &JournalEntry{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalEntryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalEntryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalEntry{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalEntryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalEntryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JournalEntryORM) error
}

// DefaultCreateJournalLine executes a basic gorm create call
func DefaultCreateJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type JournalLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &JournalLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := JournalLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(JournalLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type JournalLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&JournalLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type JournalLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteJournalLineSet(ctx context.Context, in []*JournalLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&JournalLineORM{})).(JournalLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&JournalLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&JournalLineORM{})).(JournalLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type JournalLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*JournalLine, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*JournalLine, *gorm.DB) error
}

// DefaultStrictUpdateJournalLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateJournalLine(ctx context.Context, in *JournalLine, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateJournalLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &JournalLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type JournalLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchJournalLine executes a basic gorm update call with patch behavior
func DefaultPatchJournalLine(ctx context.Context, in *JournalLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*JournalLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj JournalLine
	var err error
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadJournalLine(ctx, &JournalLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskJournalLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(JournalLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateJournalLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(JournalLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type JournalLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type JournalLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *JournalLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetJournalLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetJournalLine(ctx context.Context, objects []*JournalLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*JournalLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*JournalLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchJournalLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskJournalLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskJournalLine(ctx context.Context, patchee *JournalLine, patcher *JournalLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*JournalLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListJournalLine executes a gorm list call
func DefaultListJournalLine(ctx context.Context, db *gorm.DB) ([]*JournalLine, error) {
	in := JournalLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &JournalLineORM{}, &JournalLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []JournalLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(JournalLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*JournalLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type JournalLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type JournalLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]JournalLineORM) error
}

// DefaultCreatePayment executes a basic gorm create call
func DefaultCreatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PaymentORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PaymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PaymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePayment(ctx context.Context, in *Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PaymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePaymentSet(ctx context.Context, in []*Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PaymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Payment, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Payment, *gorm.DB) error
}

// DefaultStrictUpdatePayment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePayment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PaymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PaymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPayment executes a basic gorm update call with patch behavior
func DefaultPatchPayment(ctx context.Context, in *Payment, updateMask *field_mask.FieldMask, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Payment
	var err error
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPayment(ctx, &Payment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPayment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePayment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PaymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PaymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPayment executes a bulk gorm update call with patch behavior
func DefaultPatchSetPayment(ctx context.Context, objects []*Payment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Payment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Payment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPayment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPayment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPayment(ctx context.Context, patchee *Payment, patcher *Payment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Payment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPayment executes a gorm list call
func DefaultListPayment(ctx context.Context, db *gorm.DB) ([]*Payment, error) {
	in := Payment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PaymentORM{}, &Payment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PaymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Payment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentORM) error
}

// DefaultCreatePurchaseOrder executes a basic gorm create call
func DefaultCreatePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PurchaseOrderORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseOrderORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseOrderORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseOrderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseOrderORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderSet(ctx context.Context, in []*PurchaseOrder, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseOrderORM{})).(PurchaseOrderORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseOrderORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseOrderORM{})).(PurchaseOrderORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseOrderORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PurchaseOrder, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PurchaseOrder, *gorm.DB) error
}

// DefaultStrictUpdatePurchaseOrder clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchaseOrder(ctx context.Context, in *PurchaseOrder, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchaseOrder")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseOrderORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDeliveryAddress := CompanyAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDeliveryAddress.PurchaseOrderId = new(uint64)
	*filterDeliveryAddress.PurchaseOrderId = ormObj.Id
	if err = db.Where(filterDeliveryAddress).Delete(CompanyAddressORM{}).Error; err != nil {
		return nil, err
	}
	filterLineItems := PurchaseOrderLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.PurchaseOrderId = new(uint64)
	*filterLineItems.PurchaseOrderId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(PurchaseOrderLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseOrderORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPurchaseOrder executes a basic gorm update call with patch behavior
func DefaultPatchPurchaseOrder(ctx context.Context, in *PurchaseOrder, updateMask *field_mask.FieldMask, db *gorm.DB) (*PurchaseOrder, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PurchaseOrder
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchaseOrder(ctx, &PurchaseOrder{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchaseOrder(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseOrderWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchaseOrder(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseOrderWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseOrderWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PurchaseOrder, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPurchaseOrder executes a bulk gorm update call with patch behavior
func DefaultPatchSetPurchaseOrder(ctx context.Context, objects []*PurchaseOrder, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PurchaseOrder, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PurchaseOrder, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPurchaseOrder(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPurchaseOrder patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchaseOrder(ctx context.Context, patchee *PurchaseOrder, patcher *PurchaseOrder, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PurchaseOrder, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedIssueDate bool
	var updatedDeliveryDate bool
	var updatedDeliveryAddress bool
	var updatedRemoteCreatedAt bool
	var updatedRemoteUpdatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if !updatedIssueDate && strings.HasPrefix(f, prefix+"IssueDate.") {
			if patcher.IssueDate == nil {
				patchee.IssueDate = nil
				continue
			}
			if patchee.IssueDate == nil {
				patchee.IssueDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IssueDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IssueDate, patchee.IssueDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IssueDate" {
			updatedIssueDate = true
			patchee.IssueDate = patcher.IssueDate
			continue
		}
		if f == prefix+"PurchaseOrderNumber" {
			patchee.PurchaseOrderNumber = patcher.PurchaseOrderNumber
			continue
		}
		if !updatedDeliveryDate && strings.HasPrefix(f, prefix+"DeliveryDate.") {
			if patcher.DeliveryDate == nil {
				patchee.DeliveryDate = nil
				continue
			}
			if patchee.DeliveryDate == nil {
				patchee.DeliveryDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DeliveryDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DeliveryDate, patchee.DeliveryDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DeliveryDate" {
			updatedDeliveryDate = true
			patchee.DeliveryDate = patcher.DeliveryDate
			continue
		}
		if !updatedDeliveryAddress && strings.HasPrefix(f, prefix+"DeliveryAddress.") {
			updatedDeliveryAddress = true
			if patcher.DeliveryAddress == nil {
				patchee.DeliveryAddress = nil
				continue
			}
			if patchee.DeliveryAddress == nil {
				patchee.DeliveryAddress = &CompanyAddress{}
			}
			if o, err := DefaultApplyFieldMaskCompanyAddress(ctx, patchee.DeliveryAddress, patcher.DeliveryAddress, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DeliveryAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.DeliveryAddress = o
			}
			continue
		}
		if f == prefix+"DeliveryAddress" {
			updatedDeliveryAddress = true
			patchee.DeliveryAddress = patcher.DeliveryAddress
			continue
		}
		if f == prefix+"Customer" {
			patchee.Customer = patcher.Customer
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if !updatedRemoteUpdatedAt && strings.HasPrefix(f, prefix+"RemoteUpdatedAt.") {
			if patcher.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = nil
				continue
			}
			if patchee.RemoteUpdatedAt == nil {
				patchee.RemoteUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteUpdatedAt, patchee.RemoteUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteUpdatedAt" {
			updatedRemoteUpdatedAt = true
			patchee.RemoteUpdatedAt = patcher.RemoteUpdatedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchaseOrder executes a gorm list call
func DefaultListPurchaseOrder(ctx context.Context, db *gorm.DB) ([]*PurchaseOrder, error) {
	in := PurchaseOrder{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PurchaseOrderORM{}, &PurchaseOrder{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseOrderORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PurchaseOrder{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseOrderORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PurchaseOrderORM) error
}

// DefaultCreatePurchaseOrderLineItem executes a basic gorm create call
func DefaultCreatePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PurchaseOrderLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseOrderLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseOrderLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseOrderLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseOrderLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePurchaseOrderLineItemSet(ctx context.Context, in []*PurchaseOrderLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseOrderLineItemORM{})).(PurchaseOrderLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseOrderLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseOrderLineItemORM{})).(PurchaseOrderLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseOrderLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PurchaseOrderLineItem, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PurchaseOrderLineItem, *gorm.DB) error
}

// DefaultStrictUpdatePurchaseOrderLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchaseOrderLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseOrderLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseOrderLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPurchaseOrderLineItem executes a basic gorm update call with patch behavior
func DefaultPatchPurchaseOrderLineItem(ctx context.Context, in *PurchaseOrderLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj PurchaseOrderLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchaseOrderLineItem(ctx, &PurchaseOrderLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchaseOrderLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseOrderLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchaseOrderLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseOrderLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseOrderLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PurchaseOrderLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPurchaseOrderLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetPurchaseOrderLineItem(ctx context.Context, objects []*PurchaseOrderLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*PurchaseOrderLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PurchaseOrderLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPurchaseOrderLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPurchaseOrderLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchaseOrderLineItem(ctx context.Context, patchee *PurchaseOrderLineItem, patcher *PurchaseOrderLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*PurchaseOrderLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"TaxAmount" {
			patchee.TaxAmount = patcher.TaxAmount
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchaseOrderLineItem executes a gorm list call
func DefaultListPurchaseOrderLineItem(ctx context.Context, db *gorm.DB) ([]*PurchaseOrderLineItem, error) {
	in := PurchaseOrderLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PurchaseOrderLineItemORM{}, &PurchaseOrderLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseOrderLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseOrderLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PurchaseOrderLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseOrderLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PurchaseOrderLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PurchaseOrderLineItemORM) error
}

// DefaultCreateTaxRate executes a basic gorm create call
func DefaultCreateTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TaxRateORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TaxRateORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TaxRateORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TaxRateORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TaxRateORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TaxRateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TaxRateORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxRateSet(ctx context.Context, in []*TaxRate, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TaxRateORM{})).(TaxRateORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TaxRateORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TaxRateORM{})).(TaxRateORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TaxRateORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TaxRate, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TaxRate, *gorm.DB) error
}

// DefaultStrictUpdateTaxRate clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTaxRate(ctx context.Context, in *TaxRate, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTaxRate")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TaxRateORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TaxRateORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTaxRate executes a basic gorm update call with patch behavior
func DefaultPatchTaxRate(ctx context.Context, in *TaxRate, updateMask *field_mask.FieldMask, db *gorm.DB) (*TaxRate, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TaxRate
	var err error
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTaxRate(ctx, &TaxRate{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTaxRate(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TaxRateWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTaxRate(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TaxRateWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TaxRateWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxRateWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TaxRate, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTaxRate executes a bulk gorm update call with patch behavior
func DefaultPatchSetTaxRate(ctx context.Context, objects []*TaxRate, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TaxRate, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TaxRate, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTaxRate(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTaxRate patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTaxRate(ctx context.Context, patchee *TaxRate, patcher *TaxRate, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TaxRate, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"TotalTaxRate" {
			patchee.TotalTaxRate = patcher.TotalTaxRate
			continue
		}
		if f == prefix+"EffectiveTaxRate" {
			patchee.EffectiveTaxRate = patcher.EffectiveTaxRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTaxRate executes a gorm list call
func DefaultListTaxRate(ctx context.Context, db *gorm.DB) ([]*TaxRate, error) {
	in := TaxRate{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TaxRateORM{}, &TaxRate{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TaxRateORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxRateORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TaxRate{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TaxRateORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxRateORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TaxRateORM) error
}

// DefaultCreateTrackingCategory executes a basic gorm create call
func DefaultCreateTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TrackingCategoryORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TrackingCategoryORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TrackingCategoryORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TrackingCategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TrackingCategoryORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTrackingCategorySet(ctx context.Context, in []*TrackingCategory, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TrackingCategoryORM{})).(TrackingCategoryORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TrackingCategoryORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TrackingCategoryORM{})).(TrackingCategoryORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TrackingCategoryORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TrackingCategory, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TrackingCategory, *gorm.DB) error
}

// DefaultStrictUpdateTrackingCategory clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTrackingCategory(ctx context.Context, in *TrackingCategory, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTrackingCategory")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TrackingCategoryORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TrackingCategoryORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTrackingCategory executes a basic gorm update call with patch behavior
func DefaultPatchTrackingCategory(ctx context.Context, in *TrackingCategory, updateMask *field_mask.FieldMask, db *gorm.DB) (*TrackingCategory, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TrackingCategory
	var err error
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTrackingCategory(ctx, &TrackingCategory{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTrackingCategory(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TrackingCategoryWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTrackingCategory(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TrackingCategoryWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TrackingCategoryWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TrackingCategory, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTrackingCategory executes a bulk gorm update call with patch behavior
func DefaultPatchSetTrackingCategory(ctx context.Context, objects []*TrackingCategory, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TrackingCategory, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TrackingCategory, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTrackingCategory(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTrackingCategory patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTrackingCategory(ctx context.Context, patchee *TrackingCategory, patcher *TrackingCategory, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TrackingCategory, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"CategoryType" {
			patchee.CategoryType = patcher.CategoryType
			continue
		}
		if f == prefix+"ParentCategory" {
			patchee.ParentCategory = patcher.ParentCategory
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTrackingCategory executes a gorm list call
func DefaultListTrackingCategory(ctx context.Context, db *gorm.DB) ([]*TrackingCategory, error) {
	in := TrackingCategory{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TrackingCategoryORM{}, &TrackingCategory{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TrackingCategoryORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TrackingCategoryORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TrackingCategory{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TrackingCategoryORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TrackingCategoryORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TrackingCategoryORM) error
}

// DefaultCreateBusinessTransaction executes a basic gorm create call
func DefaultCreateBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessTransactionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessTransactionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessTransactionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessTransactionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessTransactionSet(ctx context.Context, in []*BusinessTransaction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessTransactionORM{})).(BusinessTransactionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessTransactionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessTransactionORM{})).(BusinessTransactionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessTransactionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessTransaction, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessTransaction, *gorm.DB) error
}

// DefaultStrictUpdateBusinessTransaction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessTransaction(ctx context.Context, in *BusinessTransaction, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessTransaction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessTransactionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLineItems := TransactionLineItemORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLineItems.BusinessTransactionId = new(uint64)
	*filterLineItems.BusinessTransactionId = ormObj.Id
	if err = db.Where(filterLineItems).Delete(TransactionLineItemORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessTransactionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessTransaction executes a basic gorm update call with patch behavior
func DefaultPatchBusinessTransaction(ctx context.Context, in *BusinessTransaction, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessTransaction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessTransaction
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessTransaction(ctx, &BusinessTransaction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessTransaction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessTransactionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessTransaction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessTransactionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessTransactionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessTransaction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessTransaction executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessTransaction(ctx context.Context, objects []*BusinessTransaction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessTransaction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessTransaction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessTransaction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessTransaction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessTransaction(ctx context.Context, patchee *BusinessTransaction, patcher *BusinessTransaction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessTransaction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TransactionType" {
			patchee.TransactionType = patcher.TransactionType
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Contact" {
			patchee.Contact = patcher.Contact
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"LineItems" {
			patchee.LineItems = patcher.LineItems
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessTransaction executes a gorm list call
func DefaultListBusinessTransaction(ctx context.Context, db *gorm.DB) ([]*BusinessTransaction, error) {
	in := BusinessTransaction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessTransactionORM{}, &BusinessTransaction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessTransactionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessTransactionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessTransaction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessTransactionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessTransactionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessTransactionORM) error
}

// DefaultCreateTransactionLineItem executes a basic gorm create call
func DefaultCreateTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TransactionLineItemORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TransactionLineItemORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TransactionLineItemORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TransactionLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TransactionLineItemORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTransactionLineItemSet(ctx context.Context, in []*TransactionLineItem, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TransactionLineItemORM{})).(TransactionLineItemORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TransactionLineItemORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TransactionLineItemORM{})).(TransactionLineItemORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TransactionLineItemORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TransactionLineItem, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TransactionLineItem, *gorm.DB) error
}

// DefaultStrictUpdateTransactionLineItem clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTransactionLineItem(ctx context.Context, in *TransactionLineItem, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTransactionLineItem")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TransactionLineItemORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TransactionLineItemORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTransactionLineItem executes a basic gorm update call with patch behavior
func DefaultPatchTransactionLineItem(ctx context.Context, in *TransactionLineItem, updateMask *field_mask.FieldMask, db *gorm.DB) (*TransactionLineItem, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TransactionLineItem
	var err error
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTransactionLineItem(ctx, &TransactionLineItem{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTransactionLineItem(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TransactionLineItemWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTransactionLineItem(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TransactionLineItemWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TransactionLineItemWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TransactionLineItem, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTransactionLineItem executes a bulk gorm update call with patch behavior
func DefaultPatchSetTransactionLineItem(ctx context.Context, objects []*TransactionLineItem, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TransactionLineItem, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TransactionLineItem, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTransactionLineItem(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTransactionLineItem patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTransactionLineItem(ctx context.Context, patchee *TransactionLineItem, patcher *TransactionLineItem, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TransactionLineItem, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Memo" {
			patchee.Memo = patcher.Memo
			continue
		}
		if f == prefix+"UnitPrice" {
			patchee.UnitPrice = patcher.UnitPrice
			continue
		}
		if f == prefix+"Quantity" {
			patchee.Quantity = patcher.Quantity
			continue
		}
		if f == prefix+"Item" {
			patchee.Item = patcher.Item
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"TotalLineAmount" {
			patchee.TotalLineAmount = patcher.TotalLineAmount
			continue
		}
		if f == prefix+"TaxRate" {
			patchee.TaxRate = patcher.TaxRate
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTransactionLineItem executes a gorm list call
func DefaultListTransactionLineItem(ctx context.Context, db *gorm.DB) ([]*TransactionLineItem, error) {
	in := TransactionLineItem{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TransactionLineItemORM{}, &TransactionLineItem{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TransactionLineItemORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TransactionLineItemORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TransactionLineItem{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TransactionLineItemORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TransactionLineItemORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TransactionLineItemORM) error
}

// DefaultCreateVendorCredit executes a basic gorm create call
func DefaultCreateVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VendorCreditORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VendorCreditORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VendorCreditORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VendorCreditORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VendorCreditORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditSet(ctx context.Context, in []*VendorCredit, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VendorCreditORM{})).(VendorCreditORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VendorCreditORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VendorCreditORM{})).(VendorCreditORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VendorCreditORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VendorCredit, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VendorCredit, *gorm.DB) error
}

// DefaultStrictUpdateVendorCredit clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVendorCredit(ctx context.Context, in *VendorCredit, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVendorCredit")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VendorCreditORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLines := VendorCreditLineORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterLines.VendorCreditId = new(uint64)
	*filterLines.VendorCreditId = ormObj.Id
	if err = db.Where(filterLines).Delete(VendorCreditLineORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VendorCreditORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVendorCredit executes a basic gorm update call with patch behavior
func DefaultPatchVendorCredit(ctx context.Context, in *VendorCredit, updateMask *field_mask.FieldMask, db *gorm.DB) (*VendorCredit, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VendorCredit
	var err error
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVendorCredit(ctx, &VendorCredit{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVendorCredit(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VendorCreditWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVendorCredit(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VendorCreditWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VendorCreditWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VendorCredit, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVendorCredit executes a bulk gorm update call with patch behavior
func DefaultPatchSetVendorCredit(ctx context.Context, objects []*VendorCredit, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VendorCredit, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VendorCredit, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVendorCredit(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVendorCredit patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVendorCredit(ctx context.Context, patchee *VendorCredit, patcher *VendorCredit, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VendorCredit, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTransactionDate bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if !updatedTransactionDate && strings.HasPrefix(f, prefix+"TransactionDate.") {
			if patcher.TransactionDate == nil {
				patchee.TransactionDate = nil
				continue
			}
			if patchee.TransactionDate == nil {
				patchee.TransactionDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TransactionDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TransactionDate, patchee.TransactionDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TransactionDate" {
			updatedTransactionDate = true
			patchee.TransactionDate = patcher.TransactionDate
			continue
		}
		if f == prefix+"Vendor" {
			patchee.Vendor = patcher.Vendor
			continue
		}
		if f == prefix+"TotalAmount" {
			patchee.TotalAmount = patcher.TotalAmount
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"Lines" {
			patchee.Lines = patcher.Lines
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if f == prefix+"AccountingPeriod" {
			patchee.AccountingPeriod = patcher.AccountingPeriod
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVendorCredit executes a gorm list call
func DefaultListVendorCredit(ctx context.Context, db *gorm.DB) ([]*VendorCredit, error) {
	in := VendorCredit{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VendorCreditORM{}, &VendorCredit{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VendorCreditORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VendorCredit{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VendorCreditORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VendorCreditORM) error
}

// DefaultCreateVendorCreditLine executes a basic gorm create call
func DefaultCreateVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VendorCreditLineORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VendorCreditLineORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VendorCreditLineORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VendorCreditLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VendorCreditLineORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVendorCreditLineSet(ctx context.Context, in []*VendorCreditLine, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VendorCreditLineORM{})).(VendorCreditLineORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VendorCreditLineORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VendorCreditLineORM{})).(VendorCreditLineORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VendorCreditLineORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VendorCreditLine, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VendorCreditLine, *gorm.DB) error
}

// DefaultStrictUpdateVendorCreditLine clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVendorCreditLine(ctx context.Context, in *VendorCreditLine, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVendorCreditLine")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VendorCreditLineORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VendorCreditLineORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVendorCreditLine executes a basic gorm update call with patch behavior
func DefaultPatchVendorCreditLine(ctx context.Context, in *VendorCreditLine, updateMask *field_mask.FieldMask, db *gorm.DB) (*VendorCreditLine, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VendorCreditLine
	var err error
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVendorCreditLine(ctx, &VendorCreditLine{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVendorCreditLine(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VendorCreditLineWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVendorCreditLine(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VendorCreditLineWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VendorCreditLineWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VendorCreditLine, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVendorCreditLine executes a bulk gorm update call with patch behavior
func DefaultPatchSetVendorCreditLine(ctx context.Context, objects []*VendorCreditLine, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VendorCreditLine, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VendorCreditLine, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVendorCreditLine(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVendorCreditLine patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVendorCreditLine(ctx context.Context, patchee *VendorCreditLine, patcher *VendorCreditLine, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VendorCreditLine, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"NetAmount" {
			patchee.NetAmount = patcher.NetAmount
			continue
		}
		if f == prefix+"TrackingCategory" {
			patchee.TrackingCategory = patcher.TrackingCategory
			continue
		}
		if f == prefix+"TrackingCategories" {
			patchee.TrackingCategories = patcher.TrackingCategories
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Account" {
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"Company" {
			patchee.Company = patcher.Company
			continue
		}
		if f == prefix+"ExchangeRate" {
			patchee.ExchangeRate = patcher.ExchangeRate
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVendorCreditLine executes a gorm list call
func DefaultListVendorCreditLine(ctx context.Context, db *gorm.DB) ([]*VendorCreditLine, error) {
	in := VendorCreditLine{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VendorCreditLineORM{}, &VendorCreditLine{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VendorCreditLineORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VendorCreditLineORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VendorCreditLine{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VendorCreditLineORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VendorCreditLineORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VendorCreditLineORM) error
}
