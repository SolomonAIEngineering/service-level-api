package accounting_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type HrisIntegrationMergeLinkORM struct {
	Account                 *HrisLinkedAccountORM `gorm:"foreignkey:HrisIntegrationMergeLinkId;association_foreignkey:Id;preload:true"`
	Category                string
	EndUserEmailAddress     string
	EndUserOrganizationName string
	EndUserOriginId         string
	Id                      uint64
	Integration             string
	IntegrationImage        string
	IntegrationName         string
	IntegrationSlug         string
	IntegrationSquareImage  string
	IsDuplicate             bool
	LastModifiedAt          *time.Time
	MergeBusinessProfileId  *uint64
	MergeLinkedAccountId    string
	Status                  string
	Token                   *MergeLinkedAccountTokenORM `gorm:"foreignkey:HrisIntegrationMergeLinkId;association_foreignkey:Id;preload:true"`
	WebhookListenerUrl      string
}

// TableName overrides the default tablename generated by GORM
func (HrisIntegrationMergeLinkORM) TableName() string {
	return "hris_integration_merge_links"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HrisIntegrationMergeLink) ToORM(ctx context.Context) (HrisIntegrationMergeLinkORM, error) {
	to := HrisIntegrationMergeLinkORM{}
	var err error
	if prehook, ok := interface{}(m).(HrisIntegrationMergeLinkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	if m.Account != nil {
		tempAccount, err := m.Account.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if m.LastModifiedAt != nil {
		t := m.LastModifiedAt.AsTime()
		to.LastModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(HrisIntegrationMergeLinkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HrisIntegrationMergeLinkORM) ToPB(ctx context.Context) (HrisIntegrationMergeLink, error) {
	to := HrisIntegrationMergeLink{}
	var err error
	if prehook, ok := interface{}(m).(HrisIntegrationMergeLinkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Integration = m.Integration
	to.IntegrationSlug = m.IntegrationSlug
	to.Category = m.Category
	to.EndUserOriginId = m.EndUserOriginId
	to.EndUserOrganizationName = m.EndUserOrganizationName
	to.EndUserEmailAddress = m.EndUserEmailAddress
	to.Status = m.Status
	to.WebhookListenerUrl = m.WebhookListenerUrl
	to.IsDuplicate = m.IsDuplicate
	if m.Token != nil {
		tempToken, err := m.Token.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Token = &tempToken
	}
	to.IntegrationName = m.IntegrationName
	to.IntegrationImage = m.IntegrationImage
	to.IntegrationSquareImage = m.IntegrationSquareImage
	if m.Account != nil {
		tempAccount, err := m.Account.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Account = &tempAccount
	}
	to.MergeLinkedAccountId = m.MergeLinkedAccountId
	if m.LastModifiedAt != nil {
		to.LastModifiedAt = timestamppb.New(*m.LastModifiedAt)
	}
	if posthook, ok := interface{}(m).(HrisIntegrationMergeLinkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HrisIntegrationMergeLink the arg will be the target, the caller the one being converted from

// HrisIntegrationMergeLinkBeforeToORM called before default ToORM code
type HrisIntegrationMergeLinkWithBeforeToORM interface {
	BeforeToORM(context.Context, *HrisIntegrationMergeLinkORM) error
}

// HrisIntegrationMergeLinkAfterToORM called after default ToORM code
type HrisIntegrationMergeLinkWithAfterToORM interface {
	AfterToORM(context.Context, *HrisIntegrationMergeLinkORM) error
}

// HrisIntegrationMergeLinkBeforeToPB called before default ToPB code
type HrisIntegrationMergeLinkWithBeforeToPB interface {
	BeforeToPB(context.Context, *HrisIntegrationMergeLink) error
}

// HrisIntegrationMergeLinkAfterToPB called after default ToPB code
type HrisIntegrationMergeLinkWithAfterToPB interface {
	AfterToPB(context.Context, *HrisIntegrationMergeLink) error
}

type HrisLinkedAccountORM struct {
	BenefitPlans               []*EmployerBenefitsORM `gorm:"foreignkey:HrisLinkedAccountId;association_foreignkey:Id;preload:true"`
	Employees                  []*EmployeeORM         `gorm:"foreignkey:HrisLinkedAccountId;association_foreignkey:Id;preload:true"`
	HrisIntegrationMergeLinkId *uint64
	Id                         uint64
	PayrollRuns                []*EmployerPayrollRunORM `gorm:"foreignkey:HrisLinkedAccountId;association_foreignkey:Id;preload:true"`
	Profile                    *CompanyProfileORM       `gorm:"foreignkey:HrisLinkedAccountId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (HrisLinkedAccountORM) TableName() string {
	return "hris_linked_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HrisLinkedAccount) ToORM(ctx context.Context) (HrisLinkedAccountORM, error) {
	to := HrisLinkedAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(HrisLinkedAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Profile != nil {
		tempProfile, err := m.Profile.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Profile = &tempProfile
	}
	for _, v := range m.BenefitPlans {
		if v != nil {
			if tempBenefitPlans, cErr := v.ToORM(ctx); cErr == nil {
				to.BenefitPlans = append(to.BenefitPlans, &tempBenefitPlans)
			} else {
				return to, cErr
			}
		} else {
			to.BenefitPlans = append(to.BenefitPlans, nil)
		}
	}
	for _, v := range m.Employees {
		if v != nil {
			if tempEmployees, cErr := v.ToORM(ctx); cErr == nil {
				to.Employees = append(to.Employees, &tempEmployees)
			} else {
				return to, cErr
			}
		} else {
			to.Employees = append(to.Employees, nil)
		}
	}
	for _, v := range m.PayrollRuns {
		if v != nil {
			if tempPayrollRuns, cErr := v.ToORM(ctx); cErr == nil {
				to.PayrollRuns = append(to.PayrollRuns, &tempPayrollRuns)
			} else {
				return to, cErr
			}
		} else {
			to.PayrollRuns = append(to.PayrollRuns, nil)
		}
	}
	if posthook, ok := interface{}(m).(HrisLinkedAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HrisLinkedAccountORM) ToPB(ctx context.Context) (HrisLinkedAccount, error) {
	to := HrisLinkedAccount{}
	var err error
	if prehook, ok := interface{}(m).(HrisLinkedAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Profile != nil {
		tempProfile, err := m.Profile.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Profile = &tempProfile
	}
	for _, v := range m.BenefitPlans {
		if v != nil {
			if tempBenefitPlans, cErr := v.ToPB(ctx); cErr == nil {
				to.BenefitPlans = append(to.BenefitPlans, &tempBenefitPlans)
			} else {
				return to, cErr
			}
		} else {
			to.BenefitPlans = append(to.BenefitPlans, nil)
		}
	}
	for _, v := range m.Employees {
		if v != nil {
			if tempEmployees, cErr := v.ToPB(ctx); cErr == nil {
				to.Employees = append(to.Employees, &tempEmployees)
			} else {
				return to, cErr
			}
		} else {
			to.Employees = append(to.Employees, nil)
		}
	}
	for _, v := range m.PayrollRuns {
		if v != nil {
			if tempPayrollRuns, cErr := v.ToPB(ctx); cErr == nil {
				to.PayrollRuns = append(to.PayrollRuns, &tempPayrollRuns)
			} else {
				return to, cErr
			}
		} else {
			to.PayrollRuns = append(to.PayrollRuns, nil)
		}
	}
	if posthook, ok := interface{}(m).(HrisLinkedAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HrisLinkedAccount the arg will be the target, the caller the one being converted from

// HrisLinkedAccountBeforeToORM called before default ToORM code
type HrisLinkedAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *HrisLinkedAccountORM) error
}

// HrisLinkedAccountAfterToORM called after default ToORM code
type HrisLinkedAccountWithAfterToORM interface {
	AfterToORM(context.Context, *HrisLinkedAccountORM) error
}

// HrisLinkedAccountBeforeToPB called before default ToPB code
type HrisLinkedAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *HrisLinkedAccount) error
}

// HrisLinkedAccountAfterToPB called after default ToPB code
type HrisLinkedAccountWithAfterToPB interface {
	AfterToPB(context.Context, *HrisLinkedAccount) error
}

type CompanyProfileORM struct {
	DisplayName         string
	EinNumbers          pq.StringArray `gorm:"type:text[]"`
	HrisLinkedAccountId *uint64
	Id                  uint64
	LastUpdatedAt       *time.Time
	LegalName           string
	MergeAccountId      string
	ModifiedAt          *time.Time
	RemoteId            string
	RemoteWasDeleted    bool
}

// TableName overrides the default tablename generated by GORM
func (CompanyProfileORM) TableName() string {
	return "company_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CompanyProfile) ToORM(ctx context.Context) (CompanyProfileORM, error) {
	to := CompanyProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(CompanyProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.LegalName = m.LegalName
	to.DisplayName = m.DisplayName
	if m.EinNumbers != nil {
		to.EinNumbers = make(pq.StringArray, len(m.EinNumbers))
		copy(to.EinNumbers, m.EinNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if m.LastUpdatedAt != nil {
		t := m.LastUpdatedAt.AsTime()
		to.LastUpdatedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CompanyProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CompanyProfileORM) ToPB(ctx context.Context) (CompanyProfile, error) {
	to := CompanyProfile{}
	var err error
	if prehook, ok := interface{}(m).(CompanyProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.LegalName = m.LegalName
	to.DisplayName = m.DisplayName
	if m.EinNumbers != nil {
		to.EinNumbers = make(pq.StringArray, len(m.EinNumbers))
		copy(to.EinNumbers, m.EinNumbers)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if m.LastUpdatedAt != nil {
		to.LastUpdatedAt = timestamppb.New(*m.LastUpdatedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(CompanyProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CompanyProfile the arg will be the target, the caller the one being converted from

// CompanyProfileBeforeToORM called before default ToORM code
type CompanyProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *CompanyProfileORM) error
}

// CompanyProfileAfterToORM called after default ToORM code
type CompanyProfileWithAfterToORM interface {
	AfterToORM(context.Context, *CompanyProfileORM) error
}

// CompanyProfileBeforeToPB called before default ToPB code
type CompanyProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *CompanyProfile) error
}

// CompanyProfileAfterToPB called after default ToPB code
type CompanyProfileWithAfterToPB interface {
	AfterToPB(context.Context, *CompanyProfile) error
}

type EmployerBenefitsORM struct {
	BenefitPlanType     string
	CreatedAt           *time.Time
	DeductionCode       string
	Description         string
	EmployeeBenefits    []*EmployeeBenefitsORM `gorm:"foreignkey:EmployerBenefitsId;association_foreignkey:Id;preload:true"`
	HrisLinkedAccountId *uint64
	Id                  uint64
	MergeAccountId      string
	ModifiedAt          *time.Time
	Name                string
	RemoteId            string
	RemoteWasDeleted    *time.Time
}

// TableName overrides the default tablename generated by GORM
func (EmployerBenefitsORM) TableName() string {
	return "employer_benefits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmployerBenefits) ToORM(ctx context.Context) (EmployerBenefitsORM, error) {
	to := EmployerBenefitsORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployerBenefitsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.BenefitPlanType = BenefitPlanType_name[int32(m.BenefitPlanType)]
	to.Name = m.Name
	to.Description = m.Description
	to.DeductionCode = m.DeductionCode
	if m.RemoteWasDeleted != nil {
		t := m.RemoteWasDeleted.AsTime()
		to.RemoteWasDeleted = &t
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	for _, v := range m.EmployeeBenefits {
		if v != nil {
			if tempEmployeeBenefits, cErr := v.ToORM(ctx); cErr == nil {
				to.EmployeeBenefits = append(to.EmployeeBenefits, &tempEmployeeBenefits)
			} else {
				return to, cErr
			}
		} else {
			to.EmployeeBenefits = append(to.EmployeeBenefits, nil)
		}
	}
	if posthook, ok := interface{}(m).(EmployerBenefitsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployerBenefitsORM) ToPB(ctx context.Context) (EmployerBenefits, error) {
	to := EmployerBenefits{}
	var err error
	if prehook, ok := interface{}(m).(EmployerBenefitsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.BenefitPlanType = BenefitPlanType(BenefitPlanType_value[m.BenefitPlanType])
	to.Name = m.Name
	to.Description = m.Description
	to.DeductionCode = m.DeductionCode
	if m.RemoteWasDeleted != nil {
		to.RemoteWasDeleted = timestamppb.New(*m.RemoteWasDeleted)
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	for _, v := range m.EmployeeBenefits {
		if v != nil {
			if tempEmployeeBenefits, cErr := v.ToPB(ctx); cErr == nil {
				to.EmployeeBenefits = append(to.EmployeeBenefits, &tempEmployeeBenefits)
			} else {
				return to, cErr
			}
		} else {
			to.EmployeeBenefits = append(to.EmployeeBenefits, nil)
		}
	}
	if posthook, ok := interface{}(m).(EmployerBenefitsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmployerBenefits the arg will be the target, the caller the one being converted from

// EmployerBenefitsBeforeToORM called before default ToORM code
type EmployerBenefitsWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployerBenefitsORM) error
}

// EmployerBenefitsAfterToORM called after default ToORM code
type EmployerBenefitsWithAfterToORM interface {
	AfterToORM(context.Context, *EmployerBenefitsORM) error
}

// EmployerBenefitsBeforeToPB called before default ToPB code
type EmployerBenefitsWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmployerBenefits) error
}

// EmployerBenefitsAfterToPB called after default ToPB code
type EmployerBenefitsWithAfterToPB interface {
	AfterToPB(context.Context, *EmployerBenefits) error
}

type EmployeeORM struct {
	ApproverTimeOffId                *uint64
	Avatar                           string
	BankAccounts                     []*BankInfoORM         `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	Benefits                         []*EmployeeBenefitsORM `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	CompanyId                        string
	CreatedAt                        *time.Time
	DateOfBirth                      string
	Dependents                       []*DependentsORM `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	DisplayFullName                  string
	EmployeeId                       *uint64
	EmployeeNumber                   string
	EmployeeTimeOffId                *uint64
	EmployeeUserNameAsSeenInRemoteUi string
	EmployeesPreferredName           string
	EmploymentStatus                 string
	EmploymentType                   string
	Employments                      []*EmployeeJobPositionAtCompanyORM `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	Ethnicity                        string
	FirstName                        string
	Gender                           string
	Group                            *GroupORM           `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	HomeLocation                     *LocationAddressORM `gorm:"foreignkey:HomeLocationEmployeeId;association_foreignkey:Id;preload:true"`
	HrisLinkedAccountId              *uint64
	Id                               uint64
	LastName                         string
	Manager                          *EmployeeORM `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	MaritalStatus                    string
	MergeAccountId                   string
	MobilePhoneNumber                string
	ModifiedAt                       *time.Time
	PayTimeOffBalance                *EmployeTimeOffBalanceORM `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	PayrollRuns                      []*EmployeePayrollRunORM  `gorm:"foreignkey:EmployeeId;association_foreignkey:Id;preload:true"`
	PersonalEmail                    string
	RemoteCreatedAt                  *time.Time
	RemoteId                         string
	RemoteWasDeleted                 bool
	Ssn                              string
	StartDate                        *time.Time
	TerminationDate                  *time.Time
	WorkEmail                        string
	WorkLocation                     *LocationAddressORM `gorm:"foreignkey:WorkLocationEmployeeId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (EmployeeORM) TableName() string {
	return "employees"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Employee) ToORM(ctx context.Context) (EmployeeORM, error) {
	to := EmployeeORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.EmployeeNumber = m.EmployeeNumber
	to.CompanyId = m.CompanyId
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.EmployeesPreferredName = m.EmployeesPreferredName
	to.DisplayFullName = m.DisplayFullName
	to.EmployeeUserNameAsSeenInRemoteUi = m.EmployeeUserNameAsSeenInRemoteUi
	to.WorkEmail = m.WorkEmail
	to.PersonalEmail = m.PersonalEmail
	to.MobilePhoneNumber = m.MobilePhoneNumber
	for _, v := range m.Employments {
		if v != nil {
			if tempEmployments, cErr := v.ToORM(ctx); cErr == nil {
				to.Employments = append(to.Employments, &tempEmployments)
			} else {
				return to, cErr
			}
		} else {
			to.Employments = append(to.Employments, nil)
		}
	}
	to.EmploymentType = m.EmploymentType
	if m.HomeLocation != nil {
		tempHomeLocation, err := m.HomeLocation.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HomeLocation = &tempHomeLocation
	}
	if m.WorkLocation != nil {
		tempWorkLocation, err := m.WorkLocation.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.WorkLocation = &tempWorkLocation
	}
	if m.Manager != nil {
		tempManager, err := m.Manager.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Manager = &tempManager
	}
	if m.Group != nil {
		tempGroup, err := m.Group.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Group = &tempGroup
	}
	to.Ssn = m.Ssn
	to.Gender = Gender_name[int32(m.Gender)]
	to.Ethnicity = Ethnicity_name[int32(m.Ethnicity)]
	to.MaritalStatus = MaritalStatus_name[int32(m.MaritalStatus)]
	to.DateOfBirth = m.DateOfBirth
	if m.StartDate != nil {
		t := m.StartDate.AsTime()
		to.StartDate = &t
	}
	if m.RemoteCreatedAt != nil {
		t := m.RemoteCreatedAt.AsTime()
		to.RemoteCreatedAt = &t
	}
	to.EmploymentStatus = EmploymentStatus_name[int32(m.EmploymentStatus)]
	if m.TerminationDate != nil {
		t := m.TerminationDate.AsTime()
		to.TerminationDate = &t
	}
	to.Avatar = m.Avatar
	for _, v := range m.BankAccounts {
		if v != nil {
			if tempBankAccounts, cErr := v.ToORM(ctx); cErr == nil {
				to.BankAccounts = append(to.BankAccounts, &tempBankAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.BankAccounts = append(to.BankAccounts, nil)
		}
	}
	for _, v := range m.Dependents {
		if v != nil {
			if tempDependents, cErr := v.ToORM(ctx); cErr == nil {
				to.Dependents = append(to.Dependents, &tempDependents)
			} else {
				return to, cErr
			}
		} else {
			to.Dependents = append(to.Dependents, nil)
		}
	}
	for _, v := range m.PayrollRuns {
		if v != nil {
			if tempPayrollRuns, cErr := v.ToORM(ctx); cErr == nil {
				to.PayrollRuns = append(to.PayrollRuns, &tempPayrollRuns)
			} else {
				return to, cErr
			}
		} else {
			to.PayrollRuns = append(to.PayrollRuns, nil)
		}
	}
	if m.PayTimeOffBalance != nil {
		tempPayTimeOffBalance, err := m.PayTimeOffBalance.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PayTimeOffBalance = &tempPayTimeOffBalance
	}
	for _, v := range m.Benefits {
		if v != nil {
			if tempBenefits, cErr := v.ToORM(ctx); cErr == nil {
				to.Benefits = append(to.Benefits, &tempBenefits)
			} else {
				return to, cErr
			}
		} else {
			to.Benefits = append(to.Benefits, nil)
		}
	}
	to.MergeAccountId = m.MergeAccountId
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(EmployeeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployeeORM) ToPB(ctx context.Context) (Employee, error) {
	to := Employee{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.EmployeeNumber = m.EmployeeNumber
	to.CompanyId = m.CompanyId
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.EmployeesPreferredName = m.EmployeesPreferredName
	to.DisplayFullName = m.DisplayFullName
	to.EmployeeUserNameAsSeenInRemoteUi = m.EmployeeUserNameAsSeenInRemoteUi
	to.WorkEmail = m.WorkEmail
	to.PersonalEmail = m.PersonalEmail
	to.MobilePhoneNumber = m.MobilePhoneNumber
	for _, v := range m.Employments {
		if v != nil {
			if tempEmployments, cErr := v.ToPB(ctx); cErr == nil {
				to.Employments = append(to.Employments, &tempEmployments)
			} else {
				return to, cErr
			}
		} else {
			to.Employments = append(to.Employments, nil)
		}
	}
	to.EmploymentType = m.EmploymentType
	if m.HomeLocation != nil {
		tempHomeLocation, err := m.HomeLocation.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HomeLocation = &tempHomeLocation
	}
	if m.WorkLocation != nil {
		tempWorkLocation, err := m.WorkLocation.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.WorkLocation = &tempWorkLocation
	}
	if m.Manager != nil {
		tempManager, err := m.Manager.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Manager = &tempManager
	}
	if m.Group != nil {
		tempGroup, err := m.Group.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Group = &tempGroup
	}
	to.Ssn = m.Ssn
	to.Gender = Gender(Gender_value[m.Gender])
	to.Ethnicity = Ethnicity(Ethnicity_value[m.Ethnicity])
	to.MaritalStatus = MaritalStatus(MaritalStatus_value[m.MaritalStatus])
	to.DateOfBirth = m.DateOfBirth
	if m.StartDate != nil {
		to.StartDate = timestamppb.New(*m.StartDate)
	}
	if m.RemoteCreatedAt != nil {
		to.RemoteCreatedAt = timestamppb.New(*m.RemoteCreatedAt)
	}
	to.EmploymentStatus = EmploymentStatus(EmploymentStatus_value[m.EmploymentStatus])
	if m.TerminationDate != nil {
		to.TerminationDate = timestamppb.New(*m.TerminationDate)
	}
	to.Avatar = m.Avatar
	for _, v := range m.BankAccounts {
		if v != nil {
			if tempBankAccounts, cErr := v.ToPB(ctx); cErr == nil {
				to.BankAccounts = append(to.BankAccounts, &tempBankAccounts)
			} else {
				return to, cErr
			}
		} else {
			to.BankAccounts = append(to.BankAccounts, nil)
		}
	}
	for _, v := range m.Dependents {
		if v != nil {
			if tempDependents, cErr := v.ToPB(ctx); cErr == nil {
				to.Dependents = append(to.Dependents, &tempDependents)
			} else {
				return to, cErr
			}
		} else {
			to.Dependents = append(to.Dependents, nil)
		}
	}
	for _, v := range m.PayrollRuns {
		if v != nil {
			if tempPayrollRuns, cErr := v.ToPB(ctx); cErr == nil {
				to.PayrollRuns = append(to.PayrollRuns, &tempPayrollRuns)
			} else {
				return to, cErr
			}
		} else {
			to.PayrollRuns = append(to.PayrollRuns, nil)
		}
	}
	if m.PayTimeOffBalance != nil {
		tempPayTimeOffBalance, err := m.PayTimeOffBalance.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PayTimeOffBalance = &tempPayTimeOffBalance
	}
	for _, v := range m.Benefits {
		if v != nil {
			if tempBenefits, cErr := v.ToPB(ctx); cErr == nil {
				to.Benefits = append(to.Benefits, &tempBenefits)
			} else {
				return to, cErr
			}
		} else {
			to.Benefits = append(to.Benefits, nil)
		}
	}
	to.MergeAccountId = m.MergeAccountId
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if posthook, ok := interface{}(m).(EmployeeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Employee the arg will be the target, the caller the one being converted from

// EmployeeBeforeToORM called before default ToORM code
type EmployeeWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployeeORM) error
}

// EmployeeAfterToORM called after default ToORM code
type EmployeeWithAfterToORM interface {
	AfterToORM(context.Context, *EmployeeORM) error
}

// EmployeeBeforeToPB called before default ToPB code
type EmployeeWithBeforeToPB interface {
	BeforeToPB(context.Context, *Employee) error
}

// EmployeeAfterToPB called after default ToPB code
type EmployeeWithAfterToPB interface {
	AfterToPB(context.Context, *Employee) error
}

type EmployeeBenefitsORM struct {
	BenefitPlanMergeAccountId string
	CompanyContribution       uint64
	CreatedAt                 *time.Time
	EmployeeContribution      uint64
	EmployeeId                *uint64
	EmployeeMergeAccountId    string
	EmployerBenefitsId        *uint64
	EndDate                   *time.Time
	Id                        uint64
	MergeAccountId            string
	ModifiedAt                *time.Time
	ProviderName              string
	RemoteId                  string
	RemoteWasDeleted          bool
	StartDate                 *time.Time
}

// TableName overrides the default tablename generated by GORM
func (EmployeeBenefitsORM) TableName() string {
	return "employee_benefits"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmployeeBenefits) ToORM(ctx context.Context) (EmployeeBenefitsORM, error) {
	to := EmployeeBenefitsORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeBenefitsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.ProviderName = m.ProviderName
	to.EmployeeMergeAccountId = m.EmployeeMergeAccountId
	to.BenefitPlanMergeAccountId = m.BenefitPlanMergeAccountId
	to.EmployeeContribution = m.EmployeeContribution
	to.CompanyContribution = m.CompanyContribution
	if m.StartDate != nil {
		t := m.StartDate.AsTime()
		to.StartDate = &t
	}
	if m.EndDate != nil {
		t := m.EndDate.AsTime()
		to.EndDate = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeeBenefitsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployeeBenefitsORM) ToPB(ctx context.Context) (EmployeeBenefits, error) {
	to := EmployeeBenefits{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeBenefitsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.ProviderName = m.ProviderName
	to.EmployeeMergeAccountId = m.EmployeeMergeAccountId
	to.BenefitPlanMergeAccountId = m.BenefitPlanMergeAccountId
	to.EmployeeContribution = m.EmployeeContribution
	to.CompanyContribution = m.CompanyContribution
	if m.StartDate != nil {
		to.StartDate = timestamppb.New(*m.StartDate)
	}
	if m.EndDate != nil {
		to.EndDate = timestamppb.New(*m.EndDate)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeeBenefitsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmployeeBenefits the arg will be the target, the caller the one being converted from

// EmployeeBenefitsBeforeToORM called before default ToORM code
type EmployeeBenefitsWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployeeBenefitsORM) error
}

// EmployeeBenefitsAfterToORM called after default ToORM code
type EmployeeBenefitsWithAfterToORM interface {
	AfterToORM(context.Context, *EmployeeBenefitsORM) error
}

// EmployeeBenefitsBeforeToPB called before default ToPB code
type EmployeeBenefitsWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmployeeBenefits) error
}

// EmployeeBenefitsAfterToPB called after default ToPB code
type EmployeeBenefitsWithAfterToPB interface {
	AfterToPB(context.Context, *EmployeeBenefits) error
}

type EmployerPayrollRunORM struct {
	CheckDate           *time.Time
	CreatedAt           *time.Time
	EndDate             *time.Time
	HrisLinkedAccountId *uint64
	Id                  uint64
	ModifiedAt          *time.Time
	PayrollRuns         []*EmployeePayrollRunORM `gorm:"foreignkey:EmployerPayrollRunId;association_foreignkey:Id;preload:true"`
	RemoteId            string
	RemoteWasDeleted    bool
	RunState            string
	RunType             string
	StartDate           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (EmployerPayrollRunORM) TableName() string {
	return "employer_payroll_runs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmployerPayrollRun) ToORM(ctx context.Context) (EmployerPayrollRunORM, error) {
	to := EmployerPayrollRunORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployerPayrollRunWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.RunState = PayrollRunState_name[int32(m.RunState)]
	to.RunType = PayrollRunType_name[int32(m.RunType)]
	if m.StartDate != nil {
		t := m.StartDate.AsTime()
		to.StartDate = &t
	}
	if m.EndDate != nil {
		t := m.EndDate.AsTime()
		to.EndDate = &t
	}
	if m.CheckDate != nil {
		t := m.CheckDate.AsTime()
		to.CheckDate = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	for _, v := range m.PayrollRuns {
		if v != nil {
			if tempPayrollRuns, cErr := v.ToORM(ctx); cErr == nil {
				to.PayrollRuns = append(to.PayrollRuns, &tempPayrollRuns)
			} else {
				return to, cErr
			}
		} else {
			to.PayrollRuns = append(to.PayrollRuns, nil)
		}
	}
	if posthook, ok := interface{}(m).(EmployerPayrollRunWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployerPayrollRunORM) ToPB(ctx context.Context) (EmployerPayrollRun, error) {
	to := EmployerPayrollRun{}
	var err error
	if prehook, ok := interface{}(m).(EmployerPayrollRunWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.RunState = PayrollRunState(PayrollRunState_value[m.RunState])
	to.RunType = PayrollRunType(PayrollRunType_value[m.RunType])
	if m.StartDate != nil {
		to.StartDate = timestamppb.New(*m.StartDate)
	}
	if m.EndDate != nil {
		to.EndDate = timestamppb.New(*m.EndDate)
	}
	if m.CheckDate != nil {
		to.CheckDate = timestamppb.New(*m.CheckDate)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	for _, v := range m.PayrollRuns {
		if v != nil {
			if tempPayrollRuns, cErr := v.ToPB(ctx); cErr == nil {
				to.PayrollRuns = append(to.PayrollRuns, &tempPayrollRuns)
			} else {
				return to, cErr
			}
		} else {
			to.PayrollRuns = append(to.PayrollRuns, nil)
		}
	}
	if posthook, ok := interface{}(m).(EmployerPayrollRunWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmployerPayrollRun the arg will be the target, the caller the one being converted from

// EmployerPayrollRunBeforeToORM called before default ToORM code
type EmployerPayrollRunWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployerPayrollRunORM) error
}

// EmployerPayrollRunAfterToORM called after default ToORM code
type EmployerPayrollRunWithAfterToORM interface {
	AfterToORM(context.Context, *EmployerPayrollRunORM) error
}

// EmployerPayrollRunBeforeToPB called before default ToPB code
type EmployerPayrollRunWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmployerPayrollRun) error
}

// EmployerPayrollRunAfterToPB called after default ToPB code
type EmployerPayrollRunWithAfterToPB interface {
	AfterToPB(context.Context, *EmployerPayrollRun) error
}

type EmployeeJobPositionAtCompanyORM struct {
	CreatedAt        *time.Time
	EffectiveDate    *time.Time
	EmployeeId       *uint64
	FlsaStatus       string
	Id               uint64
	JobTitle         string
	MergeAccountId   string
	ModifiedAt       *time.Time
	PayCurrency      string
	PayFrequency     string
	PayPeriod        string
	PayRate          float64
	RemoteId         string
	RemoteWasDeleted bool
}

// TableName overrides the default tablename generated by GORM
func (EmployeeJobPositionAtCompanyORM) TableName() string {
	return "employee_job_position_at_companies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmployeeJobPositionAtCompany) ToORM(ctx context.Context) (EmployeeJobPositionAtCompanyORM, error) {
	to := EmployeeJobPositionAtCompanyORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeJobPositionAtCompanyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.JobTitle = m.JobTitle
	to.PayRate = m.PayRate
	to.PayPeriod = PayPeriod_name[int32(m.PayPeriod)]
	to.PayFrequency = PayFrequency_name[int32(m.PayFrequency)]
	to.PayCurrency = m.PayCurrency
	to.FlsaStatus = FlsaStatus_name[int32(m.FlsaStatus)]
	if m.EffectiveDate != nil {
		t := m.EffectiveDate.AsTime()
		to.EffectiveDate = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeeJobPositionAtCompanyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployeeJobPositionAtCompanyORM) ToPB(ctx context.Context) (EmployeeJobPositionAtCompany, error) {
	to := EmployeeJobPositionAtCompany{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeJobPositionAtCompanyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.JobTitle = m.JobTitle
	to.PayRate = m.PayRate
	to.PayPeriod = PayPeriod(PayPeriod_value[m.PayPeriod])
	to.PayFrequency = PayFrequency(PayFrequency_value[m.PayFrequency])
	to.PayCurrency = m.PayCurrency
	to.FlsaStatus = FlsaStatus(FlsaStatus_value[m.FlsaStatus])
	if m.EffectiveDate != nil {
		to.EffectiveDate = timestamppb.New(*m.EffectiveDate)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeeJobPositionAtCompanyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmployeeJobPositionAtCompany the arg will be the target, the caller the one being converted from

// EmployeeJobPositionAtCompanyBeforeToORM called before default ToORM code
type EmployeeJobPositionAtCompanyWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployeeJobPositionAtCompanyORM) error
}

// EmployeeJobPositionAtCompanyAfterToORM called after default ToORM code
type EmployeeJobPositionAtCompanyWithAfterToORM interface {
	AfterToORM(context.Context, *EmployeeJobPositionAtCompanyORM) error
}

// EmployeeJobPositionAtCompanyBeforeToPB called before default ToPB code
type EmployeeJobPositionAtCompanyWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmployeeJobPositionAtCompany) error
}

// EmployeeJobPositionAtCompanyAfterToPB called after default ToPB code
type EmployeeJobPositionAtCompanyWithAfterToPB interface {
	AfterToPB(context.Context, *EmployeeJobPositionAtCompany) error
}

type GroupORM struct {
	CreatedAt                 *time.Time
	EmployeeId                *uint64
	Id                        uint64
	MergeAccountId            string
	ModifiedAt                *time.Time
	Name                      string
	ParentGroupMergeAccountId string
	RemoteId                  string
	RemoteWasDeleted          bool
	Type                      string
}

// TableName overrides the default tablename generated by GORM
func (GroupORM) TableName() string {
	return "groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Group) ToORM(ctx context.Context) (GroupORM, error) {
	to := GroupORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Type = PayGroupType_name[int32(m.Type)]
	to.ParentGroupMergeAccountId = m.ParentGroupMergeAccountId
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(GroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupORM) ToPB(ctx context.Context) (Group, error) {
	to := Group{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Type = PayGroupType(PayGroupType_value[m.Type])
	to.ParentGroupMergeAccountId = m.ParentGroupMergeAccountId
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(GroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Group the arg will be the target, the caller the one being converted from

// GroupBeforeToORM called before default ToORM code
type GroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupORM) error
}

// GroupAfterToORM called after default ToORM code
type GroupWithAfterToORM interface {
	AfterToORM(context.Context, *GroupORM) error
}

// GroupBeforeToPB called before default ToPB code
type GroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *Group) error
}

// GroupAfterToPB called after default ToPB code
type GroupWithAfterToPB interface {
	AfterToPB(context.Context, *Group) error
}

type LocationAddressORM struct {
	City                   string
	Country                string
	CreatedAt              *time.Time
	DependentsId           *uint64
	HomeLocationEmployeeId *uint64
	Id                     uint64
	LocationType           string
	MergeAccountId         string
	ModifiedAt             *time.Time
	Name                   string
	PhoneNumber            string
	RemoteId               string
	RemoteWasDeleted       bool
	State                  string
	Street_1               string
	Street_2               string
	WorkLocationEmployeeId *uint64
	ZipCode                string
}

// TableName overrides the default tablename generated by GORM
func (LocationAddressORM) TableName() string {
	return "location_addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LocationAddress) ToORM(ctx context.Context) (LocationAddressORM, error) {
	to := LocationAddressORM{}
	var err error
	if prehook, ok := interface{}(m).(LocationAddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.PhoneNumber = m.PhoneNumber
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.ZipCode = m.ZipCode
	to.Country = m.Country
	to.LocationType = LocationType_name[int32(m.LocationType)]
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(LocationAddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LocationAddressORM) ToPB(ctx context.Context) (LocationAddress, error) {
	to := LocationAddress{}
	var err error
	if prehook, ok := interface{}(m).(LocationAddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.PhoneNumber = m.PhoneNumber
	to.Street_1 = m.Street_1
	to.Street_2 = m.Street_2
	to.City = m.City
	to.State = m.State
	to.ZipCode = m.ZipCode
	to.Country = m.Country
	to.LocationType = LocationType(LocationType_value[m.LocationType])
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(LocationAddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LocationAddress the arg will be the target, the caller the one being converted from

// LocationAddressBeforeToORM called before default ToORM code
type LocationAddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *LocationAddressORM) error
}

// LocationAddressAfterToORM called after default ToORM code
type LocationAddressWithAfterToORM interface {
	AfterToORM(context.Context, *LocationAddressORM) error
}

// LocationAddressBeforeToPB called before default ToPB code
type LocationAddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *LocationAddress) error
}

// LocationAddressAfterToPB called after default ToPB code
type LocationAddressWithAfterToPB interface {
	AfterToPB(context.Context, *LocationAddress) error
}

type BankInfoORM struct {
	AccountNumber    string
	AccountType      string
	BankName         string
	CreatedAt        *time.Time
	EmployeeId       *uint64
	Id               uint64
	MergeAccountId   string
	ModifiedAt       *time.Time
	RemoteId         string
	RemoteWasDeleted bool
	RoutingNumber    string
}

// TableName overrides the default tablename generated by GORM
func (BankInfoORM) TableName() string {
	return "bank_infos"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BankInfo) ToORM(ctx context.Context) (BankInfoORM, error) {
	to := BankInfoORM{}
	var err error
	if prehook, ok := interface{}(m).(BankInfoWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.AccountNumber = m.AccountNumber
	to.RoutingNumber = m.RoutingNumber
	to.BankName = m.BankName
	to.AccountType = BankAccountType_name[int32(m.AccountType)]
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	if posthook, ok := interface{}(m).(BankInfoWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BankInfoORM) ToPB(ctx context.Context) (BankInfo, error) {
	to := BankInfo{}
	var err error
	if prehook, ok := interface{}(m).(BankInfoWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.AccountNumber = m.AccountNumber
	to.RoutingNumber = m.RoutingNumber
	to.BankName = m.BankName
	to.AccountType = BankAccountType(BankAccountType_value[m.AccountType])
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	if posthook, ok := interface{}(m).(BankInfoWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BankInfo the arg will be the target, the caller the one being converted from

// BankInfoBeforeToORM called before default ToORM code
type BankInfoWithBeforeToORM interface {
	BeforeToORM(context.Context, *BankInfoORM) error
}

// BankInfoAfterToORM called after default ToORM code
type BankInfoWithAfterToORM interface {
	AfterToORM(context.Context, *BankInfoORM) error
}

// BankInfoBeforeToPB called before default ToPB code
type BankInfoWithBeforeToPB interface {
	BeforeToPB(context.Context, *BankInfo) error
}

// BankInfoAfterToPB called after default ToPB code
type BankInfoWithAfterToPB interface {
	AfterToPB(context.Context, *BankInfo) error
}

type DependentsORM struct {
	CreatedAt                       *time.Time
	DateOfBirth                     *time.Time
	DependentRelationshipToEmployee string
	EmployeeId                      *uint64
	FirstName                       string
	Gender                          string
	HomeLocation                    *LocationAddressORM `gorm:"foreignkey:DependentsId;association_foreignkey:Id"`
	Id                              uint64
	IsStudent                       bool
	LastName                        string
	MergeAccountId                  string
	MiddleName                      string
	ModifiedAt                      *time.Time
	PhoneNumber                     string
	RemoteId                        string
	RemoteWasDeleted                bool
	Ssn                             string
}

// TableName overrides the default tablename generated by GORM
func (DependentsORM) TableName() string {
	return "dependents"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Dependents) ToORM(ctx context.Context) (DependentsORM, error) {
	to := DependentsORM{}
	var err error
	if prehook, ok := interface{}(m).(DependentsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.MiddleName = m.MiddleName
	to.DependentRelationshipToEmployee = DependentRelationship_name[int32(m.DependentRelationshipToEmployee)]
	if m.DateOfBirth != nil {
		t := m.DateOfBirth.AsTime()
		to.DateOfBirth = &t
	}
	to.Gender = Gender_name[int32(m.Gender)]
	to.PhoneNumber = m.PhoneNumber
	if m.HomeLocation != nil {
		tempHomeLocation, err := m.HomeLocation.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HomeLocation = &tempHomeLocation
	}
	to.IsStudent = m.IsStudent
	to.Ssn = m.Ssn
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(DependentsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DependentsORM) ToPB(ctx context.Context) (Dependents, error) {
	to := Dependents{}
	var err error
	if prehook, ok := interface{}(m).(DependentsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.MiddleName = m.MiddleName
	to.DependentRelationshipToEmployee = DependentRelationship(DependentRelationship_value[m.DependentRelationshipToEmployee])
	if m.DateOfBirth != nil {
		to.DateOfBirth = timestamppb.New(*m.DateOfBirth)
	}
	to.Gender = Gender(Gender_value[m.Gender])
	to.PhoneNumber = m.PhoneNumber
	if m.HomeLocation != nil {
		tempHomeLocation, err := m.HomeLocation.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HomeLocation = &tempHomeLocation
	}
	to.IsStudent = m.IsStudent
	to.Ssn = m.Ssn
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(DependentsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Dependents the arg will be the target, the caller the one being converted from

// DependentsBeforeToORM called before default ToORM code
type DependentsWithBeforeToORM interface {
	BeforeToORM(context.Context, *DependentsORM) error
}

// DependentsAfterToORM called after default ToORM code
type DependentsWithAfterToORM interface {
	AfterToORM(context.Context, *DependentsORM) error
}

// DependentsBeforeToPB called before default ToPB code
type DependentsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Dependents) error
}

// DependentsAfterToPB called after default ToPB code
type DependentsWithAfterToPB interface {
	AfterToPB(context.Context, *Dependents) error
}

type EmployeePayrollRunORM struct {
	CheckDate                *time.Time
	CreatedAt                *time.Time
	Deductions               []*DeductionORM `gorm:"foreignkey:EmployeePayrollRunId;association_foreignkey:Id"`
	Earnings                 []*EarningORM   `gorm:"foreignkey:EmployeePayrollRunId;association_foreignkey:Id"`
	EmployeeId               *uint64
	EmployeeMergeAccountId   string
	EmployerPayrollRunId     *uint64
	EndDate                  *time.Time
	GrossPay                 float64
	Id                       uint64
	MergeAccountId           string
	ModifiedAt               *time.Time
	NetPay                   float64
	PayrollRunMergeAccountId string
	RemoteId                 string
	RemoteWasDeleted         bool
	StartDate                *time.Time
	Taxes                    []*TaxORM `gorm:"foreignkey:EmployeePayrollRunId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (EmployeePayrollRunORM) TableName() string {
	return "employee_payroll_runs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmployeePayrollRun) ToORM(ctx context.Context) (EmployeePayrollRunORM, error) {
	to := EmployeePayrollRunORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployeePayrollRunWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.GrossPay = m.GrossPay
	to.NetPay = m.NetPay
	if m.StartDate != nil {
		t := m.StartDate.AsTime()
		to.StartDate = &t
	}
	if m.EndDate != nil {
		t := m.EndDate.AsTime()
		to.EndDate = &t
	}
	if m.CheckDate != nil {
		t := m.CheckDate.AsTime()
		to.CheckDate = &t
	}
	for _, v := range m.Earnings {
		if v != nil {
			if tempEarnings, cErr := v.ToORM(ctx); cErr == nil {
				to.Earnings = append(to.Earnings, &tempEarnings)
			} else {
				return to, cErr
			}
		} else {
			to.Earnings = append(to.Earnings, nil)
		}
	}
	for _, v := range m.Deductions {
		if v != nil {
			if tempDeductions, cErr := v.ToORM(ctx); cErr == nil {
				to.Deductions = append(to.Deductions, &tempDeductions)
			} else {
				return to, cErr
			}
		} else {
			to.Deductions = append(to.Deductions, nil)
		}
	}
	for _, v := range m.Taxes {
		if v != nil {
			if tempTaxes, cErr := v.ToORM(ctx); cErr == nil {
				to.Taxes = append(to.Taxes, &tempTaxes)
			} else {
				return to, cErr
			}
		} else {
			to.Taxes = append(to.Taxes, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.EmployeeMergeAccountId = m.EmployeeMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeePayrollRunWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployeePayrollRunORM) ToPB(ctx context.Context) (EmployeePayrollRun, error) {
	to := EmployeePayrollRun{}
	var err error
	if prehook, ok := interface{}(m).(EmployeePayrollRunWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.GrossPay = m.GrossPay
	to.NetPay = m.NetPay
	if m.StartDate != nil {
		to.StartDate = timestamppb.New(*m.StartDate)
	}
	if m.EndDate != nil {
		to.EndDate = timestamppb.New(*m.EndDate)
	}
	if m.CheckDate != nil {
		to.CheckDate = timestamppb.New(*m.CheckDate)
	}
	for _, v := range m.Earnings {
		if v != nil {
			if tempEarnings, cErr := v.ToPB(ctx); cErr == nil {
				to.Earnings = append(to.Earnings, &tempEarnings)
			} else {
				return to, cErr
			}
		} else {
			to.Earnings = append(to.Earnings, nil)
		}
	}
	for _, v := range m.Deductions {
		if v != nil {
			if tempDeductions, cErr := v.ToPB(ctx); cErr == nil {
				to.Deductions = append(to.Deductions, &tempDeductions)
			} else {
				return to, cErr
			}
		} else {
			to.Deductions = append(to.Deductions, nil)
		}
	}
	for _, v := range m.Taxes {
		if v != nil {
			if tempTaxes, cErr := v.ToPB(ctx); cErr == nil {
				to.Taxes = append(to.Taxes, &tempTaxes)
			} else {
				return to, cErr
			}
		} else {
			to.Taxes = append(to.Taxes, nil)
		}
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.EmployeeMergeAccountId = m.EmployeeMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeePayrollRunWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmployeePayrollRun the arg will be the target, the caller the one being converted from

// EmployeePayrollRunBeforeToORM called before default ToORM code
type EmployeePayrollRunWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployeePayrollRunORM) error
}

// EmployeePayrollRunAfterToORM called after default ToORM code
type EmployeePayrollRunWithAfterToORM interface {
	AfterToORM(context.Context, *EmployeePayrollRunORM) error
}

// EmployeePayrollRunBeforeToPB called before default ToPB code
type EmployeePayrollRunWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmployeePayrollRun) error
}

// EmployeePayrollRunAfterToPB called after default ToPB code
type EmployeePayrollRunWithAfterToPB interface {
	AfterToPB(context.Context, *EmployeePayrollRun) error
}

type EarningORM struct {
	Amount                   float64
	CreatedAt                *time.Time
	EmployeePayrollRunId     *uint64
	Id                       uint64
	MergeAccountId           string
	ModifiedAt               *time.Time
	PayrollRunMergeAccountId string
	RemoteId                 string
	RemoteWasDeleted         bool
	Type                     string
}

// TableName overrides the default tablename generated by GORM
func (EarningORM) TableName() string {
	return "earnings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Earning) ToORM(ctx context.Context) (EarningORM, error) {
	to := EarningORM{}
	var err error
	if prehook, ok := interface{}(m).(EarningWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Amount = m.Amount
	to.Type = EarningType_name[int32(m.Type)]
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EarningWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EarningORM) ToPB(ctx context.Context) (Earning, error) {
	to := Earning{}
	var err error
	if prehook, ok := interface{}(m).(EarningWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Amount = m.Amount
	to.Type = EarningType(EarningType_value[m.Type])
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EarningWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Earning the arg will be the target, the caller the one being converted from

// EarningBeforeToORM called before default ToORM code
type EarningWithBeforeToORM interface {
	BeforeToORM(context.Context, *EarningORM) error
}

// EarningAfterToORM called after default ToORM code
type EarningWithAfterToORM interface {
	AfterToORM(context.Context, *EarningORM) error
}

// EarningBeforeToPB called before default ToPB code
type EarningWithBeforeToPB interface {
	BeforeToPB(context.Context, *Earning) error
}

// EarningAfterToPB called after default ToPB code
type EarningWithAfterToPB interface {
	AfterToPB(context.Context, *Earning) error
}

type DeductionORM struct {
	CompanyDeduction         float64
	CreatedAt                *time.Time
	EmployeeDeduction        float64
	EmployeePayrollRunId     *uint64
	Id                       uint64
	MergeAccountId           string
	ModifiedAt               *time.Time
	Name                     string
	PayrollRunMergeAccountId string
	RemoteId                 string
	RemoteWasDeleted         bool
}

// TableName overrides the default tablename generated by GORM
func (DeductionORM) TableName() string {
	return "deductions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Deduction) ToORM(ctx context.Context) (DeductionORM, error) {
	to := DeductionORM{}
	var err error
	if prehook, ok := interface{}(m).(DeductionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.EmployeeDeduction = m.EmployeeDeduction
	to.CompanyDeduction = m.CompanyDeduction
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(DeductionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DeductionORM) ToPB(ctx context.Context) (Deduction, error) {
	to := Deduction{}
	var err error
	if prehook, ok := interface{}(m).(DeductionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.EmployeeDeduction = m.EmployeeDeduction
	to.CompanyDeduction = m.CompanyDeduction
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(DeductionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Deduction the arg will be the target, the caller the one being converted from

// DeductionBeforeToORM called before default ToORM code
type DeductionWithBeforeToORM interface {
	BeforeToORM(context.Context, *DeductionORM) error
}

// DeductionAfterToORM called after default ToORM code
type DeductionWithAfterToORM interface {
	AfterToORM(context.Context, *DeductionORM) error
}

// DeductionBeforeToPB called before default ToPB code
type DeductionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Deduction) error
}

// DeductionAfterToPB called after default ToPB code
type DeductionWithAfterToPB interface {
	AfterToPB(context.Context, *Deduction) error
}

type TaxORM struct {
	Amount                   float64
	CreatedAt                *time.Time
	EmployeePayrollRunId     *uint64
	EmployerTax              bool
	Id                       uint64
	MergeAccountId           string
	ModifiedAt               *time.Time
	Name                     string
	PayrollRunMergeAccountId string
	RemoteId                 string
	RemoteWasDeleted         bool
}

// TableName overrides the default tablename generated by GORM
func (TaxORM) TableName() string {
	return "taxes"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tax) ToORM(ctx context.Context) (TaxORM, error) {
	to := TaxORM{}
	var err error
	if prehook, ok := interface{}(m).(TaxWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Amount = m.Amount
	to.EmployerTax = m.EmployerTax
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(TaxWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TaxORM) ToPB(ctx context.Context) (Tax, error) {
	to := Tax{}
	var err error
	if prehook, ok := interface{}(m).(TaxWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Name = m.Name
	to.Amount = m.Amount
	to.EmployerTax = m.EmployerTax
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.PayrollRunMergeAccountId = m.PayrollRunMergeAccountId
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(TaxWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tax the arg will be the target, the caller the one being converted from

// TaxBeforeToORM called before default ToORM code
type TaxWithBeforeToORM interface {
	BeforeToORM(context.Context, *TaxORM) error
}

// TaxAfterToORM called after default ToORM code
type TaxWithAfterToORM interface {
	AfterToORM(context.Context, *TaxORM) error
}

// TaxBeforeToPB called before default ToPB code
type TaxWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tax) error
}

// TaxAfterToPB called after default ToPB code
type TaxWithAfterToPB interface {
	AfterToPB(context.Context, *Tax) error
}

type EmployeTimeOffBalanceORM struct {
	Balance          float64
	CreatedAt        *time.Time
	EmployeeId       *uint64
	Id               uint64
	MergeAccountId   string
	ModifiedAt       *time.Time
	PolicyType       string
	RemoteId         string
	RemoteWasDeleted bool
	Used             float64
}

// TableName overrides the default tablename generated by GORM
func (EmployeTimeOffBalanceORM) TableName() string {
	return "employe_time_off_balances"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmployeTimeOffBalance) ToORM(ctx context.Context) (EmployeTimeOffBalanceORM, error) {
	to := EmployeTimeOffBalanceORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployeTimeOffBalanceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Balance = m.Balance
	to.Used = m.Used
	to.PolicyType = PolicyType_name[int32(m.PolicyType)]
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeTimeOffBalanceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployeTimeOffBalanceORM) ToPB(ctx context.Context) (EmployeTimeOffBalance, error) {
	to := EmployeTimeOffBalance{}
	var err error
	if prehook, ok := interface{}(m).(EmployeTimeOffBalanceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	to.Balance = m.Balance
	to.Used = m.Used
	to.PolicyType = PolicyType(PolicyType_value[m.PolicyType])
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	if posthook, ok := interface{}(m).(EmployeTimeOffBalanceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmployeTimeOffBalance the arg will be the target, the caller the one being converted from

// EmployeTimeOffBalanceBeforeToORM called before default ToORM code
type EmployeTimeOffBalanceWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployeTimeOffBalanceORM) error
}

// EmployeTimeOffBalanceAfterToORM called after default ToORM code
type EmployeTimeOffBalanceWithAfterToORM interface {
	AfterToORM(context.Context, *EmployeTimeOffBalanceORM) error
}

// EmployeTimeOffBalanceBeforeToPB called before default ToPB code
type EmployeTimeOffBalanceWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmployeTimeOffBalance) error
}

// EmployeTimeOffBalanceAfterToPB called after default ToPB code
type EmployeTimeOffBalanceWithAfterToPB interface {
	AfterToPB(context.Context, *EmployeTimeOffBalance) error
}

type TimeOffORM struct {
	Amount                 float64
	Approver               *EmployeeORM `gorm:"foreignkey:ApproverTimeOffId;association_foreignkey:Id;preload:true"`
	ApproverMergeAccountId string
	CreatedAt              *time.Time
	Employee               *EmployeeORM `gorm:"foreignkey:EmployeeTimeOffId;association_foreignkey:Id;preload:true"`
	EmployeeMergeAccountId string
	EmploymentNote         string
	EndTime                *time.Time
	Id                     uint64
	MergeAccountId         string
	ModifiedAt             *time.Time
	RemoteId               string
	RemoteWasDeleted       bool
	RequestType            string
	StartTime              *time.Time
	Status                 string
	Units                  string
}

// TableName overrides the default tablename generated by GORM
func (TimeOffORM) TableName() string {
	return "time_offs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TimeOff) ToORM(ctx context.Context) (TimeOffORM, error) {
	to := TimeOffORM{}
	var err error
	if prehook, ok := interface{}(m).(TimeOffWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.Employee != nil {
		tempEmployee, err := m.Employee.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Employee = &tempEmployee
	}
	if m.Approver != nil {
		tempApprover, err := m.Approver.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Approver = &tempApprover
	}
	to.Status = TimeOffStatus_name[int32(m.Status)]
	to.EmploymentNote = m.EmploymentNote
	to.Units = TimeOffUnits_name[int32(m.Units)]
	to.Amount = m.Amount
	to.RequestType = m.RequestType
	if m.StartTime != nil {
		t := m.StartTime.AsTime()
		to.StartTime = &t
	}
	if m.EndTime != nil {
		t := m.EndTime.AsTime()
		to.EndTime = &t
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.ModifiedAt != nil {
		t := m.ModifiedAt.AsTime()
		to.ModifiedAt = &t
	}
	to.MergeAccountId = m.MergeAccountId
	to.EmployeeMergeAccountId = m.EmployeeMergeAccountId
	to.ApproverMergeAccountId = m.ApproverMergeAccountId
	if posthook, ok := interface{}(m).(TimeOffWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TimeOffORM) ToPB(ctx context.Context) (TimeOff, error) {
	to := TimeOff{}
	var err error
	if prehook, ok := interface{}(m).(TimeOffWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.RemoteId = m.RemoteId
	if m.Employee != nil {
		tempEmployee, err := m.Employee.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Employee = &tempEmployee
	}
	if m.Approver != nil {
		tempApprover, err := m.Approver.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Approver = &tempApprover
	}
	to.Status = TimeOffStatus(TimeOffStatus_value[m.Status])
	to.EmploymentNote = m.EmploymentNote
	to.Units = TimeOffUnits(TimeOffUnits_value[m.Units])
	to.Amount = m.Amount
	to.RequestType = m.RequestType
	if m.StartTime != nil {
		to.StartTime = timestamppb.New(*m.StartTime)
	}
	if m.EndTime != nil {
		to.EndTime = timestamppb.New(*m.EndTime)
	}
	to.RemoteWasDeleted = m.RemoteWasDeleted
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.ModifiedAt != nil {
		to.ModifiedAt = timestamppb.New(*m.ModifiedAt)
	}
	to.MergeAccountId = m.MergeAccountId
	to.EmployeeMergeAccountId = m.EmployeeMergeAccountId
	to.ApproverMergeAccountId = m.ApproverMergeAccountId
	if posthook, ok := interface{}(m).(TimeOffWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TimeOff the arg will be the target, the caller the one being converted from

// TimeOffBeforeToORM called before default ToORM code
type TimeOffWithBeforeToORM interface {
	BeforeToORM(context.Context, *TimeOffORM) error
}

// TimeOffAfterToORM called after default ToORM code
type TimeOffWithAfterToORM interface {
	AfterToORM(context.Context, *TimeOffORM) error
}

// TimeOffBeforeToPB called before default ToPB code
type TimeOffWithBeforeToPB interface {
	BeforeToPB(context.Context, *TimeOff) error
}

// TimeOffAfterToPB called after default ToPB code
type TimeOffWithAfterToPB interface {
	AfterToPB(context.Context, *TimeOff) error
}

// DefaultCreateHrisIntegrationMergeLink executes a basic gorm create call
func DefaultCreateHrisIntegrationMergeLink(ctx context.Context, in *HrisIntegrationMergeLink, db *gorm.DB) (*HrisIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HrisIntegrationMergeLinkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHrisIntegrationMergeLink(ctx context.Context, in *HrisIntegrationMergeLink, db *gorm.DB) (*HrisIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HrisIntegrationMergeLinkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HrisIntegrationMergeLinkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HrisIntegrationMergeLinkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HrisIntegrationMergeLinkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHrisIntegrationMergeLink(ctx context.Context, in *HrisIntegrationMergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HrisIntegrationMergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HrisIntegrationMergeLinkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHrisIntegrationMergeLinkSet(ctx context.Context, in []*HrisIntegrationMergeLink, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HrisIntegrationMergeLinkORM{})).(HrisIntegrationMergeLinkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HrisIntegrationMergeLinkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HrisIntegrationMergeLinkORM{})).(HrisIntegrationMergeLinkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HrisIntegrationMergeLinkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HrisIntegrationMergeLink, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HrisIntegrationMergeLink, *gorm.DB) error
}

// DefaultStrictUpdateHrisIntegrationMergeLink clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHrisIntegrationMergeLink(ctx context.Context, in *HrisIntegrationMergeLink, db *gorm.DB) (*HrisIntegrationMergeLink, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHrisIntegrationMergeLink")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HrisIntegrationMergeLinkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccount := HrisLinkedAccountORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccount.HrisIntegrationMergeLinkId = new(uint64)
	*filterAccount.HrisIntegrationMergeLinkId = ormObj.Id
	if err = db.Where(filterAccount).Delete(HrisLinkedAccountORM{}).Error; err != nil {
		return nil, err
	}
	filterToken := MergeLinkedAccountTokenORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterToken.HrisIntegrationMergeLinkId = new(uint64)
	*filterToken.HrisIntegrationMergeLinkId = ormObj.Id
	if err = db.Where(filterToken).Delete(MergeLinkedAccountTokenORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HrisIntegrationMergeLinkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHrisIntegrationMergeLink executes a basic gorm update call with patch behavior
func DefaultPatchHrisIntegrationMergeLink(ctx context.Context, in *HrisIntegrationMergeLink, updateMask *field_mask.FieldMask, db *gorm.DB) (*HrisIntegrationMergeLink, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj HrisIntegrationMergeLink
	var err error
	if hook, ok := interface{}(&pbObj).(HrisIntegrationMergeLinkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHrisIntegrationMergeLink(ctx, &HrisIntegrationMergeLink{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HrisIntegrationMergeLinkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHrisIntegrationMergeLink(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HrisIntegrationMergeLinkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHrisIntegrationMergeLink(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HrisIntegrationMergeLinkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HrisIntegrationMergeLinkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HrisIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HrisIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HrisIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HrisIntegrationMergeLink, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHrisIntegrationMergeLink executes a bulk gorm update call with patch behavior
func DefaultPatchSetHrisIntegrationMergeLink(ctx context.Context, objects []*HrisIntegrationMergeLink, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*HrisIntegrationMergeLink, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HrisIntegrationMergeLink, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHrisIntegrationMergeLink(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHrisIntegrationMergeLink patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHrisIntegrationMergeLink(ctx context.Context, patchee *HrisIntegrationMergeLink, patcher *HrisIntegrationMergeLink, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HrisIntegrationMergeLink, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedToken bool
	var updatedAccount bool
	var updatedLastModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Integration" {
			patchee.Integration = patcher.Integration
			continue
		}
		if f == prefix+"IntegrationSlug" {
			patchee.IntegrationSlug = patcher.IntegrationSlug
			continue
		}
		if f == prefix+"Category" {
			patchee.Category = patcher.Category
			continue
		}
		if f == prefix+"EndUserOriginId" {
			patchee.EndUserOriginId = patcher.EndUserOriginId
			continue
		}
		if f == prefix+"EndUserOrganizationName" {
			patchee.EndUserOrganizationName = patcher.EndUserOrganizationName
			continue
		}
		if f == prefix+"EndUserEmailAddress" {
			patchee.EndUserEmailAddress = patcher.EndUserEmailAddress
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"WebhookListenerUrl" {
			patchee.WebhookListenerUrl = patcher.WebhookListenerUrl
			continue
		}
		if f == prefix+"IsDuplicate" {
			patchee.IsDuplicate = patcher.IsDuplicate
			continue
		}
		if !updatedToken && strings.HasPrefix(f, prefix+"Token.") {
			updatedToken = true
			if patcher.Token == nil {
				patchee.Token = nil
				continue
			}
			if patchee.Token == nil {
				patchee.Token = &MergeLinkedAccountToken{}
			}
			if o, err := DefaultApplyFieldMaskMergeLinkedAccountToken(ctx, patchee.Token, patcher.Token, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Token.", db); err != nil {
				return nil, err
			} else {
				patchee.Token = o
			}
			continue
		}
		if f == prefix+"Token" {
			updatedToken = true
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"IntegrationName" {
			patchee.IntegrationName = patcher.IntegrationName
			continue
		}
		if f == prefix+"IntegrationImage" {
			patchee.IntegrationImage = patcher.IntegrationImage
			continue
		}
		if f == prefix+"IntegrationSquareImage" {
			patchee.IntegrationSquareImage = patcher.IntegrationSquareImage
			continue
		}
		if !updatedAccount && strings.HasPrefix(f, prefix+"Account.") {
			updatedAccount = true
			if patcher.Account == nil {
				patchee.Account = nil
				continue
			}
			if patchee.Account == nil {
				patchee.Account = &HrisLinkedAccount{}
			}
			if o, err := DefaultApplyFieldMaskHrisLinkedAccount(ctx, patchee.Account, patcher.Account, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Account.", db); err != nil {
				return nil, err
			} else {
				patchee.Account = o
			}
			continue
		}
		if f == prefix+"Account" {
			updatedAccount = true
			patchee.Account = patcher.Account
			continue
		}
		if f == prefix+"MergeLinkedAccountId" {
			patchee.MergeLinkedAccountId = patcher.MergeLinkedAccountId
			continue
		}
		if !updatedLastModifiedAt && strings.HasPrefix(f, prefix+"LastModifiedAt.") {
			if patcher.LastModifiedAt == nil {
				patchee.LastModifiedAt = nil
				continue
			}
			if patchee.LastModifiedAt == nil {
				patchee.LastModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastModifiedAt, patchee.LastModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastModifiedAt" {
			updatedLastModifiedAt = true
			patchee.LastModifiedAt = patcher.LastModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHrisIntegrationMergeLink executes a gorm list call
func DefaultListHrisIntegrationMergeLink(ctx context.Context, db *gorm.DB) ([]*HrisIntegrationMergeLink, error) {
	in := HrisIntegrationMergeLink{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HrisIntegrationMergeLinkORM{}, &HrisIntegrationMergeLink{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HrisIntegrationMergeLinkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisIntegrationMergeLinkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HrisIntegrationMergeLink{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HrisIntegrationMergeLinkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisIntegrationMergeLinkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HrisIntegrationMergeLinkORM) error
}

// DefaultCreateHrisLinkedAccount executes a basic gorm create call
func DefaultCreateHrisLinkedAccount(ctx context.Context, in *HrisLinkedAccount, db *gorm.DB) (*HrisLinkedAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HrisLinkedAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadHrisLinkedAccount(ctx context.Context, in *HrisLinkedAccount, db *gorm.DB) (*HrisLinkedAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &HrisLinkedAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := HrisLinkedAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(HrisLinkedAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type HrisLinkedAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteHrisLinkedAccount(ctx context.Context, in *HrisLinkedAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&HrisLinkedAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type HrisLinkedAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteHrisLinkedAccountSet(ctx context.Context, in []*HrisLinkedAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&HrisLinkedAccountORM{})).(HrisLinkedAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&HrisLinkedAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&HrisLinkedAccountORM{})).(HrisLinkedAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type HrisLinkedAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*HrisLinkedAccount, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*HrisLinkedAccount, *gorm.DB) error
}

// DefaultStrictUpdateHrisLinkedAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateHrisLinkedAccount(ctx context.Context, in *HrisLinkedAccount, db *gorm.DB) (*HrisLinkedAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateHrisLinkedAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &HrisLinkedAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBenefitPlans := EmployerBenefitsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBenefitPlans.HrisLinkedAccountId = new(uint64)
	*filterBenefitPlans.HrisLinkedAccountId = ormObj.Id
	if err = db.Where(filterBenefitPlans).Delete(EmployerBenefitsORM{}).Error; err != nil {
		return nil, err
	}
	filterEmployees := EmployeeORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEmployees.HrisLinkedAccountId = new(uint64)
	*filterEmployees.HrisLinkedAccountId = ormObj.Id
	if err = db.Where(filterEmployees).Delete(EmployeeORM{}).Error; err != nil {
		return nil, err
	}
	filterPayrollRuns := EmployerPayrollRunORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayrollRuns.HrisLinkedAccountId = new(uint64)
	*filterPayrollRuns.HrisLinkedAccountId = ormObj.Id
	if err = db.Where(filterPayrollRuns).Delete(EmployerPayrollRunORM{}).Error; err != nil {
		return nil, err
	}
	filterProfile := CompanyProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterProfile.HrisLinkedAccountId = new(uint64)
	*filterProfile.HrisLinkedAccountId = ormObj.Id
	if err = db.Where(filterProfile).Delete(CompanyProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type HrisLinkedAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchHrisLinkedAccount executes a basic gorm update call with patch behavior
func DefaultPatchHrisLinkedAccount(ctx context.Context, in *HrisLinkedAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*HrisLinkedAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj HrisLinkedAccount
	var err error
	if hook, ok := interface{}(&pbObj).(HrisLinkedAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadHrisLinkedAccount(ctx, &HrisLinkedAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(HrisLinkedAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskHrisLinkedAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(HrisLinkedAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateHrisLinkedAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(HrisLinkedAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type HrisLinkedAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *HrisLinkedAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *HrisLinkedAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *HrisLinkedAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *HrisLinkedAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetHrisLinkedAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetHrisLinkedAccount(ctx context.Context, objects []*HrisLinkedAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*HrisLinkedAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*HrisLinkedAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchHrisLinkedAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskHrisLinkedAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHrisLinkedAccount(ctx context.Context, patchee *HrisLinkedAccount, patcher *HrisLinkedAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HrisLinkedAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedProfile bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedProfile && strings.HasPrefix(f, prefix+"Profile.") {
			updatedProfile = true
			if patcher.Profile == nil {
				patchee.Profile = nil
				continue
			}
			if patchee.Profile == nil {
				patchee.Profile = &CompanyProfile{}
			}
			if o, err := DefaultApplyFieldMaskCompanyProfile(ctx, patchee.Profile, patcher.Profile, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Profile.", db); err != nil {
				return nil, err
			} else {
				patchee.Profile = o
			}
			continue
		}
		if f == prefix+"Profile" {
			updatedProfile = true
			patchee.Profile = patcher.Profile
			continue
		}
		if f == prefix+"BenefitPlans" {
			patchee.BenefitPlans = patcher.BenefitPlans
			continue
		}
		if f == prefix+"Employees" {
			patchee.Employees = patcher.Employees
			continue
		}
		if f == prefix+"PayrollRuns" {
			patchee.PayrollRuns = patcher.PayrollRuns
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHrisLinkedAccount executes a gorm list call
func DefaultListHrisLinkedAccount(ctx context.Context, db *gorm.DB) ([]*HrisLinkedAccount, error) {
	in := HrisLinkedAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HrisLinkedAccountORM{}, &HrisLinkedAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []HrisLinkedAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HrisLinkedAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HrisLinkedAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HrisLinkedAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HrisLinkedAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HrisLinkedAccountORM) error
}

// DefaultCreateCompanyProfile executes a basic gorm create call
func DefaultCreateCompanyProfile(ctx context.Context, in *CompanyProfile, db *gorm.DB) (*CompanyProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CompanyProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCompanyProfile(ctx context.Context, in *CompanyProfile, db *gorm.DB) (*CompanyProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CompanyProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CompanyProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CompanyProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CompanyProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyProfile(ctx context.Context, in *CompanyProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CompanyProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CompanyProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCompanyProfileSet(ctx context.Context, in []*CompanyProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CompanyProfileORM{})).(CompanyProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CompanyProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CompanyProfileORM{})).(CompanyProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CompanyProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CompanyProfile, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CompanyProfile, *gorm.DB) error
}

// DefaultStrictUpdateCompanyProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCompanyProfile(ctx context.Context, in *CompanyProfile, db *gorm.DB) (*CompanyProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCompanyProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CompanyProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CompanyProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCompanyProfile executes a basic gorm update call with patch behavior
func DefaultPatchCompanyProfile(ctx context.Context, in *CompanyProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*CompanyProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CompanyProfile
	var err error
	if hook, ok := interface{}(&pbObj).(CompanyProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCompanyProfile(ctx, &CompanyProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CompanyProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCompanyProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CompanyProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCompanyProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CompanyProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CompanyProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CompanyProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CompanyProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CompanyProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CompanyProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCompanyProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetCompanyProfile(ctx context.Context, objects []*CompanyProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CompanyProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CompanyProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCompanyProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCompanyProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCompanyProfile(ctx context.Context, patchee *CompanyProfile, patcher *CompanyProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CompanyProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedModifiedAt bool
	var updatedLastUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"LegalName" {
			patchee.LegalName = patcher.LegalName
			continue
		}
		if f == prefix+"DisplayName" {
			patchee.DisplayName = patcher.DisplayName
			continue
		}
		if f == prefix+"EinNumbers" {
			patchee.EinNumbers = patcher.EinNumbers
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if !updatedLastUpdatedAt && strings.HasPrefix(f, prefix+"LastUpdatedAt.") {
			if patcher.LastUpdatedAt == nil {
				patchee.LastUpdatedAt = nil
				continue
			}
			if patchee.LastUpdatedAt == nil {
				patchee.LastUpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LastUpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.LastUpdatedAt, patchee.LastUpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LastUpdatedAt" {
			updatedLastUpdatedAt = true
			patchee.LastUpdatedAt = patcher.LastUpdatedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCompanyProfile executes a gorm list call
func DefaultListCompanyProfile(ctx context.Context, db *gorm.DB) ([]*CompanyProfile, error) {
	in := CompanyProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CompanyProfileORM{}, &CompanyProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CompanyProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CompanyProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CompanyProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CompanyProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CompanyProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CompanyProfileORM) error
}

// DefaultCreateEmployerBenefits executes a basic gorm create call
func DefaultCreateEmployerBenefits(ctx context.Context, in *EmployerBenefits, db *gorm.DB) (*EmployerBenefits, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployerBenefitsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployerBenefits(ctx context.Context, in *EmployerBenefits, db *gorm.DB) (*EmployerBenefits, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployerBenefitsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployerBenefitsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployerBenefitsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployerBenefitsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployerBenefits(ctx context.Context, in *EmployerBenefits, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployerBenefitsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployerBenefitsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployerBenefitsSet(ctx context.Context, in []*EmployerBenefits, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployerBenefitsORM{})).(EmployerBenefitsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployerBenefitsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployerBenefitsORM{})).(EmployerBenefitsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployerBenefitsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmployerBenefits, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmployerBenefits, *gorm.DB) error
}

// DefaultStrictUpdateEmployerBenefits clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployerBenefits(ctx context.Context, in *EmployerBenefits, db *gorm.DB) (*EmployerBenefits, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployerBenefits")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployerBenefitsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEmployeeBenefits := EmployeeBenefitsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEmployeeBenefits.EmployerBenefitsId = new(uint64)
	*filterEmployeeBenefits.EmployerBenefitsId = ormObj.Id
	if err = db.Where(filterEmployeeBenefits).Delete(EmployeeBenefitsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployerBenefitsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployerBenefits executes a basic gorm update call with patch behavior
func DefaultPatchEmployerBenefits(ctx context.Context, in *EmployerBenefits, updateMask *field_mask.FieldMask, db *gorm.DB) (*EmployerBenefits, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EmployerBenefits
	var err error
	if hook, ok := interface{}(&pbObj).(EmployerBenefitsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployerBenefits(ctx, &EmployerBenefits{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployerBenefitsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployerBenefits(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployerBenefitsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployerBenefits(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployerBenefitsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployerBenefitsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmployerBenefits, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmployerBenefits, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmployerBenefits, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmployerBenefits, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployerBenefits executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployerBenefits(ctx context.Context, objects []*EmployerBenefits, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EmployerBenefits, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmployerBenefits, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployerBenefits(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployerBenefits patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployerBenefits(ctx context.Context, patchee *EmployerBenefits, patcher *EmployerBenefits, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EmployerBenefits, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedRemoteWasDeleted bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"BenefitPlanType" {
			patchee.BenefitPlanType = patcher.BenefitPlanType
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"DeductionCode" {
			patchee.DeductionCode = patcher.DeductionCode
			continue
		}
		if !updatedRemoteWasDeleted && strings.HasPrefix(f, prefix+"RemoteWasDeleted.") {
			if patcher.RemoteWasDeleted == nil {
				patchee.RemoteWasDeleted = nil
				continue
			}
			if patchee.RemoteWasDeleted == nil {
				patchee.RemoteWasDeleted = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteWasDeleted."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteWasDeleted, patchee.RemoteWasDeleted, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteWasDeleted" {
			updatedRemoteWasDeleted = true
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"EmployeeBenefits" {
			patchee.EmployeeBenefits = patcher.EmployeeBenefits
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployerBenefits executes a gorm list call
func DefaultListEmployerBenefits(ctx context.Context, db *gorm.DB) ([]*EmployerBenefits, error) {
	in := EmployerBenefits{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployerBenefitsORM{}, &EmployerBenefits{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployerBenefitsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerBenefitsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmployerBenefits{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployerBenefitsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerBenefitsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployerBenefitsORM) error
}

// DefaultCreateEmployee executes a basic gorm create call
func DefaultCreateEmployee(ctx context.Context, in *Employee, db *gorm.DB) (*Employee, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployee(ctx context.Context, in *Employee, db *gorm.DB) (*Employee, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployeeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployeeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployeeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployee(ctx context.Context, in *Employee, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployeeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployeeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeeSet(ctx context.Context, in []*Employee, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployeeORM{})).(EmployeeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployeeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployeeORM{})).(EmployeeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployeeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Employee, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Employee, *gorm.DB) error
}

// DefaultStrictUpdateEmployee clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployee(ctx context.Context, in *Employee, db *gorm.DB) (*Employee, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployee")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployeeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBankAccounts := BankInfoORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBankAccounts.EmployeeId = new(uint64)
	*filterBankAccounts.EmployeeId = ormObj.Id
	if err = db.Where(filterBankAccounts).Delete(BankInfoORM{}).Error; err != nil {
		return nil, err
	}
	filterBenefits := EmployeeBenefitsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBenefits.EmployeeId = new(uint64)
	*filterBenefits.EmployeeId = ormObj.Id
	if err = db.Where(filterBenefits).Delete(EmployeeBenefitsORM{}).Error; err != nil {
		return nil, err
	}
	filterDependents := DependentsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDependents.EmployeeId = new(uint64)
	*filterDependents.EmployeeId = ormObj.Id
	if err = db.Where(filterDependents).Delete(DependentsORM{}).Error; err != nil {
		return nil, err
	}
	filterEmployments := EmployeeJobPositionAtCompanyORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEmployments.EmployeeId = new(uint64)
	*filterEmployments.EmployeeId = ormObj.Id
	if err = db.Where(filterEmployments).Delete(EmployeeJobPositionAtCompanyORM{}).Error; err != nil {
		return nil, err
	}
	filterGroup := GroupORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterGroup.EmployeeId = new(uint64)
	*filterGroup.EmployeeId = ormObj.Id
	if err = db.Where(filterGroup).Delete(GroupORM{}).Error; err != nil {
		return nil, err
	}
	filterHomeLocation := LocationAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterHomeLocation.HomeLocationEmployeeId = new(uint64)
	*filterHomeLocation.HomeLocationEmployeeId = ormObj.Id
	if err = db.Where(filterHomeLocation).Delete(LocationAddressORM{}).Error; err != nil {
		return nil, err
	}
	filterManager := EmployeeORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterManager.EmployeeId = new(uint64)
	*filterManager.EmployeeId = ormObj.Id
	if err = db.Where(filterManager).Delete(EmployeeORM{}).Error; err != nil {
		return nil, err
	}
	filterPayTimeOffBalance := EmployeTimeOffBalanceORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayTimeOffBalance.EmployeeId = new(uint64)
	*filterPayTimeOffBalance.EmployeeId = ormObj.Id
	if err = db.Where(filterPayTimeOffBalance).Delete(EmployeTimeOffBalanceORM{}).Error; err != nil {
		return nil, err
	}
	filterPayrollRuns := EmployeePayrollRunORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayrollRuns.EmployeeId = new(uint64)
	*filterPayrollRuns.EmployeeId = ormObj.Id
	if err = db.Where(filterPayrollRuns).Delete(EmployeePayrollRunORM{}).Error; err != nil {
		return nil, err
	}
	filterWorkLocation := LocationAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterWorkLocation.WorkLocationEmployeeId = new(uint64)
	*filterWorkLocation.WorkLocationEmployeeId = ormObj.Id
	if err = db.Where(filterWorkLocation).Delete(LocationAddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployeeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployee executes a basic gorm update call with patch behavior
func DefaultPatchEmployee(ctx context.Context, in *Employee, updateMask *field_mask.FieldMask, db *gorm.DB) (*Employee, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Employee
	var err error
	if hook, ok := interface{}(&pbObj).(EmployeeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployee(ctx, &Employee{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployeeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployee(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployeeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployee(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployeeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployeeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Employee, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Employee, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Employee, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Employee, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployee executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployee(ctx context.Context, objects []*Employee, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Employee, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Employee, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployee(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployee patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployee(ctx context.Context, patchee *Employee, patcher *Employee, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Employee, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedHomeLocation bool
	var updatedWorkLocation bool
	var updatedManager bool
	var updatedGroup bool
	var updatedStartDate bool
	var updatedRemoteCreatedAt bool
	var updatedTerminationDate bool
	var updatedPayTimeOffBalance bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"EmployeeNumber" {
			patchee.EmployeeNumber = patcher.EmployeeNumber
			continue
		}
		if f == prefix+"CompanyId" {
			patchee.CompanyId = patcher.CompanyId
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"EmployeesPreferredName" {
			patchee.EmployeesPreferredName = patcher.EmployeesPreferredName
			continue
		}
		if f == prefix+"DisplayFullName" {
			patchee.DisplayFullName = patcher.DisplayFullName
			continue
		}
		if f == prefix+"EmployeeUserNameAsSeenInRemoteUi" {
			patchee.EmployeeUserNameAsSeenInRemoteUi = patcher.EmployeeUserNameAsSeenInRemoteUi
			continue
		}
		if f == prefix+"WorkEmail" {
			patchee.WorkEmail = patcher.WorkEmail
			continue
		}
		if f == prefix+"PersonalEmail" {
			patchee.PersonalEmail = patcher.PersonalEmail
			continue
		}
		if f == prefix+"MobilePhoneNumber" {
			patchee.MobilePhoneNumber = patcher.MobilePhoneNumber
			continue
		}
		if f == prefix+"Employments" {
			patchee.Employments = patcher.Employments
			continue
		}
		if f == prefix+"EmploymentType" {
			patchee.EmploymentType = patcher.EmploymentType
			continue
		}
		if !updatedHomeLocation && strings.HasPrefix(f, prefix+"HomeLocation.") {
			updatedHomeLocation = true
			if patcher.HomeLocation == nil {
				patchee.HomeLocation = nil
				continue
			}
			if patchee.HomeLocation == nil {
				patchee.HomeLocation = &LocationAddress{}
			}
			if o, err := DefaultApplyFieldMaskLocationAddress(ctx, patchee.HomeLocation, patcher.HomeLocation, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"HomeLocation.", db); err != nil {
				return nil, err
			} else {
				patchee.HomeLocation = o
			}
			continue
		}
		if f == prefix+"HomeLocation" {
			updatedHomeLocation = true
			patchee.HomeLocation = patcher.HomeLocation
			continue
		}
		if !updatedWorkLocation && strings.HasPrefix(f, prefix+"WorkLocation.") {
			updatedWorkLocation = true
			if patcher.WorkLocation == nil {
				patchee.WorkLocation = nil
				continue
			}
			if patchee.WorkLocation == nil {
				patchee.WorkLocation = &LocationAddress{}
			}
			if o, err := DefaultApplyFieldMaskLocationAddress(ctx, patchee.WorkLocation, patcher.WorkLocation, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"WorkLocation.", db); err != nil {
				return nil, err
			} else {
				patchee.WorkLocation = o
			}
			continue
		}
		if f == prefix+"WorkLocation" {
			updatedWorkLocation = true
			patchee.WorkLocation = patcher.WorkLocation
			continue
		}
		if !updatedManager && strings.HasPrefix(f, prefix+"Manager.") {
			updatedManager = true
			if patcher.Manager == nil {
				patchee.Manager = nil
				continue
			}
			if patchee.Manager == nil {
				patchee.Manager = &Employee{}
			}
			if o, err := DefaultApplyFieldMaskEmployee(ctx, patchee.Manager, patcher.Manager, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Manager.", db); err != nil {
				return nil, err
			} else {
				patchee.Manager = o
			}
			continue
		}
		if f == prefix+"Manager" {
			updatedManager = true
			patchee.Manager = patcher.Manager
			continue
		}
		if !updatedGroup && strings.HasPrefix(f, prefix+"Group.") {
			updatedGroup = true
			if patcher.Group == nil {
				patchee.Group = nil
				continue
			}
			if patchee.Group == nil {
				patchee.Group = &Group{}
			}
			if o, err := DefaultApplyFieldMaskGroup(ctx, patchee.Group, patcher.Group, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Group.", db); err != nil {
				return nil, err
			} else {
				patchee.Group = o
			}
			continue
		}
		if f == prefix+"Group" {
			updatedGroup = true
			patchee.Group = patcher.Group
			continue
		}
		if f == prefix+"Ssn" {
			patchee.Ssn = patcher.Ssn
			continue
		}
		if f == prefix+"Gender" {
			patchee.Gender = patcher.Gender
			continue
		}
		if f == prefix+"Ethnicity" {
			patchee.Ethnicity = patcher.Ethnicity
			continue
		}
		if f == prefix+"MaritalStatus" {
			patchee.MaritalStatus = patcher.MaritalStatus
			continue
		}
		if f == prefix+"DateOfBirth" {
			patchee.DateOfBirth = patcher.DateOfBirth
			continue
		}
		if !updatedStartDate && strings.HasPrefix(f, prefix+"StartDate.") {
			if patcher.StartDate == nil {
				patchee.StartDate = nil
				continue
			}
			if patchee.StartDate == nil {
				patchee.StartDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartDate, patchee.StartDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartDate" {
			updatedStartDate = true
			patchee.StartDate = patcher.StartDate
			continue
		}
		if !updatedRemoteCreatedAt && strings.HasPrefix(f, prefix+"RemoteCreatedAt.") {
			if patcher.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = nil
				continue
			}
			if patchee.RemoteCreatedAt == nil {
				patchee.RemoteCreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"RemoteCreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.RemoteCreatedAt, patchee.RemoteCreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"RemoteCreatedAt" {
			updatedRemoteCreatedAt = true
			patchee.RemoteCreatedAt = patcher.RemoteCreatedAt
			continue
		}
		if f == prefix+"EmploymentStatus" {
			patchee.EmploymentStatus = patcher.EmploymentStatus
			continue
		}
		if !updatedTerminationDate && strings.HasPrefix(f, prefix+"TerminationDate.") {
			if patcher.TerminationDate == nil {
				patchee.TerminationDate = nil
				continue
			}
			if patchee.TerminationDate == nil {
				patchee.TerminationDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"TerminationDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.TerminationDate, patchee.TerminationDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"TerminationDate" {
			updatedTerminationDate = true
			patchee.TerminationDate = patcher.TerminationDate
			continue
		}
		if f == prefix+"Avatar" {
			patchee.Avatar = patcher.Avatar
			continue
		}
		if f == prefix+"BankAccounts" {
			patchee.BankAccounts = patcher.BankAccounts
			continue
		}
		if f == prefix+"Dependents" {
			patchee.Dependents = patcher.Dependents
			continue
		}
		if f == prefix+"PayrollRuns" {
			patchee.PayrollRuns = patcher.PayrollRuns
			continue
		}
		if !updatedPayTimeOffBalance && strings.HasPrefix(f, prefix+"PayTimeOffBalance.") {
			updatedPayTimeOffBalance = true
			if patcher.PayTimeOffBalance == nil {
				patchee.PayTimeOffBalance = nil
				continue
			}
			if patchee.PayTimeOffBalance == nil {
				patchee.PayTimeOffBalance = &EmployeTimeOffBalance{}
			}
			if o, err := DefaultApplyFieldMaskEmployeTimeOffBalance(ctx, patchee.PayTimeOffBalance, patcher.PayTimeOffBalance, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PayTimeOffBalance.", db); err != nil {
				return nil, err
			} else {
				patchee.PayTimeOffBalance = o
			}
			continue
		}
		if f == prefix+"PayTimeOffBalance" {
			updatedPayTimeOffBalance = true
			patchee.PayTimeOffBalance = patcher.PayTimeOffBalance
			continue
		}
		if f == prefix+"Benefits" {
			patchee.Benefits = patcher.Benefits
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployee executes a gorm list call
func DefaultListEmployee(ctx context.Context, db *gorm.DB) ([]*Employee, error) {
	in := Employee{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployeeORM{}, &Employee{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployeeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Employee{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployeeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployeeORM) error
}

// DefaultCreateEmployeeBenefits executes a basic gorm create call
func DefaultCreateEmployeeBenefits(ctx context.Context, in *EmployeeBenefits, db *gorm.DB) (*EmployeeBenefits, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeBenefitsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployeeBenefits(ctx context.Context, in *EmployeeBenefits, db *gorm.DB) (*EmployeeBenefits, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployeeBenefitsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployeeBenefitsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployeeBenefitsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeBenefitsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeeBenefits(ctx context.Context, in *EmployeeBenefits, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployeeBenefitsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployeeBenefitsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeeBenefitsSet(ctx context.Context, in []*EmployeeBenefits, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployeeBenefitsORM{})).(EmployeeBenefitsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployeeBenefitsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployeeBenefitsORM{})).(EmployeeBenefitsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployeeBenefitsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmployeeBenefits, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmployeeBenefits, *gorm.DB) error
}

// DefaultStrictUpdateEmployeeBenefits clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployeeBenefits(ctx context.Context, in *EmployeeBenefits, db *gorm.DB) (*EmployeeBenefits, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployeeBenefits")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployeeBenefitsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployeeBenefitsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployeeBenefits executes a basic gorm update call with patch behavior
func DefaultPatchEmployeeBenefits(ctx context.Context, in *EmployeeBenefits, updateMask *field_mask.FieldMask, db *gorm.DB) (*EmployeeBenefits, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EmployeeBenefits
	var err error
	if hook, ok := interface{}(&pbObj).(EmployeeBenefitsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployeeBenefits(ctx, &EmployeeBenefits{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployeeBenefitsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployeeBenefits(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployeeBenefitsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployeeBenefits(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployeeBenefitsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployeeBenefitsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmployeeBenefits, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmployeeBenefits, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmployeeBenefits, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmployeeBenefits, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployeeBenefits executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployeeBenefits(ctx context.Context, objects []*EmployeeBenefits, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EmployeeBenefits, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmployeeBenefits, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployeeBenefits(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployeeBenefits patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployeeBenefits(ctx context.Context, patchee *EmployeeBenefits, patcher *EmployeeBenefits, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EmployeeBenefits, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartDate bool
	var updatedEndDate bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"ProviderName" {
			patchee.ProviderName = patcher.ProviderName
			continue
		}
		if f == prefix+"EmployeeMergeAccountId" {
			patchee.EmployeeMergeAccountId = patcher.EmployeeMergeAccountId
			continue
		}
		if f == prefix+"BenefitPlanMergeAccountId" {
			patchee.BenefitPlanMergeAccountId = patcher.BenefitPlanMergeAccountId
			continue
		}
		if f == prefix+"EmployeeContribution" {
			patchee.EmployeeContribution = patcher.EmployeeContribution
			continue
		}
		if f == prefix+"CompanyContribution" {
			patchee.CompanyContribution = patcher.CompanyContribution
			continue
		}
		if !updatedStartDate && strings.HasPrefix(f, prefix+"StartDate.") {
			if patcher.StartDate == nil {
				patchee.StartDate = nil
				continue
			}
			if patchee.StartDate == nil {
				patchee.StartDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartDate, patchee.StartDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartDate" {
			updatedStartDate = true
			patchee.StartDate = patcher.StartDate
			continue
		}
		if !updatedEndDate && strings.HasPrefix(f, prefix+"EndDate.") {
			if patcher.EndDate == nil {
				patchee.EndDate = nil
				continue
			}
			if patchee.EndDate == nil {
				patchee.EndDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndDate, patchee.EndDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndDate" {
			updatedEndDate = true
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployeeBenefits executes a gorm list call
func DefaultListEmployeeBenefits(ctx context.Context, db *gorm.DB) ([]*EmployeeBenefits, error) {
	in := EmployeeBenefits{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployeeBenefitsORM{}, &EmployeeBenefits{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployeeBenefitsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeBenefitsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmployeeBenefits{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployeeBenefitsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeBenefitsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployeeBenefitsORM) error
}

// DefaultCreateEmployerPayrollRun executes a basic gorm create call
func DefaultCreateEmployerPayrollRun(ctx context.Context, in *EmployerPayrollRun, db *gorm.DB) (*EmployerPayrollRun, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployerPayrollRunORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployerPayrollRun(ctx context.Context, in *EmployerPayrollRun, db *gorm.DB) (*EmployerPayrollRun, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployerPayrollRunORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployerPayrollRunORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployerPayrollRunORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployerPayrollRunORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployerPayrollRun(ctx context.Context, in *EmployerPayrollRun, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployerPayrollRunORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployerPayrollRunORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployerPayrollRunSet(ctx context.Context, in []*EmployerPayrollRun, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployerPayrollRunORM{})).(EmployerPayrollRunORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployerPayrollRunORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployerPayrollRunORM{})).(EmployerPayrollRunORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployerPayrollRunORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmployerPayrollRun, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmployerPayrollRun, *gorm.DB) error
}

// DefaultStrictUpdateEmployerPayrollRun clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployerPayrollRun(ctx context.Context, in *EmployerPayrollRun, db *gorm.DB) (*EmployerPayrollRun, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployerPayrollRun")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployerPayrollRunORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterPayrollRuns := EmployeePayrollRunORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPayrollRuns.EmployerPayrollRunId = new(uint64)
	*filterPayrollRuns.EmployerPayrollRunId = ormObj.Id
	if err = db.Where(filterPayrollRuns).Delete(EmployeePayrollRunORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployerPayrollRunORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployerPayrollRun executes a basic gorm update call with patch behavior
func DefaultPatchEmployerPayrollRun(ctx context.Context, in *EmployerPayrollRun, updateMask *field_mask.FieldMask, db *gorm.DB) (*EmployerPayrollRun, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EmployerPayrollRun
	var err error
	if hook, ok := interface{}(&pbObj).(EmployerPayrollRunWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployerPayrollRun(ctx, &EmployerPayrollRun{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployerPayrollRunWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployerPayrollRun(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployerPayrollRunWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployerPayrollRun(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployerPayrollRunWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployerPayrollRunWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmployerPayrollRun, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmployerPayrollRun, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmployerPayrollRun, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmployerPayrollRun, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployerPayrollRun executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployerPayrollRun(ctx context.Context, objects []*EmployerPayrollRun, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EmployerPayrollRun, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmployerPayrollRun, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployerPayrollRun(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployerPayrollRun patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployerPayrollRun(ctx context.Context, patchee *EmployerPayrollRun, patcher *EmployerPayrollRun, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EmployerPayrollRun, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartDate bool
	var updatedEndDate bool
	var updatedCheckDate bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"RunState" {
			patchee.RunState = patcher.RunState
			continue
		}
		if f == prefix+"RunType" {
			patchee.RunType = patcher.RunType
			continue
		}
		if !updatedStartDate && strings.HasPrefix(f, prefix+"StartDate.") {
			if patcher.StartDate == nil {
				patchee.StartDate = nil
				continue
			}
			if patchee.StartDate == nil {
				patchee.StartDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartDate, patchee.StartDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartDate" {
			updatedStartDate = true
			patchee.StartDate = patcher.StartDate
			continue
		}
		if !updatedEndDate && strings.HasPrefix(f, prefix+"EndDate.") {
			if patcher.EndDate == nil {
				patchee.EndDate = nil
				continue
			}
			if patchee.EndDate == nil {
				patchee.EndDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndDate, patchee.EndDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndDate" {
			updatedEndDate = true
			patchee.EndDate = patcher.EndDate
			continue
		}
		if !updatedCheckDate && strings.HasPrefix(f, prefix+"CheckDate.") {
			if patcher.CheckDate == nil {
				patchee.CheckDate = nil
				continue
			}
			if patchee.CheckDate == nil {
				patchee.CheckDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CheckDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CheckDate, patchee.CheckDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CheckDate" {
			updatedCheckDate = true
			patchee.CheckDate = patcher.CheckDate
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"PayrollRuns" {
			patchee.PayrollRuns = patcher.PayrollRuns
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployerPayrollRun executes a gorm list call
func DefaultListEmployerPayrollRun(ctx context.Context, db *gorm.DB) ([]*EmployerPayrollRun, error) {
	in := EmployerPayrollRun{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployerPayrollRunORM{}, &EmployerPayrollRun{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployerPayrollRunORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployerPayrollRunORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmployerPayrollRun{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployerPayrollRunORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployerPayrollRunORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployerPayrollRunORM) error
}

// DefaultCreateEmployeeJobPositionAtCompany executes a basic gorm create call
func DefaultCreateEmployeeJobPositionAtCompany(ctx context.Context, in *EmployeeJobPositionAtCompany, db *gorm.DB) (*EmployeeJobPositionAtCompany, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeJobPositionAtCompanyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployeeJobPositionAtCompany(ctx context.Context, in *EmployeeJobPositionAtCompany, db *gorm.DB) (*EmployeeJobPositionAtCompany, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployeeJobPositionAtCompanyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployeeJobPositionAtCompanyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployeeJobPositionAtCompanyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeJobPositionAtCompanyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeeJobPositionAtCompany(ctx context.Context, in *EmployeeJobPositionAtCompany, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployeeJobPositionAtCompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployeeJobPositionAtCompanyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeeJobPositionAtCompanySet(ctx context.Context, in []*EmployeeJobPositionAtCompany, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployeeJobPositionAtCompanyORM{})).(EmployeeJobPositionAtCompanyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployeeJobPositionAtCompanyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployeeJobPositionAtCompanyORM{})).(EmployeeJobPositionAtCompanyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployeeJobPositionAtCompanyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmployeeJobPositionAtCompany, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmployeeJobPositionAtCompany, *gorm.DB) error
}

// DefaultStrictUpdateEmployeeJobPositionAtCompany clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployeeJobPositionAtCompany(ctx context.Context, in *EmployeeJobPositionAtCompany, db *gorm.DB) (*EmployeeJobPositionAtCompany, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployeeJobPositionAtCompany")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployeeJobPositionAtCompanyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployeeJobPositionAtCompanyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployeeJobPositionAtCompany executes a basic gorm update call with patch behavior
func DefaultPatchEmployeeJobPositionAtCompany(ctx context.Context, in *EmployeeJobPositionAtCompany, updateMask *field_mask.FieldMask, db *gorm.DB) (*EmployeeJobPositionAtCompany, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EmployeeJobPositionAtCompany
	var err error
	if hook, ok := interface{}(&pbObj).(EmployeeJobPositionAtCompanyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployeeJobPositionAtCompany(ctx, &EmployeeJobPositionAtCompany{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployeeJobPositionAtCompanyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployeeJobPositionAtCompany(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployeeJobPositionAtCompanyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployeeJobPositionAtCompany(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployeeJobPositionAtCompanyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployeeJobPositionAtCompanyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmployeeJobPositionAtCompany, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmployeeJobPositionAtCompany, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmployeeJobPositionAtCompany, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmployeeJobPositionAtCompany, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployeeJobPositionAtCompany executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployeeJobPositionAtCompany(ctx context.Context, objects []*EmployeeJobPositionAtCompany, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EmployeeJobPositionAtCompany, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmployeeJobPositionAtCompany, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployeeJobPositionAtCompany(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployeeJobPositionAtCompany patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployeeJobPositionAtCompany(ctx context.Context, patchee *EmployeeJobPositionAtCompany, patcher *EmployeeJobPositionAtCompany, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EmployeeJobPositionAtCompany, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedEffectiveDate bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"JobTitle" {
			patchee.JobTitle = patcher.JobTitle
			continue
		}
		if f == prefix+"PayRate" {
			patchee.PayRate = patcher.PayRate
			continue
		}
		if f == prefix+"PayPeriod" {
			patchee.PayPeriod = patcher.PayPeriod
			continue
		}
		if f == prefix+"PayFrequency" {
			patchee.PayFrequency = patcher.PayFrequency
			continue
		}
		if f == prefix+"PayCurrency" {
			patchee.PayCurrency = patcher.PayCurrency
			continue
		}
		if f == prefix+"FlsaStatus" {
			patchee.FlsaStatus = patcher.FlsaStatus
			continue
		}
		if !updatedEffectiveDate && strings.HasPrefix(f, prefix+"EffectiveDate.") {
			if patcher.EffectiveDate == nil {
				patchee.EffectiveDate = nil
				continue
			}
			if patchee.EffectiveDate == nil {
				patchee.EffectiveDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EffectiveDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EffectiveDate, patchee.EffectiveDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EffectiveDate" {
			updatedEffectiveDate = true
			patchee.EffectiveDate = patcher.EffectiveDate
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployeeJobPositionAtCompany executes a gorm list call
func DefaultListEmployeeJobPositionAtCompany(ctx context.Context, db *gorm.DB) ([]*EmployeeJobPositionAtCompany, error) {
	in := EmployeeJobPositionAtCompany{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployeeJobPositionAtCompanyORM{}, &EmployeeJobPositionAtCompany{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployeeJobPositionAtCompanyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeJobPositionAtCompanyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmployeeJobPositionAtCompany{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployeeJobPositionAtCompanyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeeJobPositionAtCompanyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployeeJobPositionAtCompanyORM) error
}

// DefaultCreateGroup executes a basic gorm create call
func DefaultCreateGroup(ctx context.Context, in *Group, db *gorm.DB) (*Group, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadGroup(ctx context.Context, in *Group, db *gorm.DB) (*Group, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &GroupORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteGroup(ctx context.Context, in *Group, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteGroupSet(ctx context.Context, in []*Group, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Group, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Group, *gorm.DB) error
}

// DefaultStrictUpdateGroup clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroup(ctx context.Context, in *Group, db *gorm.DB) (*Group, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &GroupORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchGroup executes a basic gorm update call with patch behavior
func DefaultPatchGroup(ctx context.Context, in *Group, updateMask *field_mask.FieldMask, db *gorm.DB) (*Group, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Group
	var err error
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroup(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroup(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Group, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Group, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Group, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type GroupWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Group, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetGroup executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroup(ctx context.Context, objects []*Group, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Group, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Group, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroup(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroup(ctx context.Context, patchee *Group, patcher *Group, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Group, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"ParentGroupMergeAccountId" {
			patchee.ParentGroupMergeAccountId = patcher.ParentGroupMergeAccountId
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroup executes a gorm list call
func DefaultListGroup(ctx context.Context, db *gorm.DB) ([]*Group, error) {
	in := Group{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &GroupORM{}, &Group{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []GroupORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Group{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type GroupORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]GroupORM) error
}

// DefaultCreateLocationAddress executes a basic gorm create call
func DefaultCreateLocationAddress(ctx context.Context, in *LocationAddress, db *gorm.DB) (*LocationAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LocationAddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLocationAddress(ctx context.Context, in *LocationAddress, db *gorm.DB) (*LocationAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &LocationAddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LocationAddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LocationAddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LocationAddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLocationAddress(ctx context.Context, in *LocationAddress, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LocationAddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LocationAddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLocationAddressSet(ctx context.Context, in []*LocationAddress, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LocationAddressORM{})).(LocationAddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LocationAddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LocationAddressORM{})).(LocationAddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LocationAddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LocationAddress, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LocationAddress, *gorm.DB) error
}

// DefaultStrictUpdateLocationAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLocationAddress(ctx context.Context, in *LocationAddress, db *gorm.DB) (*LocationAddress, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLocationAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LocationAddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LocationAddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLocationAddress executes a basic gorm update call with patch behavior
func DefaultPatchLocationAddress(ctx context.Context, in *LocationAddress, updateMask *field_mask.FieldMask, db *gorm.DB) (*LocationAddress, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LocationAddress
	var err error
	if hook, ok := interface{}(&pbObj).(LocationAddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLocationAddress(ctx, &LocationAddress{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LocationAddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLocationAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LocationAddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLocationAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LocationAddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LocationAddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LocationAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LocationAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LocationAddress, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LocationAddress, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLocationAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetLocationAddress(ctx context.Context, objects []*LocationAddress, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LocationAddress, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LocationAddress, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLocationAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLocationAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLocationAddress(ctx context.Context, patchee *LocationAddress, patcher *LocationAddress, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LocationAddress, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Street_1" {
			patchee.Street_1 = patcher.Street_1
			continue
		}
		if f == prefix+"Street_2" {
			patchee.Street_2 = patcher.Street_2
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"LocationType" {
			patchee.LocationType = patcher.LocationType
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLocationAddress executes a gorm list call
func DefaultListLocationAddress(ctx context.Context, db *gorm.DB) ([]*LocationAddress, error) {
	in := LocationAddress{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &LocationAddressORM{}, &LocationAddress{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LocationAddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationAddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LocationAddress{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LocationAddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LocationAddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LocationAddressORM) error
}

// DefaultCreateBankInfo executes a basic gorm create call
func DefaultCreateBankInfo(ctx context.Context, in *BankInfo, db *gorm.DB) (*BankInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BankInfoORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBankInfo(ctx context.Context, in *BankInfo, db *gorm.DB) (*BankInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BankInfoORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BankInfoORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BankInfoORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BankInfoORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBankInfo(ctx context.Context, in *BankInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BankInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BankInfoORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBankInfoSet(ctx context.Context, in []*BankInfo, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BankInfoORM{})).(BankInfoORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BankInfoORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BankInfoORM{})).(BankInfoORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BankInfoORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BankInfo, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BankInfo, *gorm.DB) error
}

// DefaultStrictUpdateBankInfo clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBankInfo(ctx context.Context, in *BankInfo, db *gorm.DB) (*BankInfo, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBankInfo")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BankInfoORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BankInfoORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBankInfo executes a basic gorm update call with patch behavior
func DefaultPatchBankInfo(ctx context.Context, in *BankInfo, updateMask *field_mask.FieldMask, db *gorm.DB) (*BankInfo, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BankInfo
	var err error
	if hook, ok := interface{}(&pbObj).(BankInfoWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBankInfo(ctx, &BankInfo{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BankInfoWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBankInfo(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BankInfoWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBankInfo(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BankInfoWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BankInfoWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BankInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankInfoWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BankInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankInfoWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BankInfo, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BankInfoWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BankInfo, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBankInfo executes a bulk gorm update call with patch behavior
func DefaultPatchSetBankInfo(ctx context.Context, objects []*BankInfo, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BankInfo, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BankInfo, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBankInfo(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBankInfo patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBankInfo(ctx context.Context, patchee *BankInfo, patcher *BankInfo, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BankInfo, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"AccountNumber" {
			patchee.AccountNumber = patcher.AccountNumber
			continue
		}
		if f == prefix+"RoutingNumber" {
			patchee.RoutingNumber = patcher.RoutingNumber
			continue
		}
		if f == prefix+"BankName" {
			patchee.BankName = patcher.BankName
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBankInfo executes a gorm list call
func DefaultListBankInfo(ctx context.Context, db *gorm.DB) ([]*BankInfo, error) {
	in := BankInfo{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BankInfoORM{}, &BankInfo{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BankInfoORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BankInfoORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BankInfo{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BankInfoORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BankInfoORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BankInfoORM) error
}

// DefaultCreateDependents executes a basic gorm create call
func DefaultCreateDependents(ctx context.Context, in *Dependents, db *gorm.DB) (*Dependents, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DependentsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDependents(ctx context.Context, in *Dependents, db *gorm.DB) (*Dependents, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &DependentsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DependentsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DependentsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DependentsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDependents(ctx context.Context, in *Dependents, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DependentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DependentsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDependentsSet(ctx context.Context, in []*Dependents, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DependentsORM{})).(DependentsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DependentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DependentsORM{})).(DependentsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DependentsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Dependents, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Dependents, *gorm.DB) error
}

// DefaultStrictUpdateDependents clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDependents(ctx context.Context, in *Dependents, db *gorm.DB) (*Dependents, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDependents")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DependentsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterHomeLocation := LocationAddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterHomeLocation.DependentsId = new(uint64)
	*filterHomeLocation.DependentsId = ormObj.Id
	if err = db.Where(filterHomeLocation).Delete(LocationAddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DependentsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDependents executes a basic gorm update call with patch behavior
func DefaultPatchDependents(ctx context.Context, in *Dependents, updateMask *field_mask.FieldMask, db *gorm.DB) (*Dependents, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Dependents
	var err error
	if hook, ok := interface{}(&pbObj).(DependentsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDependents(ctx, &Dependents{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DependentsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDependents(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DependentsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDependents(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DependentsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DependentsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Dependents, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DependentsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Dependents, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DependentsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Dependents, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DependentsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Dependents, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDependents executes a bulk gorm update call with patch behavior
func DefaultPatchSetDependents(ctx context.Context, objects []*Dependents, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Dependents, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Dependents, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDependents(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDependents patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDependents(ctx context.Context, patchee *Dependents, patcher *Dependents, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Dependents, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedDateOfBirth bool
	var updatedHomeLocation bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"MiddleName" {
			patchee.MiddleName = patcher.MiddleName
			continue
		}
		if f == prefix+"DependentRelationshipToEmployee" {
			patchee.DependentRelationshipToEmployee = patcher.DependentRelationshipToEmployee
			continue
		}
		if !updatedDateOfBirth && strings.HasPrefix(f, prefix+"DateOfBirth.") {
			if patcher.DateOfBirth == nil {
				patchee.DateOfBirth = nil
				continue
			}
			if patchee.DateOfBirth == nil {
				patchee.DateOfBirth = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DateOfBirth."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.DateOfBirth, patchee.DateOfBirth, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DateOfBirth" {
			updatedDateOfBirth = true
			patchee.DateOfBirth = patcher.DateOfBirth
			continue
		}
		if f == prefix+"Gender" {
			patchee.Gender = patcher.Gender
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if !updatedHomeLocation && strings.HasPrefix(f, prefix+"HomeLocation.") {
			updatedHomeLocation = true
			if patcher.HomeLocation == nil {
				patchee.HomeLocation = nil
				continue
			}
			if patchee.HomeLocation == nil {
				patchee.HomeLocation = &LocationAddress{}
			}
			if o, err := DefaultApplyFieldMaskLocationAddress(ctx, patchee.HomeLocation, patcher.HomeLocation, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"HomeLocation.", db); err != nil {
				return nil, err
			} else {
				patchee.HomeLocation = o
			}
			continue
		}
		if f == prefix+"HomeLocation" {
			updatedHomeLocation = true
			patchee.HomeLocation = patcher.HomeLocation
			continue
		}
		if f == prefix+"IsStudent" {
			patchee.IsStudent = patcher.IsStudent
			continue
		}
		if f == prefix+"Ssn" {
			patchee.Ssn = patcher.Ssn
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDependents executes a gorm list call
func DefaultListDependents(ctx context.Context, db *gorm.DB) ([]*Dependents, error) {
	in := Dependents{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DependentsORM{}, &Dependents{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DependentsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DependentsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Dependents{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DependentsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DependentsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DependentsORM) error
}

// DefaultCreateEmployeePayrollRun executes a basic gorm create call
func DefaultCreateEmployeePayrollRun(ctx context.Context, in *EmployeePayrollRun, db *gorm.DB) (*EmployeePayrollRun, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployeePayrollRunORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployeePayrollRun(ctx context.Context, in *EmployeePayrollRun, db *gorm.DB) (*EmployeePayrollRun, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployeePayrollRunORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployeePayrollRunORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployeePayrollRunORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployeePayrollRunORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeePayrollRun(ctx context.Context, in *EmployeePayrollRun, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployeePayrollRunORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployeePayrollRunORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeePayrollRunSet(ctx context.Context, in []*EmployeePayrollRun, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployeePayrollRunORM{})).(EmployeePayrollRunORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployeePayrollRunORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployeePayrollRunORM{})).(EmployeePayrollRunORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployeePayrollRunORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmployeePayrollRun, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmployeePayrollRun, *gorm.DB) error
}

// DefaultStrictUpdateEmployeePayrollRun clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployeePayrollRun(ctx context.Context, in *EmployeePayrollRun, db *gorm.DB) (*EmployeePayrollRun, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployeePayrollRun")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployeePayrollRunORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDeductions := DeductionORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDeductions.EmployeePayrollRunId = new(uint64)
	*filterDeductions.EmployeePayrollRunId = ormObj.Id
	if err = db.Where(filterDeductions).Delete(DeductionORM{}).Error; err != nil {
		return nil, err
	}
	filterEarnings := EarningORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEarnings.EmployeePayrollRunId = new(uint64)
	*filterEarnings.EmployeePayrollRunId = ormObj.Id
	if err = db.Where(filterEarnings).Delete(EarningORM{}).Error; err != nil {
		return nil, err
	}
	filterTaxes := TaxORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTaxes.EmployeePayrollRunId = new(uint64)
	*filterTaxes.EmployeePayrollRunId = ormObj.Id
	if err = db.Where(filterTaxes).Delete(TaxORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployeePayrollRunORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployeePayrollRun executes a basic gorm update call with patch behavior
func DefaultPatchEmployeePayrollRun(ctx context.Context, in *EmployeePayrollRun, updateMask *field_mask.FieldMask, db *gorm.DB) (*EmployeePayrollRun, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EmployeePayrollRun
	var err error
	if hook, ok := interface{}(&pbObj).(EmployeePayrollRunWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployeePayrollRun(ctx, &EmployeePayrollRun{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployeePayrollRunWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployeePayrollRun(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployeePayrollRunWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployeePayrollRun(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployeePayrollRunWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployeePayrollRunWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmployeePayrollRun, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmployeePayrollRun, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmployeePayrollRun, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmployeePayrollRun, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployeePayrollRun executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployeePayrollRun(ctx context.Context, objects []*EmployeePayrollRun, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EmployeePayrollRun, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmployeePayrollRun, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployeePayrollRun(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployeePayrollRun patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployeePayrollRun(ctx context.Context, patchee *EmployeePayrollRun, patcher *EmployeePayrollRun, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EmployeePayrollRun, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedStartDate bool
	var updatedEndDate bool
	var updatedCheckDate bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"GrossPay" {
			patchee.GrossPay = patcher.GrossPay
			continue
		}
		if f == prefix+"NetPay" {
			patchee.NetPay = patcher.NetPay
			continue
		}
		if !updatedStartDate && strings.HasPrefix(f, prefix+"StartDate.") {
			if patcher.StartDate == nil {
				patchee.StartDate = nil
				continue
			}
			if patchee.StartDate == nil {
				patchee.StartDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartDate, patchee.StartDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartDate" {
			updatedStartDate = true
			patchee.StartDate = patcher.StartDate
			continue
		}
		if !updatedEndDate && strings.HasPrefix(f, prefix+"EndDate.") {
			if patcher.EndDate == nil {
				patchee.EndDate = nil
				continue
			}
			if patchee.EndDate == nil {
				patchee.EndDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndDate, patchee.EndDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndDate" {
			updatedEndDate = true
			patchee.EndDate = patcher.EndDate
			continue
		}
		if !updatedCheckDate && strings.HasPrefix(f, prefix+"CheckDate.") {
			if patcher.CheckDate == nil {
				patchee.CheckDate = nil
				continue
			}
			if patchee.CheckDate == nil {
				patchee.CheckDate = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CheckDate."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CheckDate, patchee.CheckDate, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CheckDate" {
			updatedCheckDate = true
			patchee.CheckDate = patcher.CheckDate
			continue
		}
		if f == prefix+"Earnings" {
			patchee.Earnings = patcher.Earnings
			continue
		}
		if f == prefix+"Deductions" {
			patchee.Deductions = patcher.Deductions
			continue
		}
		if f == prefix+"Taxes" {
			patchee.Taxes = patcher.Taxes
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"PayrollRunMergeAccountId" {
			patchee.PayrollRunMergeAccountId = patcher.PayrollRunMergeAccountId
			continue
		}
		if f == prefix+"EmployeeMergeAccountId" {
			patchee.EmployeeMergeAccountId = patcher.EmployeeMergeAccountId
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployeePayrollRun executes a gorm list call
func DefaultListEmployeePayrollRun(ctx context.Context, db *gorm.DB) ([]*EmployeePayrollRun, error) {
	in := EmployeePayrollRun{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployeePayrollRunORM{}, &EmployeePayrollRun{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployeePayrollRunORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeePayrollRunORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmployeePayrollRun{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployeePayrollRunORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeePayrollRunORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployeePayrollRunORM) error
}

// DefaultCreateEarning executes a basic gorm create call
func DefaultCreateEarning(ctx context.Context, in *Earning, db *gorm.DB) (*Earning, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EarningORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEarning(ctx context.Context, in *Earning, db *gorm.DB) (*Earning, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EarningORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EarningORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EarningORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EarningORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEarning(ctx context.Context, in *Earning, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EarningORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EarningORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEarningSet(ctx context.Context, in []*Earning, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EarningORM{})).(EarningORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EarningORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EarningORM{})).(EarningORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EarningORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Earning, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Earning, *gorm.DB) error
}

// DefaultStrictUpdateEarning clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEarning(ctx context.Context, in *Earning, db *gorm.DB) (*Earning, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEarning")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EarningORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EarningORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEarning executes a basic gorm update call with patch behavior
func DefaultPatchEarning(ctx context.Context, in *Earning, updateMask *field_mask.FieldMask, db *gorm.DB) (*Earning, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Earning
	var err error
	if hook, ok := interface{}(&pbObj).(EarningWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEarning(ctx, &Earning{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EarningWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEarning(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EarningWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEarning(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EarningWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EarningWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Earning, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EarningWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Earning, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EarningWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Earning, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EarningWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Earning, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEarning executes a bulk gorm update call with patch behavior
func DefaultPatchSetEarning(ctx context.Context, objects []*Earning, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Earning, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Earning, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEarning(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEarning patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEarning(ctx context.Context, patchee *Earning, patcher *Earning, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Earning, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"PayrollRunMergeAccountId" {
			patchee.PayrollRunMergeAccountId = patcher.PayrollRunMergeAccountId
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEarning executes a gorm list call
func DefaultListEarning(ctx context.Context, db *gorm.DB) ([]*Earning, error) {
	in := Earning{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EarningORM{}, &Earning{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EarningORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EarningORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Earning{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EarningORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EarningORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EarningORM) error
}

// DefaultCreateDeduction executes a basic gorm create call
func DefaultCreateDeduction(ctx context.Context, in *Deduction, db *gorm.DB) (*Deduction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DeductionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDeduction(ctx context.Context, in *Deduction, db *gorm.DB) (*Deduction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &DeductionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DeductionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DeductionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DeductionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDeduction(ctx context.Context, in *Deduction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DeductionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DeductionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDeductionSet(ctx context.Context, in []*Deduction, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DeductionORM{})).(DeductionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DeductionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DeductionORM{})).(DeductionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DeductionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Deduction, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Deduction, *gorm.DB) error
}

// DefaultStrictUpdateDeduction clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDeduction(ctx context.Context, in *Deduction, db *gorm.DB) (*Deduction, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDeduction")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DeductionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DeductionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDeduction executes a basic gorm update call with patch behavior
func DefaultPatchDeduction(ctx context.Context, in *Deduction, updateMask *field_mask.FieldMask, db *gorm.DB) (*Deduction, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Deduction
	var err error
	if hook, ok := interface{}(&pbObj).(DeductionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDeduction(ctx, &Deduction{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DeductionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDeduction(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DeductionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDeduction(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DeductionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DeductionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Deduction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DeductionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Deduction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DeductionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Deduction, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DeductionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Deduction, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDeduction executes a bulk gorm update call with patch behavior
func DefaultPatchSetDeduction(ctx context.Context, objects []*Deduction, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Deduction, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Deduction, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDeduction(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDeduction patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDeduction(ctx context.Context, patchee *Deduction, patcher *Deduction, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Deduction, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"EmployeeDeduction" {
			patchee.EmployeeDeduction = patcher.EmployeeDeduction
			continue
		}
		if f == prefix+"CompanyDeduction" {
			patchee.CompanyDeduction = patcher.CompanyDeduction
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"PayrollRunMergeAccountId" {
			patchee.PayrollRunMergeAccountId = patcher.PayrollRunMergeAccountId
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDeduction executes a gorm list call
func DefaultListDeduction(ctx context.Context, db *gorm.DB) ([]*Deduction, error) {
	in := Deduction{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DeductionORM{}, &Deduction{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DeductionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DeductionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Deduction{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DeductionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DeductionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DeductionORM) error
}

// DefaultCreateTax executes a basic gorm create call
func DefaultCreateTax(ctx context.Context, in *Tax, db *gorm.DB) (*Tax, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TaxORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTax(ctx context.Context, in *Tax, db *gorm.DB) (*Tax, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TaxORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TaxORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TaxORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TaxORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTax(ctx context.Context, in *Tax, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TaxORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TaxORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxSet(ctx context.Context, in []*Tax, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TaxORM{})).(TaxORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TaxORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TaxORM{})).(TaxORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TaxORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tax, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tax, *gorm.DB) error
}

// DefaultStrictUpdateTax clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTax(ctx context.Context, in *Tax, db *gorm.DB) (*Tax, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTax")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TaxORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TaxORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTax executes a basic gorm update call with patch behavior
func DefaultPatchTax(ctx context.Context, in *Tax, updateMask *field_mask.FieldMask, db *gorm.DB) (*Tax, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Tax
	var err error
	if hook, ok := interface{}(&pbObj).(TaxWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTax(ctx, &Tax{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TaxWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTax(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TaxWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTax(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TaxWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TaxWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tax, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tax, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tax, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tax, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTax executes a bulk gorm update call with patch behavior
func DefaultPatchSetTax(ctx context.Context, objects []*Tax, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Tax, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tax, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTax(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTax patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTax(ctx context.Context, patchee *Tax, patcher *Tax, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tax, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"EmployerTax" {
			patchee.EmployerTax = patcher.EmployerTax
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"PayrollRunMergeAccountId" {
			patchee.PayrollRunMergeAccountId = patcher.PayrollRunMergeAccountId
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTax executes a gorm list call
func DefaultListTax(ctx context.Context, db *gorm.DB) ([]*Tax, error) {
	in := Tax{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TaxORM{}, &Tax{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TaxORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tax{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TaxORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TaxORM) error
}

// DefaultCreateEmployeTimeOffBalance executes a basic gorm create call
func DefaultCreateEmployeTimeOffBalance(ctx context.Context, in *EmployeTimeOffBalance, db *gorm.DB) (*EmployeTimeOffBalance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployeTimeOffBalanceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmployeTimeOffBalance(ctx context.Context, in *EmployeTimeOffBalance, db *gorm.DB) (*EmployeTimeOffBalance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &EmployeTimeOffBalanceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployeTimeOffBalanceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployeTimeOffBalanceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployeTimeOffBalanceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeTimeOffBalance(ctx context.Context, in *EmployeTimeOffBalance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployeTimeOffBalanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployeTimeOffBalanceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmployeTimeOffBalanceSet(ctx context.Context, in []*EmployeTimeOffBalance, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployeTimeOffBalanceORM{})).(EmployeTimeOffBalanceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployeTimeOffBalanceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployeTimeOffBalanceORM{})).(EmployeTimeOffBalanceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployeTimeOffBalanceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmployeTimeOffBalance, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmployeTimeOffBalance, *gorm.DB) error
}

// DefaultStrictUpdateEmployeTimeOffBalance clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployeTimeOffBalance(ctx context.Context, in *EmployeTimeOffBalance, db *gorm.DB) (*EmployeTimeOffBalance, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployeTimeOffBalance")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployeTimeOffBalanceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployeTimeOffBalanceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmployeTimeOffBalance executes a basic gorm update call with patch behavior
func DefaultPatchEmployeTimeOffBalance(ctx context.Context, in *EmployeTimeOffBalance, updateMask *field_mask.FieldMask, db *gorm.DB) (*EmployeTimeOffBalance, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj EmployeTimeOffBalance
	var err error
	if hook, ok := interface{}(&pbObj).(EmployeTimeOffBalanceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployeTimeOffBalance(ctx, &EmployeTimeOffBalance{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployeTimeOffBalanceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployeTimeOffBalance(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployeTimeOffBalanceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployeTimeOffBalance(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployeTimeOffBalanceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployeTimeOffBalanceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmployeTimeOffBalance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmployeTimeOffBalance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmployeTimeOffBalance, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmployeTimeOffBalance, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmployeTimeOffBalance executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmployeTimeOffBalance(ctx context.Context, objects []*EmployeTimeOffBalance, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*EmployeTimeOffBalance, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmployeTimeOffBalance, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmployeTimeOffBalance(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmployeTimeOffBalance patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployeTimeOffBalance(ctx context.Context, patchee *EmployeTimeOffBalance, patcher *EmployeTimeOffBalance, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*EmployeTimeOffBalance, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if f == prefix+"Balance" {
			patchee.Balance = patcher.Balance
			continue
		}
		if f == prefix+"Used" {
			patchee.Used = patcher.Used
			continue
		}
		if f == prefix+"PolicyType" {
			patchee.PolicyType = patcher.PolicyType
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployeTimeOffBalance executes a gorm list call
func DefaultListEmployeTimeOffBalance(ctx context.Context, db *gorm.DB) ([]*EmployeTimeOffBalance, error) {
	in := EmployeTimeOffBalance{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &EmployeTimeOffBalanceORM{}, &EmployeTimeOffBalance{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployeTimeOffBalanceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeTimeOffBalanceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmployeTimeOffBalance{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployeTimeOffBalanceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmployeTimeOffBalanceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmployeTimeOffBalanceORM) error
}

// DefaultCreateTimeOff executes a basic gorm create call
func DefaultCreateTimeOff(ctx context.Context, in *TimeOff, db *gorm.DB) (*TimeOff, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TimeOffORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTimeOff(ctx context.Context, in *TimeOff, db *gorm.DB) (*TimeOff, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TimeOffORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TimeOffORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TimeOffORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TimeOffORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTimeOff(ctx context.Context, in *TimeOff, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TimeOffORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TimeOffORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTimeOffSet(ctx context.Context, in []*TimeOff, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TimeOffORM{})).(TimeOffORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TimeOffORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TimeOffORM{})).(TimeOffORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TimeOffORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TimeOff, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TimeOff, *gorm.DB) error
}

// DefaultStrictUpdateTimeOff clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTimeOff(ctx context.Context, in *TimeOff, db *gorm.DB) (*TimeOff, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTimeOff")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TimeOffORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterApprover := EmployeeORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterApprover.ApproverTimeOffId = new(uint64)
	*filterApprover.ApproverTimeOffId = ormObj.Id
	if err = db.Where(filterApprover).Delete(EmployeeORM{}).Error; err != nil {
		return nil, err
	}
	filterEmployee := EmployeeORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEmployee.EmployeeTimeOffId = new(uint64)
	*filterEmployee.EmployeeTimeOffId = ormObj.Id
	if err = db.Where(filterEmployee).Delete(EmployeeORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TimeOffORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTimeOff executes a basic gorm update call with patch behavior
func DefaultPatchTimeOff(ctx context.Context, in *TimeOff, updateMask *field_mask.FieldMask, db *gorm.DB) (*TimeOff, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TimeOff
	var err error
	if hook, ok := interface{}(&pbObj).(TimeOffWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTimeOff(ctx, &TimeOff{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TimeOffWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTimeOff(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TimeOffWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTimeOff(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TimeOffWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TimeOffWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TimeOff, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TimeOffWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TimeOff, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TimeOffWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TimeOff, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TimeOffWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TimeOff, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTimeOff executes a bulk gorm update call with patch behavior
func DefaultPatchSetTimeOff(ctx context.Context, objects []*TimeOff, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TimeOff, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TimeOff, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTimeOff(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTimeOff patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTimeOff(ctx context.Context, patchee *TimeOff, patcher *TimeOff, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TimeOff, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedEmployee bool
	var updatedApprover bool
	var updatedStartTime bool
	var updatedEndTime bool
	var updatedCreatedAt bool
	var updatedModifiedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"RemoteId" {
			patchee.RemoteId = patcher.RemoteId
			continue
		}
		if !updatedEmployee && strings.HasPrefix(f, prefix+"Employee.") {
			updatedEmployee = true
			if patcher.Employee == nil {
				patchee.Employee = nil
				continue
			}
			if patchee.Employee == nil {
				patchee.Employee = &Employee{}
			}
			if o, err := DefaultApplyFieldMaskEmployee(ctx, patchee.Employee, patcher.Employee, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Employee.", db); err != nil {
				return nil, err
			} else {
				patchee.Employee = o
			}
			continue
		}
		if f == prefix+"Employee" {
			updatedEmployee = true
			patchee.Employee = patcher.Employee
			continue
		}
		if !updatedApprover && strings.HasPrefix(f, prefix+"Approver.") {
			updatedApprover = true
			if patcher.Approver == nil {
				patchee.Approver = nil
				continue
			}
			if patchee.Approver == nil {
				patchee.Approver = &Employee{}
			}
			if o, err := DefaultApplyFieldMaskEmployee(ctx, patchee.Approver, patcher.Approver, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Approver.", db); err != nil {
				return nil, err
			} else {
				patchee.Approver = o
			}
			continue
		}
		if f == prefix+"Approver" {
			updatedApprover = true
			patchee.Approver = patcher.Approver
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"EmploymentNote" {
			patchee.EmploymentNote = patcher.EmploymentNote
			continue
		}
		if f == prefix+"Units" {
			patchee.Units = patcher.Units
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"RequestType" {
			patchee.RequestType = patcher.RequestType
			continue
		}
		if !updatedStartTime && strings.HasPrefix(f, prefix+"StartTime.") {
			if patcher.StartTime == nil {
				patchee.StartTime = nil
				continue
			}
			if patchee.StartTime == nil {
				patchee.StartTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"StartTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.StartTime, patchee.StartTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"StartTime" {
			updatedStartTime = true
			patchee.StartTime = patcher.StartTime
			continue
		}
		if !updatedEndTime && strings.HasPrefix(f, prefix+"EndTime.") {
			if patcher.EndTime == nil {
				patchee.EndTime = nil
				continue
			}
			if patchee.EndTime == nil {
				patchee.EndTime = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EndTime."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EndTime, patchee.EndTime, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EndTime" {
			updatedEndTime = true
			patchee.EndTime = patcher.EndTime
			continue
		}
		if f == prefix+"RemoteWasDeleted" {
			patchee.RemoteWasDeleted = patcher.RemoteWasDeleted
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedModifiedAt && strings.HasPrefix(f, prefix+"ModifiedAt.") {
			if patcher.ModifiedAt == nil {
				patchee.ModifiedAt = nil
				continue
			}
			if patchee.ModifiedAt == nil {
				patchee.ModifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ModifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ModifiedAt, patchee.ModifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ModifiedAt" {
			updatedModifiedAt = true
			patchee.ModifiedAt = patcher.ModifiedAt
			continue
		}
		if f == prefix+"MergeAccountId" {
			patchee.MergeAccountId = patcher.MergeAccountId
			continue
		}
		if f == prefix+"EmployeeMergeAccountId" {
			patchee.EmployeeMergeAccountId = patcher.EmployeeMergeAccountId
			continue
		}
		if f == prefix+"ApproverMergeAccountId" {
			patchee.ApproverMergeAccountId = patcher.ApproverMergeAccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTimeOff executes a gorm list call
func DefaultListTimeOff(ctx context.Context, db *gorm.DB) ([]*TimeOff, error) {
	in := TimeOff{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TimeOffORM{}, &TimeOff{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TimeOffORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TimeOffORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TimeOff{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TimeOffORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TimeOffORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TimeOffORM) error
}
