package social_servicev2

import (
	context "context"
	fmt "fmt"
	strings "strings"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type VirtualProfileORM struct {
	Activated   bool
	Communities []*CommunityProfileORM `gorm:"foreignkey:VirtualProfileId;association_foreignkey:Id;preload:true"`
	Id          uint64
	ProfileType string
	User        *UserProfileORM `gorm:"foreignkey:VirtualProfileId;association_foreignkey:Id;preload:true"`
	UserId      uint64
}

// TableName overrides the default tablename generated by GORM
func (VirtualProfileORM) TableName() string {
	return "virtual_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *VirtualProfile) ToORM(ctx context.Context) (VirtualProfileORM, error) {
	to := VirtualProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(VirtualProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	for _, v := range m.Communities {
		if v != nil {
			if tempCommunities, cErr := v.ToORM(ctx); cErr == nil {
				to.Communities = append(to.Communities, &tempCommunities)
			} else {
				return to, cErr
			}
		} else {
			to.Communities = append(to.Communities, nil)
		}
	}
	to.Activated = m.Activated
	to.ProfileType = VirtualProfileType_name[int32(m.ProfileType)]
	if posthook, ok := interface{}(m).(VirtualProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *VirtualProfileORM) ToPB(ctx context.Context) (VirtualProfile, error) {
	to := VirtualProfile{}
	var err error
	if prehook, ok := interface{}(m).(VirtualProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.UserId = m.UserId
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	for _, v := range m.Communities {
		if v != nil {
			if tempCommunities, cErr := v.ToPB(ctx); cErr == nil {
				to.Communities = append(to.Communities, &tempCommunities)
			} else {
				return to, cErr
			}
		} else {
			to.Communities = append(to.Communities, nil)
		}
	}
	to.Activated = m.Activated
	to.ProfileType = VirtualProfileType(VirtualProfileType_value[m.ProfileType])
	if posthook, ok := interface{}(m).(VirtualProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type VirtualProfile the arg will be the target, the caller the one being converted from

// VirtualProfileBeforeToORM called before default ToORM code
type VirtualProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *VirtualProfileORM) error
}

// VirtualProfileAfterToORM called after default ToORM code
type VirtualProfileWithAfterToORM interface {
	AfterToORM(context.Context, *VirtualProfileORM) error
}

// VirtualProfileBeforeToPB called before default ToPB code
type VirtualProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *VirtualProfile) error
}

// VirtualProfileAfterToPB called after default ToPB code
type VirtualProfileWithAfterToPB interface {
	AfterToPB(context.Context, *VirtualProfile) error
}

type UserProfileORM struct {
	AdminPublicationId         *uint64
	AlgoliaId                  string
	BookmarkId                 *uint64
	Bookmarks                  *BookmarkORM `gorm:"foreignkey:BookmarkId;association_foreignkey:Id;preload:true"`
	EditorsPublicationId       *uint64
	Followers                  int64
	Following                  int64
	Id                         uint64
	Name                       string
	NewsFeedTimelineId         string
	NotificationFeedTimelineId string
	PersonalFeedTimelineId     string
	Private                    bool
	ProfileImageUrl            string
	Tags                       []*UserTagsORM `gorm:"foreignkey:UserProfileId;association_foreignkey:Id;preload:true"`
	VirtualProfileId           *uint64
}

// TableName overrides the default tablename generated by GORM
func (UserProfileORM) TableName() string {
	return "user_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserProfile) ToORM(ctx context.Context) (UserProfileORM, error) {
	to := UserProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(UserProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.Name = m.Name
	to.Private = m.Private
	to.Followers = m.Followers
	to.Following = m.Following
	to.NotificationFeedTimelineId = m.NotificationFeedTimelineId
	to.PersonalFeedTimelineId = m.PersonalFeedTimelineId
	to.NewsFeedTimelineId = m.NewsFeedTimelineId
	to.ProfileImageUrl = m.ProfileImageUrl
	if m.Bookmarks != nil {
		tempBookmarks, err := m.Bookmarks.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Bookmarks = &tempBookmarks
	}
	to.AlgoliaId = m.AlgoliaId
	if posthook, ok := interface{}(m).(UserProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserProfileORM) ToPB(ctx context.Context) (UserProfile, error) {
	to := UserProfile{}
	var err error
	if prehook, ok := interface{}(m).(UserProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.Name = m.Name
	to.Private = m.Private
	to.Followers = m.Followers
	to.Following = m.Following
	to.NotificationFeedTimelineId = m.NotificationFeedTimelineId
	to.PersonalFeedTimelineId = m.PersonalFeedTimelineId
	to.NewsFeedTimelineId = m.NewsFeedTimelineId
	to.ProfileImageUrl = m.ProfileImageUrl
	if m.Bookmarks != nil {
		tempBookmarks, err := m.Bookmarks.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Bookmarks = &tempBookmarks
	}
	to.AlgoliaId = m.AlgoliaId
	if posthook, ok := interface{}(m).(UserProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserProfile the arg will be the target, the caller the one being converted from

// UserProfileBeforeToORM called before default ToORM code
type UserProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserProfileORM) error
}

// UserProfileAfterToORM called after default ToORM code
type UserProfileWithAfterToORM interface {
	AfterToORM(context.Context, *UserProfileORM) error
}

// UserProfileBeforeToPB called before default ToPB code
type UserProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserProfile) error
}

// UserProfileAfterToPB called after default ToPB code
type UserProfileWithAfterToPB interface {
	AfterToPB(context.Context, *UserProfile) error
}

type CommunityProfileORM struct {
	AlgoliaId                  string
	CommunityRules             string
	Description                string
	Followers                  int64
	Id                         uint64
	Name                       string
	NewsFeedTimelineId         string
	NotificationFeedTimelineId string
	PersonalFeedTimelineId     string
	Private                    bool
	ProfileImageUrl            string
	Topics                     []*TopicORM `gorm:"foreignkey:CommunityProfileId;association_foreignkey:Id;preload:true"`
	VirtualProfileId           *uint64
	Visible                    bool
}

// TableName overrides the default tablename generated by GORM
func (CommunityProfileORM) TableName() string {
	return "community_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CommunityProfile) ToORM(ctx context.Context) (CommunityProfileORM, error) {
	to := CommunityProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(CommunityProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Private = m.Private
	to.Visible = m.Visible
	to.Followers = m.Followers
	to.CommunityRules = m.CommunityRules
	for _, v := range m.Topics {
		if v != nil {
			if tempTopics, cErr := v.ToORM(ctx); cErr == nil {
				to.Topics = append(to.Topics, &tempTopics)
			} else {
				return to, cErr
			}
		} else {
			to.Topics = append(to.Topics, nil)
		}
	}
	to.NotificationFeedTimelineId = m.NotificationFeedTimelineId
	to.PersonalFeedTimelineId = m.PersonalFeedTimelineId
	to.NewsFeedTimelineId = m.NewsFeedTimelineId
	to.ProfileImageUrl = m.ProfileImageUrl
	to.AlgoliaId = m.AlgoliaId
	if posthook, ok := interface{}(m).(CommunityProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CommunityProfileORM) ToPB(ctx context.Context) (CommunityProfile, error) {
	to := CommunityProfile{}
	var err error
	if prehook, ok := interface{}(m).(CommunityProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.Private = m.Private
	to.Visible = m.Visible
	to.Followers = m.Followers
	to.CommunityRules = m.CommunityRules
	for _, v := range m.Topics {
		if v != nil {
			if tempTopics, cErr := v.ToPB(ctx); cErr == nil {
				to.Topics = append(to.Topics, &tempTopics)
			} else {
				return to, cErr
			}
		} else {
			to.Topics = append(to.Topics, nil)
		}
	}
	to.NotificationFeedTimelineId = m.NotificationFeedTimelineId
	to.PersonalFeedTimelineId = m.PersonalFeedTimelineId
	to.NewsFeedTimelineId = m.NewsFeedTimelineId
	to.ProfileImageUrl = m.ProfileImageUrl
	to.AlgoliaId = m.AlgoliaId
	if posthook, ok := interface{}(m).(CommunityProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CommunityProfile the arg will be the target, the caller the one being converted from

// CommunityProfileBeforeToORM called before default ToORM code
type CommunityProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *CommunityProfileORM) error
}

// CommunityProfileAfterToORM called after default ToORM code
type CommunityProfileWithAfterToORM interface {
	AfterToORM(context.Context, *CommunityProfileORM) error
}

// CommunityProfileBeforeToPB called before default ToPB code
type CommunityProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *CommunityProfile) error
}

// CommunityProfileAfterToPB called after default ToPB code
type CommunityProfileWithAfterToPB interface {
	AfterToPB(context.Context, *CommunityProfile) error
}

type FollowerORM struct {
	ApprovedAt         string
	CreatedAt          string
	Id                 uint64
	ProfileFollowedId  uint64
	ProfileFollowingId uint64
	RequestApproved    bool
	TargetFollowerType string
}

// TableName overrides the default tablename generated by GORM
func (FollowerORM) TableName() string {
	return "followers"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Follower) ToORM(ctx context.Context) (FollowerORM, error) {
	to := FollowerORM{}
	var err error
	if prehook, ok := interface{}(m).(FollowerWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ProfileFollowedId = m.ProfileFollowedId
	to.ProfileFollowingId = m.ProfileFollowingId
	to.RequestApproved = m.RequestApproved
	to.CreatedAt = m.CreatedAt
	to.ApprovedAt = m.ApprovedAt
	to.TargetFollowerType = Follower_TargetFollowerProfileType_name[int32(m.TargetFollowerType)]
	if posthook, ok := interface{}(m).(FollowerWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FollowerORM) ToPB(ctx context.Context) (Follower, error) {
	to := Follower{}
	var err error
	if prehook, ok := interface{}(m).(FollowerWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ProfileFollowedId = m.ProfileFollowedId
	to.ProfileFollowingId = m.ProfileFollowingId
	to.RequestApproved = m.RequestApproved
	to.CreatedAt = m.CreatedAt
	to.ApprovedAt = m.ApprovedAt
	to.TargetFollowerType = Follower_TargetFollowerProfileType(Follower_TargetFollowerProfileType_value[m.TargetFollowerType])
	if posthook, ok := interface{}(m).(FollowerWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Follower the arg will be the target, the caller the one being converted from

// FollowerBeforeToORM called before default ToORM code
type FollowerWithBeforeToORM interface {
	BeforeToORM(context.Context, *FollowerORM) error
}

// FollowerAfterToORM called after default ToORM code
type FollowerWithAfterToORM interface {
	AfterToORM(context.Context, *FollowerORM) error
}

// FollowerBeforeToPB called before default ToPB code
type FollowerWithBeforeToPB interface {
	BeforeToPB(context.Context, *Follower) error
}

// FollowerAfterToPB called after default ToPB code
type FollowerWithAfterToPB interface {
	AfterToPB(context.Context, *Follower) error
}

type UserTagsORM struct {
	Description   string
	Id            uint64
	TagName       string
	UserProfileId *uint64
}

// TableName overrides the default tablename generated by GORM
func (UserTagsORM) TableName() string {
	return "user_tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserTags) ToORM(ctx context.Context) (UserTagsORM, error) {
	to := UserTagsORM{}
	var err error
	if prehook, ok := interface{}(m).(UserTagsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.Description = m.Description
	if posthook, ok := interface{}(m).(UserTagsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserTagsORM) ToPB(ctx context.Context) (UserTags, error) {
	to := UserTags{}
	var err error
	if prehook, ok := interface{}(m).(UserTagsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.Description = m.Description
	if posthook, ok := interface{}(m).(UserTagsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserTags the arg will be the target, the caller the one being converted from

// UserTagsBeforeToORM called before default ToORM code
type UserTagsWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserTagsORM) error
}

// UserTagsAfterToORM called after default ToORM code
type UserTagsWithAfterToORM interface {
	AfterToORM(context.Context, *UserTagsORM) error
}

// UserTagsBeforeToPB called before default ToPB code
type UserTagsWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserTags) error
}

// UserTagsAfterToPB called after default ToPB code
type UserTagsWithAfterToPB interface {
	AfterToPB(context.Context, *UserTags) error
}

type TopicORM struct {
	CommunityProfileId *uint64
	Description        string
	Id                 uint64
	ImageUrl           string
	TopicName          string
}

// TableName overrides the default tablename generated by GORM
func (TopicORM) TableName() string {
	return "topics"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Topic) ToORM(ctx context.Context) (TopicORM, error) {
	to := TopicORM{}
	var err error
	if prehook, ok := interface{}(m).(TopicWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TopicName = m.TopicName
	to.Description = m.Description
	to.ImageUrl = m.ImageUrl
	if posthook, ok := interface{}(m).(TopicWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TopicORM) ToPB(ctx context.Context) (Topic, error) {
	to := Topic{}
	var err error
	if prehook, ok := interface{}(m).(TopicWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TopicName = m.TopicName
	to.Description = m.Description
	to.ImageUrl = m.ImageUrl
	if posthook, ok := interface{}(m).(TopicWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Topic the arg will be the target, the caller the one being converted from

// TopicBeforeToORM called before default ToORM code
type TopicWithBeforeToORM interface {
	BeforeToORM(context.Context, *TopicORM) error
}

// TopicAfterToORM called after default ToORM code
type TopicWithAfterToORM interface {
	AfterToORM(context.Context, *TopicORM) error
}

// TopicBeforeToPB called before default ToPB code
type TopicWithBeforeToPB interface {
	BeforeToPB(context.Context, *Topic) error
}

// TopicAfterToPB called after default ToPB code
type TopicWithAfterToPB interface {
	AfterToPB(context.Context, *Topic) error
}

type BlockedORM struct {
	CreatedAt           string
	Id                  uint64
	ProfileBlockedId    uint64
	ProfileBlockedType  string
	ProfileBlockingId   uint64
	ProfileBlockingType string
}

// TableName overrides the default tablename generated by GORM
func (BlockedORM) TableName() string {
	return "blockeds"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Blocked) ToORM(ctx context.Context) (BlockedORM, error) {
	to := BlockedORM{}
	var err error
	if prehook, ok := interface{}(m).(BlockedWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ProfileBlockedId = m.ProfileBlockedId
	to.ProfileBlockingId = m.ProfileBlockingId
	to.CreatedAt = m.CreatedAt
	to.ProfileBlockedType = Blocked_BlockedProfileType_name[int32(m.ProfileBlockedType)]
	to.ProfileBlockingType = Blocked_BlockedProfileType_name[int32(m.ProfileBlockingType)]
	if posthook, ok := interface{}(m).(BlockedWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BlockedORM) ToPB(ctx context.Context) (Blocked, error) {
	to := Blocked{}
	var err error
	if prehook, ok := interface{}(m).(BlockedWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ProfileBlockedId = m.ProfileBlockedId
	to.ProfileBlockingId = m.ProfileBlockingId
	to.CreatedAt = m.CreatedAt
	to.ProfileBlockedType = Blocked_BlockedProfileType(Blocked_BlockedProfileType_value[m.ProfileBlockedType])
	to.ProfileBlockingType = Blocked_BlockedProfileType(Blocked_BlockedProfileType_value[m.ProfileBlockingType])
	if posthook, ok := interface{}(m).(BlockedWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Blocked the arg will be the target, the caller the one being converted from

// BlockedBeforeToORM called before default ToORM code
type BlockedWithBeforeToORM interface {
	BeforeToORM(context.Context, *BlockedORM) error
}

// BlockedAfterToORM called after default ToORM code
type BlockedWithAfterToORM interface {
	AfterToORM(context.Context, *BlockedORM) error
}

// BlockedBeforeToPB called before default ToPB code
type BlockedWithBeforeToPB interface {
	BeforeToPB(context.Context, *Blocked) error
}

// BlockedAfterToPB called after default ToPB code
type BlockedWithAfterToPB interface {
	AfterToPB(context.Context, *Blocked) error
}

type BookmarkORM struct {
	Id           uint64
	PostIds      pq.StringArray    `gorm:"type:text[]"`
	Publications []*PublicationORM `gorm:"foreignkey:BookmarkId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (BookmarkORM) TableName() string {
	return "bookmarks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Bookmark) ToORM(ctx context.Context) (BookmarkORM, error) {
	to := BookmarkORM{}
	var err error
	if prehook, ok := interface{}(m).(BookmarkWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PostIds != nil {
		to.PostIds = make(pq.StringArray, len(m.PostIds))
		copy(to.PostIds, m.PostIds)
	}
	for _, v := range m.Publications {
		if v != nil {
			if tempPublications, cErr := v.ToORM(ctx); cErr == nil {
				to.Publications = append(to.Publications, &tempPublications)
			} else {
				return to, cErr
			}
		} else {
			to.Publications = append(to.Publications, nil)
		}
	}
	if posthook, ok := interface{}(m).(BookmarkWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BookmarkORM) ToPB(ctx context.Context) (Bookmark, error) {
	to := Bookmark{}
	var err error
	if prehook, ok := interface{}(m).(BookmarkWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PostIds != nil {
		to.PostIds = make(pq.StringArray, len(m.PostIds))
		copy(to.PostIds, m.PostIds)
	}
	for _, v := range m.Publications {
		if v != nil {
			if tempPublications, cErr := v.ToPB(ctx); cErr == nil {
				to.Publications = append(to.Publications, &tempPublications)
			} else {
				return to, cErr
			}
		} else {
			to.Publications = append(to.Publications, nil)
		}
	}
	if posthook, ok := interface{}(m).(BookmarkWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Bookmark the arg will be the target, the caller the one being converted from

// BookmarkBeforeToORM called before default ToORM code
type BookmarkWithBeforeToORM interface {
	BeforeToORM(context.Context, *BookmarkORM) error
}

// BookmarkAfterToORM called after default ToORM code
type BookmarkWithAfterToORM interface {
	AfterToORM(context.Context, *BookmarkORM) error
}

// BookmarkBeforeToPB called before default ToPB code
type BookmarkWithBeforeToPB interface {
	BeforeToPB(context.Context, *Bookmark) error
}

// BookmarkAfterToPB called after default ToPB code
type BookmarkWithAfterToPB interface {
	AfterToPB(context.Context, *Bookmark) error
}

type PublicationORM struct {
	Admin                      *UserProfileORM `gorm:"foreignkey:AdminPublicationId;association_foreignkey:Id;preload:true"`
	AdminSimfinyPlatformUserId uint64
	BookmarkId                 *uint64
	CreatedAt                  string
	Description                string
	Editors                    []*UserProfileORM `gorm:"foreignkey:EditorsPublicationId;association_foreignkey:Id;preload:true"`
	Id                         uint64
	PostIds                    pq.StringArray `gorm:"type:text[]"`
	PublicationName            string
	Subjects                   pq.StringArray `gorm:"type:text[]"`
	Tags                       pq.StringArray `gorm:"type:text[]"`
	Type                       string
}

// TableName overrides the default tablename generated by GORM
func (PublicationORM) TableName() string {
	return "publications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Publication) ToORM(ctx context.Context) (PublicationORM, error) {
	to := PublicationORM{}
	var err error
	if prehook, ok := interface{}(m).(PublicationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PostIds != nil {
		to.PostIds = make(pq.StringArray, len(m.PostIds))
		copy(to.PostIds, m.PostIds)
	}
	if m.Admin != nil {
		tempAdmin, err := m.Admin.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Admin = &tempAdmin
	}
	to.AdminSimfinyPlatformUserId = m.AdminSimfinyPlatformUserId
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Editors {
		if v != nil {
			if tempEditors, cErr := v.ToORM(ctx); cErr == nil {
				to.Editors = append(to.Editors, &tempEditors)
			} else {
				return to, cErr
			}
		} else {
			to.Editors = append(to.Editors, nil)
		}
	}
	if m.Subjects != nil {
		to.Subjects = make(pq.StringArray, len(m.Subjects))
		copy(to.Subjects, m.Subjects)
	}
	to.Description = m.Description
	to.CreatedAt = m.CreatedAt
	to.Type = PublicationType_name[int32(m.Type)]
	to.PublicationName = m.PublicationName
	if posthook, ok := interface{}(m).(PublicationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PublicationORM) ToPB(ctx context.Context) (Publication, error) {
	to := Publication{}
	var err error
	if prehook, ok := interface{}(m).(PublicationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.PostIds != nil {
		to.PostIds = make(pq.StringArray, len(m.PostIds))
		copy(to.PostIds, m.PostIds)
	}
	if m.Admin != nil {
		tempAdmin, err := m.Admin.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Admin = &tempAdmin
	}
	to.AdminSimfinyPlatformUserId = m.AdminSimfinyPlatformUserId
	if m.Tags != nil {
		to.Tags = make(pq.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	for _, v := range m.Editors {
		if v != nil {
			if tempEditors, cErr := v.ToPB(ctx); cErr == nil {
				to.Editors = append(to.Editors, &tempEditors)
			} else {
				return to, cErr
			}
		} else {
			to.Editors = append(to.Editors, nil)
		}
	}
	if m.Subjects != nil {
		to.Subjects = make(pq.StringArray, len(m.Subjects))
		copy(to.Subjects, m.Subjects)
	}
	to.Description = m.Description
	to.CreatedAt = m.CreatedAt
	to.Type = PublicationType(PublicationType_value[m.Type])
	to.PublicationName = m.PublicationName
	if posthook, ok := interface{}(m).(PublicationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Publication the arg will be the target, the caller the one being converted from

// PublicationBeforeToORM called before default ToORM code
type PublicationWithBeforeToORM interface {
	BeforeToORM(context.Context, *PublicationORM) error
}

// PublicationAfterToORM called after default ToORM code
type PublicationWithAfterToORM interface {
	AfterToORM(context.Context, *PublicationORM) error
}

// PublicationBeforeToPB called before default ToPB code
type PublicationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Publication) error
}

// PublicationAfterToPB called after default ToPB code
type PublicationWithAfterToPB interface {
	AfterToPB(context.Context, *Publication) error
}

// DefaultCreateVirtualProfile executes a basic gorm create call
func DefaultCreateVirtualProfile(ctx context.Context, in *VirtualProfile, db *gorm.DB) (*VirtualProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type VirtualProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadVirtualProfile(ctx context.Context, in *VirtualProfile, db *gorm.DB) (*VirtualProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &VirtualProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := VirtualProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(VirtualProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type VirtualProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteVirtualProfile(ctx context.Context, in *VirtualProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&VirtualProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type VirtualProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteVirtualProfileSet(ctx context.Context, in []*VirtualProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&VirtualProfileORM{})).(VirtualProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&VirtualProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&VirtualProfileORM{})).(VirtualProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type VirtualProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*VirtualProfile, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*VirtualProfile, *gorm.DB) error
}

// DefaultStrictUpdateVirtualProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateVirtualProfile(ctx context.Context, in *VirtualProfile, db *gorm.DB) (*VirtualProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateVirtualProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &VirtualProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCommunities := CommunityProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterCommunities.VirtualProfileId = new(uint64)
	*filterCommunities.VirtualProfileId = ormObj.Id
	if err = db.Where(filterCommunities).Delete(CommunityProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterUser := UserProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterUser.VirtualProfileId = new(uint64)
	*filterUser.VirtualProfileId = ormObj.Id
	if err = db.Where(filterUser).Delete(UserProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type VirtualProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchVirtualProfile executes a basic gorm update call with patch behavior
func DefaultPatchVirtualProfile(ctx context.Context, in *VirtualProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*VirtualProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj VirtualProfile
	var err error
	if hook, ok := interface{}(&pbObj).(VirtualProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadVirtualProfile(ctx, &VirtualProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(VirtualProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskVirtualProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(VirtualProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateVirtualProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(VirtualProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type VirtualProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *VirtualProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *VirtualProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *VirtualProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *VirtualProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetVirtualProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetVirtualProfile(ctx context.Context, objects []*VirtualProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*VirtualProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*VirtualProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchVirtualProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskVirtualProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskVirtualProfile(ctx context.Context, patchee *VirtualProfile, patcher *VirtualProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*VirtualProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedUser bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &UserProfile{}
			}
			if o, err := DefaultApplyFieldMaskUserProfile(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if f == prefix+"Communities" {
			patchee.Communities = patcher.Communities
			continue
		}
		if f == prefix+"Activated" {
			patchee.Activated = patcher.Activated
			continue
		}
		if f == prefix+"ProfileType" {
			patchee.ProfileType = patcher.ProfileType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListVirtualProfile executes a gorm list call
func DefaultListVirtualProfile(ctx context.Context, db *gorm.DB) ([]*VirtualProfile, error) {
	in := VirtualProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &VirtualProfileORM{}, &VirtualProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []VirtualProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(VirtualProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*VirtualProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type VirtualProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type VirtualProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]VirtualProfileORM) error
}

// DefaultCreateUserProfile executes a basic gorm create call
func DefaultCreateUserProfile(ctx context.Context, in *UserProfile, db *gorm.DB) (*UserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserProfile(ctx context.Context, in *UserProfile, db *gorm.DB) (*UserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserProfile(ctx context.Context, in *UserProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserProfileSet(ctx context.Context, in []*UserProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserProfileORM{})).(UserProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserProfileORM{})).(UserProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserProfile, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserProfile, *gorm.DB) error
}

// DefaultStrictUpdateUserProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserProfile(ctx context.Context, in *UserProfile, db *gorm.DB) (*UserProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterTags := UserTagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.UserProfileId = new(uint64)
	*filterTags.UserProfileId = ormObj.Id
	if err = db.Where(filterTags).Delete(UserTagsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserProfile executes a basic gorm update call with patch behavior
func DefaultPatchUserProfile(ctx context.Context, in *UserProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserProfile
	var err error
	if hook, ok := interface{}(&pbObj).(UserProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserProfile(ctx, &UserProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserProfile(ctx context.Context, objects []*UserProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserProfile(ctx context.Context, patchee *UserProfile, patcher *UserProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedBookmarks bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Private" {
			patchee.Private = patcher.Private
			continue
		}
		if f == prefix+"Followers" {
			patchee.Followers = patcher.Followers
			continue
		}
		if f == prefix+"Following" {
			patchee.Following = patcher.Following
			continue
		}
		if f == prefix+"NotificationFeedTimelineId" {
			patchee.NotificationFeedTimelineId = patcher.NotificationFeedTimelineId
			continue
		}
		if f == prefix+"PersonalFeedTimelineId" {
			patchee.PersonalFeedTimelineId = patcher.PersonalFeedTimelineId
			continue
		}
		if f == prefix+"NewsFeedTimelineId" {
			patchee.NewsFeedTimelineId = patcher.NewsFeedTimelineId
			continue
		}
		if f == prefix+"ProfileImageUrl" {
			patchee.ProfileImageUrl = patcher.ProfileImageUrl
			continue
		}
		if !updatedBookmarks && strings.HasPrefix(f, prefix+"Bookmarks.") {
			updatedBookmarks = true
			if patcher.Bookmarks == nil {
				patchee.Bookmarks = nil
				continue
			}
			if patchee.Bookmarks == nil {
				patchee.Bookmarks = &Bookmark{}
			}
			if o, err := DefaultApplyFieldMaskBookmark(ctx, patchee.Bookmarks, patcher.Bookmarks, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Bookmarks.", db); err != nil {
				return nil, err
			} else {
				patchee.Bookmarks = o
			}
			continue
		}
		if f == prefix+"Bookmarks" {
			updatedBookmarks = true
			patchee.Bookmarks = patcher.Bookmarks
			continue
		}
		if f == prefix+"AlgoliaId" {
			patchee.AlgoliaId = patcher.AlgoliaId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserProfile executes a gorm list call
func DefaultListUserProfile(ctx context.Context, db *gorm.DB) ([]*UserProfile, error) {
	in := UserProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserProfileORM{}, &UserProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserProfileORM) error
}

// DefaultCreateCommunityProfile executes a basic gorm create call
func DefaultCreateCommunityProfile(ctx context.Context, in *CommunityProfile, db *gorm.DB) (*CommunityProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CommunityProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCommunityProfile(ctx context.Context, in *CommunityProfile, db *gorm.DB) (*CommunityProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &CommunityProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CommunityProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CommunityProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CommunityProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCommunityProfile(ctx context.Context, in *CommunityProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CommunityProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CommunityProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCommunityProfileSet(ctx context.Context, in []*CommunityProfile, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CommunityProfileORM{})).(CommunityProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CommunityProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CommunityProfileORM{})).(CommunityProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CommunityProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CommunityProfile, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CommunityProfile, *gorm.DB) error
}

// DefaultStrictUpdateCommunityProfile clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCommunityProfile(ctx context.Context, in *CommunityProfile, db *gorm.DB) (*CommunityProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCommunityProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CommunityProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterTopics := TopicORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTopics.CommunityProfileId = new(uint64)
	*filterTopics.CommunityProfileId = ormObj.Id
	if err = db.Where(filterTopics).Delete(TopicORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CommunityProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCommunityProfile executes a basic gorm update call with patch behavior
func DefaultPatchCommunityProfile(ctx context.Context, in *CommunityProfile, updateMask *field_mask.FieldMask, db *gorm.DB) (*CommunityProfile, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CommunityProfile
	var err error
	if hook, ok := interface{}(&pbObj).(CommunityProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCommunityProfile(ctx, &CommunityProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CommunityProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCommunityProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CommunityProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCommunityProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CommunityProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CommunityProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CommunityProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CommunityProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CommunityProfile, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CommunityProfile, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCommunityProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetCommunityProfile(ctx context.Context, objects []*CommunityProfile, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CommunityProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CommunityProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCommunityProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCommunityProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCommunityProfile(ctx context.Context, patchee *CommunityProfile, patcher *CommunityProfile, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CommunityProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Private" {
			patchee.Private = patcher.Private
			continue
		}
		if f == prefix+"Visible" {
			patchee.Visible = patcher.Visible
			continue
		}
		if f == prefix+"Followers" {
			patchee.Followers = patcher.Followers
			continue
		}
		if f == prefix+"CommunityRules" {
			patchee.CommunityRules = patcher.CommunityRules
			continue
		}
		if f == prefix+"Topics" {
			patchee.Topics = patcher.Topics
			continue
		}
		if f == prefix+"NotificationFeedTimelineId" {
			patchee.NotificationFeedTimelineId = patcher.NotificationFeedTimelineId
			continue
		}
		if f == prefix+"PersonalFeedTimelineId" {
			patchee.PersonalFeedTimelineId = patcher.PersonalFeedTimelineId
			continue
		}
		if f == prefix+"NewsFeedTimelineId" {
			patchee.NewsFeedTimelineId = patcher.NewsFeedTimelineId
			continue
		}
		if f == prefix+"ProfileImageUrl" {
			patchee.ProfileImageUrl = patcher.ProfileImageUrl
			continue
		}
		if f == prefix+"AlgoliaId" {
			patchee.AlgoliaId = patcher.AlgoliaId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCommunityProfile executes a gorm list call
func DefaultListCommunityProfile(ctx context.Context, db *gorm.DB) ([]*CommunityProfile, error) {
	in := CommunityProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &CommunityProfileORM{}, &CommunityProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CommunityProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CommunityProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CommunityProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CommunityProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CommunityProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CommunityProfileORM) error
}

// DefaultCreateFollower executes a basic gorm create call
func DefaultCreateFollower(ctx context.Context, in *Follower, db *gorm.DB) (*Follower, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FollowerORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFollower(ctx context.Context, in *Follower, db *gorm.DB) (*Follower, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FollowerORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FollowerORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FollowerORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FollowerORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFollower(ctx context.Context, in *Follower, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FollowerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FollowerORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFollowerSet(ctx context.Context, in []*Follower, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FollowerORM{})).(FollowerORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FollowerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FollowerORM{})).(FollowerORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FollowerORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Follower, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Follower, *gorm.DB) error
}

// DefaultStrictUpdateFollower clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFollower(ctx context.Context, in *Follower, db *gorm.DB) (*Follower, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFollower")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FollowerORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FollowerORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFollower executes a basic gorm update call with patch behavior
func DefaultPatchFollower(ctx context.Context, in *Follower, updateMask *field_mask.FieldMask, db *gorm.DB) (*Follower, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Follower
	var err error
	if hook, ok := interface{}(&pbObj).(FollowerWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFollower(ctx, &Follower{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FollowerWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFollower(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FollowerWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFollower(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FollowerWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FollowerWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Follower, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FollowerWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Follower, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FollowerWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Follower, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FollowerWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Follower, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFollower executes a bulk gorm update call with patch behavior
func DefaultPatchSetFollower(ctx context.Context, objects []*Follower, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Follower, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Follower, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFollower(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFollower patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFollower(ctx context.Context, patchee *Follower, patcher *Follower, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Follower, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ProfileFollowedId" {
			patchee.ProfileFollowedId = patcher.ProfileFollowedId
			continue
		}
		if f == prefix+"ProfileFollowingId" {
			patchee.ProfileFollowingId = patcher.ProfileFollowingId
			continue
		}
		if f == prefix+"RequestApproved" {
			patchee.RequestApproved = patcher.RequestApproved
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"ApprovedAt" {
			patchee.ApprovedAt = patcher.ApprovedAt
			continue
		}
		if f == prefix+"TargetFollowerType" {
			patchee.TargetFollowerType = patcher.TargetFollowerType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFollower executes a gorm list call
func DefaultListFollower(ctx context.Context, db *gorm.DB) ([]*Follower, error) {
	in := Follower{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FollowerORM{}, &Follower{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FollowerORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowerORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Follower{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FollowerORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FollowerORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FollowerORM) error
}

// DefaultCreateUserTags executes a basic gorm create call
func DefaultCreateUserTags(ctx context.Context, in *UserTags, db *gorm.DB) (*UserTags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserTagsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserTags(ctx context.Context, in *UserTags, db *gorm.DB) (*UserTags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserTagsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserTagsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserTagsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserTagsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserTags(ctx context.Context, in *UserTags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserTagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserTagsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserTagsSet(ctx context.Context, in []*UserTags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserTagsORM{})).(UserTagsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserTagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserTagsORM{})).(UserTagsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserTagsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserTags, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserTags, *gorm.DB) error
}

// DefaultStrictUpdateUserTags clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserTags(ctx context.Context, in *UserTags, db *gorm.DB) (*UserTags, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserTags")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserTagsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserTagsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserTags executes a basic gorm update call with patch behavior
func DefaultPatchUserTags(ctx context.Context, in *UserTags, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserTags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserTags
	var err error
	if hook, ok := interface{}(&pbObj).(UserTagsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserTags(ctx, &UserTags{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserTagsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserTags(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserTagsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserTags(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserTagsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserTagsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserTags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserTagsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserTags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserTagsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserTags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserTagsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserTags, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserTags executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserTags(ctx context.Context, objects []*UserTags, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserTags, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserTags, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserTags(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserTags patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserTags(ctx context.Context, patchee *UserTags, patcher *UserTags, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserTags, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TagName" {
			patchee.TagName = patcher.TagName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserTags executes a gorm list call
func DefaultListUserTags(ctx context.Context, db *gorm.DB) ([]*UserTags, error) {
	in := UserTags{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserTagsORM{}, &UserTags{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserTagsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserTagsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserTags{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserTagsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserTagsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserTagsORM) error
}

// DefaultCreateTopic executes a basic gorm create call
func DefaultCreateTopic(ctx context.Context, in *Topic, db *gorm.DB) (*Topic, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TopicORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTopic(ctx context.Context, in *Topic, db *gorm.DB) (*Topic, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TopicORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TopicORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TopicORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TopicORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTopic(ctx context.Context, in *Topic, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TopicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TopicORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTopicSet(ctx context.Context, in []*Topic, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TopicORM{})).(TopicORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TopicORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TopicORM{})).(TopicORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TopicORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Topic, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Topic, *gorm.DB) error
}

// DefaultStrictUpdateTopic clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTopic(ctx context.Context, in *Topic, db *gorm.DB) (*Topic, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTopic")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TopicORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TopicORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTopic executes a basic gorm update call with patch behavior
func DefaultPatchTopic(ctx context.Context, in *Topic, updateMask *field_mask.FieldMask, db *gorm.DB) (*Topic, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Topic
	var err error
	if hook, ok := interface{}(&pbObj).(TopicWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTopic(ctx, &Topic{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TopicWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTopic(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TopicWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTopic(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TopicWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TopicWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Topic, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TopicWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Topic, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TopicWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Topic, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TopicWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Topic, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTopic executes a bulk gorm update call with patch behavior
func DefaultPatchSetTopic(ctx context.Context, objects []*Topic, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Topic, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Topic, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTopic(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTopic patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTopic(ctx context.Context, patchee *Topic, patcher *Topic, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Topic, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TopicName" {
			patchee.TopicName = patcher.TopicName
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"ImageUrl" {
			patchee.ImageUrl = patcher.ImageUrl
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTopic executes a gorm list call
func DefaultListTopic(ctx context.Context, db *gorm.DB) ([]*Topic, error) {
	in := Topic{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TopicORM{}, &Topic{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TopicORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TopicORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Topic{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TopicORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TopicORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TopicORM) error
}

// DefaultCreateBlocked executes a basic gorm create call
func DefaultCreateBlocked(ctx context.Context, in *Blocked, db *gorm.DB) (*Blocked, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BlockedORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBlocked(ctx context.Context, in *Blocked, db *gorm.DB) (*Blocked, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BlockedORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BlockedORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BlockedORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BlockedORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBlocked(ctx context.Context, in *Blocked, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BlockedORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BlockedORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBlockedSet(ctx context.Context, in []*Blocked, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BlockedORM{})).(BlockedORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BlockedORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BlockedORM{})).(BlockedORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BlockedORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Blocked, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Blocked, *gorm.DB) error
}

// DefaultStrictUpdateBlocked clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBlocked(ctx context.Context, in *Blocked, db *gorm.DB) (*Blocked, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBlocked")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BlockedORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BlockedORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBlocked executes a basic gorm update call with patch behavior
func DefaultPatchBlocked(ctx context.Context, in *Blocked, updateMask *field_mask.FieldMask, db *gorm.DB) (*Blocked, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Blocked
	var err error
	if hook, ok := interface{}(&pbObj).(BlockedWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBlocked(ctx, &Blocked{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BlockedWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBlocked(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BlockedWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBlocked(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BlockedWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BlockedWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Blocked, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BlockedWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Blocked, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BlockedWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Blocked, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BlockedWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Blocked, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBlocked executes a bulk gorm update call with patch behavior
func DefaultPatchSetBlocked(ctx context.Context, objects []*Blocked, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Blocked, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Blocked, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBlocked(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBlocked patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBlocked(ctx context.Context, patchee *Blocked, patcher *Blocked, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Blocked, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ProfileBlockedId" {
			patchee.ProfileBlockedId = patcher.ProfileBlockedId
			continue
		}
		if f == prefix+"ProfileBlockingId" {
			patchee.ProfileBlockingId = patcher.ProfileBlockingId
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"ProfileBlockedType" {
			patchee.ProfileBlockedType = patcher.ProfileBlockedType
			continue
		}
		if f == prefix+"ProfileBlockingType" {
			patchee.ProfileBlockingType = patcher.ProfileBlockingType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBlocked executes a gorm list call
func DefaultListBlocked(ctx context.Context, db *gorm.DB) ([]*Blocked, error) {
	in := Blocked{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BlockedORM{}, &Blocked{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BlockedORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BlockedORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Blocked{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BlockedORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BlockedORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BlockedORM) error
}

// DefaultCreateBookmark executes a basic gorm create call
func DefaultCreateBookmark(ctx context.Context, in *Bookmark, db *gorm.DB) (*Bookmark, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BookmarkORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBookmark(ctx context.Context, in *Bookmark, db *gorm.DB) (*Bookmark, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BookmarkORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BookmarkORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BookmarkORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BookmarkORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBookmark(ctx context.Context, in *Bookmark, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BookmarkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BookmarkORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBookmarkSet(ctx context.Context, in []*Bookmark, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BookmarkORM{})).(BookmarkORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BookmarkORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BookmarkORM{})).(BookmarkORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BookmarkORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Bookmark, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Bookmark, *gorm.DB) error
}

// DefaultStrictUpdateBookmark clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBookmark(ctx context.Context, in *Bookmark, db *gorm.DB) (*Bookmark, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBookmark")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BookmarkORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterPublications := PublicationORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterPublications.BookmarkId = new(uint64)
	*filterPublications.BookmarkId = ormObj.Id
	if err = db.Where(filterPublications).Delete(PublicationORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BookmarkORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBookmark executes a basic gorm update call with patch behavior
func DefaultPatchBookmark(ctx context.Context, in *Bookmark, updateMask *field_mask.FieldMask, db *gorm.DB) (*Bookmark, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Bookmark
	var err error
	if hook, ok := interface{}(&pbObj).(BookmarkWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBookmark(ctx, &Bookmark{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BookmarkWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBookmark(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BookmarkWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBookmark(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BookmarkWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BookmarkWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Bookmark, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BookmarkWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Bookmark, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BookmarkWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Bookmark, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BookmarkWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Bookmark, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBookmark executes a bulk gorm update call with patch behavior
func DefaultPatchSetBookmark(ctx context.Context, objects []*Bookmark, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Bookmark, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Bookmark, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBookmark(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBookmark patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBookmark(ctx context.Context, patchee *Bookmark, patcher *Bookmark, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Bookmark, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PostIds" {
			patchee.PostIds = patcher.PostIds
			continue
		}
		if f == prefix+"Publications" {
			patchee.Publications = patcher.Publications
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBookmark executes a gorm list call
func DefaultListBookmark(ctx context.Context, db *gorm.DB) ([]*Bookmark, error) {
	in := Bookmark{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BookmarkORM{}, &Bookmark{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BookmarkORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BookmarkORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Bookmark{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BookmarkORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BookmarkORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BookmarkORM) error
}

// DefaultCreatePublication executes a basic gorm create call
func DefaultCreatePublication(ctx context.Context, in *Publication, db *gorm.DB) (*Publication, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PublicationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPublication(ctx context.Context, in *Publication, db *gorm.DB) (*Publication, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &PublicationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PublicationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PublicationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PublicationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePublication(ctx context.Context, in *Publication, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PublicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PublicationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePublicationSet(ctx context.Context, in []*Publication, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PublicationORM{})).(PublicationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PublicationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PublicationORM{})).(PublicationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PublicationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Publication, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Publication, *gorm.DB) error
}

// DefaultStrictUpdatePublication clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePublication(ctx context.Context, in *Publication, db *gorm.DB) (*Publication, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePublication")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PublicationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAdmin := UserProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAdmin.AdminPublicationId = new(uint64)
	*filterAdmin.AdminPublicationId = ormObj.Id
	if err = db.Where(filterAdmin).Delete(UserProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterEditors := UserProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterEditors.EditorsPublicationId = new(uint64)
	*filterEditors.EditorsPublicationId = ormObj.Id
	if err = db.Where(filterEditors).Delete(UserProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PublicationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPublication executes a basic gorm update call with patch behavior
func DefaultPatchPublication(ctx context.Context, in *Publication, updateMask *field_mask.FieldMask, db *gorm.DB) (*Publication, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Publication
	var err error
	if hook, ok := interface{}(&pbObj).(PublicationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPublication(ctx, &Publication{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PublicationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPublication(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PublicationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePublication(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PublicationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PublicationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Publication, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PublicationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Publication, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PublicationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Publication, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PublicationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Publication, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPublication executes a bulk gorm update call with patch behavior
func DefaultPatchSetPublication(ctx context.Context, objects []*Publication, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Publication, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Publication, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPublication(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPublication patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPublication(ctx context.Context, patchee *Publication, patcher *Publication, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Publication, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAdmin bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PostIds" {
			patchee.PostIds = patcher.PostIds
			continue
		}
		if !updatedAdmin && strings.HasPrefix(f, prefix+"Admin.") {
			updatedAdmin = true
			if patcher.Admin == nil {
				patchee.Admin = nil
				continue
			}
			if patchee.Admin == nil {
				patchee.Admin = &UserProfile{}
			}
			if o, err := DefaultApplyFieldMaskUserProfile(ctx, patchee.Admin, patcher.Admin, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Admin.", db); err != nil {
				return nil, err
			} else {
				patchee.Admin = o
			}
			continue
		}
		if f == prefix+"Admin" {
			updatedAdmin = true
			patchee.Admin = patcher.Admin
			continue
		}
		if f == prefix+"AdminSimfinyPlatformUserId" {
			patchee.AdminSimfinyPlatformUserId = patcher.AdminSimfinyPlatformUserId
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Editors" {
			patchee.Editors = patcher.Editors
			continue
		}
		if f == prefix+"Subjects" {
			patchee.Subjects = patcher.Subjects
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"PublicationName" {
			patchee.PublicationName = patcher.PublicationName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPublication executes a gorm list call
func DefaultListPublication(ctx context.Context, db *gorm.DB) ([]*Publication, error) {
	in := Publication{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &PublicationORM{}, &Publication{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PublicationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PublicationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Publication{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PublicationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PublicationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PublicationORM) error
}
