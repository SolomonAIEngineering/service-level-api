package user_servicev1

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	strings "strings"
	time "time"
)

type UserAccountORM struct {
	Address                 *AddressORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	AuthnAccountId          uint64
	Bio                     string
	BusinessAccountSettings *BusinessAccountSettingsORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	CompanyDescription      string
	CompanyEstablishedDate  string
	CompanyIndustryType     string
	CompanyName             string
	CompanyWebsiteUrl       string
	CreatedAt               *time.Time
	Email                   string
	Firstname               string
	Headline                string
	Id                      uint64
	IsActive                bool
	IsBusinessAccount       bool
	IsEmailVerified         bool
	IsPrivate               bool
	Lastname                string
	PhoneNumber             string
	Tags                    []*TagsORM       `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	UserSettings            *UserSettingsORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	Username                string
	VerifiedAt              *time.Time
}

// TableName overrides the default tablename generated by GORM
func (UserAccountORM) TableName() string {
	return "user_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserAccount) ToORM(ctx context.Context) (UserAccountORM, error) {
	to := UserAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.VerifiedAt != nil {
		t := m.VerifiedAt.AsTime()
		to.VerifiedAt = &t
	}
	to.IsBusinessAccount = m.IsBusinessAccount
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.UserSettings != nil {
		tempUserSettings, err := m.UserSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.UserSettings = &tempUserSettings
	}
	if m.BusinessAccountSettings != nil {
		tempBusinessAccountSettings, err := m.BusinessAccountSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BusinessAccountSettings = &tempBusinessAccountSettings
	}
	if posthook, ok := interface{}(m).(UserAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserAccountORM) ToPB(ctx context.Context) (UserAccount, error) {
	to := UserAccount{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.VerifiedAt != nil {
		to.VerifiedAt = timestamppb.New(*m.VerifiedAt)
	}
	to.IsBusinessAccount = m.IsBusinessAccount
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.UserSettings != nil {
		tempUserSettings, err := m.UserSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.UserSettings = &tempUserSettings
	}
	if m.BusinessAccountSettings != nil {
		tempBusinessAccountSettings, err := m.BusinessAccountSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BusinessAccountSettings = &tempBusinessAccountSettings
	}
	if posthook, ok := interface{}(m).(UserAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserAccount the arg will be the target, the caller the one being converted from

// UserAccountBeforeToORM called before default ToORM code
type UserAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserAccountORM) error
}

// UserAccountAfterToORM called after default ToORM code
type UserAccountWithAfterToORM interface {
	AfterToORM(context.Context, *UserAccountORM) error
}

// UserAccountBeforeToPB called before default ToPB code
type UserAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserAccount) error
}

// UserAccountAfterToPB called after default ToPB code
type UserAccountWithAfterToPB interface {
	AfterToPB(context.Context, *UserAccount) error
}

type AddressORM struct {
	Address       string
	City          string
	Id            uint64
	Lattitude     string
	Longitude     string
	State         string
	Unit          string
	UserAccountId *uint64
	Zipcode       string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type TagsORM struct {
	Id             uint64
	Metadata       pq.StringArray `gorm:"type:text[]"`
	TagDescription string
	TagName        string
	UserAccountId  *uint64
}

// TableName overrides the default tablename generated by GORM
func (TagsORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tags) ToORM(ctx context.Context) (TagsORM, error) {
	to := TagsORM{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagsORM) ToPB(ctx context.Context) (Tags, error) {
	to := Tags{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tags the arg will be the target, the caller the one being converted from

// TagsBeforeToORM called before default ToORM code
type TagsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagsORM) error
}

// TagsAfterToORM called after default ToORM code
type TagsWithAfterToORM interface {
	AfterToORM(context.Context, *TagsORM) error
}

// TagsBeforeToPB called before default ToPB code
type TagsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tags) error
}

// TagsAfterToPB called after default ToPB code
type TagsWithAfterToPB interface {
	AfterToPB(context.Context, *Tags) error
}

type UserSettingsORM struct {
	AppTheme                       string
	DatetimeFormat                 string
	DefaultCurrency                string
	EmailNotifications             bool
	EnableGoalJournal              bool
	Id                             uint64
	InvestmentRiskTolerance        string
	PreferredLanguage              string
	PublicProfile                  bool
	PushNotifications              bool
	SmsNotifications               bool
	TwoFactorAuthenticationEnabled bool
	UserAccountId                  *uint64
}

// TableName overrides the default tablename generated by GORM
func (UserSettingsORM) TableName() string {
	return "user_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserSettings) ToORM(ctx context.Context) (UserSettingsORM, error) {
	to := UserSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(UserSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppTheme = UserSettings_Theme_name[int32(m.AppTheme)]
	to.EmailNotifications = m.EmailNotifications
	to.PushNotifications = m.PushNotifications
	to.SmsNotifications = m.SmsNotifications
	to.DefaultCurrency = m.DefaultCurrency
	to.DatetimeFormat = m.DatetimeFormat
	to.TwoFactorAuthenticationEnabled = m.TwoFactorAuthenticationEnabled
	to.PreferredLanguage = m.PreferredLanguage
	to.PublicProfile = m.PublicProfile
	to.EnableGoalJournal = m.EnableGoalJournal
	to.InvestmentRiskTolerance = UserSettings_RiskTolerance_name[int32(m.InvestmentRiskTolerance)]
	// Repeated type enum is not an ORMable message type
	if posthook, ok := interface{}(m).(UserSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserSettingsORM) ToPB(ctx context.Context) (UserSettings, error) {
	to := UserSettings{}
	var err error
	if prehook, ok := interface{}(m).(UserSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppTheme = UserSettings_Theme(UserSettings_Theme_value[m.AppTheme])
	to.EmailNotifications = m.EmailNotifications
	to.PushNotifications = m.PushNotifications
	to.SmsNotifications = m.SmsNotifications
	to.DefaultCurrency = m.DefaultCurrency
	to.DatetimeFormat = m.DatetimeFormat
	to.TwoFactorAuthenticationEnabled = m.TwoFactorAuthenticationEnabled
	to.PreferredLanguage = m.PreferredLanguage
	to.PublicProfile = m.PublicProfile
	to.EnableGoalJournal = m.EnableGoalJournal
	to.InvestmentRiskTolerance = UserSettings_RiskTolerance(UserSettings_RiskTolerance_value[m.InvestmentRiskTolerance])
	// Repeated type enum is not an ORMable message type
	if posthook, ok := interface{}(m).(UserSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserSettings the arg will be the target, the caller the one being converted from

// UserSettingsBeforeToORM called before default ToORM code
type UserSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserSettingsORM) error
}

// UserSettingsAfterToORM called after default ToORM code
type UserSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *UserSettingsORM) error
}

// UserSettingsBeforeToPB called before default ToPB code
type UserSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserSettings) error
}

// UserSettingsAfterToPB called after default ToPB code
type UserSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *UserSettings) error
}

type ContactInformationORM struct {
	AccountInformationId *uint64
	Address              string
	Email                string
	Id                   uint64
	PhoneNumber          string
}

// TableName overrides the default tablename generated by GORM
func (ContactInformationORM) TableName() string {
	return "contact_informations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ContactInformation) ToORM(ctx context.Context) (ContactInformationORM, error) {
	to := ContactInformationORM{}
	var err error
	if prehook, ok := interface{}(m).(ContactInformationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	to.PhoneNumber = m.PhoneNumber
	to.Address = m.Address
	if posthook, ok := interface{}(m).(ContactInformationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ContactInformationORM) ToPB(ctx context.Context) (ContactInformation, error) {
	to := ContactInformation{}
	var err error
	if prehook, ok := interface{}(m).(ContactInformationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	to.PhoneNumber = m.PhoneNumber
	to.Address = m.Address
	if posthook, ok := interface{}(m).(ContactInformationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ContactInformation the arg will be the target, the caller the one being converted from

// ContactInformationBeforeToORM called before default ToORM code
type ContactInformationWithBeforeToORM interface {
	BeforeToORM(context.Context, *ContactInformationORM) error
}

// ContactInformationAfterToORM called after default ToORM code
type ContactInformationWithAfterToORM interface {
	AfterToORM(context.Context, *ContactInformationORM) error
}

// ContactInformationBeforeToPB called before default ToPB code
type ContactInformationWithBeforeToPB interface {
	BeforeToPB(context.Context, *ContactInformation) error
}

// ContactInformationAfterToPB called after default ToPB code
type ContactInformationWithAfterToPB interface {
	AfterToPB(context.Context, *ContactInformation) error
}

type AccountInformationORM struct {
	BusinessAccountSettingsId  *uint64
	BusinessName               string
	BusinessRegistrationNumber string
	BusinessType               string
	ContactInfo                *ContactInformationORM `gorm:"foreignkey:AccountInformationId;association_foreignkey:Id"`
	Id                         uint64
}

// TableName overrides the default tablename generated by GORM
func (AccountInformationORM) TableName() string {
	return "account_informations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AccountInformation) ToORM(ctx context.Context) (AccountInformationORM, error) {
	to := AccountInformationORM{}
	var err error
	if prehook, ok := interface{}(m).(AccountInformationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BusinessName = m.BusinessName
	to.BusinessType = AccountInformation_BusinessType_name[int32(m.BusinessType)]
	to.BusinessRegistrationNumber = m.BusinessRegistrationNumber
	if m.ContactInfo != nil {
		tempContactInfo, err := m.ContactInfo.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ContactInfo = &tempContactInfo
	}
	if posthook, ok := interface{}(m).(AccountInformationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AccountInformationORM) ToPB(ctx context.Context) (AccountInformation, error) {
	to := AccountInformation{}
	var err error
	if prehook, ok := interface{}(m).(AccountInformationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BusinessName = m.BusinessName
	to.BusinessType = AccountInformation_BusinessType(AccountInformation_BusinessType_value[m.BusinessType])
	to.BusinessRegistrationNumber = m.BusinessRegistrationNumber
	if m.ContactInfo != nil {
		tempContactInfo, err := m.ContactInfo.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ContactInfo = &tempContactInfo
	}
	if posthook, ok := interface{}(m).(AccountInformationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AccountInformation the arg will be the target, the caller the one being converted from

// AccountInformationBeforeToORM called before default ToORM code
type AccountInformationWithBeforeToORM interface {
	BeforeToORM(context.Context, *AccountInformationORM) error
}

// AccountInformationAfterToORM called after default ToORM code
type AccountInformationWithAfterToORM interface {
	AfterToORM(context.Context, *AccountInformationORM) error
}

// AccountInformationBeforeToPB called before default ToPB code
type AccountInformationWithBeforeToPB interface {
	BeforeToPB(context.Context, *AccountInformation) error
}

// AccountInformationAfterToPB called after default ToPB code
type AccountInformationWithAfterToPB interface {
	AfterToPB(context.Context, *AccountInformation) error
}

type TaxSettingsORM struct {
	FinancialPreferencesId *uint64
	Id                     uint64
	TaxCode                string
	TaxPercentage          float64
}

// TableName overrides the default tablename generated by GORM
func (TaxSettingsORM) TableName() string {
	return "tax_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TaxSettings) ToORM(ctx context.Context) (TaxSettingsORM, error) {
	to := TaxSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(TaxSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaxPercentage = m.TaxPercentage
	to.TaxCode = m.TaxCode
	if posthook, ok := interface{}(m).(TaxSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TaxSettingsORM) ToPB(ctx context.Context) (TaxSettings, error) {
	to := TaxSettings{}
	var err error
	if prehook, ok := interface{}(m).(TaxSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TaxPercentage = m.TaxPercentage
	to.TaxCode = m.TaxCode
	if posthook, ok := interface{}(m).(TaxSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TaxSettings the arg will be the target, the caller the one being converted from

// TaxSettingsBeforeToORM called before default ToORM code
type TaxSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TaxSettingsORM) error
}

// TaxSettingsAfterToORM called after default ToORM code
type TaxSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *TaxSettingsORM) error
}

// TaxSettingsBeforeToPB called before default ToPB code
type TaxSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *TaxSettings) error
}

// TaxSettingsAfterToPB called after default ToPB code
type TaxSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *TaxSettings) error
}

type FinancialPreferencesORM struct {
	BusinessAccountSettingsId *uint64
	CurrencyPreference        string
	FinancialYearStart        string
	Id                        uint64
	TaxSettings               *TaxSettingsORM `gorm:"foreignkey:FinancialPreferencesId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (FinancialPreferencesORM) TableName() string {
	return "financial_preferences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FinancialPreferences) ToORM(ctx context.Context) (FinancialPreferencesORM, error) {
	to := FinancialPreferencesORM{}
	var err error
	if prehook, ok := interface{}(m).(FinancialPreferencesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CurrencyPreference = m.CurrencyPreference
	if m.TaxSettings != nil {
		tempTaxSettings, err := m.TaxSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TaxSettings = &tempTaxSettings
	}
	to.FinancialYearStart = m.FinancialYearStart
	if posthook, ok := interface{}(m).(FinancialPreferencesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FinancialPreferencesORM) ToPB(ctx context.Context) (FinancialPreferences, error) {
	to := FinancialPreferences{}
	var err error
	if prehook, ok := interface{}(m).(FinancialPreferencesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CurrencyPreference = m.CurrencyPreference
	if m.TaxSettings != nil {
		tempTaxSettings, err := m.TaxSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TaxSettings = &tempTaxSettings
	}
	to.FinancialYearStart = m.FinancialYearStart
	if posthook, ok := interface{}(m).(FinancialPreferencesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FinancialPreferences the arg will be the target, the caller the one being converted from

// FinancialPreferencesBeforeToORM called before default ToORM code
type FinancialPreferencesWithBeforeToORM interface {
	BeforeToORM(context.Context, *FinancialPreferencesORM) error
}

// FinancialPreferencesAfterToORM called after default ToORM code
type FinancialPreferencesWithAfterToORM interface {
	AfterToORM(context.Context, *FinancialPreferencesORM) error
}

// FinancialPreferencesBeforeToPB called before default ToPB code
type FinancialPreferencesWithBeforeToPB interface {
	BeforeToPB(context.Context, *FinancialPreferences) error
}

// FinancialPreferencesAfterToPB called after default ToPB code
type FinancialPreferencesWithAfterToPB interface {
	AfterToPB(context.Context, *FinancialPreferences) error
}

type AIPoweredInsightsORM struct {
	AreasOfInterest           pq.StringArray `gorm:"type:text[]"`
	BusinessAccountSettingsId *uint64
	DataSharing               bool
	Id                        uint64
	InsightFrequency          string
}

// TableName overrides the default tablename generated by GORM
func (AIPoweredInsightsORM) TableName() string {
	return "a_ipowered_insights"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AIPoweredInsights) ToORM(ctx context.Context) (AIPoweredInsightsORM, error) {
	to := AIPoweredInsightsORM{}
	var err error
	if prehook, ok := interface{}(m).(AIPoweredInsightsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightFrequency = AIPoweredInsights_Frequency_name[int32(m.InsightFrequency)]
	if m.AreasOfInterest != nil {
		to.AreasOfInterest = make(pq.StringArray, len(m.AreasOfInterest))
		copy(to.AreasOfInterest, m.AreasOfInterest)
	}
	to.DataSharing = m.DataSharing
	if posthook, ok := interface{}(m).(AIPoweredInsightsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AIPoweredInsightsORM) ToPB(ctx context.Context) (AIPoweredInsights, error) {
	to := AIPoweredInsights{}
	var err error
	if prehook, ok := interface{}(m).(AIPoweredInsightsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InsightFrequency = AIPoweredInsights_Frequency(AIPoweredInsights_Frequency_value[m.InsightFrequency])
	if m.AreasOfInterest != nil {
		to.AreasOfInterest = make(pq.StringArray, len(m.AreasOfInterest))
		copy(to.AreasOfInterest, m.AreasOfInterest)
	}
	to.DataSharing = m.DataSharing
	if posthook, ok := interface{}(m).(AIPoweredInsightsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AIPoweredInsights the arg will be the target, the caller the one being converted from

// AIPoweredInsightsBeforeToORM called before default ToORM code
type AIPoweredInsightsWithBeforeToORM interface {
	BeforeToORM(context.Context, *AIPoweredInsightsORM) error
}

// AIPoweredInsightsAfterToORM called after default ToORM code
type AIPoweredInsightsWithAfterToORM interface {
	AfterToORM(context.Context, *AIPoweredInsightsORM) error
}

// AIPoweredInsightsBeforeToPB called before default ToPB code
type AIPoweredInsightsWithBeforeToPB interface {
	BeforeToPB(context.Context, *AIPoweredInsights) error
}

// AIPoweredInsightsAfterToPB called after default ToPB code
type AIPoweredInsightsWithAfterToPB interface {
	AfterToPB(context.Context, *AIPoweredInsights) error
}

type IntegrationSettingsORM struct {
	BankAccountLinking        bool
	BusinessAccountSettingsId *uint64
	Id                        uint64
	ThirdPartyApps            pq.StringArray `gorm:"type:text[]"`
}

// TableName overrides the default tablename generated by GORM
func (IntegrationSettingsORM) TableName() string {
	return "integration_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *IntegrationSettings) ToORM(ctx context.Context) (IntegrationSettingsORM, error) {
	to := IntegrationSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(IntegrationSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BankAccountLinking = m.BankAccountLinking
	if m.ThirdPartyApps != nil {
		to.ThirdPartyApps = make(pq.StringArray, len(m.ThirdPartyApps))
		copy(to.ThirdPartyApps, m.ThirdPartyApps)
	}
	if posthook, ok := interface{}(m).(IntegrationSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *IntegrationSettingsORM) ToPB(ctx context.Context) (IntegrationSettings, error) {
	to := IntegrationSettings{}
	var err error
	if prehook, ok := interface{}(m).(IntegrationSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.BankAccountLinking = m.BankAccountLinking
	if m.ThirdPartyApps != nil {
		to.ThirdPartyApps = make(pq.StringArray, len(m.ThirdPartyApps))
		copy(to.ThirdPartyApps, m.ThirdPartyApps)
	}
	if posthook, ok := interface{}(m).(IntegrationSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type IntegrationSettings the arg will be the target, the caller the one being converted from

// IntegrationSettingsBeforeToORM called before default ToORM code
type IntegrationSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *IntegrationSettingsORM) error
}

// IntegrationSettingsAfterToORM called after default ToORM code
type IntegrationSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *IntegrationSettingsORM) error
}

// IntegrationSettingsBeforeToPB called before default ToPB code
type IntegrationSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *IntegrationSettings) error
}

// IntegrationSettingsAfterToPB called after default ToPB code
type IntegrationSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *IntegrationSettings) error
}

type NotificationSettingsORM struct {
	Alerts                    bool
	BusinessAccountSettingsId *uint64
	Id                        uint64
	NotificationType          string
}

// TableName overrides the default tablename generated by GORM
func (NotificationSettingsORM) TableName() string {
	return "notification_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationSettings) ToORM(ctx context.Context) (NotificationSettingsORM, error) {
	to := NotificationSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NotificationType = NotificationSettings_Type_name[int32(m.NotificationType)]
	to.Alerts = m.Alerts
	if posthook, ok := interface{}(m).(NotificationSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationSettingsORM) ToPB(ctx context.Context) (NotificationSettings, error) {
	to := NotificationSettings{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NotificationType = NotificationSettings_Type(NotificationSettings_Type_value[m.NotificationType])
	to.Alerts = m.Alerts
	if posthook, ok := interface{}(m).(NotificationSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationSettings the arg will be the target, the caller the one being converted from

// NotificationSettingsBeforeToORM called before default ToORM code
type NotificationSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationSettingsORM) error
}

// NotificationSettingsAfterToORM called after default ToORM code
type NotificationSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationSettingsORM) error
}

// NotificationSettingsBeforeToPB called before default ToPB code
type NotificationSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationSettings) error
}

// NotificationSettingsAfterToPB called after default ToPB code
type NotificationSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationSettings) error
}

type BusinessAccountSettingsORM struct {
	AccountInformation   *AccountInformationORM   `gorm:"foreignkey:BusinessAccountSettingsId;association_foreignkey:Id;preload:true"`
	AiPoweredInsights    *AIPoweredInsightsORM    `gorm:"foreignkey:BusinessAccountSettingsId;association_foreignkey:Id;preload:true"`
	FinancialPreferences *FinancialPreferencesORM `gorm:"foreignkey:BusinessAccountSettingsId;association_foreignkey:Id"`
	Id                   uint64
	IntegrationSettings  *IntegrationSettingsORM  `gorm:"foreignkey:BusinessAccountSettingsId;association_foreignkey:Id;preload:true"`
	NotificationSettings *NotificationSettingsORM `gorm:"foreignkey:BusinessAccountSettingsId;association_foreignkey:Id;preload:true"`
	UserAccountId        *uint64
}

// TableName overrides the default tablename generated by GORM
func (BusinessAccountSettingsORM) TableName() string {
	return "business_account_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessAccountSettings) ToORM(ctx context.Context) (BusinessAccountSettingsORM, error) {
	to := BusinessAccountSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.AccountInformation != nil {
		tempAccountInformation, err := m.AccountInformation.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.AccountInformation = &tempAccountInformation
	}
	if m.FinancialPreferences != nil {
		tempFinancialPreferences, err := m.FinancialPreferences.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FinancialPreferences = &tempFinancialPreferences
	}
	if m.AiPoweredInsights != nil {
		tempAiPoweredInsights, err := m.AiPoweredInsights.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.AiPoweredInsights = &tempAiPoweredInsights
	}
	if m.IntegrationSettings != nil {
		tempIntegrationSettings, err := m.IntegrationSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.IntegrationSettings = &tempIntegrationSettings
	}
	if m.NotificationSettings != nil {
		tempNotificationSettings, err := m.NotificationSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSettings = &tempNotificationSettings
	}
	if posthook, ok := interface{}(m).(BusinessAccountSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessAccountSettingsORM) ToPB(ctx context.Context) (BusinessAccountSettings, error) {
	to := BusinessAccountSettings{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.AccountInformation != nil {
		tempAccountInformation, err := m.AccountInformation.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.AccountInformation = &tempAccountInformation
	}
	if m.FinancialPreferences != nil {
		tempFinancialPreferences, err := m.FinancialPreferences.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FinancialPreferences = &tempFinancialPreferences
	}
	if m.AiPoweredInsights != nil {
		tempAiPoweredInsights, err := m.AiPoweredInsights.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.AiPoweredInsights = &tempAiPoweredInsights
	}
	if m.IntegrationSettings != nil {
		tempIntegrationSettings, err := m.IntegrationSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.IntegrationSettings = &tempIntegrationSettings
	}
	if m.NotificationSettings != nil {
		tempNotificationSettings, err := m.NotificationSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSettings = &tempNotificationSettings
	}
	if posthook, ok := interface{}(m).(BusinessAccountSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessAccountSettings the arg will be the target, the caller the one being converted from

// BusinessAccountSettingsBeforeToORM called before default ToORM code
type BusinessAccountSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessAccountSettingsORM) error
}

// BusinessAccountSettingsAfterToORM called after default ToORM code
type BusinessAccountSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessAccountSettingsORM) error
}

// BusinessAccountSettingsBeforeToPB called before default ToPB code
type BusinessAccountSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessAccountSettings) error
}

// BusinessAccountSettingsAfterToPB called after default ToPB code
type BusinessAccountSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessAccountSettings) error
}

// DefaultCreateUserAccount executes a basic gorm create call
func DefaultCreateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccountSet(ctx context.Context, in []*UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserAccount, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserAccount, *gorm.DB) error
}

// DefaultStrictUpdateUserAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.UserAccountId = new(uint64)
	*filterAddress.UserAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterBusinessAccountSettings := BusinessAccountSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBusinessAccountSettings.UserAccountId = new(uint64)
	*filterBusinessAccountSettings.UserAccountId = ormObj.Id
	if err = db.Where(filterBusinessAccountSettings).Delete(BusinessAccountSettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.UserAccountId = new(uint64)
	*filterTags.UserAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	filterUserSettings := UserSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterUserSettings.UserAccountId = new(uint64)
	*filterUserSettings.UserAccountId = ormObj.Id
	if err = db.Where(filterUserSettings).Delete(UserSettingsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserAccount executes a basic gorm update call with patch behavior
func DefaultPatchUserAccount(ctx context.Context, in *UserAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserAccount
	var err error
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserAccount(ctx, &UserAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserAccount(ctx context.Context, objects []*UserAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserAccount(ctx context.Context, patchee *UserAccount, patcher *UserAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedCreatedAt bool
	var updatedVerifiedAt bool
	var updatedUserSettings bool
	var updatedBusinessAccountSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Firstname" {
			patchee.Firstname = patcher.Firstname
			continue
		}
		if f == prefix+"Lastname" {
			patchee.Lastname = patcher.Lastname
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"IsPrivate" {
			patchee.IsPrivate = patcher.IsPrivate
			continue
		}
		if f == prefix+"IsEmailVerified" {
			patchee.IsEmailVerified = patcher.IsEmailVerified
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedVerifiedAt && strings.HasPrefix(f, prefix+"VerifiedAt.") {
			if patcher.VerifiedAt == nil {
				patchee.VerifiedAt = nil
				continue
			}
			if patchee.VerifiedAt == nil {
				patchee.VerifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"VerifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.VerifiedAt, patchee.VerifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"VerifiedAt" {
			updatedVerifiedAt = true
			patchee.VerifiedAt = patcher.VerifiedAt
			continue
		}
		if f == prefix+"IsBusinessAccount" {
			patchee.IsBusinessAccount = patcher.IsBusinessAccount
			continue
		}
		if f == prefix+"CompanyEstablishedDate" {
			patchee.CompanyEstablishedDate = patcher.CompanyEstablishedDate
			continue
		}
		if f == prefix+"CompanyIndustryType" {
			patchee.CompanyIndustryType = patcher.CompanyIndustryType
			continue
		}
		if f == prefix+"CompanyWebsiteUrl" {
			patchee.CompanyWebsiteUrl = patcher.CompanyWebsiteUrl
			continue
		}
		if f == prefix+"CompanyDescription" {
			patchee.CompanyDescription = patcher.CompanyDescription
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if !updatedUserSettings && strings.HasPrefix(f, prefix+"UserSettings.") {
			updatedUserSettings = true
			if patcher.UserSettings == nil {
				patchee.UserSettings = nil
				continue
			}
			if patchee.UserSettings == nil {
				patchee.UserSettings = &UserSettings{}
			}
			if o, err := DefaultApplyFieldMaskUserSettings(ctx, patchee.UserSettings, patcher.UserSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"UserSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.UserSettings = o
			}
			continue
		}
		if f == prefix+"UserSettings" {
			updatedUserSettings = true
			patchee.UserSettings = patcher.UserSettings
			continue
		}
		if !updatedBusinessAccountSettings && strings.HasPrefix(f, prefix+"BusinessAccountSettings.") {
			updatedBusinessAccountSettings = true
			if patcher.BusinessAccountSettings == nil {
				patchee.BusinessAccountSettings = nil
				continue
			}
			if patchee.BusinessAccountSettings == nil {
				patchee.BusinessAccountSettings = &BusinessAccountSettings{}
			}
			if o, err := DefaultApplyFieldMaskBusinessAccountSettings(ctx, patchee.BusinessAccountSettings, patcher.BusinessAccountSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BusinessAccountSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.BusinessAccountSettings = o
			}
			continue
		}
		if f == prefix+"BusinessAccountSettings" {
			updatedBusinessAccountSettings = true
			patchee.BusinessAccountSettings = patcher.BusinessAccountSettings
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserAccount executes a gorm list call
func DefaultListUserAccount(ctx context.Context, db *gorm.DB) ([]*UserAccount, error) {
	in := UserAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserAccountORM{}, &UserAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserAccountORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Unit" {
			patchee.Unit = patcher.Unit
			continue
		}
		if f == prefix+"Zipcode" {
			patchee.Zipcode = patcher.Zipcode
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Lattitude" {
			patchee.Lattitude = patcher.Lattitude
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateTags executes a basic gorm create call
func DefaultCreateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TagsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTags(ctx context.Context, in *Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TagsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTagsSet(ctx context.Context, in []*Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tags, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tags, *gorm.DB) error
}

// DefaultStrictUpdateTags clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTags")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TagsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTags executes a basic gorm update call with patch behavior
func DefaultPatchTags(ctx context.Context, in *Tags, updateMask *field_mask.FieldMask, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Tags
	var err error
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTags(ctx, &Tags{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTags(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTags(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTags executes a bulk gorm update call with patch behavior
func DefaultPatchSetTags(ctx context.Context, objects []*Tags, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Tags, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tags, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTags(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTags patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTags(ctx context.Context, patchee *Tags, patcher *Tags, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tags, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TagName" {
			patchee.TagName = patcher.TagName
			continue
		}
		if f == prefix+"TagDescription" {
			patchee.TagDescription = patcher.TagDescription
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTags executes a gorm list call
func DefaultListTags(ctx context.Context, db *gorm.DB) ([]*Tags, error) {
	in := Tags{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TagsORM{}, &Tags{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tags{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TagsORM) error
}

// DefaultCreateUserSettings executes a basic gorm create call
func DefaultCreateUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSettingsSet(ctx context.Context, in []*UserSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserSettingsORM{})).(UserSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserSettingsORM{})).(UserSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserSettings, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserSettings, *gorm.DB) error
}

// DefaultStrictUpdateUserSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserSettings executes a basic gorm update call with patch behavior
func DefaultPatchUserSettings(ctx context.Context, in *UserSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserSettings
	var err error
	if hook, ok := interface{}(&pbObj).(UserSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserSettings(ctx, &UserSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserSettings(ctx context.Context, objects []*UserSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserSettings(ctx context.Context, patchee *UserSettings, patcher *UserSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppTheme" {
			patchee.AppTheme = patcher.AppTheme
			continue
		}
		if f == prefix+"EmailNotifications" {
			patchee.EmailNotifications = patcher.EmailNotifications
			continue
		}
		if f == prefix+"PushNotifications" {
			patchee.PushNotifications = patcher.PushNotifications
			continue
		}
		if f == prefix+"SmsNotifications" {
			patchee.SmsNotifications = patcher.SmsNotifications
			continue
		}
		if f == prefix+"DefaultCurrency" {
			patchee.DefaultCurrency = patcher.DefaultCurrency
			continue
		}
		if f == prefix+"DatetimeFormat" {
			patchee.DatetimeFormat = patcher.DatetimeFormat
			continue
		}
		if f == prefix+"TwoFactorAuthenticationEnabled" {
			patchee.TwoFactorAuthenticationEnabled = patcher.TwoFactorAuthenticationEnabled
			continue
		}
		if f == prefix+"PreferredLanguage" {
			patchee.PreferredLanguage = patcher.PreferredLanguage
			continue
		}
		if f == prefix+"PublicProfile" {
			patchee.PublicProfile = patcher.PublicProfile
			continue
		}
		if f == prefix+"EnableGoalJournal" {
			patchee.EnableGoalJournal = patcher.EnableGoalJournal
			continue
		}
		if f == prefix+"InvestmentRiskTolerance" {
			patchee.InvestmentRiskTolerance = patcher.InvestmentRiskTolerance
			continue
		}
		if f == prefix+"DashboardWidgets" {
			patchee.DashboardWidgets = patcher.DashboardWidgets
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserSettings executes a gorm list call
func DefaultListUserSettings(ctx context.Context, db *gorm.DB) ([]*UserSettings, error) {
	in := UserSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserSettingsORM{}, &UserSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserSettingsORM) error
}

// DefaultCreateContactInformation executes a basic gorm create call
func DefaultCreateContactInformation(ctx context.Context, in *ContactInformation, db *gorm.DB) (*ContactInformation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ContactInformationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadContactInformation(ctx context.Context, in *ContactInformation, db *gorm.DB) (*ContactInformation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ContactInformationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ContactInformationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ContactInformationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ContactInformationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteContactInformation(ctx context.Context, in *ContactInformation, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ContactInformationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ContactInformationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteContactInformationSet(ctx context.Context, in []*ContactInformation, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ContactInformationORM{})).(ContactInformationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ContactInformationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ContactInformationORM{})).(ContactInformationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ContactInformationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ContactInformation, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ContactInformation, *gorm.DB) error
}

// DefaultStrictUpdateContactInformation clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateContactInformation(ctx context.Context, in *ContactInformation, db *gorm.DB) (*ContactInformation, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateContactInformation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ContactInformationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ContactInformationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchContactInformation executes a basic gorm update call with patch behavior
func DefaultPatchContactInformation(ctx context.Context, in *ContactInformation, updateMask *field_mask.FieldMask, db *gorm.DB) (*ContactInformation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ContactInformation
	var err error
	if hook, ok := interface{}(&pbObj).(ContactInformationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadContactInformation(ctx, &ContactInformation{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ContactInformationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskContactInformation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ContactInformationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateContactInformation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ContactInformationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ContactInformationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ContactInformation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ContactInformation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ContactInformation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ContactInformation, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetContactInformation executes a bulk gorm update call with patch behavior
func DefaultPatchSetContactInformation(ctx context.Context, objects []*ContactInformation, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ContactInformation, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ContactInformation, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchContactInformation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskContactInformation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskContactInformation(ctx context.Context, patchee *ContactInformation, patcher *ContactInformation, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ContactInformation, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListContactInformation executes a gorm list call
func DefaultListContactInformation(ctx context.Context, db *gorm.DB) ([]*ContactInformation, error) {
	in := ContactInformation{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ContactInformationORM{}, &ContactInformation{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ContactInformationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ContactInformationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ContactInformation{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ContactInformationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ContactInformationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ContactInformationORM) error
}

// DefaultCreateAccountInformation executes a basic gorm create call
func DefaultCreateAccountInformation(ctx context.Context, in *AccountInformation, db *gorm.DB) (*AccountInformation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AccountInformationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAccountInformation(ctx context.Context, in *AccountInformation, db *gorm.DB) (*AccountInformation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AccountInformationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AccountInformationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AccountInformationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AccountInformationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountInformation(ctx context.Context, in *AccountInformation, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AccountInformationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AccountInformationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAccountInformationSet(ctx context.Context, in []*AccountInformation, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AccountInformationORM{})).(AccountInformationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AccountInformationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AccountInformationORM{})).(AccountInformationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AccountInformationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AccountInformation, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AccountInformation, *gorm.DB) error
}

// DefaultStrictUpdateAccountInformation clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAccountInformation(ctx context.Context, in *AccountInformation, db *gorm.DB) (*AccountInformation, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAccountInformation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AccountInformationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterContactInfo := ContactInformationORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterContactInfo.AccountInformationId = new(uint64)
	*filterContactInfo.AccountInformationId = ormObj.Id
	if err = db.Where(filterContactInfo).Delete(ContactInformationORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AccountInformationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAccountInformation executes a basic gorm update call with patch behavior
func DefaultPatchAccountInformation(ctx context.Context, in *AccountInformation, updateMask *field_mask.FieldMask, db *gorm.DB) (*AccountInformation, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AccountInformation
	var err error
	if hook, ok := interface{}(&pbObj).(AccountInformationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAccountInformation(ctx, &AccountInformation{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AccountInformationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAccountInformation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AccountInformationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAccountInformation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AccountInformationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AccountInformationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AccountInformation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AccountInformation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AccountInformation, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AccountInformation, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAccountInformation executes a bulk gorm update call with patch behavior
func DefaultPatchSetAccountInformation(ctx context.Context, objects []*AccountInformation, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AccountInformation, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AccountInformation, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAccountInformation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAccountInformation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAccountInformation(ctx context.Context, patchee *AccountInformation, patcher *AccountInformation, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AccountInformation, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedContactInfo bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"BusinessName" {
			patchee.BusinessName = patcher.BusinessName
			continue
		}
		if f == prefix+"BusinessType" {
			patchee.BusinessType = patcher.BusinessType
			continue
		}
		if f == prefix+"BusinessRegistrationNumber" {
			patchee.BusinessRegistrationNumber = patcher.BusinessRegistrationNumber
			continue
		}
		if !updatedContactInfo && strings.HasPrefix(f, prefix+"ContactInfo.") {
			updatedContactInfo = true
			if patcher.ContactInfo == nil {
				patchee.ContactInfo = nil
				continue
			}
			if patchee.ContactInfo == nil {
				patchee.ContactInfo = &ContactInformation{}
			}
			if o, err := DefaultApplyFieldMaskContactInformation(ctx, patchee.ContactInfo, patcher.ContactInfo, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ContactInfo.", db); err != nil {
				return nil, err
			} else {
				patchee.ContactInfo = o
			}
			continue
		}
		if f == prefix+"ContactInfo" {
			updatedContactInfo = true
			patchee.ContactInfo = patcher.ContactInfo
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAccountInformation executes a gorm list call
func DefaultListAccountInformation(ctx context.Context, db *gorm.DB) ([]*AccountInformation, error) {
	in := AccountInformation{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AccountInformationORM{}, &AccountInformation{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AccountInformationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AccountInformationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AccountInformation{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AccountInformationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AccountInformationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AccountInformationORM) error
}

// DefaultCreateTaxSettings executes a basic gorm create call
func DefaultCreateTaxSettings(ctx context.Context, in *TaxSettings, db *gorm.DB) (*TaxSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TaxSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTaxSettings(ctx context.Context, in *TaxSettings, db *gorm.DB) (*TaxSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TaxSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TaxSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TaxSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TaxSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxSettings(ctx context.Context, in *TaxSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TaxSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TaxSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTaxSettingsSet(ctx context.Context, in []*TaxSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TaxSettingsORM{})).(TaxSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TaxSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TaxSettingsORM{})).(TaxSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TaxSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TaxSettings, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TaxSettings, *gorm.DB) error
}

// DefaultStrictUpdateTaxSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTaxSettings(ctx context.Context, in *TaxSettings, db *gorm.DB) (*TaxSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTaxSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TaxSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TaxSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTaxSettings executes a basic gorm update call with patch behavior
func DefaultPatchTaxSettings(ctx context.Context, in *TaxSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*TaxSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj TaxSettings
	var err error
	if hook, ok := interface{}(&pbObj).(TaxSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTaxSettings(ctx, &TaxSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TaxSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTaxSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TaxSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTaxSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TaxSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TaxSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TaxSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TaxSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TaxSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TaxSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTaxSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetTaxSettings(ctx context.Context, objects []*TaxSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*TaxSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TaxSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTaxSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTaxSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTaxSettings(ctx context.Context, patchee *TaxSettings, patcher *TaxSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*TaxSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TaxPercentage" {
			patchee.TaxPercentage = patcher.TaxPercentage
			continue
		}
		if f == prefix+"TaxCode" {
			patchee.TaxCode = patcher.TaxCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTaxSettings executes a gorm list call
func DefaultListTaxSettings(ctx context.Context, db *gorm.DB) ([]*TaxSettings, error) {
	in := TaxSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TaxSettingsORM{}, &TaxSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TaxSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaxSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TaxSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TaxSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaxSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TaxSettingsORM) error
}

// DefaultCreateFinancialPreferences executes a basic gorm create call
func DefaultCreateFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FinancialPreferencesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FinancialPreferencesORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FinancialPreferencesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FinancialPreferencesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FinancialPreferencesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FinancialPreferencesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FinancialPreferencesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialPreferencesSet(ctx context.Context, in []*FinancialPreferences, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FinancialPreferencesORM{})).(FinancialPreferencesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FinancialPreferencesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FinancialPreferencesORM{})).(FinancialPreferencesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FinancialPreferencesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FinancialPreferences, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FinancialPreferences, *gorm.DB) error
}

// DefaultStrictUpdateFinancialPreferences clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFinancialPreferences")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FinancialPreferencesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterTaxSettings := TaxSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTaxSettings.FinancialPreferencesId = new(uint64)
	*filterTaxSettings.FinancialPreferencesId = ormObj.Id
	if err = db.Where(filterTaxSettings).Delete(TaxSettingsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FinancialPreferencesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFinancialPreferences executes a basic gorm update call with patch behavior
func DefaultPatchFinancialPreferences(ctx context.Context, in *FinancialPreferences, updateMask *field_mask.FieldMask, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FinancialPreferences
	var err error
	if hook, ok := interface{}(&pbObj).(FinancialPreferencesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFinancialPreferences(ctx, &FinancialPreferences{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FinancialPreferencesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFinancialPreferences(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FinancialPreferencesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFinancialPreferences(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FinancialPreferencesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FinancialPreferencesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFinancialPreferences executes a bulk gorm update call with patch behavior
func DefaultPatchSetFinancialPreferences(ctx context.Context, objects []*FinancialPreferences, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FinancialPreferences, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FinancialPreferences, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFinancialPreferences(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFinancialPreferences patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFinancialPreferences(ctx context.Context, patchee *FinancialPreferences, patcher *FinancialPreferences, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FinancialPreferences, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedTaxSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CurrencyPreference" {
			patchee.CurrencyPreference = patcher.CurrencyPreference
			continue
		}
		if !updatedTaxSettings && strings.HasPrefix(f, prefix+"TaxSettings.") {
			updatedTaxSettings = true
			if patcher.TaxSettings == nil {
				patchee.TaxSettings = nil
				continue
			}
			if patchee.TaxSettings == nil {
				patchee.TaxSettings = &TaxSettings{}
			}
			if o, err := DefaultApplyFieldMaskTaxSettings(ctx, patchee.TaxSettings, patcher.TaxSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TaxSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.TaxSettings = o
			}
			continue
		}
		if f == prefix+"TaxSettings" {
			updatedTaxSettings = true
			patchee.TaxSettings = patcher.TaxSettings
			continue
		}
		if f == prefix+"FinancialYearStart" {
			patchee.FinancialYearStart = patcher.FinancialYearStart
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFinancialPreferences executes a gorm list call
func DefaultListFinancialPreferences(ctx context.Context, db *gorm.DB) ([]*FinancialPreferences, error) {
	in := FinancialPreferences{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FinancialPreferencesORM{}, &FinancialPreferences{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FinancialPreferencesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FinancialPreferences{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FinancialPreferencesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FinancialPreferencesORM) error
}

// DefaultCreateAIPoweredInsights executes a basic gorm create call
func DefaultCreateAIPoweredInsights(ctx context.Context, in *AIPoweredInsights, db *gorm.DB) (*AIPoweredInsights, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AIPoweredInsightsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAIPoweredInsights(ctx context.Context, in *AIPoweredInsights, db *gorm.DB) (*AIPoweredInsights, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AIPoweredInsightsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AIPoweredInsightsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AIPoweredInsightsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AIPoweredInsightsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAIPoweredInsights(ctx context.Context, in *AIPoweredInsights, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AIPoweredInsightsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AIPoweredInsightsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAIPoweredInsightsSet(ctx context.Context, in []*AIPoweredInsights, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AIPoweredInsightsORM{})).(AIPoweredInsightsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AIPoweredInsightsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AIPoweredInsightsORM{})).(AIPoweredInsightsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AIPoweredInsightsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AIPoweredInsights, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AIPoweredInsights, *gorm.DB) error
}

// DefaultStrictUpdateAIPoweredInsights clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAIPoweredInsights(ctx context.Context, in *AIPoweredInsights, db *gorm.DB) (*AIPoweredInsights, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAIPoweredInsights")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AIPoweredInsightsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AIPoweredInsightsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAIPoweredInsights executes a basic gorm update call with patch behavior
func DefaultPatchAIPoweredInsights(ctx context.Context, in *AIPoweredInsights, updateMask *field_mask.FieldMask, db *gorm.DB) (*AIPoweredInsights, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj AIPoweredInsights
	var err error
	if hook, ok := interface{}(&pbObj).(AIPoweredInsightsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAIPoweredInsights(ctx, &AIPoweredInsights{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AIPoweredInsightsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAIPoweredInsights(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AIPoweredInsightsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAIPoweredInsights(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AIPoweredInsightsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AIPoweredInsightsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AIPoweredInsights, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AIPoweredInsights, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AIPoweredInsights, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AIPoweredInsights, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAIPoweredInsights executes a bulk gorm update call with patch behavior
func DefaultPatchSetAIPoweredInsights(ctx context.Context, objects []*AIPoweredInsights, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*AIPoweredInsights, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AIPoweredInsights, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAIPoweredInsights(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAIPoweredInsights patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAIPoweredInsights(ctx context.Context, patchee *AIPoweredInsights, patcher *AIPoweredInsights, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*AIPoweredInsights, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"InsightFrequency" {
			patchee.InsightFrequency = patcher.InsightFrequency
			continue
		}
		if f == prefix+"AreasOfInterest" {
			patchee.AreasOfInterest = patcher.AreasOfInterest
			continue
		}
		if f == prefix+"DataSharing" {
			patchee.DataSharing = patcher.DataSharing
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAIPoweredInsights executes a gorm list call
func DefaultListAIPoweredInsights(ctx context.Context, db *gorm.DB) ([]*AIPoweredInsights, error) {
	in := AIPoweredInsights{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AIPoweredInsightsORM{}, &AIPoweredInsights{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AIPoweredInsightsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AIPoweredInsightsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AIPoweredInsights{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AIPoweredInsightsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AIPoweredInsightsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AIPoweredInsightsORM) error
}

// DefaultCreateIntegrationSettings executes a basic gorm create call
func DefaultCreateIntegrationSettings(ctx context.Context, in *IntegrationSettings, db *gorm.DB) (*IntegrationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type IntegrationSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadIntegrationSettings(ctx context.Context, in *IntegrationSettings, db *gorm.DB) (*IntegrationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &IntegrationSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := IntegrationSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(IntegrationSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type IntegrationSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteIntegrationSettings(ctx context.Context, in *IntegrationSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&IntegrationSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type IntegrationSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteIntegrationSettingsSet(ctx context.Context, in []*IntegrationSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&IntegrationSettingsORM{})).(IntegrationSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&IntegrationSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&IntegrationSettingsORM{})).(IntegrationSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type IntegrationSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*IntegrationSettings, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*IntegrationSettings, *gorm.DB) error
}

// DefaultStrictUpdateIntegrationSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateIntegrationSettings(ctx context.Context, in *IntegrationSettings, db *gorm.DB) (*IntegrationSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateIntegrationSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &IntegrationSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type IntegrationSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchIntegrationSettings executes a basic gorm update call with patch behavior
func DefaultPatchIntegrationSettings(ctx context.Context, in *IntegrationSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*IntegrationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj IntegrationSettings
	var err error
	if hook, ok := interface{}(&pbObj).(IntegrationSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadIntegrationSettings(ctx, &IntegrationSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(IntegrationSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskIntegrationSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(IntegrationSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateIntegrationSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(IntegrationSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type IntegrationSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *IntegrationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *IntegrationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *IntegrationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *IntegrationSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetIntegrationSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetIntegrationSettings(ctx context.Context, objects []*IntegrationSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*IntegrationSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*IntegrationSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchIntegrationSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskIntegrationSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskIntegrationSettings(ctx context.Context, patchee *IntegrationSettings, patcher *IntegrationSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*IntegrationSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"BankAccountLinking" {
			patchee.BankAccountLinking = patcher.BankAccountLinking
			continue
		}
		if f == prefix+"ThirdPartyApps" {
			patchee.ThirdPartyApps = patcher.ThirdPartyApps
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListIntegrationSettings executes a gorm list call
func DefaultListIntegrationSettings(ctx context.Context, db *gorm.DB) ([]*IntegrationSettings, error) {
	in := IntegrationSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &IntegrationSettingsORM{}, &IntegrationSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []IntegrationSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(IntegrationSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*IntegrationSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type IntegrationSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type IntegrationSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]IntegrationSettingsORM) error
}

// DefaultCreateNotificationSettings executes a basic gorm create call
func DefaultCreateNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSettingsSet(ctx context.Context, in []*NotificationSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationSettingsORM{})).(NotificationSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NotificationSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationSettingsORM{})).(NotificationSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationSettings, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationSettings, *gorm.DB) error
}

// DefaultStrictUpdateNotificationSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationSettings executes a basic gorm update call with patch behavior
func DefaultPatchNotificationSettings(ctx context.Context, in *NotificationSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationSettings
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotificationSettings(ctx, &NotificationSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationSettings(ctx context.Context, objects []*NotificationSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationSettings(ctx context.Context, patchee *NotificationSettings, patcher *NotificationSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"NotificationType" {
			patchee.NotificationType = patcher.NotificationType
			continue
		}
		if f == prefix+"Alerts" {
			patchee.Alerts = patcher.Alerts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationSettings executes a gorm list call
func DefaultListNotificationSettings(ctx context.Context, db *gorm.DB) ([]*NotificationSettings, error) {
	in := NotificationSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationSettingsORM{}, &NotificationSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationSettingsORM) error
}

// DefaultCreateBusinessAccountSettings executes a basic gorm create call
func DefaultCreateBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessAccountSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessAccountSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessAccountSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessAccountSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessAccountSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountSettingsSet(ctx context.Context, in []*BusinessAccountSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessAccountSettingsORM{})).(BusinessAccountSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessAccountSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessAccountSettingsORM{})).(BusinessAccountSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessAccountSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessAccountSettings, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessAccountSettings, *gorm.DB) error
}

// DefaultStrictUpdateBusinessAccountSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessAccountSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessAccountSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAccountInformation := AccountInformationORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAccountInformation.BusinessAccountSettingsId = new(uint64)
	*filterAccountInformation.BusinessAccountSettingsId = ormObj.Id
	if err = db.Where(filterAccountInformation).Delete(AccountInformationORM{}).Error; err != nil {
		return nil, err
	}
	filterAiPoweredInsights := AIPoweredInsightsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAiPoweredInsights.BusinessAccountSettingsId = new(uint64)
	*filterAiPoweredInsights.BusinessAccountSettingsId = ormObj.Id
	if err = db.Where(filterAiPoweredInsights).Delete(AIPoweredInsightsORM{}).Error; err != nil {
		return nil, err
	}
	filterFinancialPreferences := FinancialPreferencesORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFinancialPreferences.BusinessAccountSettingsId = new(uint64)
	*filterFinancialPreferences.BusinessAccountSettingsId = ormObj.Id
	if err = db.Where(filterFinancialPreferences).Delete(FinancialPreferencesORM{}).Error; err != nil {
		return nil, err
	}
	filterIntegrationSettings := IntegrationSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterIntegrationSettings.BusinessAccountSettingsId = new(uint64)
	*filterIntegrationSettings.BusinessAccountSettingsId = ormObj.Id
	if err = db.Where(filterIntegrationSettings).Delete(IntegrationSettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterNotificationSettings := NotificationSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationSettings.BusinessAccountSettingsId = new(uint64)
	*filterNotificationSettings.BusinessAccountSettingsId = ormObj.Id
	if err = db.Where(filterNotificationSettings).Delete(NotificationSettingsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessAccountSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessAccountSettings executes a basic gorm update call with patch behavior
func DefaultPatchBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessAccountSettings
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessAccountSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessAccountSettings(ctx, &BusinessAccountSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessAccountSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessAccountSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessAccountSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessAccountSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessAccountSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessAccountSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessAccountSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessAccountSettings(ctx context.Context, objects []*BusinessAccountSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessAccountSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessAccountSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessAccountSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessAccountSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessAccountSettings(ctx context.Context, patchee *BusinessAccountSettings, patcher *BusinessAccountSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessAccountSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAccountInformation bool
	var updatedFinancialPreferences bool
	var updatedAiPoweredInsights bool
	var updatedIntegrationSettings bool
	var updatedNotificationSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedAccountInformation && strings.HasPrefix(f, prefix+"AccountInformation.") {
			updatedAccountInformation = true
			if patcher.AccountInformation == nil {
				patchee.AccountInformation = nil
				continue
			}
			if patchee.AccountInformation == nil {
				patchee.AccountInformation = &AccountInformation{}
			}
			if o, err := DefaultApplyFieldMaskAccountInformation(ctx, patchee.AccountInformation, patcher.AccountInformation, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"AccountInformation.", db); err != nil {
				return nil, err
			} else {
				patchee.AccountInformation = o
			}
			continue
		}
		if f == prefix+"AccountInformation" {
			updatedAccountInformation = true
			patchee.AccountInformation = patcher.AccountInformation
			continue
		}
		if !updatedFinancialPreferences && strings.HasPrefix(f, prefix+"FinancialPreferences.") {
			updatedFinancialPreferences = true
			if patcher.FinancialPreferences == nil {
				patchee.FinancialPreferences = nil
				continue
			}
			if patchee.FinancialPreferences == nil {
				patchee.FinancialPreferences = &FinancialPreferences{}
			}
			if o, err := DefaultApplyFieldMaskFinancialPreferences(ctx, patchee.FinancialPreferences, patcher.FinancialPreferences, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FinancialPreferences.", db); err != nil {
				return nil, err
			} else {
				patchee.FinancialPreferences = o
			}
			continue
		}
		if f == prefix+"FinancialPreferences" {
			updatedFinancialPreferences = true
			patchee.FinancialPreferences = patcher.FinancialPreferences
			continue
		}
		if !updatedAiPoweredInsights && strings.HasPrefix(f, prefix+"AiPoweredInsights.") {
			updatedAiPoweredInsights = true
			if patcher.AiPoweredInsights == nil {
				patchee.AiPoweredInsights = nil
				continue
			}
			if patchee.AiPoweredInsights == nil {
				patchee.AiPoweredInsights = &AIPoweredInsights{}
			}
			if o, err := DefaultApplyFieldMaskAIPoweredInsights(ctx, patchee.AiPoweredInsights, patcher.AiPoweredInsights, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"AiPoweredInsights.", db); err != nil {
				return nil, err
			} else {
				patchee.AiPoweredInsights = o
			}
			continue
		}
		if f == prefix+"AiPoweredInsights" {
			updatedAiPoweredInsights = true
			patchee.AiPoweredInsights = patcher.AiPoweredInsights
			continue
		}
		if !updatedIntegrationSettings && strings.HasPrefix(f, prefix+"IntegrationSettings.") {
			updatedIntegrationSettings = true
			if patcher.IntegrationSettings == nil {
				patchee.IntegrationSettings = nil
				continue
			}
			if patchee.IntegrationSettings == nil {
				patchee.IntegrationSettings = &IntegrationSettings{}
			}
			if o, err := DefaultApplyFieldMaskIntegrationSettings(ctx, patchee.IntegrationSettings, patcher.IntegrationSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"IntegrationSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.IntegrationSettings = o
			}
			continue
		}
		if f == prefix+"IntegrationSettings" {
			updatedIntegrationSettings = true
			patchee.IntegrationSettings = patcher.IntegrationSettings
			continue
		}
		if !updatedNotificationSettings && strings.HasPrefix(f, prefix+"NotificationSettings.") {
			updatedNotificationSettings = true
			if patcher.NotificationSettings == nil {
				patchee.NotificationSettings = nil
				continue
			}
			if patchee.NotificationSettings == nil {
				patchee.NotificationSettings = &NotificationSettings{}
			}
			if o, err := DefaultApplyFieldMaskNotificationSettings(ctx, patchee.NotificationSettings, patcher.NotificationSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationSettings = o
			}
			continue
		}
		if f == prefix+"NotificationSettings" {
			updatedNotificationSettings = true
			patchee.NotificationSettings = patcher.NotificationSettings
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessAccountSettings executes a gorm list call
func DefaultListBusinessAccountSettings(ctx context.Context, db *gorm.DB) ([]*BusinessAccountSettings, error) {
	in := BusinessAccountSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessAccountSettingsORM{}, &BusinessAccountSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessAccountSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessAccountSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessAccountSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessAccountSettingsORM) error
}
