package user_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type UserAccountORM struct {
	AccountType     string
	Address         *AddressORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id"`
	Auth0UserId     string      `gorm:"unique_index:idx_user_auth0_user_id"`
	AuthnAccountId  uint64
	Bio             string
	CreatedAt       *time.Time
	Email           string `gorm:"unique_index:idx_user_email"`
	Firstname       string
	Headline        string
	Id              uint64 `gorm:"unique_index:idx_user_id"`
	IsActive        bool
	IsEmailVerified bool
	IsPrivate       bool
	Lastname        string
	PhoneNumber     string
	ProfileImageUrl string
	Role            *RoleORM     `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	Settings        *SettingsORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id"`
	Tags            []*TagsORM   `gorm:"foreignkey:UserAccountId;association_foreignkey:Id"`
	Username        string       `gorm:"unique_index:idx_user_username"`
	VerifiedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (UserAccountORM) TableName() string {
	return "user_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserAccount) ToORM(ctx context.Context) (UserAccountORM, error) {
	to := UserAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.VerifiedAt != nil {
		t := m.VerifiedAt.AsTime()
		to.VerifiedAt = &t
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType_name[int32(m.AccountType)]
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	if m.Role != nil {
		tempRole, err := m.Role.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Role = &tempRole
	}
	if posthook, ok := interface{}(m).(UserAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserAccountORM) ToPB(ctx context.Context) (UserAccount, error) {
	to := UserAccount{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.VerifiedAt != nil {
		to.VerifiedAt = timestamppb.New(*m.VerifiedAt)
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType(ProfileType_value[m.AccountType])
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	if m.Role != nil {
		tempRole, err := m.Role.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Role = &tempRole
	}
	if posthook, ok := interface{}(m).(UserAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserAccount the arg will be the target, the caller the one being converted from

// UserAccountBeforeToORM called before default ToORM code
type UserAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserAccountORM) error
}

// UserAccountAfterToORM called after default ToORM code
type UserAccountWithAfterToORM interface {
	AfterToORM(context.Context, *UserAccountORM) error
}

// UserAccountBeforeToPB called before default ToPB code
type UserAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserAccount) error
}

// UserAccountAfterToPB called after default ToPB code
type UserAccountWithAfterToPB interface {
	AfterToPB(context.Context, *UserAccount) error
}

type BusinessAccountORM struct {
	AccountType            string
	Address                *AddressORM `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	Auth0UserId            string      `gorm:"unique_index:auth0_user_id"`
	AuthnAccountId         uint64
	Bio                    string
	CompanyDescription     string
	CompanyEstablishedDate string
	CompanyIndustryType    string
	CompanyName            string
	CompanyWebsiteUrl      string
	CreatedAt              *time.Time
	Email                  string `gorm:"unique_index:idx_business_email"`
	Headline               string
	Id                     uint64 `gorm:"unique_index:idx_business_id"`
	IsActive               bool
	IsEmailVerified        bool
	IsPrivate              bool
	PhoneNumber            string
	ProfileImageUrl        string
	Role                   *RoleORM     `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	Settings               *SettingsORM `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	Tags                   []*TagsORM   `gorm:"foreignkey:BusinessAccountId;association_foreignkey:Id;preload:true"`
	Username               string       `gorm:"unique_index:idx_business_username"`
	VerifiedAt             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (BusinessAccountORM) TableName() string {
	return "business_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessAccount) ToORM(ctx context.Context) (BusinessAccountORM, error) {
	to := BusinessAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.VerifiedAt != nil {
		t := m.VerifiedAt.AsTime()
		to.VerifiedAt = &t
	}
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType_name[int32(m.AccountType)]
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	if m.Role != nil {
		tempRole, err := m.Role.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Role = &tempRole
	}
	if posthook, ok := interface{}(m).(BusinessAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessAccountORM) ToPB(ctx context.Context) (BusinessAccount, error) {
	to := BusinessAccount{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.VerifiedAt != nil {
		to.VerifiedAt = timestamppb.New(*m.VerifiedAt)
	}
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	to.AccountType = ProfileType(ProfileType_value[m.AccountType])
	to.ProfileImageUrl = m.ProfileImageUrl
	to.Auth0UserId = m.Auth0UserId
	if m.Role != nil {
		tempRole, err := m.Role.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Role = &tempRole
	}
	if posthook, ok := interface{}(m).(BusinessAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessAccount the arg will be the target, the caller the one being converted from

// BusinessAccountBeforeToORM called before default ToORM code
type BusinessAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessAccountORM) error
}

// BusinessAccountAfterToORM called after default ToORM code
type BusinessAccountWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessAccountORM) error
}

// BusinessAccountBeforeToPB called before default ToPB code
type BusinessAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessAccount) error
}

// BusinessAccountAfterToPB called after default ToPB code
type BusinessAccountWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessAccount) error
}

type AddressORM struct {
	Address           string
	BusinessAccountId *uint64
	City              string
	Id                uint64 `gorm:"unique_index:idx_address_id"`
	Lattitude         string
	Longitude         string
	State             string
	Unit              string
	UserAccountId     *uint64
	Zipcode           string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type TagsORM struct {
	BusinessAccountId *uint64
	Id                uint64         `gorm:"unique_index:idx_tags_id"`
	Metadata          pq.StringArray `gorm:"type:text[]"`
	TagDescription    string
	TagName           string
	UserAccountId     *uint64
}

// TableName overrides the default tablename generated by GORM
func (TagsORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tags) ToORM(ctx context.Context) (TagsORM, error) {
	to := TagsORM{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagsORM) ToPB(ctx context.Context) (Tags, error) {
	to := Tags{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tags the arg will be the target, the caller the one being converted from

// TagsBeforeToORM called before default ToORM code
type TagsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagsORM) error
}

// TagsAfterToORM called after default ToORM code
type TagsWithAfterToORM interface {
	AfterToORM(context.Context, *TagsORM) error
}

// TagsBeforeToPB called before default ToPB code
type TagsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tags) error
}

// TagsAfterToPB called after default ToPB code
type TagsWithAfterToPB interface {
	AfterToPB(context.Context, *Tags) error
}

// DefaultCreateUserAccount executes a basic gorm create call
func DefaultCreateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccountSet(ctx context.Context, in []*UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserAccount, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserAccount, *gorm.DB) error
}

// DefaultStrictUpdateUserAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.UserAccountId = new(uint64)
	*filterAddress.UserAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterRole := RoleORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRole.UserAccountId = new(uint64)
	*filterRole.UserAccountId = ormObj.Id
	if err = db.Where(filterRole).Delete(RoleORM{}).Error; err != nil {
		return nil, err
	}
	filterSettings := SettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSettings.UserAccountId = new(uint64)
	*filterSettings.UserAccountId = ormObj.Id
	if err = db.Where(filterSettings).Delete(SettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.UserAccountId = new(uint64)
	*filterTags.UserAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserAccount executes a basic gorm update call with patch behavior
func DefaultPatchUserAccount(ctx context.Context, in *UserAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserAccount
	var err error
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserAccount(ctx, &UserAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserAccount(ctx context.Context, objects []*UserAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserAccount(ctx context.Context, patchee *UserAccount, patcher *UserAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedCreatedAt bool
	var updatedVerifiedAt bool
	var updatedSettings bool
	var updatedRole bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Firstname" {
			patchee.Firstname = patcher.Firstname
			continue
		}
		if f == prefix+"Lastname" {
			patchee.Lastname = patcher.Lastname
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"IsPrivate" {
			patchee.IsPrivate = patcher.IsPrivate
			continue
		}
		if f == prefix+"IsEmailVerified" {
			patchee.IsEmailVerified = patcher.IsEmailVerified
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedVerifiedAt && strings.HasPrefix(f, prefix+"VerifiedAt.") {
			if patcher.VerifiedAt == nil {
				patchee.VerifiedAt = nil
				continue
			}
			if patchee.VerifiedAt == nil {
				patchee.VerifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"VerifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.VerifiedAt, patchee.VerifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"VerifiedAt" {
			updatedVerifiedAt = true
			patchee.VerifiedAt = patcher.VerifiedAt
			continue
		}
		if !updatedSettings && strings.HasPrefix(f, prefix+"Settings.") {
			updatedSettings = true
			if patcher.Settings == nil {
				patchee.Settings = nil
				continue
			}
			if patchee.Settings == nil {
				patchee.Settings = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.Settings, patcher.Settings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Settings.", db); err != nil {
				return nil, err
			} else {
				patchee.Settings = o
			}
			continue
		}
		if f == prefix+"Settings" {
			updatedSettings = true
			patchee.Settings = patcher.Settings
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"ProfileImageUrl" {
			patchee.ProfileImageUrl = patcher.ProfileImageUrl
			continue
		}
		if f == prefix+"Auth0UserId" {
			patchee.Auth0UserId = patcher.Auth0UserId
			continue
		}
		if !updatedRole && strings.HasPrefix(f, prefix+"Role.") {
			updatedRole = true
			if patcher.Role == nil {
				patchee.Role = nil
				continue
			}
			if patchee.Role == nil {
				patchee.Role = &Role{}
			}
			if o, err := DefaultApplyFieldMaskRole(ctx, patchee.Role, patcher.Role, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Role.", db); err != nil {
				return nil, err
			} else {
				patchee.Role = o
			}
			continue
		}
		if f == prefix+"Role" {
			updatedRole = true
			patchee.Role = patcher.Role
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserAccount executes a gorm list call
func DefaultListUserAccount(ctx context.Context, db *gorm.DB) ([]*UserAccount, error) {
	in := UserAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserAccountORM{}, &UserAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserAccountORM) error
}

// DefaultCreateBusinessAccount executes a basic gorm create call
func DefaultCreateBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountSet(ctx context.Context, in []*BusinessAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessAccountORM{})).(BusinessAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessAccountORM{})).(BusinessAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessAccount, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessAccount, *gorm.DB) error
}

// DefaultStrictUpdateBusinessAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessAccount(ctx context.Context, in *BusinessAccount, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.BusinessAccountId = new(uint64)
	*filterAddress.BusinessAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterRole := RoleORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterRole.BusinessAccountId = new(uint64)
	*filterRole.BusinessAccountId = ormObj.Id
	if err = db.Where(filterRole).Delete(RoleORM{}).Error; err != nil {
		return nil, err
	}
	filterSettings := SettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterSettings.BusinessAccountId = new(uint64)
	*filterSettings.BusinessAccountId = ormObj.Id
	if err = db.Where(filterSettings).Delete(SettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.BusinessAccountId = new(uint64)
	*filterTags.BusinessAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessAccount executes a basic gorm update call with patch behavior
func DefaultPatchBusinessAccount(ctx context.Context, in *BusinessAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessAccount
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessAccount(ctx, &BusinessAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessAccount(ctx context.Context, objects []*BusinessAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessAccount(ctx context.Context, patchee *BusinessAccount, patcher *BusinessAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedCreatedAt bool
	var updatedVerifiedAt bool
	var updatedSettings bool
	var updatedRole bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"IsPrivate" {
			patchee.IsPrivate = patcher.IsPrivate
			continue
		}
		if f == prefix+"IsEmailVerified" {
			patchee.IsEmailVerified = patcher.IsEmailVerified
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedVerifiedAt && strings.HasPrefix(f, prefix+"VerifiedAt.") {
			if patcher.VerifiedAt == nil {
				patchee.VerifiedAt = nil
				continue
			}
			if patchee.VerifiedAt == nil {
				patchee.VerifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"VerifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.VerifiedAt, patchee.VerifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"VerifiedAt" {
			updatedVerifiedAt = true
			patchee.VerifiedAt = patcher.VerifiedAt
			continue
		}
		if f == prefix+"CompanyEstablishedDate" {
			patchee.CompanyEstablishedDate = patcher.CompanyEstablishedDate
			continue
		}
		if f == prefix+"CompanyIndustryType" {
			patchee.CompanyIndustryType = patcher.CompanyIndustryType
			continue
		}
		if f == prefix+"CompanyWebsiteUrl" {
			patchee.CompanyWebsiteUrl = patcher.CompanyWebsiteUrl
			continue
		}
		if f == prefix+"CompanyDescription" {
			patchee.CompanyDescription = patcher.CompanyDescription
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if !updatedSettings && strings.HasPrefix(f, prefix+"Settings.") {
			updatedSettings = true
			if patcher.Settings == nil {
				patchee.Settings = nil
				continue
			}
			if patchee.Settings == nil {
				patchee.Settings = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.Settings, patcher.Settings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Settings.", db); err != nil {
				return nil, err
			} else {
				patchee.Settings = o
			}
			continue
		}
		if f == prefix+"Settings" {
			updatedSettings = true
			patchee.Settings = patcher.Settings
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"ProfileImageUrl" {
			patchee.ProfileImageUrl = patcher.ProfileImageUrl
			continue
		}
		if f == prefix+"Auth0UserId" {
			patchee.Auth0UserId = patcher.Auth0UserId
			continue
		}
		if !updatedRole && strings.HasPrefix(f, prefix+"Role.") {
			updatedRole = true
			if patcher.Role == nil {
				patchee.Role = nil
				continue
			}
			if patchee.Role == nil {
				patchee.Role = &Role{}
			}
			if o, err := DefaultApplyFieldMaskRole(ctx, patchee.Role, patcher.Role, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Role.", db); err != nil {
				return nil, err
			} else {
				patchee.Role = o
			}
			continue
		}
		if f == prefix+"Role" {
			updatedRole = true
			patchee.Role = patcher.Role
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessAccount executes a gorm list call
func DefaultListBusinessAccount(ctx context.Context, db *gorm.DB) ([]*BusinessAccount, error) {
	in := BusinessAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessAccountORM{}, &BusinessAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessAccountORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Unit" {
			patchee.Unit = patcher.Unit
			continue
		}
		if f == prefix+"Zipcode" {
			patchee.Zipcode = patcher.Zipcode
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Lattitude" {
			patchee.Lattitude = patcher.Lattitude
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateTags executes a basic gorm create call
func DefaultCreateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TagsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTags(ctx context.Context, in *Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TagsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTagsSet(ctx context.Context, in []*Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tags, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tags, *gorm.DB) error
}

// DefaultStrictUpdateTags clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTags")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TagsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTags executes a basic gorm update call with patch behavior
func DefaultPatchTags(ctx context.Context, in *Tags, updateMask *field_mask.FieldMask, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Tags
	var err error
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTags(ctx, &Tags{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTags(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTags(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTags executes a bulk gorm update call with patch behavior
func DefaultPatchSetTags(ctx context.Context, objects []*Tags, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Tags, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tags, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTags(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTags patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTags(ctx context.Context, patchee *Tags, patcher *Tags, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tags, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TagName" {
			patchee.TagName = patcher.TagName
			continue
		}
		if f == prefix+"TagDescription" {
			patchee.TagDescription = patcher.TagDescription
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTags executes a gorm list call
func DefaultListTags(ctx context.Context, db *gorm.DB) ([]*Tags, error) {
	in := Tags{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TagsORM{}, &Tags{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tags{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TagsORM) error
}
