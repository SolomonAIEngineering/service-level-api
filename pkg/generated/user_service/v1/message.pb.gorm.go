package user_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"
	time "time"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type UserAccountORM struct {
	Address                 *AddressORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	AuthnAccountId          uint64
	Bio                     string
	BusinessAccountSettings *BusinessAccountSettingsORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	CompanyDescription      string
	CompanyEstablishedDate  string
	CompanyIndustryType     string
	CompanyName             string
	CompanyWebsiteUrl       string
	CreatedAt               *time.Time
	Email                   string
	Firstname               string
	Headline                string
	Id                      uint64
	IsActive                bool
	IsBusinessAccount       bool
	IsEmailVerified         bool
	IsPrivate               bool
	Lastname                string
	PhoneNumber             string
	Tags                    []*TagsORM       `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	UserSettings            *UserSettingsORM `gorm:"foreignkey:UserAccountId;association_foreignkey:Id;preload:true"`
	Username                string
	VerifiedAt              *time.Time
}

// TableName overrides the default tablename generated by GORM
func (UserAccountORM) TableName() string {
	return "user_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserAccount) ToORM(ctx context.Context) (UserAccountORM, error) {
	to := UserAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.VerifiedAt != nil {
		t := m.VerifiedAt.AsTime()
		to.VerifiedAt = &t
	}
	to.IsBusinessAccount = m.IsBusinessAccount
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.UserSettings != nil {
		tempUserSettings, err := m.UserSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.UserSettings = &tempUserSettings
	}
	if m.BusinessAccountSettings != nil {
		tempBusinessAccountSettings, err := m.BusinessAccountSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BusinessAccountSettings = &tempBusinessAccountSettings
	}
	if posthook, ok := interface{}(m).(UserAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserAccountORM) ToPB(ctx context.Context) (UserAccount, error) {
	to := UserAccount{}
	var err error
	if prehook, ok := interface{}(m).(UserAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Email = m.Email
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.AuthnAccountId = m.AuthnAccountId
	to.IsActive = m.IsActive
	to.Firstname = m.Firstname
	to.Lastname = m.Lastname
	to.Username = m.Username
	to.IsPrivate = m.IsPrivate
	to.IsEmailVerified = m.IsEmailVerified
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.VerifiedAt != nil {
		to.VerifiedAt = timestamppb.New(*m.VerifiedAt)
	}
	to.IsBusinessAccount = m.IsBusinessAccount
	to.CompanyEstablishedDate = m.CompanyEstablishedDate
	to.CompanyIndustryType = m.CompanyIndustryType
	to.CompanyWebsiteUrl = m.CompanyWebsiteUrl
	to.CompanyDescription = m.CompanyDescription
	to.CompanyName = m.CompanyName
	if m.UserSettings != nil {
		tempUserSettings, err := m.UserSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.UserSettings = &tempUserSettings
	}
	if m.BusinessAccountSettings != nil {
		tempBusinessAccountSettings, err := m.BusinessAccountSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BusinessAccountSettings = &tempBusinessAccountSettings
	}
	if posthook, ok := interface{}(m).(UserAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserAccount the arg will be the target, the caller the one being converted from

// UserAccountBeforeToORM called before default ToORM code
type UserAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserAccountORM) error
}

// UserAccountAfterToORM called after default ToORM code
type UserAccountWithAfterToORM interface {
	AfterToORM(context.Context, *UserAccountORM) error
}

// UserAccountBeforeToPB called before default ToPB code
type UserAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserAccount) error
}

// UserAccountAfterToPB called after default ToPB code
type UserAccountWithAfterToPB interface {
	AfterToPB(context.Context, *UserAccount) error
}

type AddressORM struct {
	Address       string
	City          string
	Id            uint64
	Lattitude     string
	Longitude     string
	State         string
	Unit          string
	UserAccountId *uint64
	Zipcode       string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.Zipcode = m.Zipcode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type TagsORM struct {
	Id             uint64
	Metadata       pq.StringArray `gorm:"type:text[]"`
	TagDescription string
	TagName        string
	UserAccountId  *uint64
}

// TableName overrides the default tablename generated by GORM
func (TagsORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tags) ToORM(ctx context.Context) (TagsORM, error) {
	to := TagsORM{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagsORM) ToPB(ctx context.Context) (Tags, error) {
	to := Tags{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tags the arg will be the target, the caller the one being converted from

// TagsBeforeToORM called before default ToORM code
type TagsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagsORM) error
}

// TagsAfterToORM called after default ToORM code
type TagsWithAfterToORM interface {
	AfterToORM(context.Context, *TagsORM) error
}

// TagsBeforeToPB called before default ToPB code
type TagsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tags) error
}

// TagsAfterToPB called after default ToPB code
type TagsWithAfterToPB interface {
	AfterToPB(context.Context, *Tags) error
}

type UserSettingsORM struct {
	AppTheme                       string
	DatetimeFormat                 string
	DefaultCurrency                string
	EmailNotifications             bool
	EnableGoalJournal              bool
	Id                             uint64
	InvestmentRiskTolerance        string
	PreferredLanguage              string
	PublicProfile                  bool
	PushNotifications              bool
	SmsNotifications               bool
	TwoFactorAuthenticationEnabled bool
	UserAccountId                  *uint64
}

// TableName overrides the default tablename generated by GORM
func (UserSettingsORM) TableName() string {
	return "user_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserSettings) ToORM(ctx context.Context) (UserSettingsORM, error) {
	to := UserSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(UserSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppTheme = UserSettings_Theme_name[int32(m.AppTheme)]
	to.EmailNotifications = m.EmailNotifications
	to.PushNotifications = m.PushNotifications
	to.SmsNotifications = m.SmsNotifications
	to.DefaultCurrency = m.DefaultCurrency
	to.DatetimeFormat = m.DatetimeFormat
	to.TwoFactorAuthenticationEnabled = m.TwoFactorAuthenticationEnabled
	to.PreferredLanguage = m.PreferredLanguage
	to.PublicProfile = m.PublicProfile
	to.EnableGoalJournal = m.EnableGoalJournal
	to.InvestmentRiskTolerance = UserSettings_RiskTolerance_name[int32(m.InvestmentRiskTolerance)]
	// Repeated type enum is not an ORMable message type
	if posthook, ok := interface{}(m).(UserSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserSettingsORM) ToPB(ctx context.Context) (UserSettings, error) {
	to := UserSettings{}
	var err error
	if prehook, ok := interface{}(m).(UserSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppTheme = UserSettings_Theme(UserSettings_Theme_value[m.AppTheme])
	to.EmailNotifications = m.EmailNotifications
	to.PushNotifications = m.PushNotifications
	to.SmsNotifications = m.SmsNotifications
	to.DefaultCurrency = m.DefaultCurrency
	to.DatetimeFormat = m.DatetimeFormat
	to.TwoFactorAuthenticationEnabled = m.TwoFactorAuthenticationEnabled
	to.PreferredLanguage = m.PreferredLanguage
	to.PublicProfile = m.PublicProfile
	to.EnableGoalJournal = m.EnableGoalJournal
	to.InvestmentRiskTolerance = UserSettings_RiskTolerance(UserSettings_RiskTolerance_value[m.InvestmentRiskTolerance])
	// Repeated type enum is not an ORMable message type
	if posthook, ok := interface{}(m).(UserSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserSettings the arg will be the target, the caller the one being converted from

// UserSettingsBeforeToORM called before default ToORM code
type UserSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserSettingsORM) error
}

// UserSettingsAfterToORM called after default ToORM code
type UserSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *UserSettingsORM) error
}

// UserSettingsBeforeToPB called before default ToPB code
type UserSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserSettings) error
}

// UserSettingsAfterToPB called after default ToPB code
type UserSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *UserSettings) error
}

type BusinessAccountSettingsORM struct {
	Id            uint64
	UserAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (BusinessAccountSettingsORM) TableName() string {
	return "business_account_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *BusinessAccountSettings) ToORM(ctx context.Context) (BusinessAccountSettingsORM, error) {
	to := BusinessAccountSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(BusinessAccountSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *BusinessAccountSettingsORM) ToPB(ctx context.Context) (BusinessAccountSettings, error) {
	to := BusinessAccountSettings{}
	var err error
	if prehook, ok := interface{}(m).(BusinessAccountSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if posthook, ok := interface{}(m).(BusinessAccountSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type BusinessAccountSettings the arg will be the target, the caller the one being converted from

// BusinessAccountSettingsBeforeToORM called before default ToORM code
type BusinessAccountSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *BusinessAccountSettingsORM) error
}

// BusinessAccountSettingsAfterToORM called after default ToORM code
type BusinessAccountSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *BusinessAccountSettingsORM) error
}

// BusinessAccountSettingsBeforeToPB called before default ToPB code
type BusinessAccountSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *BusinessAccountSettings) error
}

// BusinessAccountSettingsAfterToPB called after default ToPB code
type BusinessAccountSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *BusinessAccountSettings) error
}

// DefaultCreateUserAccount executes a basic gorm create call
func DefaultCreateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserAccountSet(ctx context.Context, in []*UserAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserAccountORM{})).(UserAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserAccount, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserAccount, *gorm.DB) error
}

// DefaultStrictUpdateUserAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserAccount(ctx context.Context, in *UserAccount, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.UserAccountId = new(uint64)
	*filterAddress.UserAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterBusinessAccountSettings := BusinessAccountSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterBusinessAccountSettings.UserAccountId = new(uint64)
	*filterBusinessAccountSettings.UserAccountId = ormObj.Id
	if err = db.Where(filterBusinessAccountSettings).Delete(BusinessAccountSettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.UserAccountId = new(uint64)
	*filterTags.UserAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	filterUserSettings := UserSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterUserSettings.UserAccountId = new(uint64)
	*filterUserSettings.UserAccountId = ormObj.Id
	if err = db.Where(filterUserSettings).Delete(UserSettingsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserAccount executes a basic gorm update call with patch behavior
func DefaultPatchUserAccount(ctx context.Context, in *UserAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserAccount
	var err error
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserAccount(ctx, &UserAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserAccount(ctx context.Context, objects []*UserAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserAccount(ctx context.Context, patchee *UserAccount, patcher *UserAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedCreatedAt bool
	var updatedVerifiedAt bool
	var updatedUserSettings bool
	var updatedBusinessAccountSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"Firstname" {
			patchee.Firstname = patcher.Firstname
			continue
		}
		if f == prefix+"Lastname" {
			patchee.Lastname = patcher.Lastname
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
		if f == prefix+"IsPrivate" {
			patchee.IsPrivate = patcher.IsPrivate
			continue
		}
		if f == prefix+"IsEmailVerified" {
			patchee.IsEmailVerified = patcher.IsEmailVerified
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedVerifiedAt && strings.HasPrefix(f, prefix+"VerifiedAt.") {
			if patcher.VerifiedAt == nil {
				patchee.VerifiedAt = nil
				continue
			}
			if patchee.VerifiedAt == nil {
				patchee.VerifiedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"VerifiedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.VerifiedAt, patchee.VerifiedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"VerifiedAt" {
			updatedVerifiedAt = true
			patchee.VerifiedAt = patcher.VerifiedAt
			continue
		}
		if f == prefix+"IsBusinessAccount" {
			patchee.IsBusinessAccount = patcher.IsBusinessAccount
			continue
		}
		if f == prefix+"CompanyEstablishedDate" {
			patchee.CompanyEstablishedDate = patcher.CompanyEstablishedDate
			continue
		}
		if f == prefix+"CompanyIndustryType" {
			patchee.CompanyIndustryType = patcher.CompanyIndustryType
			continue
		}
		if f == prefix+"CompanyWebsiteUrl" {
			patchee.CompanyWebsiteUrl = patcher.CompanyWebsiteUrl
			continue
		}
		if f == prefix+"CompanyDescription" {
			patchee.CompanyDescription = patcher.CompanyDescription
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if !updatedUserSettings && strings.HasPrefix(f, prefix+"UserSettings.") {
			updatedUserSettings = true
			if patcher.UserSettings == nil {
				patchee.UserSettings = nil
				continue
			}
			if patchee.UserSettings == nil {
				patchee.UserSettings = &UserSettings{}
			}
			if o, err := DefaultApplyFieldMaskUserSettings(ctx, patchee.UserSettings, patcher.UserSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"UserSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.UserSettings = o
			}
			continue
		}
		if f == prefix+"UserSettings" {
			updatedUserSettings = true
			patchee.UserSettings = patcher.UserSettings
			continue
		}
		if !updatedBusinessAccountSettings && strings.HasPrefix(f, prefix+"BusinessAccountSettings.") {
			updatedBusinessAccountSettings = true
			if patcher.BusinessAccountSettings == nil {
				patchee.BusinessAccountSettings = nil
				continue
			}
			if patchee.BusinessAccountSettings == nil {
				patchee.BusinessAccountSettings = &BusinessAccountSettings{}
			}
			if o, err := DefaultApplyFieldMaskBusinessAccountSettings(ctx, patchee.BusinessAccountSettings, patcher.BusinessAccountSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BusinessAccountSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.BusinessAccountSettings = o
			}
			continue
		}
		if f == prefix+"BusinessAccountSettings" {
			updatedBusinessAccountSettings = true
			patchee.BusinessAccountSettings = patcher.BusinessAccountSettings
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserAccount executes a gorm list call
func DefaultListUserAccount(ctx context.Context, db *gorm.DB) ([]*UserAccount, error) {
	in := UserAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserAccountORM{}, &UserAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserAccountORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Unit" {
			patchee.Unit = patcher.Unit
			continue
		}
		if f == prefix+"Zipcode" {
			patchee.Zipcode = patcher.Zipcode
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Lattitude" {
			patchee.Lattitude = patcher.Lattitude
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateTags executes a basic gorm create call
func DefaultCreateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TagsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTags(ctx context.Context, in *Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TagsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTagsSet(ctx context.Context, in []*Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tags, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tags, *gorm.DB) error
}

// DefaultStrictUpdateTags clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTags")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TagsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTags executes a basic gorm update call with patch behavior
func DefaultPatchTags(ctx context.Context, in *Tags, updateMask *field_mask.FieldMask, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Tags
	var err error
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTags(ctx, &Tags{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTags(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTags(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTags executes a bulk gorm update call with patch behavior
func DefaultPatchSetTags(ctx context.Context, objects []*Tags, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Tags, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tags, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTags(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTags patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTags(ctx context.Context, patchee *Tags, patcher *Tags, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tags, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TagName" {
			patchee.TagName = patcher.TagName
			continue
		}
		if f == prefix+"TagDescription" {
			patchee.TagDescription = patcher.TagDescription
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTags executes a gorm list call
func DefaultListTags(ctx context.Context, db *gorm.DB) ([]*Tags, error) {
	in := Tags{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TagsORM{}, &Tags{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tags{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TagsORM) error
}

// DefaultCreateUserSettings executes a basic gorm create call
func DefaultCreateUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &UserSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSettingsSet(ctx context.Context, in []*UserSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserSettingsORM{})).(UserSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserSettingsORM{})).(UserSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserSettings, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserSettings, *gorm.DB) error
}

// DefaultStrictUpdateUserSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserSettings(ctx context.Context, in *UserSettings, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserSettings executes a basic gorm update call with patch behavior
func DefaultPatchUserSettings(ctx context.Context, in *UserSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserSettings
	var err error
	if hook, ok := interface{}(&pbObj).(UserSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserSettings(ctx, &UserSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserSettings(ctx context.Context, objects []*UserSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserSettings(ctx context.Context, patchee *UserSettings, patcher *UserSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppTheme" {
			patchee.AppTheme = patcher.AppTheme
			continue
		}
		if f == prefix+"EmailNotifications" {
			patchee.EmailNotifications = patcher.EmailNotifications
			continue
		}
		if f == prefix+"PushNotifications" {
			patchee.PushNotifications = patcher.PushNotifications
			continue
		}
		if f == prefix+"SmsNotifications" {
			patchee.SmsNotifications = patcher.SmsNotifications
			continue
		}
		if f == prefix+"DefaultCurrency" {
			patchee.DefaultCurrency = patcher.DefaultCurrency
			continue
		}
		if f == prefix+"DatetimeFormat" {
			patchee.DatetimeFormat = patcher.DatetimeFormat
			continue
		}
		if f == prefix+"TwoFactorAuthenticationEnabled" {
			patchee.TwoFactorAuthenticationEnabled = patcher.TwoFactorAuthenticationEnabled
			continue
		}
		if f == prefix+"PreferredLanguage" {
			patchee.PreferredLanguage = patcher.PreferredLanguage
			continue
		}
		if f == prefix+"PublicProfile" {
			patchee.PublicProfile = patcher.PublicProfile
			continue
		}
		if f == prefix+"EnableGoalJournal" {
			patchee.EnableGoalJournal = patcher.EnableGoalJournal
			continue
		}
		if f == prefix+"InvestmentRiskTolerance" {
			patchee.InvestmentRiskTolerance = patcher.InvestmentRiskTolerance
			continue
		}
		if f == prefix+"DashboardWidgets" {
			patchee.DashboardWidgets = patcher.DashboardWidgets
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserSettings executes a gorm list call
func DefaultListUserSettings(ctx context.Context, db *gorm.DB) ([]*UserSettings, error) {
	in := UserSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &UserSettingsORM{}, &UserSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserSettingsORM) error
}

// DefaultCreateBusinessAccountSettings executes a basic gorm create call
func DefaultCreateBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &BusinessAccountSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := BusinessAccountSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(BusinessAccountSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type BusinessAccountSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&BusinessAccountSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type BusinessAccountSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteBusinessAccountSettingsSet(ctx context.Context, in []*BusinessAccountSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&BusinessAccountSettingsORM{})).(BusinessAccountSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&BusinessAccountSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&BusinessAccountSettingsORM{})).(BusinessAccountSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type BusinessAccountSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*BusinessAccountSettings, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*BusinessAccountSettings, *gorm.DB) error
}

// DefaultStrictUpdateBusinessAccountSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateBusinessAccountSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &BusinessAccountSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type BusinessAccountSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchBusinessAccountSettings executes a basic gorm update call with patch behavior
func DefaultPatchBusinessAccountSettings(ctx context.Context, in *BusinessAccountSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*BusinessAccountSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj BusinessAccountSettings
	var err error
	if hook, ok := interface{}(&pbObj).(BusinessAccountSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadBusinessAccountSettings(ctx, &BusinessAccountSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(BusinessAccountSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskBusinessAccountSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(BusinessAccountSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateBusinessAccountSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(BusinessAccountSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type BusinessAccountSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *BusinessAccountSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetBusinessAccountSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetBusinessAccountSettings(ctx context.Context, objects []*BusinessAccountSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*BusinessAccountSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*BusinessAccountSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchBusinessAccountSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskBusinessAccountSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskBusinessAccountSettings(ctx context.Context, patchee *BusinessAccountSettings, patcher *BusinessAccountSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*BusinessAccountSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAccountInformation bool
	var updatedFinancialPreferences bool
	var updatedAiPoweredInsights bool
	var updatedIntegrationSettings bool
	var updatedNotifications bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedAccountInformation && strings.HasPrefix(f, prefix+"AccountInformation.") {
			if patcher.AccountInformation == nil {
				patchee.AccountInformation = nil
				continue
			}
			if patchee.AccountInformation == nil {
				patchee.AccountInformation = &BusinessAccountSettings_AccountInformation{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AccountInformation."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AccountInformation, patchee.AccountInformation, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AccountInformation" {
			updatedAccountInformation = true
			patchee.AccountInformation = patcher.AccountInformation
			continue
		}
		if !updatedFinancialPreferences && strings.HasPrefix(f, prefix+"FinancialPreferences.") {
			if patcher.FinancialPreferences == nil {
				patchee.FinancialPreferences = nil
				continue
			}
			if patchee.FinancialPreferences == nil {
				patchee.FinancialPreferences = &BusinessAccountSettings_FinancialPreferences{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FinancialPreferences."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.FinancialPreferences, patchee.FinancialPreferences, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FinancialPreferences" {
			updatedFinancialPreferences = true
			patchee.FinancialPreferences = patcher.FinancialPreferences
			continue
		}
		if !updatedAiPoweredInsights && strings.HasPrefix(f, prefix+"AiPoweredInsights.") {
			if patcher.AiPoweredInsights == nil {
				patchee.AiPoweredInsights = nil
				continue
			}
			if patchee.AiPoweredInsights == nil {
				patchee.AiPoweredInsights = &BusinessAccountSettings_AIPoweredInsights{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AiPoweredInsights."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.AiPoweredInsights, patchee.AiPoweredInsights, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AiPoweredInsights" {
			updatedAiPoweredInsights = true
			patchee.AiPoweredInsights = patcher.AiPoweredInsights
			continue
		}
		if !updatedIntegrationSettings && strings.HasPrefix(f, prefix+"IntegrationSettings.") {
			if patcher.IntegrationSettings == nil {
				patchee.IntegrationSettings = nil
				continue
			}
			if patchee.IntegrationSettings == nil {
				patchee.IntegrationSettings = &BusinessAccountSettings_IntegrationSettings{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"IntegrationSettings."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.IntegrationSettings, patchee.IntegrationSettings, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"IntegrationSettings" {
			updatedIntegrationSettings = true
			patchee.IntegrationSettings = patcher.IntegrationSettings
			continue
		}
		if !updatedNotifications && strings.HasPrefix(f, prefix+"Notifications.") {
			if patcher.Notifications == nil {
				patchee.Notifications = nil
				continue
			}
			if patchee.Notifications == nil {
				patchee.Notifications = &BusinessAccountSettings_Notifications{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Notifications."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Notifications, patchee.Notifications, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Notifications" {
			updatedNotifications = true
			patchee.Notifications = patcher.Notifications
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListBusinessAccountSettings executes a gorm list call
func DefaultListBusinessAccountSettings(ctx context.Context, db *gorm.DB) ([]*BusinessAccountSettings, error) {
	in := BusinessAccountSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &BusinessAccountSettingsORM{}, &BusinessAccountSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []BusinessAccountSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(BusinessAccountSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*BusinessAccountSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type BusinessAccountSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type BusinessAccountSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]BusinessAccountSettingsORM) error
}
