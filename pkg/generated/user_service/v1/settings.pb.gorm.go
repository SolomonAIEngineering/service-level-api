package user_servicev1

import (
	context "context"
	fmt "fmt"
	strings "strings"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type NotificationSettingsORM struct {
	Alerts           bool
	Id               uint64
	NotificationType string
	SettingsId       *uint64
}

// TableName overrides the default tablename generated by GORM
func (NotificationSettingsORM) TableName() string {
	return "notification_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *NotificationSettings) ToORM(ctx context.Context) (NotificationSettingsORM, error) {
	to := NotificationSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NotificationType = NotificationType_name[int32(m.NotificationType)]
	to.Alerts = m.Alerts
	if posthook, ok := interface{}(m).(NotificationSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationSettingsORM) ToPB(ctx context.Context) (NotificationSettings, error) {
	to := NotificationSettings{}
	var err error
	if prehook, ok := interface{}(m).(NotificationSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.NotificationType = NotificationType(NotificationType_value[m.NotificationType])
	to.Alerts = m.Alerts
	if posthook, ok := interface{}(m).(NotificationSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type NotificationSettings the arg will be the target, the caller the one being converted from

// NotificationSettingsBeforeToORM called before default ToORM code
type NotificationSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationSettingsORM) error
}

// NotificationSettingsAfterToORM called after default ToORM code
type NotificationSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationSettingsORM) error
}

// NotificationSettingsBeforeToPB called before default ToPB code
type NotificationSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *NotificationSettings) error
}

// NotificationSettingsAfterToPB called after default ToPB code
type NotificationSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *NotificationSettings) error
}

type DigitalWorkerSettingsORM struct {
	EnableLogging bool
	Id            uint64
	SettingsId    *uint64
	WorkerName    string
	WorkerVersion string
}

// TableName overrides the default tablename generated by GORM
func (DigitalWorkerSettingsORM) TableName() string {
	return "digital_worker_settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DigitalWorkerSettings) ToORM(ctx context.Context) (DigitalWorkerSettingsORM, error) {
	to := DigitalWorkerSettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(DigitalWorkerSettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.WorkerName = m.WorkerName
	to.WorkerVersion = m.WorkerVersion
	to.EnableLogging = m.EnableLogging
	if posthook, ok := interface{}(m).(DigitalWorkerSettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DigitalWorkerSettingsORM) ToPB(ctx context.Context) (DigitalWorkerSettings, error) {
	to := DigitalWorkerSettings{}
	var err error
	if prehook, ok := interface{}(m).(DigitalWorkerSettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.WorkerName = m.WorkerName
	to.WorkerVersion = m.WorkerVersion
	to.EnableLogging = m.EnableLogging
	if posthook, ok := interface{}(m).(DigitalWorkerSettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DigitalWorkerSettings the arg will be the target, the caller the one being converted from

// DigitalWorkerSettingsBeforeToORM called before default ToORM code
type DigitalWorkerSettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *DigitalWorkerSettingsORM) error
}

// DigitalWorkerSettingsAfterToORM called after default ToORM code
type DigitalWorkerSettingsWithAfterToORM interface {
	AfterToORM(context.Context, *DigitalWorkerSettingsORM) error
}

// DigitalWorkerSettingsBeforeToPB called before default ToPB code
type DigitalWorkerSettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *DigitalWorkerSettings) error
}

// DigitalWorkerSettingsAfterToPB called after default ToPB code
type DigitalWorkerSettingsWithAfterToPB interface {
	AfterToPB(context.Context, *DigitalWorkerSettings) error
}

type FinancialPreferencesORM struct {
	CurrencyPreference string
	FinancialYearStart string
	Id                 uint64
	SettingsId         *uint64
	TaxCode            string
	TaxPercentage      float64
}

// TableName overrides the default tablename generated by GORM
func (FinancialPreferencesORM) TableName() string {
	return "financial_preferences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FinancialPreferences) ToORM(ctx context.Context) (FinancialPreferencesORM, error) {
	to := FinancialPreferencesORM{}
	var err error
	if prehook, ok := interface{}(m).(FinancialPreferencesWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CurrencyPreference = m.CurrencyPreference
	to.FinancialYearStart = m.FinancialYearStart
	to.TaxPercentage = m.TaxPercentage
	to.TaxCode = m.TaxCode
	if posthook, ok := interface{}(m).(FinancialPreferencesWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FinancialPreferencesORM) ToPB(ctx context.Context) (FinancialPreferences, error) {
	to := FinancialPreferences{}
	var err error
	if prehook, ok := interface{}(m).(FinancialPreferencesWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CurrencyPreference = m.CurrencyPreference
	to.FinancialYearStart = m.FinancialYearStart
	to.TaxPercentage = m.TaxPercentage
	to.TaxCode = m.TaxCode
	if posthook, ok := interface{}(m).(FinancialPreferencesWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FinancialPreferences the arg will be the target, the caller the one being converted from

// FinancialPreferencesBeforeToORM called before default ToORM code
type FinancialPreferencesWithBeforeToORM interface {
	BeforeToORM(context.Context, *FinancialPreferencesORM) error
}

// FinancialPreferencesAfterToORM called after default ToORM code
type FinancialPreferencesWithAfterToORM interface {
	AfterToORM(context.Context, *FinancialPreferencesORM) error
}

// FinancialPreferencesBeforeToPB called before default ToPB code
type FinancialPreferencesWithBeforeToPB interface {
	BeforeToPB(context.Context, *FinancialPreferences) error
}

// FinancialPreferencesAfterToPB called after default ToPB code
type FinancialPreferencesWithAfterToPB interface {
	AfterToPB(context.Context, *FinancialPreferences) error
}

type SettingsORM struct {
	AppTheme              string
	BusinessAccountId     *uint64
	DigitalWorkerSettings *DigitalWorkerSettingsORM `gorm:"foreignkey:SettingsId;association_foreignkey:Id;preload:true"`
	FinancialPreferences  *FinancialPreferencesORM  `gorm:"foreignkey:SettingsId;association_foreignkey:Id;preload:true"`
	Id                    uint64
	NotificationSettings  *NotificationSettingsORM `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	PreferredLanguage     string
	RiskTolerance         string
	UserAccountId         *uint64
}

// TableName overrides the default tablename generated by GORM
func (SettingsORM) TableName() string {
	return "settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Settings) ToORM(ctx context.Context) (SettingsORM, error) {
	to := SettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppTheme = ApplicationTheme_name[int32(m.AppTheme)]
	if m.NotificationSettings != nil {
		tempNotificationSettings, err := m.NotificationSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSettings = &tempNotificationSettings
	}
	to.PreferredLanguage = m.PreferredLanguage
	to.RiskTolerance = RiskToleranceSettings_name[int32(m.RiskTolerance)]
	// Repeated type enum is not an ORMable message type
	if m.DigitalWorkerSettings != nil {
		tempDigitalWorkerSettings, err := m.DigitalWorkerSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DigitalWorkerSettings = &tempDigitalWorkerSettings
	}
	if m.FinancialPreferences != nil {
		tempFinancialPreferences, err := m.FinancialPreferences.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FinancialPreferences = &tempFinancialPreferences
	}
	if posthook, ok := interface{}(m).(SettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SettingsORM) ToPB(ctx context.Context) (Settings, error) {
	to := Settings{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.AppTheme = ApplicationTheme(ApplicationTheme_value[m.AppTheme])
	if m.NotificationSettings != nil {
		tempNotificationSettings, err := m.NotificationSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationSettings = &tempNotificationSettings
	}
	to.PreferredLanguage = m.PreferredLanguage
	to.RiskTolerance = RiskToleranceSettings(RiskToleranceSettings_value[m.RiskTolerance])
	// Repeated type enum is not an ORMable message type
	if m.DigitalWorkerSettings != nil {
		tempDigitalWorkerSettings, err := m.DigitalWorkerSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DigitalWorkerSettings = &tempDigitalWorkerSettings
	}
	if m.FinancialPreferences != nil {
		tempFinancialPreferences, err := m.FinancialPreferences.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FinancialPreferences = &tempFinancialPreferences
	}
	if posthook, ok := interface{}(m).(SettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Settings the arg will be the target, the caller the one being converted from

// SettingsBeforeToORM called before default ToORM code
type SettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *SettingsORM) error
}

// SettingsAfterToORM called after default ToORM code
type SettingsWithAfterToORM interface {
	AfterToORM(context.Context, *SettingsORM) error
}

// SettingsBeforeToPB called before default ToPB code
type SettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Settings) error
}

// SettingsAfterToPB called after default ToPB code
type SettingsWithAfterToPB interface {
	AfterToPB(context.Context, *Settings) error
}

// DefaultCreateNotificationSettings executes a basic gorm create call
func DefaultCreateNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &NotificationSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteNotificationSettingsSet(ctx context.Context, in []*NotificationSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationSettingsORM{})).(NotificationSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NotificationSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationSettingsORM{})).(NotificationSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*NotificationSettings, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*NotificationSettings, *gorm.DB) error
}

// DefaultStrictUpdateNotificationSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotificationSettings(ctx context.Context, in *NotificationSettings, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotificationSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchNotificationSettings executes a basic gorm update call with patch behavior
func DefaultPatchNotificationSettings(ctx context.Context, in *NotificationSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*NotificationSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj NotificationSettings
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotificationSettings(ctx, &NotificationSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotificationSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotificationSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *NotificationSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetNotificationSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotificationSettings(ctx context.Context, objects []*NotificationSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*NotificationSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*NotificationSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotificationSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotificationSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotificationSettings(ctx context.Context, patchee *NotificationSettings, patcher *NotificationSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*NotificationSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"NotificationType" {
			patchee.NotificationType = patcher.NotificationType
			continue
		}
		if f == prefix+"Alerts" {
			patchee.Alerts = patcher.Alerts
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotificationSettings executes a gorm list call
func DefaultListNotificationSettings(ctx context.Context, db *gorm.DB) ([]*NotificationSettings, error) {
	in := NotificationSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &NotificationSettingsORM{}, &NotificationSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*NotificationSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type NotificationSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]NotificationSettingsORM) error
}

// DefaultCreateDigitalWorkerSettings executes a basic gorm create call
func DefaultCreateDigitalWorkerSettings(ctx context.Context, in *DigitalWorkerSettings, db *gorm.DB) (*DigitalWorkerSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DigitalWorkerSettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDigitalWorkerSettings(ctx context.Context, in *DigitalWorkerSettings, db *gorm.DB) (*DigitalWorkerSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &DigitalWorkerSettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DigitalWorkerSettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DigitalWorkerSettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DigitalWorkerSettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDigitalWorkerSettings(ctx context.Context, in *DigitalWorkerSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DigitalWorkerSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DigitalWorkerSettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteDigitalWorkerSettingsSet(ctx context.Context, in []*DigitalWorkerSettings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DigitalWorkerSettingsORM{})).(DigitalWorkerSettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DigitalWorkerSettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DigitalWorkerSettingsORM{})).(DigitalWorkerSettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DigitalWorkerSettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DigitalWorkerSettings, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DigitalWorkerSettings, *gorm.DB) error
}

// DefaultStrictUpdateDigitalWorkerSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDigitalWorkerSettings(ctx context.Context, in *DigitalWorkerSettings, db *gorm.DB) (*DigitalWorkerSettings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDigitalWorkerSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DigitalWorkerSettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DigitalWorkerSettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchDigitalWorkerSettings executes a basic gorm update call with patch behavior
func DefaultPatchDigitalWorkerSettings(ctx context.Context, in *DigitalWorkerSettings, updateMask *field_mask.FieldMask, db *gorm.DB) (*DigitalWorkerSettings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj DigitalWorkerSettings
	var err error
	if hook, ok := interface{}(&pbObj).(DigitalWorkerSettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDigitalWorkerSettings(ctx, &DigitalWorkerSettings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DigitalWorkerSettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDigitalWorkerSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DigitalWorkerSettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDigitalWorkerSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DigitalWorkerSettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DigitalWorkerSettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DigitalWorkerSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DigitalWorkerSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DigitalWorkerSettings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DigitalWorkerSettings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetDigitalWorkerSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetDigitalWorkerSettings(ctx context.Context, objects []*DigitalWorkerSettings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*DigitalWorkerSettings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DigitalWorkerSettings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDigitalWorkerSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDigitalWorkerSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDigitalWorkerSettings(ctx context.Context, patchee *DigitalWorkerSettings, patcher *DigitalWorkerSettings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*DigitalWorkerSettings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"WorkerName" {
			patchee.WorkerName = patcher.WorkerName
			continue
		}
		if f == prefix+"WorkerVersion" {
			patchee.WorkerVersion = patcher.WorkerVersion
			continue
		}
		if f == prefix+"EnableLogging" {
			patchee.EnableLogging = patcher.EnableLogging
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDigitalWorkerSettings executes a gorm list call
func DefaultListDigitalWorkerSettings(ctx context.Context, db *gorm.DB) ([]*DigitalWorkerSettings, error) {
	in := DigitalWorkerSettings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &DigitalWorkerSettingsORM{}, &DigitalWorkerSettings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DigitalWorkerSettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DigitalWorkerSettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DigitalWorkerSettings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DigitalWorkerSettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DigitalWorkerSettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DigitalWorkerSettingsORM) error
}

// DefaultCreateFinancialPreferences executes a basic gorm create call
func DefaultCreateFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FinancialPreferencesORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &FinancialPreferencesORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FinancialPreferencesORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FinancialPreferencesORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FinancialPreferencesORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FinancialPreferencesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FinancialPreferencesORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteFinancialPreferencesSet(ctx context.Context, in []*FinancialPreferences, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FinancialPreferencesORM{})).(FinancialPreferencesORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FinancialPreferencesORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FinancialPreferencesORM{})).(FinancialPreferencesORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FinancialPreferencesORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FinancialPreferences, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FinancialPreferences, *gorm.DB) error
}

// DefaultStrictUpdateFinancialPreferences clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFinancialPreferences(ctx context.Context, in *FinancialPreferences, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFinancialPreferences")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FinancialPreferencesORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FinancialPreferencesORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchFinancialPreferences executes a basic gorm update call with patch behavior
func DefaultPatchFinancialPreferences(ctx context.Context, in *FinancialPreferences, updateMask *field_mask.FieldMask, db *gorm.DB) (*FinancialPreferences, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj FinancialPreferences
	var err error
	if hook, ok := interface{}(&pbObj).(FinancialPreferencesWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFinancialPreferences(ctx, &FinancialPreferences{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FinancialPreferencesWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFinancialPreferences(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FinancialPreferencesWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFinancialPreferences(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FinancialPreferencesWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FinancialPreferencesWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FinancialPreferences, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetFinancialPreferences executes a bulk gorm update call with patch behavior
func DefaultPatchSetFinancialPreferences(ctx context.Context, objects []*FinancialPreferences, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*FinancialPreferences, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FinancialPreferences, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFinancialPreferences(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFinancialPreferences patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFinancialPreferences(ctx context.Context, patchee *FinancialPreferences, patcher *FinancialPreferences, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FinancialPreferences, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CurrencyPreference" {
			patchee.CurrencyPreference = patcher.CurrencyPreference
			continue
		}
		if f == prefix+"FinancialYearStart" {
			patchee.FinancialYearStart = patcher.FinancialYearStart
			continue
		}
		if f == prefix+"TaxPercentage" {
			patchee.TaxPercentage = patcher.TaxPercentage
			continue
		}
		if f == prefix+"TaxCode" {
			patchee.TaxCode = patcher.TaxCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFinancialPreferences executes a gorm list call
func DefaultListFinancialPreferences(ctx context.Context, db *gorm.DB) ([]*FinancialPreferences, error) {
	in := FinancialPreferences{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FinancialPreferencesORM{}, &FinancialPreferences{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FinancialPreferencesORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialPreferencesORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FinancialPreferences{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FinancialPreferencesORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialPreferencesORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FinancialPreferencesORM) error
}

// DefaultCreateSettings executes a basic gorm create call
func DefaultCreateSettings(ctx context.Context, in *Settings, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSettings(ctx context.Context, in *Settings, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSettings(ctx context.Context, in *Settings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSettingsSet(ctx context.Context, in []*Settings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Settings, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Settings, *gorm.DB) error
}

// DefaultStrictUpdateSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSettings(ctx context.Context, in *Settings, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDigitalWorkerSettings := DigitalWorkerSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterDigitalWorkerSettings.SettingsId = new(uint64)
	*filterDigitalWorkerSettings.SettingsId = ormObj.Id
	if err = db.Where(filterDigitalWorkerSettings).Delete(DigitalWorkerSettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterFinancialPreferences := FinancialPreferencesORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterFinancialPreferences.SettingsId = new(uint64)
	*filterFinancialPreferences.SettingsId = ormObj.Id
	if err = db.Where(filterFinancialPreferences).Delete(FinancialPreferencesORM{}).Error; err != nil {
		return nil, err
	}
	filterNotificationSettings := NotificationSettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterNotificationSettings.SettingsId = new(uint64)
	*filterNotificationSettings.SettingsId = ormObj.Id
	if err = db.Where(filterNotificationSettings).Delete(NotificationSettingsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSettings executes a basic gorm update call with patch behavior
func DefaultPatchSettings(ctx context.Context, in *Settings, updateMask *field_mask.FieldMask, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Settings
	var err error
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSettings(ctx, &Settings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetSettings(ctx context.Context, objects []*Settings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Settings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Settings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSettings(ctx context.Context, patchee *Settings, patcher *Settings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Settings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedNotificationSettings bool
	var updatedDigitalWorkerSettings bool
	var updatedFinancialPreferences bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"AppTheme" {
			patchee.AppTheme = patcher.AppTheme
			continue
		}
		if !updatedNotificationSettings && strings.HasPrefix(f, prefix+"NotificationSettings.") {
			updatedNotificationSettings = true
			if patcher.NotificationSettings == nil {
				patchee.NotificationSettings = nil
				continue
			}
			if patchee.NotificationSettings == nil {
				patchee.NotificationSettings = &NotificationSettings{}
			}
			if o, err := DefaultApplyFieldMaskNotificationSettings(ctx, patchee.NotificationSettings, patcher.NotificationSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationSettings = o
			}
			continue
		}
		if f == prefix+"NotificationSettings" {
			updatedNotificationSettings = true
			patchee.NotificationSettings = patcher.NotificationSettings
			continue
		}
		if f == prefix+"PreferredLanguage" {
			patchee.PreferredLanguage = patcher.PreferredLanguage
			continue
		}
		if f == prefix+"RiskTolerance" {
			patchee.RiskTolerance = patcher.RiskTolerance
			continue
		}
		if f == prefix+"LikedDashboardPanels" {
			patchee.LikedDashboardPanels = patcher.LikedDashboardPanels
			continue
		}
		if !updatedDigitalWorkerSettings && strings.HasPrefix(f, prefix+"DigitalWorkerSettings.") {
			updatedDigitalWorkerSettings = true
			if patcher.DigitalWorkerSettings == nil {
				patchee.DigitalWorkerSettings = nil
				continue
			}
			if patchee.DigitalWorkerSettings == nil {
				patchee.DigitalWorkerSettings = &DigitalWorkerSettings{}
			}
			if o, err := DefaultApplyFieldMaskDigitalWorkerSettings(ctx, patchee.DigitalWorkerSettings, patcher.DigitalWorkerSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DigitalWorkerSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.DigitalWorkerSettings = o
			}
			continue
		}
		if f == prefix+"DigitalWorkerSettings" {
			updatedDigitalWorkerSettings = true
			patchee.DigitalWorkerSettings = patcher.DigitalWorkerSettings
			continue
		}
		if !updatedFinancialPreferences && strings.HasPrefix(f, prefix+"FinancialPreferences.") {
			updatedFinancialPreferences = true
			if patcher.FinancialPreferences == nil {
				patchee.FinancialPreferences = nil
				continue
			}
			if patchee.FinancialPreferences == nil {
				patchee.FinancialPreferences = &FinancialPreferences{}
			}
			if o, err := DefaultApplyFieldMaskFinancialPreferences(ctx, patchee.FinancialPreferences, patcher.FinancialPreferences, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FinancialPreferences.", db); err != nil {
				return nil, err
			} else {
				patchee.FinancialPreferences = o
			}
			continue
		}
		if f == prefix+"FinancialPreferences" {
			updatedFinancialPreferences = true
			patchee.FinancialPreferences = patcher.FinancialPreferences
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSettings executes a gorm list call
func DefaultListSettings(ctx context.Context, db *gorm.DB) ([]*Settings, error) {
	in := Settings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SettingsORM{}, &Settings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Settings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SettingsORM) error
}
